{"task_id": "shapely_427", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_affinity.py", "testname": "test_affinity.py", "funcname": "test_rotate_angle_array", "imports": ["import unittest", "from math import pi", "import numpy as np", "import pytest", "from shapely import affinity", "from shapely.geometry import Point", "from shapely.wkt import loads as load_wkt"], "code": "def test_rotate_angle_array(self):\n    ls = load_wkt('LINESTRING(240 400, 240 300, 300 300)')\n    els = load_wkt('LINESTRING(220 320, 320 320, 320 380)')\n    theta = np.array(90.0)\n    rls = affinity.rotate(ls, theta)\n    assert (theta.item() == 90.0)\n    assert rls.equals(els)\n    theta = np.array((pi / 2))\n    rls = affinity.rotate(ls, theta, use_radians=True)\n    assert (theta.item() == (pi / 2))\n    assert rls.equals(els)", "masked_code": "def test_rotate_angle_array(self):\n    ls = load_wkt('LINESTRING(240 400, 240 300, 300 300)')\n    els = load_wkt('LINESTRING(220 320, 320 320, 320 380)')\n    theta = np.array(90.0)\n    rls = affinity.rotate(ls, theta)\n    assert (theta.item() == '???')\n    assert rls.equals(els)\n    theta = np.array((pi / 2))\n    rls = affinity.rotate(ls, theta, use_radians=True)\n    assert (theta.item() == (pi / 2))\n    assert rls.equals(els)", "ground_truth": ["90.0"], "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransformOpsTestCase"}
{"task_id": "shapely_428", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_affinity.py", "testname": "test_affinity.py", "funcname": "test_rotate_angle_array", "imports": ["import unittest", "from math import pi", "import numpy as np", "import pytest", "from shapely import affinity", "from shapely.geometry import Point", "from shapely.wkt import loads as load_wkt"], "code": "def test_rotate_angle_array(self):\n    ls = load_wkt('LINESTRING(240 400, 240 300, 300 300)')\n    els = load_wkt('LINESTRING(220 320, 320 320, 320 380)')\n    theta = np.array(90.0)\n    rls = affinity.rotate(ls, theta)\n    assert (theta.item() == 90.0)\n    assert rls.equals(els)\n    theta = np.array((pi / 2))\n    rls = affinity.rotate(ls, theta, use_radians=True)\n    assert (theta.item() == (pi / 2))\n    assert rls.equals(els)", "masked_code": "def test_rotate_angle_array(self):\n    ls = load_wkt('LINESTRING(240 400, 240 300, 300 300)')\n    els = load_wkt('LINESTRING(220 320, 320 320, 320 380)')\n    theta = np.array(90.0)\n    rls = affinity.rotate(ls, theta)\n    assert (theta.item() == 90.0)\n    assert rls.equals(els)\n    theta = np.array((pi / 2))\n    rls = affinity.rotate(ls, theta, use_radians=True)\n    assert (theta.item() == '???')\n    assert rls.equals(els)", "ground_truth": ["(pi / 2)", "90.0"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransformOpsTestCase"}
{"task_id": "shapely_429", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_affinity.py", "testname": "test_affinity.py", "funcname": "test_skew_xs_ys_array", "imports": ["import unittest", "from math import pi", "import numpy as np", "import pytest", "from shapely import affinity", "from shapely.geometry import Point", "from shapely.wkt import loads as load_wkt"], "code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(240 400 10, 240 300 30, 300 300 20)')\n    els = load_wkt('LINESTRING (253.39745962155615 417.3205080756888, 226.60254037844385 317.3205080756888, 286.60254037844385 282.67949192431126)')\n    xs_ys = np.array([15.0, (- 30.0)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 15.0)\n    assert (xs_ys[1] == (- 30.0))\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys = np.array([(pi / 12), ((- pi) / 6)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)], use_radians=True)\n    assert (xs_ys[0] == (pi / 12))\n    assert (xs_ys[1] == ((- pi) / 6))\n    assert sls.equals_exact(els, 1e-06)", "masked_code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(240 400 10, 240 300 30, 300 300 20)')\n    els = load_wkt('LINESTRING (253.39745962155615 417.3205080756888, 226.60254037844385 317.3205080756888, 286.60254037844385 282.67949192431126)')\n    xs_ys = np.array([15.0, (- 30.0)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == '???')\n    assert (xs_ys[1] == (- 30.0))\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys = np.array([(pi / 12), ((- pi) / 6)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)], use_radians=True)\n    assert (xs_ys[0] == (pi / 12))\n    assert (xs_ys[1] == ((- pi) / 6))\n    assert sls.equals_exact(els, 1e-06)", "ground_truth": ["15.0"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransformOpsTestCase"}
{"task_id": "shapely_430", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_affinity.py", "testname": "test_affinity.py", "funcname": "test_skew_xs_ys_array", "imports": ["import unittest", "from math import pi", "import numpy as np", "import pytest", "from shapely import affinity", "from shapely.geometry import Point", "from shapely.wkt import loads as load_wkt"], "code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(240 400 10, 240 300 30, 300 300 20)')\n    els = load_wkt('LINESTRING (253.39745962155615 417.3205080756888, 226.60254037844385 317.3205080756888, 286.60254037844385 282.67949192431126)')\n    xs_ys = np.array([15.0, (- 30.0)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 15.0)\n    assert (xs_ys[1] == (- 30.0))\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys = np.array([(pi / 12), ((- pi) / 6)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)], use_radians=True)\n    assert (xs_ys[0] == (pi / 12))\n    assert (xs_ys[1] == ((- pi) / 6))\n    assert sls.equals_exact(els, 1e-06)", "masked_code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(240 400 10, 240 300 30, 300 300 20)')\n    els = load_wkt('LINESTRING (253.39745962155615 417.3205080756888, 226.60254037844385 317.3205080756888, 286.60254037844385 282.67949192431126)')\n    xs_ys = np.array([15.0, (- 30.0)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 15.0)\n    assert (xs_ys[1] == '???')\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys = np.array([(pi / 12), ((- pi) / 6)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)], use_radians=True)\n    assert (xs_ys[0] == (pi / 12))\n    assert (xs_ys[1] == ((- pi) / 6))\n    assert sls.equals_exact(els, 1e-06)", "ground_truth": ["(- 30.0)", "-30.0"], "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransformOpsTestCase"}
{"task_id": "shapely_431", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_affinity.py", "testname": "test_affinity.py", "funcname": "test_skew_xs_ys_array", "imports": ["import unittest", "from math import pi", "import numpy as np", "import pytest", "from shapely import affinity", "from shapely.geometry import Point", "from shapely.wkt import loads as load_wkt"], "code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(240 400 10, 240 300 30, 300 300 20)')\n    els = load_wkt('LINESTRING (253.39745962155615 417.3205080756888, 226.60254037844385 317.3205080756888, 286.60254037844385 282.67949192431126)')\n    xs_ys = np.array([15.0, (- 30.0)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 15.0)\n    assert (xs_ys[1] == (- 30.0))\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys = np.array([(pi / 12), ((- pi) / 6)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)], use_radians=True)\n    assert (xs_ys[0] == (pi / 12))\n    assert (xs_ys[1] == ((- pi) / 6))\n    assert sls.equals_exact(els, 1e-06)", "masked_code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(240 400 10, 240 300 30, 300 300 20)')\n    els = load_wkt('LINESTRING (253.39745962155615 417.3205080756888, 226.60254037844385 317.3205080756888, 286.60254037844385 282.67949192431126)')\n    xs_ys = np.array([15.0, (- 30.0)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 15.0)\n    assert (xs_ys[1] == (- 30.0))\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys = np.array([(pi / 12), ((- pi) / 6)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)], use_radians=True)\n    assert (xs_ys[0] == '???')\n    assert (xs_ys[1] == ((- pi) / 6))\n    assert sls.equals_exact(els, 1e-06)", "ground_truth": ["(pi / 12)", "0.2617993877991494"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransformOpsTestCase"}
{"task_id": "shapely_432", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_affinity.py", "testname": "test_affinity.py", "funcname": "test_skew_xs_ys_array", "imports": ["import unittest", "from math import pi", "import numpy as np", "import pytest", "from shapely import affinity", "from shapely.geometry import Point", "from shapely.wkt import loads as load_wkt"], "code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(240 400 10, 240 300 30, 300 300 20)')\n    els = load_wkt('LINESTRING (253.39745962155615 417.3205080756888, 226.60254037844385 317.3205080756888, 286.60254037844385 282.67949192431126)')\n    xs_ys = np.array([15.0, (- 30.0)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 15.0)\n    assert (xs_ys[1] == (- 30.0))\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys = np.array([(pi / 12), ((- pi) / 6)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)], use_radians=True)\n    assert (xs_ys[0] == (pi / 12))\n    assert (xs_ys[1] == ((- pi) / 6))\n    assert sls.equals_exact(els, 1e-06)", "masked_code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(240 400 10, 240 300 30, 300 300 20)')\n    els = load_wkt('LINESTRING (253.39745962155615 417.3205080756888, 226.60254037844385 317.3205080756888, 286.60254037844385 282.67949192431126)')\n    xs_ys = np.array([15.0, (- 30.0)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 15.0)\n    assert (xs_ys[1] == (- 30.0))\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys = np.array([(pi / 12), ((- pi) / 6)])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)], use_radians=True)\n    assert (xs_ys[0] == (pi / 12))\n    assert (xs_ys[1] == '???')\n    assert sls.equals_exact(els, 1e-06)", "ground_truth": ["((- pi) / 6)", "0.2617993877991494"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransformOpsTestCase"}
{"task_id": "shapely_433", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_box.py", "testname": "test_box.py", "funcname": "test_ccw", "imports": ["import unittest", "from shapely import geometry"], "code": "def test_ccw(self):\n    b = geometry.box(0, 0, 1, 1, ccw=True)\n    assert (b.exterior.coords[0] == (1.0, 0.0))\n    assert (b.exterior.coords[1] == (1.0, 1.0))", "masked_code": "def test_ccw(self):\n    b = geometry.box(0, 0, 1, 1, ccw=True)\n    assert (b.exterior.coords[0] == '???')\n    assert (b.exterior.coords[1] == (1.0, 1.0))", "ground_truth": ["(1.0, 0.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "BoxTestCase"}
{"task_id": "shapely_434", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_box.py", "testname": "test_box.py", "funcname": "test_ccw", "imports": ["import unittest", "from shapely import geometry"], "code": "def test_ccw(self):\n    b = geometry.box(0, 0, 1, 1, ccw=True)\n    assert (b.exterior.coords[0] == (1.0, 0.0))\n    assert (b.exterior.coords[1] == (1.0, 1.0))", "masked_code": "def test_ccw(self):\n    b = geometry.box(0, 0, 1, 1, ccw=True)\n    assert (b.exterior.coords[0] == (1.0, 0.0))\n    assert (b.exterior.coords[1] == '???')", "ground_truth": ["(1.0, 1.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "BoxTestCase"}
{"task_id": "shapely_435", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_box.py", "testname": "test_box.py", "funcname": "test_ccw_default", "imports": ["import unittest", "from shapely import geometry"], "code": "def test_ccw_default(self):\n    b = geometry.box(0, 0, 1, 1)\n    assert (b.exterior.coords[0] == (1.0, 0.0))\n    assert (b.exterior.coords[1] == (1.0, 1.0))", "masked_code": "def test_ccw_default(self):\n    b = geometry.box(0, 0, 1, 1)\n    assert (b.exterior.coords[0] == '???')\n    assert (b.exterior.coords[1] == (1.0, 1.0))", "ground_truth": ["(1.0, 0.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "BoxTestCase"}
{"task_id": "shapely_436", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_box.py", "testname": "test_box.py", "funcname": "test_ccw_default", "imports": ["import unittest", "from shapely import geometry"], "code": "def test_ccw_default(self):\n    b = geometry.box(0, 0, 1, 1)\n    assert (b.exterior.coords[0] == (1.0, 0.0))\n    assert (b.exterior.coords[1] == (1.0, 1.0))", "masked_code": "def test_ccw_default(self):\n    b = geometry.box(0, 0, 1, 1)\n    assert (b.exterior.coords[0] == (1.0, 0.0))\n    assert (b.exterior.coords[1] == '???')", "ground_truth": ["(1.0, 0.0)", "(1.0, 1.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "BoxTestCase"}
{"task_id": "shapely_437", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_box.py", "testname": "test_box.py", "funcname": "test_cw", "imports": ["import unittest", "from shapely import geometry"], "code": "def test_cw(self):\n    b = geometry.box(0, 0, 1, 1, ccw=False)\n    assert (b.exterior.coords[0] == (0.0, 0.0))\n    assert (b.exterior.coords[1] == (0.0, 1.0))", "masked_code": "def test_cw(self):\n    b = geometry.box(0, 0, 1, 1, ccw=False)\n    assert (b.exterior.coords[0] == '???')\n    assert (b.exterior.coords[1] == (0.0, 1.0))", "ground_truth": ["(0.0, 0.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "BoxTestCase"}
{"task_id": "shapely_438", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_box.py", "testname": "test_box.py", "funcname": "test_cw", "imports": ["import unittest", "from shapely import geometry"], "code": "def test_cw(self):\n    b = geometry.box(0, 0, 1, 1, ccw=False)\n    assert (b.exterior.coords[0] == (0.0, 0.0))\n    assert (b.exterior.coords[1] == (0.0, 1.0))", "masked_code": "def test_cw(self):\n    b = geometry.box(0, 0, 1, 1, ccw=False)\n    assert (b.exterior.coords[0] == (0.0, 0.0))\n    assert (b.exterior.coords[1] == '???')", "ground_truth": ["(0.0, 1.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "BoxTestCase"}
{"task_id": "shapely_469", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_cga.py", "testname": "test_cga.py", "funcname": "test_square", "imports": ["import unittest", "import pytest", "from shapely.geometry.polygon import LinearRing, Polygon, orient, signed_area"], "code": "def test_square(self):\n    (xmin, xmax) = ((- 1), 1)\n    (ymin, ymax) = ((- 2), 3)\n    rect = LinearRing([(xmin, ymin), (xmax, ymin), (xmax, ymax), (xmin, ymax), (xmin, ymin)])\n    assert (signed_area(rect) == pytest.approx(10.0))", "masked_code": "def test_square(self):\n    (xmin, xmax) = ((- 1), 1)\n    (ymin, ymax) = ((- 2), 3)\n    rect = LinearRing([(xmin, ymin), (xmax, ymin), (xmax, ymax), (xmin, ymax), (xmin, ymin)])\n    assert (signed_area(rect) == '???')", "ground_truth": ["10", "10.0", "pytest.approx(10.0)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "SignedAreaTestCase"}
{"task_id": "shapely_468", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_cga.py", "testname": "test_cga.py", "funcname": "test_triangle", "imports": ["import unittest", "import pytest", "from shapely.geometry.polygon import LinearRing, Polygon, orient, signed_area"], "code": "def test_triangle(self):\n    tri = LinearRing([(0, 0), (2, 5), (7, 0)])\n    assert (signed_area(tri) == pytest.approx((((- 7) * 5) / 2)))", "masked_code": "def test_triangle(self):\n    tri = LinearRing([(0, 0), (2, 5), (7, 0)])\n    assert (signed_area(tri) == '???')", "ground_truth": ["-17.5", "pytest.approx((((- 7) * 5) / 2))"], "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": "SignedAreaTestCase"}
{"task_id": "shapely_474", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_line_inside", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_line_inside():\n    'Line inside'\n    geom1 = load_wkt('LINESTRING (15 15, 16 15)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'LINESTRING (15 15, 16 15)')", "masked_code": "def test_line_inside():\n    'Line inside'\n    geom1 = load_wkt('LINESTRING (15 15, 16 15)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'LINESTRING (15 15, 16 15)'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_475", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_line_on_boundary", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_line_on_boundary():\n    'Line on boundary'\n    geom1 = load_wkt('LINESTRING (10 15, 10 10, 15 10)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY')", "masked_code": "def test_line_on_boundary():\n    'Line on boundary'\n    geom1 = load_wkt('LINESTRING (10 15, 10 10, 15 10)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'GEOMETRYCOLLECTION EMPTY'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_473", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_line_outside", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_line_outside():\n    'Line outside'\n    geom1 = load_wkt('LINESTRING (0 0, -5 5)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY')", "masked_code": "def test_line_outside():\n    'Line outside'\n    geom1 = load_wkt('LINESTRING (0 0, -5 5)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'GEOMETRYCOLLECTION EMPTY'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_476", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_line_splitting_rectangle", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_line_splitting_rectangle():\n    'Line splitting rectangle'\n    geom1 = load_wkt('LINESTRING (10 5, 25 20)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'LINESTRING (15 10, 20 15)')", "masked_code": "def test_line_splitting_rectangle():\n    'Line splitting rectangle'\n    geom1 = load_wkt('LINESTRING (10 5, 25 20)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'LINESTRING (15 10, 20 15)'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_471", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_point_inside", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_point_inside():\n    'Point inside'\n    geom1 = load_wkt('POINT (15 15)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'POINT (15 15)')", "masked_code": "def test_point_inside():\n    'Point inside'\n    geom1 = load_wkt('POINT (15 15)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'POINT (15 15)'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_472", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_point_on_boundary", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_point_on_boundary():\n    'Point on boundary'\n    geom1 = load_wkt('POINT (15 10)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY')", "masked_code": "def test_point_on_boundary():\n    'Point on boundary'\n    geom1 = load_wkt('POINT (15 10)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'GEOMETRYCOLLECTION EMPTY'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_470", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_point_outside", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_point_outside():\n    'Point outside'\n    geom1 = load_wkt('POINT (0 0)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY')", "masked_code": "def test_point_outside():\n    'Point outside'\n    geom1 = load_wkt('POINT (0 0)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'GEOMETRYCOLLECTION EMPTY'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_478", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_polygon_shell_cc_fully_on_rectangle_boundary", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "@pytest.mark.xfail(reason='TODO issue to CW')\ndef test_polygon_shell_cc_fully_on_rectangle_boundary():\n    'Polygon shell (CW) fully on rectangle boundary'\n    geom1 = load_wkt('POLYGON ((10 10, 10 20, 20 20, 20 10, 10 10))')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'POLYGON ((10 10, 20 10, 20 20, 10 20, 10 10))')", "masked_code": "@pytest.mark.xfail(reason='TODO issue to CW')\ndef test_polygon_shell_cc_fully_on_rectangle_boundary():\n    'Polygon shell (CW) fully on rectangle boundary'\n    geom1 = load_wkt('POLYGON ((10 10, 10 20, 20 20, 20 10, 10 10))')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'POLYGON ((10 10, 20 10, 20 20, 10 20, 10 10))'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_477", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_polygon_shell_ccw_fully_on_rectangle_boundary", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "@pytest.mark.xfail(reason='TODO issue to CCW')\ndef test_polygon_shell_ccw_fully_on_rectangle_boundary():\n    'Polygon shell (CCW) fully on rectangle boundary'\n    geom1 = load_wkt('POLYGON ((10 10, 20 10, 20 20, 10 20, 10 10))')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'POLYGON ((10 10, 20 10, 20 20, 10 20, 10 10))')", "masked_code": "@pytest.mark.xfail(reason='TODO issue to CCW')\ndef test_polygon_shell_ccw_fully_on_rectangle_boundary():\n    'Polygon shell (CCW) fully on rectangle boundary'\n    geom1 = load_wkt('POLYGON ((10 10, 20 10, 20 20, 10 20, 10 10))')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'POLYGON ((10 10, 20 10, 20 20, 10 20, 10 10))'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_232", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_empty", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "@pytest.mark.parametrize('geom', [GeometryCollection(), GeometryCollection([]), shape({'type': 'GeometryCollection', 'geometries': []}), wkt.loads('GEOMETRYCOLLECTION EMPTY')])\ndef test_empty(geom):\n    assert (geom.geom_type == 'GeometryCollection')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    assert (list(geom.geoms) == [])", "masked_code": "@pytest.mark.parametrize('geom', [GeometryCollection(), GeometryCollection([]), shape({'type': 'GeometryCollection', 'geometries': []}), wkt.loads('GEOMETRYCOLLECTION EMPTY')])\ndef test_empty(geom):\n    assert (geom.geom_type == '???')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    assert (list(geom.geoms) == [])", "ground_truth": ["'GeometryCollection'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_233", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_empty", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "@pytest.mark.parametrize('geom', [GeometryCollection(), GeometryCollection([]), shape({'type': 'GeometryCollection', 'geometries': []}), wkt.loads('GEOMETRYCOLLECTION EMPTY')])\ndef test_empty(geom):\n    assert (geom.geom_type == 'GeometryCollection')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    assert (list(geom.geoms) == [])", "masked_code": "@pytest.mark.parametrize('geom', [GeometryCollection(), GeometryCollection([]), shape({'type': 'GeometryCollection', 'geometries': []}), wkt.loads('GEOMETRYCOLLECTION EMPTY')])\ndef test_empty(geom):\n    assert (geom.geom_type == 'GeometryCollection')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    assert (list(geom.geoms) == '???')", "ground_truth": ["[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_234", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_empty_subgeoms", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "def test_empty_subgeoms():\n    geom = GeometryCollection([Point(), LineString()])\n    assert (geom.geom_type == 'GeometryCollection')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 2)\n    assert (list(geom.geoms) == [Point(), LineString()])", "masked_code": "def test_empty_subgeoms():\n    geom = GeometryCollection([Point(), LineString()])\n    assert (geom.geom_type == '???')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 2)\n    assert (list(geom.geoms) == [Point(), LineString()])", "ground_truth": ["'GeometryCollection'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_235", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_empty_subgeoms", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "def test_empty_subgeoms():\n    geom = GeometryCollection([Point(), LineString()])\n    assert (geom.geom_type == 'GeometryCollection')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 2)\n    assert (list(geom.geoms) == [Point(), LineString()])", "masked_code": "def test_empty_subgeoms():\n    geom = GeometryCollection([Point(), LineString()])\n    assert (geom.geom_type == 'GeometryCollection')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 2)\n    assert (list(geom.geoms) == '???')", "ground_truth": ["[<POINT EMPTY>, <LINESTRING EMPTY>]", "[Point(), LineString()]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_236", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_from_geojson", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "def test_from_geojson(geometrycollection_geojson):\n    geom = shape(geometrycollection_geojson)\n    assert (geom.geom_type == 'GeometryCollection')\n    assert (len(geom.geoms) == 2)\n    geom_types = [g.geom_type for g in geom.geoms]\n    assert ('Point' in geom_types)\n    assert ('LineString' in geom_types)", "masked_code": "def test_from_geojson(geometrycollection_geojson):\n    geom = shape(geometrycollection_geojson)\n    assert (geom.geom_type == '???')\n    assert (len(geom.geoms) == 2)\n    geom_types = [g.geom_type for g in geom.geoms]\n    assert ('Point' in geom_types)\n    assert ('LineString' in geom_types)", "ground_truth": ["'GeometryCollection'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_237", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_geointerface", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "def test_geointerface(geometrycollection_geojson):\n    geom = shape(geometrycollection_geojson)\n    assert (geom.__geo_interface__ == geometrycollection_geojson)", "masked_code": "def test_geointerface(geometrycollection_geojson):\n    geom = shape(geometrycollection_geojson)\n    assert (geom.__geo_interface__ == '???')", "ground_truth": ["geometrycollection_geojson", "{'type': 'GeometryCollection', 'geometries': [{'type': 'Point', 'coordinates': [0, 3, 0]}, {'type': 'LineString', 'coordinates': [[2, 0], [1, 0]]}]}"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_238", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_numpy_object_array", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "def test_numpy_object_array():\n    geom = GeometryCollection([LineString([(0, 0), (1, 1)])])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == geom)", "masked_code": "def test_numpy_object_array():\n    geom = GeometryCollection([LineString([(0, 0), (1, 1)])])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == '???')", "ground_truth": ["<GEOMETRYCOLLECTION (LINESTRING (0 0, 1 1))>", "geom"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_10", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_clip_by_rect_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', all_types)\ndef test_clip_by_rect_array(geometry):\n    if (geometry.is_empty and (shapely.get_type_id(geometry) == shapely.GeometryType.POINT) and ((geos_version < (3, 10, 6)) or ((3, 11, 0) <= geos_version < (3, 11, 3)))):\n        with pytest.raises(GEOSException):\n            shapely.clip_by_rect([geometry, geometry], 0.0, 0.0, 1.0, 1.0)\n        return\n    actual = shapely.clip_by_rect([geometry, geometry], 0.0, 0.0, 1.0, 1.0)\n    assert (actual.shape == (2,))\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))", "masked_code": "@pytest.mark.parametrize('geometry', all_types)\ndef test_clip_by_rect_array(geometry):\n    if (geometry.is_empty and (shapely.get_type_id(geometry) == shapely.GeometryType.POINT) and ((geos_version < (3, 10, 6)) or ((3, 11, 0) <= geos_version < (3, 11, 3)))):\n        with pytest.raises(GEOSException):\n            shapely.clip_by_rect([geometry, geometry], 0.0, 0.0, 1.0, 1.0)\n        return\n    actual = shapely.clip_by_rect([geometry, geometry], 0.0, 0.0, 1.0, 1.0)\n    assert (actual.shape == '???')\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_1", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_float_arg_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', all_types)\n@pytest.mark.parametrize('func', CONSTRUCTIVE_FLOAT_ARG)\ndef test_float_arg_array(geometry, func):\n    if ((func is shapely.offset_curve) and (shapely.get_type_id(geometry) not in [1, 2]) and (shapely.geos_version < (3, 11, 0))):\n        with pytest.raises(GEOSException, match='only accept linestrings'):\n            func([geometry, geometry], 0.0)\n        return\n    with ignore_invalid(((func is shapely.voronoi_polygons) and (shapely.get_type_id(geometry) == 0) and (shapely.geos_version < (3, 12, 0)))):\n        actual = func([geometry, geometry], 0.0)\n    assert (actual.shape == (2,))\n    assert isinstance(actual[0], Geometry)", "masked_code": "@pytest.mark.parametrize('geometry', all_types)\n@pytest.mark.parametrize('func', CONSTRUCTIVE_FLOAT_ARG)\ndef test_float_arg_array(geometry, func):\n    if ((func is shapely.offset_curve) and (shapely.get_type_id(geometry) not in [1, 2]) and (shapely.geos_version < (3, 11, 0))):\n        with pytest.raises(GEOSException, match='only accept linestrings'):\n            func([geometry, geometry], 0.0)\n        return\n    with ignore_invalid(((func is shapely.voronoi_polygons) and (shapely.get_type_id(geometry) == 0) and (shapely.geos_version < (3, 12, 0)))):\n        actual = func([geometry, geometry], 0.0)\n    assert (actual.shape == '???')\n    assert isinstance(actual[0], Geometry)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_3", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_make_valid", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geom,expected', [(point, point), (Polygon([(0, 0), (1, 1), (1, 2), (1, 1), (0, 0)]), MultiLineString([((1, 1), (1, 2)), ((0, 0), (1, 1))])), (Polygon([(0, 0), (2, 2), (2, 0), (0, 2), (0, 0)]), MultiPolygon([Polygon([(1, 1), (2, 2), (2, 0), (1, 1)]), Polygon([(0, 0), (0, 2), (1, 1), (0, 0)])])), (empty, empty), ([empty], [empty])])\ndef test_make_valid(geom, expected):\n    actual = shapely.make_valid(geom)\n    assert (actual is not expected)\n    assert (shapely.normalize(actual) == expected)", "masked_code": "@pytest.mark.parametrize('geom,expected', [(point, point), (Polygon([(0, 0), (1, 1), (1, 2), (1, 1), (0, 0)]), MultiLineString([((1, 1), (1, 2)), ((0, 0), (1, 1))])), (Polygon([(0, 0), (2, 2), (2, 0), (0, 2), (0, 0)]), MultiPolygon([Polygon([(1, 1), (2, 2), (2, 0), (1, 1)]), Polygon([(0, 0), (0, 2), (1, 1), (0, 0)])])), (empty, empty), ([empty], [empty])])\ndef test_make_valid(geom, expected):\n    actual = shapely.make_valid(geom)\n    assert (actual is not expected)\n    assert (shapely.normalize(actual) == '???')", "ground_truth": ["<POINT (2 3)>", "expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_4", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_make_valid_structure", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geom,expected', [(point, point), (Polygon([(0, 0), (1, 1), (1, 2), (1, 1), (0, 0)]), LineString([(0, 0), (1, 1), (1, 2), (1, 1), (0, 0)])), (Polygon([(0, 0), (2, 2), (2, 0), (0, 2), (0, 0)]), MultiPolygon([Polygon([(1, 1), (2, 2), (2, 0), (1, 1)]), Polygon([(0, 0), (0, 2), (1, 1), (0, 0)])])), (empty, empty), ([empty], [empty])])\ndef test_make_valid_structure(geom, expected):\n    actual = shapely.make_valid(geom, method='structure')\n    assert (actual is not expected)\n    assert (shapely.normalize(actual) == expected)", "masked_code": "@pytest.mark.parametrize('geom,expected', [(point, point), (Polygon([(0, 0), (1, 1), (1, 2), (1, 1), (0, 0)]), LineString([(0, 0), (1, 1), (1, 2), (1, 1), (0, 0)])), (Polygon([(0, 0), (2, 2), (2, 0), (0, 2), (0, 0)]), MultiPolygon([Polygon([(1, 1), (2, 2), (2, 0), (1, 1)]), Polygon([(0, 0), (0, 2), (1, 1), (0, 0)])])), (empty, empty), ([empty], [empty])])\ndef test_make_valid_structure(geom, expected):\n    actual = shapely.make_valid(geom, method='structure')\n    assert (actual is not expected)\n    assert (shapely.normalize(actual) == '???')", "ground_truth": ["<POINT (2 3)>", "expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_38", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_maximum_inscribed_circle_all_types", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', all_types)\ndef test_maximum_inscribed_circle_all_types(geometry):\n    if (shapely.get_type_id(geometry) not in [3, 6]):\n        with pytest.raises(GEOSException, match='Argument must be Polygonal or LinearRing|must be a Polygon or MultiPolygon|Operation not supported by GeometryCollection'):\n            shapely.maximum_inscribed_circle(geometry)\n        return\n    if geometry.is_empty:\n        with pytest.raises(GEOSException, match='Empty input(?: geometry)? is not supported'):\n            shapely.maximum_inscribed_circle(geometry)\n        return\n    actual = shapely.maximum_inscribed_circle([geometry, geometry])\n    assert (actual.shape == (2,))\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))\n    actual = shapely.maximum_inscribed_circle(None)\n    assert (actual is None)", "masked_code": "@pytest.mark.parametrize('geometry', all_types)\ndef test_maximum_inscribed_circle_all_types(geometry):\n    if (shapely.get_type_id(geometry) not in [3, 6]):\n        with pytest.raises(GEOSException, match='Argument must be Polygonal or LinearRing|must be a Polygon or MultiPolygon|Operation not supported by GeometryCollection'):\n            shapely.maximum_inscribed_circle(geometry)\n        return\n    if geometry.is_empty:\n        with pytest.raises(GEOSException, match='Empty input(?: geometry)? is not supported'):\n            shapely.maximum_inscribed_circle(geometry)\n        return\n    actual = shapely.maximum_inscribed_circle([geometry, geometry])\n    assert (actual.shape == '???')\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))\n    actual = shapely.maximum_inscribed_circle(None)\n    assert (actual is None)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_36", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_minimum_bounding_circle_all_types", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', all_types)\ndef test_minimum_bounding_circle_all_types(geometry):\n    actual = shapely.minimum_bounding_circle([geometry, geometry])\n    assert (actual.shape == (2,))\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))\n    actual = shapely.minimum_bounding_circle(None)\n    assert (actual is None)", "masked_code": "@pytest.mark.parametrize('geometry', all_types)\ndef test_minimum_bounding_circle_all_types(geometry):\n    actual = shapely.minimum_bounding_circle([geometry, geometry])\n    assert (actual.shape == '???')\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))\n    actual = shapely.minimum_bounding_circle(None)\n    assert (actual is None)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_0", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_no_args_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', all_types)\n@pytest.mark.parametrize('func', CONSTRUCTIVE_NO_ARGS)\ndef test_no_args_array(geometry, func):\n    if (geometry.is_empty and (shapely.get_num_geometries(geometry) > 0) and (func is shapely.node) and (geos_version < (3, 10, 3))):\n        pytest.xfail('GEOS < 3.10.3 crashes with empty geometries')\n    actual = func([geometry, geometry])\n    assert (actual.shape == (2,))\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))", "masked_code": "@pytest.mark.parametrize('geometry', all_types)\n@pytest.mark.parametrize('func', CONSTRUCTIVE_NO_ARGS)\ndef test_no_args_array(geometry, func):\n    if (geometry.is_empty and (shapely.get_num_geometries(geometry) > 0) and (func is shapely.node) and (geos_version < (3, 10, 3))):\n        pytest.xfail('GEOS < 3.10.3 crashes with empty geometries')\n    actual = func([geometry, geometry])\n    assert (actual.shape == '???')\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_6", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_offset_curve_distance_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_offset_curve_distance_array():\n    result = shapely.offset_curve([line_string, line_string], [(- 2.0), (- 3.0)])\n    assert (result[0] == shapely.offset_curve(line_string, (- 2.0)))\n    assert (result[1] == shapely.offset_curve(line_string, (- 3.0)))", "masked_code": "def test_offset_curve_distance_array():\n    result = shapely.offset_curve([line_string, line_string], [(- 2.0), (- 3.0)])\n    assert (result[0] == '???')\n    assert (result[1] == shapely.offset_curve(line_string, (- 3.0)))", "ground_truth": ["<LINESTRING (3 1, 3 0, 2.962 -0.39, 2.848 -0.765, 2.663 -1.111, 2.414 -1.414...>", "shapely.offset_curve(line_string, (- 2.0))"], "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_7", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_offset_curve_distance_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_offset_curve_distance_array():\n    result = shapely.offset_curve([line_string, line_string], [(- 2.0), (- 3.0)])\n    assert (result[0] == shapely.offset_curve(line_string, (- 2.0)))\n    assert (result[1] == shapely.offset_curve(line_string, (- 3.0)))", "masked_code": "def test_offset_curve_distance_array():\n    result = shapely.offset_curve([line_string, line_string], [(- 2.0), (- 3.0)])\n    assert (result[0] == shapely.offset_curve(line_string, (- 2.0)))\n    assert (result[1] == '???')", "ground_truth": ["<LINESTRING (3 1, 3 0, 2.962 -0.39, 2.848 -0.765, 2.663 -1.111, 2.414 -1.414...>", "shapely.offset_curve(line_string, (- 3.0))"], "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_40", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_orient_polygons", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_orient_polygons():\n    polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)], holes=[[(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(1, 1), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == Point(1, 1))\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "masked_code": "def test_orient_polygons():\n    polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)], holes=[[(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(1, 1), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == '???')\n    assert (result.geoms[0] == Point(1, 1))\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_41", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_orient_polygons", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_orient_polygons():\n    polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)], holes=[[(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(1, 1), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == Point(1, 1))\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "masked_code": "def test_orient_polygons():\n    polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)], holes=[[(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(1, 1), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == '???')\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "ground_truth": ["<POINT (1 1)>", "Point(1, 1)"], "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_42", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_orient_polygons", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_orient_polygons():\n    polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)], holes=[[(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(1, 1), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == Point(1, 1))\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "masked_code": "def test_orient_polygons():\n    polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)], holes=[[(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(1, 1), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == Point(1, 1))\n    assert (result.geoms[1] == '???')\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "ground_truth": ["<POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0), (2 2, 2 4, 4 4, 4 2, 2 2))>", "shapely.orient_polygons(polygon)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_43", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_orient_polygons", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_orient_polygons():\n    polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)], holes=[[(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(1, 1), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == Point(1, 1))\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "masked_code": "def test_orient_polygons():\n    polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)], holes=[[(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(1, 1), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == Point(1, 1))\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == '???')", "ground_truth": ["<MULTIPOLYGON (((0 0, 10 0, 10 10, 0 10, 0 0), (2 2, 2 4, 4 4, 4 2, 2 2)), (...>", "shapely.orient_polygons(mp)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_39", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_orient_polygons_all_types", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', all_types)\ndef test_orient_polygons_all_types(geometry):\n    actual = shapely.orient_polygons([geometry, geometry])\n    assert (actual.shape == (2,))\n    assert isinstance(actual[0], Geometry)\n    actual = shapely.orient_polygons(None)\n    assert (actual is None)", "masked_code": "@pytest.mark.parametrize('geometry', all_types)\ndef test_orient_polygons_all_types(geometry):\n    actual = shapely.orient_polygons([geometry, geometry])\n    assert (actual.shape == '???')\n    assert isinstance(actual[0], Geometry)\n    actual = shapely.orient_polygons(None)\n    assert (actual is None)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_44", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_orient_polygons_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_orient_polygons_array():\n    polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)], holes=[[(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)]])\n    geometries = np.array(([([polygon] * 3)] * 2))\n    actual = shapely.orient_polygons(geometries)\n    assert isinstance(actual, np.ndarray)\n    assert (actual.shape == (2, 3))\n    expected = shapely.orient_polygons(polygon)\n    assert (actual == expected).all()", "masked_code": "def test_orient_polygons_array():\n    polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)], holes=[[(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)]])\n    geometries = np.array(([([polygon] * 3)] * 2))\n    actual = shapely.orient_polygons(geometries)\n    assert isinstance(actual, np.ndarray)\n    assert (actual.shape == '???')\n    expected = shapely.orient_polygons(polygon)\n    assert (actual == expected).all()", "ground_truth": ["(2, 3)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_37", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_oriented_envelope_all_types", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', all_types)\ndef test_oriented_envelope_all_types(geometry):\n    actual = shapely.oriented_envelope([geometry, geometry])\n    assert (actual.shape == (2,))\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))\n    actual = shapely.oriented_envelope(None)\n    assert (actual is None)", "masked_code": "@pytest.mark.parametrize('geometry', all_types)\ndef test_oriented_envelope_all_types(geometry):\n    actual = shapely.oriented_envelope([geometry, geometry])\n    assert (actual.shape == '???')\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))\n    actual = shapely.oriented_envelope(None)\n    assert (actual is None)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_11", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)]), LineString([(1, 1), (1, 0)]), LineString([(1, 0), (0, 0)]), LineString([(5, 5), (6, 6)]), Point(0, 0), None]\n    result = shapely.polygonize(lines)\n    assert (shapely.get_type_id(result) == 7)\n    expected = GeometryCollection([Polygon([(0, 0), (1, 1), (1, 0), (0, 0)]), Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    assert (result == expected)", "masked_code": "def test_polygonize():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)]), LineString([(1, 1), (1, 0)]), LineString([(1, 0), (0, 0)]), LineString([(5, 5), (6, 6)]), Point(0, 0), None]\n    result = shapely.polygonize(lines)\n    assert (shapely.get_type_id(result) == '???')\n    expected = GeometryCollection([Polygon([(0, 0), (1, 1), (1, 0), (0, 0)]), Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    assert (result == expected)", "ground_truth": ["7"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_12", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == '???')\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["(1,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_13", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == '???')\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((1 1, 0 0, 0 1, 1 1)))>", "expected"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_14", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == '???')\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["(2, 3)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_15", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == '???')\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_16", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == '???')\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((1 1, 0 0, 0 1, 1 1)))>", "expected"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_17", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == '???')\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((1 1, 0 0, 0 1, 1 1)))>", "expected"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_18", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == '???')\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["(3, 2, 3)"], "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_19", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == '???')\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["(3, 2)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_20", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array_axis():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize(arr, axis=1)\n    assert (result.shape == (2,))\n    result = shapely.polygonize(arr, axis=0)\n    assert (result.shape == (3,))", "masked_code": "def test_polygonize_array_axis():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize(arr, axis=1)\n    assert (result.shape == '???')\n    result = shapely.polygonize(arr, axis=0)\n    assert (result.shape == (3,))", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_21", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array_axis():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize(arr, axis=1)\n    assert (result.shape == (2,))\n    result = shapely.polygonize(arr, axis=0)\n    assert (result.shape == (3,))", "masked_code": "def test_polygonize_array_axis():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize(arr, axis=1)\n    assert (result.shape == (2,))\n    result = shapely.polygonize(arr, axis=0)\n    assert (result.shape == '???')", "ground_truth": ["(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_22", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full():\n    lines = [None, LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)]), LineString([(1, 1), (1, 0)]), None, LineString([(1, 0), (0, 0)]), LineString([(5, 5), (6, 6)]), LineString([(1, 1), (100, 100)]), Point(0, 0), None]\n    result = shapely.polygonize_full(lines)\n    assert (len(result) == 4)\n    assert all(((shapely.get_type_id(geom) == 7) for geom in result))\n    (polygons, cuts, dangles, invalid) = result\n    expected_polygons = GeometryCollection([Polygon([(0, 0), (1, 1), (1, 0), (0, 0)]), Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    assert (polygons == expected_polygons)\n    assert (cuts == GeometryCollection())\n    expected_dangles = GeometryCollection([LineString([(1, 1), (100, 100)]), LineString([(5, 5), (6, 6)])])\n    assert (dangles == expected_dangles)\n    assert (invalid == GeometryCollection())", "masked_code": "def test_polygonize_full():\n    lines = [None, LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)]), LineString([(1, 1), (1, 0)]), None, LineString([(1, 0), (0, 0)]), LineString([(5, 5), (6, 6)]), LineString([(1, 1), (100, 100)]), Point(0, 0), None]\n    result = shapely.polygonize_full(lines)\n    assert (len(result) == '???')\n    assert all(((shapely.get_type_id(geom) == 7) for geom in result))\n    (polygons, cuts, dangles, invalid) = result\n    expected_polygons = GeometryCollection([Polygon([(0, 0), (1, 1), (1, 0), (0, 0)]), Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    assert (polygons == expected_polygons)\n    assert (cuts == GeometryCollection())\n    expected_dangles = GeometryCollection([LineString([(1, 1), (100, 100)]), LineString([(5, 5), (6, 6)])])\n    assert (dangles == expected_dangles)\n    assert (invalid == GeometryCollection())", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_23", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == '???')\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_24", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == '???')\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((1 1, 0 0, 0 1, 1 1)))>", "expected"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_25", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == '???')\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_26", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == '???')\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((1 1, 0 0, 0 1, 1 1)))>", "expected"], "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_27", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == '???')\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["(2, 3)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_28", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == '???')\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_29", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == '???')\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((1 1, 0 0, 0 1, 1 1)))>", "expected"], "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_30", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == '???')\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((1 1, 0 0, 0 1, 1 1)))>", "expected"], "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_31", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == '???')\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["(3, 2, 3)"], "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_32", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 1), (1, 1)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == '???')\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_33", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array_axis():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize_full(arr, axis=1)\n    assert (len(result) == 4)\n    assert all(((arr.shape == (2,)) for arr in result))\n    result = shapely.polygonize_full(arr, axis=0)\n    assert (len(result) == 4)\n    assert all(((arr.shape == (3,)) for arr in result))", "masked_code": "def test_polygonize_full_array_axis():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize_full(arr, axis=1)\n    assert (len(result) == '???')\n    assert all(((arr.shape == (2,)) for arr in result))\n    result = shapely.polygonize_full(arr, axis=0)\n    assert (len(result) == 4)\n    assert all(((arr.shape == (3,)) for arr in result))", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_34", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array_axis():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize_full(arr, axis=1)\n    assert (len(result) == 4)\n    assert all(((arr.shape == (2,)) for arr in result))\n    result = shapely.polygonize_full(arr, axis=0)\n    assert (len(result) == 4)\n    assert all(((arr.shape == (3,)) for arr in result))", "masked_code": "def test_polygonize_full_array_axis():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)]), LineString([(0, 1), (1, 1)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize_full(arr, axis=1)\n    assert (len(result) == 4)\n    assert all(((arr.shape == (2,)) for arr in result))\n    result = shapely.polygonize_full(arr, axis=0)\n    assert (len(result) == '???')\n    assert all(((arr.shape == (3,)) for arr in result))", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_35", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_missing", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_missing():\n    result = shapely.polygonize_full([None, None])\n    assert (len(result) == 4)\n    assert all(((geom == GeometryCollection()) for geom in result))", "masked_code": "def test_polygonize_full_missing():\n    result = shapely.polygonize_full([None, None])\n    assert (len(result) == '???')\n    assert all(((geom == GeometryCollection()) for geom in result))", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_9", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_reverse_none", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_reverse_none():\n    assert (shapely.reverse(None) is None)\n    assert (shapely.reverse([None]).tolist() == [None])\n    geometry = Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])\n    expected = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    result = shapely.reverse([None, geometry])\n    assert (result[0] is None)\n    assert_geometries_equal(result[1], expected)", "masked_code": "def test_reverse_none():\n    assert (shapely.reverse(None) is None)\n    assert (shapely.reverse([None]).tolist() == '???')\n    geometry = Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])\n    expected = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    result = shapely.reverse([None, geometry])\n    assert (result[0] is None)\n    assert_geometries_equal(result[1], expected)", "ground_truth": ["[None]"], "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_2", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_snap_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', all_types)\n@pytest.mark.parametrize('reference', all_types)\ndef test_snap_array(geometry, reference):\n    actual = shapely.snap([geometry, geometry], [reference, reference], tolerance=1.0)\n    assert (actual.shape == (2,))\n    assert isinstance(actual[0], Geometry)", "masked_code": "@pytest.mark.parametrize('geometry', all_types)\n@pytest.mark.parametrize('reference', all_types)\ndef test_snap_array(geometry, reference):\n    actual = shapely.snap([geometry, geometry], [reference, reference], tolerance=1.0)\n    assert (actual.shape == '???')\n    assert isinstance(actual[0], Geometry)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_47", "reponame": "shapely", "testpath": "shapely/tests/test_coordinates.py", "testname": "test_coordinates.py", "funcname": "test_transform_correct_coordinate_dimension", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_equal", "import shapely", "from shapely import count_coordinates, get_coordinates, set_coordinates, transform", "from shapely.tests.common import empty, empty_line_string_z, empty_point, empty_point_m, empty_point_z, empty_point_zm, geometry_collection, geometry_collection_z, geometry_collection_zm, line_string, line_string_m, line_string_z, line_string_zm, linear_ring, multi_line_string, multi_point, multi_polygon, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_z"], "code": "def test_transform_correct_coordinate_dimension():\n    geom = line_string_z\n    assert (shapely.get_coordinate_dimension(geom) == 3)\n    new_geom = transform(geom, (lambda x: (x + 1)), include_z=False)\n    assert (shapely.get_coordinate_dimension(new_geom) == 2)", "masked_code": "def test_transform_correct_coordinate_dimension():\n    geom = line_string_z\n    assert (shapely.get_coordinate_dimension(geom) == '???')\n    new_geom = transform(geom, (lambda x: (x + 1)), include_z=False)\n    assert (shapely.get_coordinate_dimension(new_geom) == 2)", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_48", "reponame": "shapely", "testpath": "shapely/tests/test_coordinates.py", "testname": "test_coordinates.py", "funcname": "test_transform_empty_preserve_z", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_equal", "import shapely", "from shapely import count_coordinates, get_coordinates, set_coordinates, transform", "from shapely.tests.common import empty, empty_line_string_z, empty_point, empty_point_m, empty_point_z, empty_point_zm, geometry_collection, geometry_collection_z, geometry_collection_zm, line_string, line_string_m, line_string_z, line_string_zm, linear_ring, multi_line_string, multi_point, multi_polygon, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_z"], "code": "@pytest.mark.parametrize('geom', [empty_point_z, empty_line_string_z])\ndef test_transform_empty_preserve_z(geom):\n    assert (shapely.get_coordinate_dimension(geom) == 3)\n    new_geom = transform(geom, (lambda x: (x + 1)), include_z=True)\n    assert (shapely.get_coordinate_dimension(new_geom) == 3)", "masked_code": "@pytest.mark.parametrize('geom', [empty_point_z, empty_line_string_z])\ndef test_transform_empty_preserve_z(geom):\n    assert (shapely.get_coordinate_dimension(geom) == '???')\n    new_geom = transform(geom, (lambda x: (x + 1)), include_z=True)\n    assert (shapely.get_coordinate_dimension(new_geom) == 3)", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_49", "reponame": "shapely", "testpath": "shapely/tests/test_coordinates.py", "testname": "test_coordinates.py", "funcname": "test_transform_empty_preserve_z", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_equal", "import shapely", "from shapely import count_coordinates, get_coordinates, set_coordinates, transform", "from shapely.tests.common import empty, empty_line_string_z, empty_point, empty_point_m, empty_point_z, empty_point_zm, geometry_collection, geometry_collection_z, geometry_collection_zm, line_string, line_string_m, line_string_z, line_string_zm, linear_ring, multi_line_string, multi_point, multi_polygon, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_z"], "code": "@pytest.mark.parametrize('geom', [empty_point_z, empty_line_string_z])\ndef test_transform_empty_preserve_z(geom):\n    assert (shapely.get_coordinate_dimension(geom) == 3)\n    new_geom = transform(geom, (lambda x: (x + 1)), include_z=True)\n    assert (shapely.get_coordinate_dimension(new_geom) == 3)", "masked_code": "@pytest.mark.parametrize('geom', [empty_point_z, empty_line_string_z])\ndef test_transform_empty_preserve_z(geom):\n    assert (shapely.get_coordinate_dimension(geom) == 3)\n    new_geom = transform(geom, (lambda x: (x + 1)), include_z=True)\n    assert (shapely.get_coordinate_dimension(new_geom) == '???')", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_46", "reponame": "shapely", "testpath": "shapely/tests/test_coordinates.py", "testname": "test_coordinates.py", "funcname": "test_transform_no_geoms", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_equal", "import shapely", "from shapely import count_coordinates, get_coordinates, set_coordinates, transform", "from shapely.tests.common import empty, empty_line_string_z, empty_point, empty_point_m, empty_point_z, empty_point_zm, geometry_collection, geometry_collection_z, geometry_collection_zm, line_string, line_string_m, line_string_z, line_string_zm, linear_ring, multi_line_string, multi_point, multi_polygon, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_z"], "code": "def test_transform_no_geoms():\n    actual = transform([], (lambda x: (x + 1)))\n    assert (actual.shape == (0,))", "masked_code": "def test_transform_no_geoms():\n    actual = transform([], (lambda x: (x + 1)))\n    assert (actual.shape == '???')", "ground_truth": ["(0,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_50", "reponame": "shapely", "testpath": "shapely/tests/test_coordinates.py", "testname": "test_coordinates.py", "funcname": "test_transform_remove_z", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_equal", "import shapely", "from shapely import count_coordinates, get_coordinates, set_coordinates, transform", "from shapely.tests.common import empty, empty_line_string_z, empty_point, empty_point_m, empty_point_z, empty_point_zm, geometry_collection, geometry_collection_z, geometry_collection_zm, line_string, line_string_m, line_string_z, line_string_zm, linear_ring, multi_line_string, multi_point, multi_polygon, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_z"], "code": "@pytest.mark.parametrize('geom', [empty_point_z, empty_line_string_z])\ndef test_transform_remove_z(geom):\n    assert (shapely.get_coordinate_dimension(geom) == 3)\n    new_geom = transform(geom, (lambda x: (x + 1)), include_z=False)\n    assert (shapely.get_coordinate_dimension(new_geom) == 2)", "masked_code": "@pytest.mark.parametrize('geom', [empty_point_z, empty_line_string_z])\ndef test_transform_remove_z(geom):\n    assert (shapely.get_coordinate_dimension(geom) == '???')\n    new_geom = transform(geom, (lambda x: (x + 1)), include_z=False)\n    assert (shapely.get_coordinate_dimension(new_geom) == 2)", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_259", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_arrays", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_arrays(self):\n    (x, y) = LineString([(0, 0), (1, 1)]).xy\n    assert (len(x) == 2)\n    assert (list(x) == [0.0, 1.0])\n    assert (len(y) == 2)\n    assert (list(y) == [0.0, 1.0])", "masked_code": "def test_arrays(self):\n    (x, y) = LineString([(0, 0), (1, 1)]).xy\n    assert (len(x) == 2)\n    assert (list(x) == '???')\n    assert (len(y) == 2)\n    assert (list(y) == [0.0, 1.0])", "ground_truth": ["[0.0, 1.0]"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestXY"}
{"task_id": "shapely_260", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_arrays", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_arrays(self):\n    (x, y) = LineString([(0, 0), (1, 1)]).xy\n    assert (len(x) == 2)\n    assert (list(x) == [0.0, 1.0])\n    assert (len(y) == 2)\n    assert (list(y) == [0.0, 1.0])", "masked_code": "def test_arrays(self):\n    (x, y) = LineString([(0, 0), (1, 1)]).xy\n    assert (len(x) == 2)\n    assert (list(x) == [0.0, 1.0])\n    assert (len(y) == 2)\n    assert (list(y) == '???')", "ground_truth": ["[0.0, 1.0]"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestXY"}
{"task_id": "shapely_244", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_data_destriding", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_data_destriding(self):\n    coords = np.array([[12, 34], [56, 78]], dtype=np.float32)\n    processed_coords = np.array(LineString(coords[::(- 1)]).coords)\n    assert (coords[::(- 1)].tolist() == processed_coords.tolist())", "masked_code": "def test_data_destriding(self):\n    coords = np.array([[12, 34], [56, 78]], dtype=np.float32)\n    processed_coords = np.array(LineString(coords[::(- 1)]).coords)\n    assert (coords[::(- 1)].tolist() == '???')", "ground_truth": ["[[56.0, 78.0], [12.0, 34.0]]", "processed_coords.tolist()"], "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoords"}
{"task_id": "shapely_243", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_data_promotion", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_data_promotion(self):\n    coords = np.array([[12, 34], [56, 78]], dtype=np.float32)\n    processed_coords = np.array(LineString(coords).coords)\n    assert (coords.tolist() == processed_coords.tolist())", "masked_code": "def test_data_promotion(self):\n    coords = np.array([[12, 34], [56, 78]], dtype=np.float32)\n    processed_coords = np.array(LineString(coords).coords)\n    assert (coords.tolist() == '???')", "ground_truth": ["[[12.0, 34.0], [56.0, 78.0]]", "processed_coords.tolist()"], "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoords"}
{"task_id": "shapely_245", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_index_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_index_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    for i in range((- 4), 4):\n        assert (g.coords[i] == c[i])\n    with pytest.raises(IndexError):\n        g.coords[4]\n    with pytest.raises(IndexError):\n        g.coords[(- 5)]", "masked_code": "def test_index_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    for i in range((- 4), 4):\n        assert (g.coords[i] == '???')\n    with pytest.raises(IndexError):\n        g.coords[4]\n    with pytest.raises(IndexError):\n        g.coords[(- 5)]", "ground_truth": ["(0.0, 0.0)", "c[i]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_246", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_index_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_index_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    for i in range((- 4), 4):\n        assert (g.coords[i] == c[i])\n    with pytest.raises(IndexError):\n        g.coords[4]\n    with pytest.raises(IndexError):\n        g.coords[(- 5)]", "masked_code": "def test_index_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    for i in range((- 4), 4):\n        assert (g.coords[i] == '???')\n    with pytest.raises(IndexError):\n        g.coords[4]\n    with pytest.raises(IndexError):\n        g.coords[(- 5)]", "ground_truth": ["(0.0, 0.0, 0.0)", "c[i]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_247", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "masked_code": "def test_slice_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == '???')\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "ground_truth": ["[[1.0, -1.0], [2.0, -2.0], [3.0, -3.0]]", "c[1:]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_248", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "masked_code": "def test_slice_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == '???')\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "ground_truth": ["[[0.0, 0.0], [1.0, -1.0], [2.0, -2.0]]", "c[:(- 1)]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_249", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "masked_code": "def test_slice_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == '???')\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "ground_truth": ["[[3.0, -3.0], [2.0, -2.0], [1.0, -1.0], [0.0, 0.0]]", "c[::(- 1)]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_250", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "masked_code": "def test_slice_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == '???')\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "ground_truth": ["[[0.0, 0.0], [2.0, -2.0]]", "c[::2]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_251", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "masked_code": "def test_slice_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == '???')\n    assert (g.coords[4:] == c[4:] == [])", "ground_truth": ["[[0.0, 0.0], [1.0, -1.0], [2.0, -2.0], [3.0, -3.0]]", "c[:4]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_252", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "masked_code": "def test_slice_coords(self):\n    c = [(float(x), float((- x))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == '???' == [])", "ground_truth": ["c[4:]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_253", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "masked_code": "def test_slice_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == '???')\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "ground_truth": ["[[1.0, -1.0, 2.0], [2.0, -2.0, 4.0], [3.0, -3.0, 6.0]]", "c[1:]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_254", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "masked_code": "def test_slice_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == '???')\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "ground_truth": ["[[0.0, 0.0, 0.0], [1.0, -1.0, 2.0], [2.0, -2.0, 4.0]]", "c[:(- 1)]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_255", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "masked_code": "def test_slice_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == '???')\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "ground_truth": ["[[3.0, -3.0, 6.0], [2.0, -2.0, 4.0], [1.0, -1.0, 2.0], [0.0, 0.0, 0.0]]", "c[::(- 1)]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_256", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "masked_code": "def test_slice_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == '???')\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "ground_truth": ["[[0.0, 0.0, 0.0], [2.0, -2.0, 4.0]]", "c[::2]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_257", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "masked_code": "def test_slice_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == '???')\n    assert (g.coords[4:] == c[4:] == [])", "ground_truth": ["[[0.0, 0.0, 0.0], [1.0, -1.0, 2.0], [2.0, -2.0, 4.0], [3.0, -3.0, 6.0]]", "c[:4]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_258", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == c[4:] == [])", "masked_code": "def test_slice_coords_z(self):\n    c = [(float(x), float((- x)), float((x * 2))) for x in range(4)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:4] == c[:4])\n    assert (g.coords[4:] == '???' == [])", "ground_truth": ["c[4:]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_479", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_create_inconsistent_dimensionality.py", "testname": "test_create_inconsistent_dimensionality.py", "funcname": "test_create_from_wkt", "imports": ["import pytest", "import shapely", "from shapely import wkt", "from shapely.errors import GEOSException", "from shapely.geometry import LineString, Polygon, shape"], "code": "@pytest.mark.parametrize('wkt_geom,expected', wkt_cases)\ndef test_create_from_wkt(wkt_geom, expected):\n    if (shapely.geos_version >= (3, 12, 0)):\n        with pytest.raises(GEOSException):\n            wkt.loads(wkt_geom)\n    else:\n        geom = wkt.loads(wkt_geom)\n        assert (geom.wkt == expected)", "masked_code": "@pytest.mark.parametrize('wkt_geom,expected', wkt_cases)\ndef test_create_from_wkt(wkt_geom, expected):\n    if (shapely.geos_version >= (3, 12, 0)):\n        with pytest.raises(GEOSException):\n            wkt.loads(wkt_geom)\n    else:\n        geom = wkt.loads(wkt_geom)\n        assert (geom.wkt == '???')", "ground_truth": ["'MULTIPOINT Z (1 1 1, 2 2 0)'", "expected"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_62", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_2_polygons_with_2_same_holes", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_2_polygons_with_2_same_holes():\n    actual = shapely.polygons([box_tpl(0, 0, 10, 10), box_tpl(0, 0, 5, 5)], [box_tpl(1, 1, 2, 2), box_tpl(3, 3, 4, 4)])\n    assert (shapely.area(actual).tolist() == [98.0, 23.0])", "masked_code": "def test_2_polygons_with_2_same_holes():\n    actual = shapely.polygons([box_tpl(0, 0, 10, 10), box_tpl(0, 0, 5, 5)], [box_tpl(1, 1, 2, 2), box_tpl(3, 3, 4, 4)])\n    assert (shapely.area(actual).tolist() == '???')", "ground_truth": ["[98.0, 23.0]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_63", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_2_polygons_with_different_holes", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_2_polygons_with_different_holes():\n    actual = shapely.polygons([box_tpl(0, 0, 10, 10), box_tpl(0, 0, 5, 5)], [[box_tpl(1, 1, 3, 3)], [box_tpl(1, 1, 2, 2)]])\n    assert (shapely.area(actual).tolist() == [96.0, 24.0])", "masked_code": "def test_2_polygons_with_different_holes():\n    actual = shapely.polygons([box_tpl(0, 0, 10, 10), box_tpl(0, 0, 5, 5)], [[box_tpl(1, 1, 3, 3)], [box_tpl(1, 1, 2, 2)]])\n    assert (shapely.area(actual).tolist() == '???')", "ground_truth": ["[96.0, 24.0]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_61", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_2_polygons_with_same_hole", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_2_polygons_with_same_hole():\n    actual = shapely.polygons([box_tpl(0, 0, 10, 10), box_tpl(0, 0, 5, 5)], [box_tpl(1, 1, 2, 2)])\n    assert (shapely.area(actual).tolist() == [99.0, 24.0])", "masked_code": "def test_2_polygons_with_same_hole():\n    actual = shapely.polygons([box_tpl(0, 0, 10, 10), box_tpl(0, 0, 5, 5)], [box_tpl(1, 1, 2, 2)])\n    assert (shapely.area(actual).tolist() == '???')", "ground_truth": ["[99.0, 24.0]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_55", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_points_nan_3D_all_nan_becomes_empty_2D", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "@pytest.mark.skipif((shapely.geos_version[:2] not in ((3, 10), (3, 11))), reason='GEOS not in 3.10, 3.11')\ndef test_points_nan_3D_all_nan_becomes_empty_2D():\n    actual = shapely.points(np.nan, np.nan, np.nan)\n    assert (actual.wkt == 'POINT EMPTY')", "masked_code": "@pytest.mark.skipif((shapely.geos_version[:2] not in ((3, 10), (3, 11))), reason='GEOS not in 3.10, 3.11')\ndef test_points_nan_3D_all_nan_becomes_empty_2D():\n    actual = shapely.points(np.nan, np.nan, np.nan)\n    assert (actual.wkt == '???')", "ground_truth": ["'POINT EMPTY'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_54", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_points_nan_all_nan_becomes_empty", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "@pytest.mark.skipif((shapely.geos_version[:2] not in ((3, 10), (3, 11), (3, 12))), reason='GEOS not in 3.10, 3.11, 3.12')\ndef test_points_nan_all_nan_becomes_empty():\n    actual = shapely.points(np.nan, np.nan)\n    assert (actual.wkt == 'POINT EMPTY')", "masked_code": "@pytest.mark.skipif((shapely.geos_version[:2] not in ((3, 10), (3, 11), (3, 12))), reason='GEOS not in 3.10, 3.11, 3.12')\ndef test_points_nan_all_nan_becomes_empty():\n    actual = shapely.points(np.nan, np.nan)\n    assert (actual.wkt == '???')", "ground_truth": ["'POINT EMPTY'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_58", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_polygon_with_1_hole", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_polygon_with_1_hole():\n    actual = shapely.polygons(box_tpl(0, 0, 10, 10), [box_tpl(1, 1, 2, 2)])\n    assert (shapely.area(actual) == 99.0)", "masked_code": "def test_polygon_with_1_hole():\n    actual = shapely.polygons(box_tpl(0, 0, 10, 10), [box_tpl(1, 1, 2, 2)])\n    assert (shapely.area(actual) == '???')", "ground_truth": ["99.0"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_59", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_polygon_with_2_holes", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_polygon_with_2_holes():\n    actual = shapely.polygons(box_tpl(0, 0, 10, 10), [box_tpl(1, 1, 2, 2), box_tpl(3, 3, 4, 4)])\n    assert (shapely.area(actual) == 98.0)", "masked_code": "def test_polygon_with_2_holes():\n    actual = shapely.polygons(box_tpl(0, 0, 10, 10), [box_tpl(1, 1, 2, 2), box_tpl(3, 3, 4, 4)])\n    assert (shapely.area(actual) == '???')", "ground_truth": ["98.0"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_60", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_polygon_with_none_hole", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_polygon_with_none_hole():\n    actual = shapely.polygons(shapely.linearrings(box_tpl(0, 0, 10, 10)), [shapely.linearrings(box_tpl(1, 1, 2, 2)), None, shapely.linearrings(box_tpl(3, 3, 4, 4))])\n    assert (shapely.area(actual) == 98.0)", "masked_code": "def test_polygon_with_none_hole():\n    actual = shapely.polygons(shapely.linearrings(box_tpl(0, 0, 10, 10)), [shapely.linearrings(box_tpl(1, 1, 2, 2)), None, shapely.linearrings(box_tpl(3, 3, 4, 4))])\n    assert (shapely.area(actual) == '???')", "ground_truth": ["98.0"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_64", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_prepare", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_prepare():\n    arr = np.array([shapely.points(1, 1), None, shapely.box(0, 0, 1, 1)])\n    assert (arr[0]._geom_prepared == 0)\n    assert (arr[2]._geom_prepared == 0)\n    shapely.prepare(arr)\n    assert (arr[0]._geom_prepared != 0)\n    assert (arr[1] is None)\n    assert (arr[2]._geom_prepared != 0)\n    original = arr[0]._geom_prepared\n    shapely.prepare(arr)\n    assert (arr[0]._geom_prepared == original)", "masked_code": "def test_prepare():\n    arr = np.array([shapely.points(1, 1), None, shapely.box(0, 0, 1, 1)])\n    assert (arr[0]._geom_prepared == 0)\n    assert (arr[2]._geom_prepared == 0)\n    shapely.prepare(arr)\n    assert (arr[0]._geom_prepared != 0)\n    assert (arr[1] is None)\n    assert (arr[2]._geom_prepared != 0)\n    original = arr[0]._geom_prepared\n    shapely.prepare(arr)\n    assert (arr[0]._geom_prepared == '???')", "ground_truth": ["original"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_261", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_decimal.py", "testname": "test_decimal.py", "funcname": "test_decimal", "imports": ["from decimal import Decimal", "import pytest", "from shapely import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon"], "code": "@pytest.mark.parametrize('geoms', list(zip(*all_geoms)))\ndef test_decimal(geoms):\n    assert (geoms[0] == geoms[1] == geoms[2])\n    assert (geoms[3] == geoms[4] == geoms[5])", "masked_code": "@pytest.mark.parametrize('geoms', list(zip(*all_geoms)))\ndef test_decimal(geoms):\n    assert (geoms[0] == '???' == geoms[2])\n    assert (geoms[3] == geoms[4] == geoms[5])", "ground_truth": ["geoms[1]"], "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_262", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_decimal.py", "testname": "test_decimal.py", "funcname": "test_decimal", "imports": ["from decimal import Decimal", "import pytest", "from shapely import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon"], "code": "@pytest.mark.parametrize('geoms', list(zip(*all_geoms)))\ndef test_decimal(geoms):\n    assert (geoms[0] == geoms[1] == geoms[2])\n    assert (geoms[3] == geoms[4] == geoms[5])", "masked_code": "@pytest.mark.parametrize('geoms', list(zip(*all_geoms)))\ndef test_decimal(geoms):\n    assert (geoms[0] == geoms[1] == geoms[2])\n    assert (geoms[3] == '???' == geoms[5])", "ground_truth": ["geoms[4]"], "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_65", "reponame": "shapely", "testpath": "shapely/tests/test_decorators.py", "testname": "test_decorators.py", "funcname": "test_all_kwargs_no_warning", "imports": ["import pytest", "from pytest import WarningsRecorder", "from shapely.decorators import deprecate_positional"], "code": "def test_all_kwargs_no_warning(recwarn: WarningsRecorder) -> None:\n    assert (func_two(a=10, b=20, c=30) == (10, 20, 30))\n    assert (not recwarn.list)", "masked_code": "def test_all_kwargs_no_warning(recwarn: WarningsRecorder) -> None:\n    assert (func_two(a=10, b=20, c=30) == '???')\n    assert (not recwarn.list)", "ground_truth": ["(10, 20, 30)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_66", "reponame": "shapely", "testpath": "shapely/tests/test_decorators.py", "testname": "test_decorators.py", "funcname": "test_only_required_arg_no_warning", "imports": ["import pytest", "from pytest import WarningsRecorder", "from shapely.decorators import deprecate_positional"], "code": "def test_only_required_arg_no_warning(recwarn: WarningsRecorder) -> None:\n    assert (func_two(1) == (1, 2, 3))\n    assert (not recwarn.list)", "masked_code": "def test_only_required_arg_no_warning(recwarn: WarningsRecorder) -> None:\n    assert (func_two(1) == '???')\n    assert (not recwarn.list)", "ground_truth": ["(1, 2, 3)"], "quality_analysis": {"complexity_score": 9, "left_complexity": 4, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_67", "reponame": "shapely", "testpath": "shapely/tests/test_decorators.py", "testname": "test_decorators.py", "funcname": "test_repeated_warnings", "imports": ["import pytest", "from pytest import WarningsRecorder", "from shapely.decorators import deprecate_positional"], "code": "def test_repeated_warnings() -> None:\n    with pytest.warns(DeprecationWarning) as record:\n        func_two(1, 4, 5)\n        func_two(1, 4, 5)\n        assert (len(record) == 2)\n        assert (str(record[0].message) == str(record[1].message))", "masked_code": "def test_repeated_warnings() -> None:\n    with pytest.warns(DeprecationWarning) as record:\n        func_two(1, 4, 5)\n        func_two(1, 4, 5)\n        assert (len(record) == 2)\n        assert (str(record[0].message) == '???')", "ground_truth": ["'positional arguments `b` and `c` for `func_two` are deprecated. Please use keyword arguments instead.'", "str(record[1].message)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_480", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_delaunay.py", "testname": "test_delaunay.py", "funcname": "test_lines", "imports": ["import unittest", "from shapely.geometry import LineString, Point, Polygon", "from shapely.ops import triangulate"], "code": "def test_lines(self):\n    polys = triangulate(self.p, edges=True)\n    assert (len(polys) == 5)\n    for p in polys:\n        assert isinstance(p, LineString)", "masked_code": "def test_lines(self):\n    polys = triangulate(self.p, edges=True)\n    assert (len(polys) == '???')\n    for p in polys:\n        assert isinstance(p, LineString)", "ground_truth": ["5"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "DelaunayTriangulation"}
{"task_id": "shapely_263", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_emptiness.py", "testname": "test_emptiness.py", "funcname": "test_empty_geometry_bounds", "imports": ["import math", "import numpy as np", "import pytest", "from shapely import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.geometry import mapping, shape", "from shapely.geometry.base import BaseGeometry, EmptyGeometry"], "code": "@pytest.mark.parametrize('geom', [Point(), LineString(), Polygon(), MultiPoint(), MultiLineString(), MultiPolygon(), GeometryCollection(), LinearRing()])\ndef test_empty_geometry_bounds(geom):\n    'The bounds of an empty geometry is a tuple of NaNs'\n    assert (len(geom.bounds) == 4)\n    assert all((math.isnan(v) for v in geom.bounds))", "masked_code": "@pytest.mark.parametrize('geom', [Point(), LineString(), Polygon(), MultiPoint(), MultiLineString(), MultiPolygon(), GeometryCollection(), LinearRing()])\ndef test_empty_geometry_bounds(geom):\n    'The bounds of an empty geometry is a tuple of NaNs'\n    assert (len(geom.bounds) == '???')\n    assert all((math.isnan(v) for v in geom.bounds))", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_483", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_empty_polygon", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_empty_polygon():\n    'Confirm fix for issue #450'\n    g = Polygon()\n    assert (g.__geo_interface__['type'] == 'Polygon')\n    assert (g.__geo_interface__['coordinates'] == ())", "masked_code": "def test_empty_polygon():\n    'Confirm fix for issue #450'\n    g = Polygon()\n    assert (g.__geo_interface__['type'] == '???')\n    assert (g.__geo_interface__['coordinates'] == ())", "ground_truth": ["'Polygon'"], "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_484", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_empty_polygon", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_empty_polygon():\n    'Confirm fix for issue #450'\n    g = Polygon()\n    assert (g.__geo_interface__['type'] == 'Polygon')\n    assert (g.__geo_interface__['coordinates'] == ())", "masked_code": "def test_empty_polygon():\n    'Confirm fix for issue #450'\n    g = Polygon()\n    assert (g.__geo_interface__['type'] == 'Polygon')\n    assert (g.__geo_interface__['coordinates'] == '???')", "ground_truth": ["()"], "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_481", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_empty_wkt_polygon", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_empty_wkt_polygon():\n    'Confirm fix for issue #450'\n    g = wkt.loads('POLYGON EMPTY')\n    assert (g.__geo_interface__['type'] == 'Polygon')\n    assert (g.__geo_interface__['coordinates'] == ())", "masked_code": "def test_empty_wkt_polygon():\n    'Confirm fix for issue #450'\n    g = wkt.loads('POLYGON EMPTY')\n    assert (g.__geo_interface__['type'] == '???')\n    assert (g.__geo_interface__['coordinates'] == ())", "ground_truth": ["'Polygon'"], "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_482", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_empty_wkt_polygon", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_empty_wkt_polygon():\n    'Confirm fix for issue #450'\n    g = wkt.loads('POLYGON EMPTY')\n    assert (g.__geo_interface__['type'] == 'Polygon')\n    assert (g.__geo_interface__['coordinates'] == ())", "masked_code": "def test_empty_wkt_polygon():\n    'Confirm fix for issue #450'\n    g = wkt.loads('POLYGON EMPTY')\n    assert (g.__geo_interface__['type'] == 'Polygon')\n    assert (g.__geo_interface__['coordinates'] == '???')", "ground_truth": ["()"], "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_485", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 1.0), (- 1.0)), (1.0, 1.0)))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == '???')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 1.0), (- 1.0)), (1.0, 1.0)))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "ground_truth": ["'Point'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_486", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 1.0), (- 1.0)), (1.0, 1.0)))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == '???')\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 1.0), (- 1.0)), (1.0, 1.0)))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "ground_truth": ["((0.0, 0.0),)", "([0.0, 0.0],)"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_487", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 1.0), (- 1.0)), (1.0, 1.0)))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == '???')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 1.0), (- 1.0)), (1.0, 1.0)))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "ground_truth": ["'Point'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_488", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 1.0), (- 1.0)), (1.0, 1.0)))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == '???')\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 1.0), (- 1.0)), (1.0, 1.0)))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "ground_truth": ["((0.0, 0.0),)", "([0.0, 0.0],)"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_489", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 1.0), (- 1.0)), (1.0, 1.0)))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == '???')\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "ground_truth": ["(((- 1.0), (- 1.0)), (1.0, 1.0))", "([-1.0, -1.0], [1.0, 1.0])"], "quality_analysis": {"complexity_score": 19, "left_complexity": 5, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_490", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 1.0), (- 1.0)), (1.0, 1.0)))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 1.0), (- 1.0)), (1.0, 1.0)))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == '???')\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "ground_truth": ["((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))", "([0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [2.0, -1.0], [0.0, 0.0])"], "quality_analysis": {"complexity_score": 29, "left_complexity": 5, "right_complexity": 24, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_491", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 1.0), (- 1.0)), (1.0, 1.0)))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': (0.0, 0.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (0.0, 0.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((0.0, 0.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 1.0), (- 1.0)), (1.0, 1.0))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 1.0), (- 1.0)), (1.0, 1.0)))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == '???')\n    assert (len(geom.interiors) == 1)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.1, 0.1), (0.1, 0.2), (0.2, 0.2), (0.2, 0.1), (0.1, 0.1)))]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)", "ground_truth": ["((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, (- 1.0)), (0.0, 0.0))", "([0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [2.0, -1.0], [0.0, 0.0])"], "quality_analysis": {"complexity_score": 29, "left_complexity": 5, "right_complexity": 24, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_83", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_force_3d", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "@pytest.mark.parametrize('geom,expected', [(point, point_z), (point_z, point_z), (empty_point, empty_point_z), (empty_point_z, empty_point_z), (line_string, line_string_z), (line_string_z, line_string_z), (empty_line_string, empty_line_string_z), (empty_line_string_z, empty_line_string_z), (polygon, polygon_z), (polygon_z, polygon_z), (polygon_with_hole, polygon_with_hole_z), (polygon_with_hole_z, polygon_with_hole_z), (multi_point, multi_point_z), (multi_point_z, multi_point_z), (multi_line_string, multi_line_string_z), (multi_line_string_z, multi_line_string_z), (multi_polygon, multi_polygon_z), (multi_polygon_z, multi_polygon_z), (geometry_collection_2, geometry_collection_z), (geometry_collection_z, geometry_collection_z)])\ndef test_force_3d(geom, expected):\n    actual = shapely.force_3d(geom, z=4)\n    assert (shapely.get_coordinate_dimension(actual) == 3)\n    assert_geometries_equal(actual, expected)", "masked_code": "@pytest.mark.parametrize('geom,expected', [(point, point_z), (point_z, point_z), (empty_point, empty_point_z), (empty_point_z, empty_point_z), (line_string, line_string_z), (line_string_z, line_string_z), (empty_line_string, empty_line_string_z), (empty_line_string_z, empty_line_string_z), (polygon, polygon_z), (polygon_z, polygon_z), (polygon_with_hole, polygon_with_hole_z), (polygon_with_hole_z, polygon_with_hole_z), (multi_point, multi_point_z), (multi_point_z, multi_point_z), (multi_line_string, multi_line_string_z), (multi_line_string_z, multi_line_string_z), (multi_polygon, multi_polygon_z), (multi_polygon_z, multi_polygon_z), (geometry_collection_2, geometry_collection_z), (geometry_collection_z, geometry_collection_z)])\ndef test_force_3d(geom, expected):\n    actual = shapely.force_3d(geom, z=4)\n    assert (shapely.get_coordinate_dimension(actual) == '???')\n    assert_geometries_equal(actual, expected)", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_73", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_parts", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "@pytest.mark.parametrize('geom', [point, multi_point, line_string, multi_line_string, polygon, multi_polygon, geometry_collection, empty_point, empty_line_string, empty_polygon, empty_geometry_collection, np.array([None]), np.empty_like(np.array([None]))])\ndef test_get_parts(geom):\n    expected_num_parts = shapely.get_num_geometries(geom)\n    if (expected_num_parts == 0):\n        expected_parts = []\n    else:\n        expected_parts = shapely.get_geometry(geom, range(expected_num_parts))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == expected_num_parts)\n    assert_geometries_equal(parts, expected_parts)", "masked_code": "@pytest.mark.parametrize('geom', [point, multi_point, line_string, multi_line_string, polygon, multi_polygon, geometry_collection, empty_point, empty_line_string, empty_polygon, empty_geometry_collection, np.array([None]), np.empty_like(np.array([None]))])\ndef test_get_parts(geom):\n    expected_num_parts = shapely.get_num_geometries(geom)\n    if (expected_num_parts == 0):\n        expected_parts = []\n    else:\n        expected_parts = shapely.get_geometry(geom, range(expected_num_parts))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == '???')\n    assert_geometries_equal(parts, expected_parts)", "ground_truth": ["expected_num_parts", "np.int32(1)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_74", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_parts_array", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "def test_get_parts_array():\n    geom = np.array([None, empty_line_string, multi_point, point, multi_polygon])\n    expected_parts = []\n    for g in geom:\n        for i in range(shapely.get_num_geometries(g)):\n            expected_parts.append(shapely.get_geometry(g, i))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == len(expected_parts))\n    assert_geometries_equal(parts, expected_parts)", "masked_code": "def test_get_parts_array():\n    geom = np.array([None, empty_line_string, multi_point, point, multi_polygon])\n    expected_parts = []\n    for g in geom:\n        for i in range(shapely.get_num_geometries(g)):\n            expected_parts.append(shapely.get_geometry(g, i))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == '???')\n    assert_geometries_equal(parts, expected_parts)", "ground_truth": ["6", "len(expected_parts)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_75", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_parts_geometry_collection_multi", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "def test_get_parts_geometry_collection_multi():\n    'On the first pass, the individual Multi* geometry objects are returned\\n    from the collection.  On the second pass, the individual singular geometry\\n    objects within those are returned.\\n    '\n    geom = shapely.geometrycollections([multi_point, multi_line_string, multi_polygon])\n    expected_num_parts = shapely.get_num_geometries(geom)\n    expected_parts = shapely.get_geometry(geom, range(expected_num_parts))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == expected_num_parts)\n    assert_geometries_equal(parts, expected_parts)\n    expected_subparts = []\n    for g in np.asarray(expected_parts):\n        for i in range(shapely.get_num_geometries(g)):\n            expected_subparts.append(shapely.get_geometry(g, i))\n    subparts = shapely.get_parts(parts)\n    assert (len(subparts) == len(expected_subparts))\n    assert_geometries_equal(subparts, expected_subparts)", "masked_code": "def test_get_parts_geometry_collection_multi():\n    'On the first pass, the individual Multi* geometry objects are returned\\n    from the collection.  On the second pass, the individual singular geometry\\n    objects within those are returned.\\n    '\n    geom = shapely.geometrycollections([multi_point, multi_line_string, multi_polygon])\n    expected_num_parts = shapely.get_num_geometries(geom)\n    expected_parts = shapely.get_geometry(geom, range(expected_num_parts))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == '???')\n    assert_geometries_equal(parts, expected_parts)\n    expected_subparts = []\n    for g in np.asarray(expected_parts):\n        for i in range(shapely.get_num_geometries(g)):\n            expected_subparts.append(shapely.get_geometry(g, i))\n    subparts = shapely.get_parts(parts)\n    assert (len(subparts) == len(expected_subparts))\n    assert_geometries_equal(subparts, expected_subparts)", "ground_truth": ["expected_num_parts", "np.int32(3)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_76", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_parts_geometry_collection_multi", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "def test_get_parts_geometry_collection_multi():\n    'On the first pass, the individual Multi* geometry objects are returned\\n    from the collection.  On the second pass, the individual singular geometry\\n    objects within those are returned.\\n    '\n    geom = shapely.geometrycollections([multi_point, multi_line_string, multi_polygon])\n    expected_num_parts = shapely.get_num_geometries(geom)\n    expected_parts = shapely.get_geometry(geom, range(expected_num_parts))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == expected_num_parts)\n    assert_geometries_equal(parts, expected_parts)\n    expected_subparts = []\n    for g in np.asarray(expected_parts):\n        for i in range(shapely.get_num_geometries(g)):\n            expected_subparts.append(shapely.get_geometry(g, i))\n    subparts = shapely.get_parts(parts)\n    assert (len(subparts) == len(expected_subparts))\n    assert_geometries_equal(subparts, expected_subparts)", "masked_code": "def test_get_parts_geometry_collection_multi():\n    'On the first pass, the individual Multi* geometry objects are returned\\n    from the collection.  On the second pass, the individual singular geometry\\n    objects within those are returned.\\n    '\n    geom = shapely.geometrycollections([multi_point, multi_line_string, multi_polygon])\n    expected_num_parts = shapely.get_num_geometries(geom)\n    expected_parts = shapely.get_geometry(geom, range(expected_num_parts))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == expected_num_parts)\n    assert_geometries_equal(parts, expected_parts)\n    expected_subparts = []\n    for g in np.asarray(expected_parts):\n        for i in range(shapely.get_num_geometries(g)):\n            expected_subparts.append(shapely.get_geometry(g, i))\n    subparts = shapely.get_parts(parts)\n    assert (len(subparts) == '???')\n    assert_geometries_equal(subparts, expected_subparts)", "ground_truth": ["5", "len(expected_subparts)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_77", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_parts_return_index", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "def test_get_parts_return_index():\n    geom = np.array([multi_point, point, multi_polygon])\n    expected_parts = []\n    expected_index = []\n    for (i, g) in enumerate(geom):\n        for j in range(shapely.get_num_geometries(g)):\n            expected_parts.append(shapely.get_geometry(g, j))\n            expected_index.append(i)\n    (parts, index) = shapely.get_parts(geom, return_index=True)\n    assert (len(parts) == len(expected_parts))\n    assert_geometries_equal(parts, expected_parts)\n    assert np.array_equal(index, expected_index)", "masked_code": "def test_get_parts_return_index():\n    geom = np.array([multi_point, point, multi_polygon])\n    expected_parts = []\n    expected_index = []\n    for (i, g) in enumerate(geom):\n        for j in range(shapely.get_num_geometries(g)):\n            expected_parts.append(shapely.get_geometry(g, j))\n            expected_index.append(i)\n    (parts, index) = shapely.get_parts(geom, return_index=True)\n    assert (len(parts) == '???')\n    assert_geometries_equal(parts, expected_parts)\n    assert np.array_equal(index, expected_index)", "ground_truth": ["5", "len(expected_parts)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_78", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_rings", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "@pytest.mark.parametrize('geom', [point, multi_point, line_string, multi_line_string, polygon, multi_polygon, geometry_collection, empty_point, empty_line_string, empty_polygon, empty_geometry_collection, None])\ndef test_get_rings(geom):\n    if ((shapely.get_type_id(geom) != shapely.GeometryType.POLYGON) or shapely.is_empty(geom)):\n        rings = shapely.get_rings(geom)\n        assert (len(rings) == 0)\n    else:\n        rings = shapely.get_rings(geom)\n        assert (len(rings) == 1)\n        assert (rings[0] == shapely.get_exterior_ring(geom))", "masked_code": "@pytest.mark.parametrize('geom', [point, multi_point, line_string, multi_line_string, polygon, multi_polygon, geometry_collection, empty_point, empty_line_string, empty_polygon, empty_geometry_collection, None])\ndef test_get_rings(geom):\n    if ((shapely.get_type_id(geom) != shapely.GeometryType.POLYGON) or shapely.is_empty(geom)):\n        rings = shapely.get_rings(geom)\n        assert (len(rings) == 0)\n    else:\n        rings = shapely.get_rings(geom)\n        assert (len(rings) == 1)\n        assert (rings[0] == '???')", "ground_truth": ["<LINEARRING (0 0, 2 0, 2 2, 0 2, 0 0)>", "shapely.get_exterior_ring(geom)"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_79", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_rings_holes", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "def test_get_rings_holes():\n    rings = shapely.get_rings(polygon_with_hole)\n    assert (len(rings) == 2)\n    assert (rings[0] == shapely.get_exterior_ring(polygon_with_hole))\n    assert (rings[1] == shapely.get_interior_ring(polygon_with_hole, 0))", "masked_code": "def test_get_rings_holes():\n    rings = shapely.get_rings(polygon_with_hole)\n    assert (len(rings) == 2)\n    assert (rings[0] == '???')\n    assert (rings[1] == shapely.get_interior_ring(polygon_with_hole, 0))", "ground_truth": ["<LINEARRING (0 0, 0 10, 10 10, 10 0, 0 0)>", "shapely.get_exterior_ring(polygon_with_hole)"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_80", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_rings_holes", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "def test_get_rings_holes():\n    rings = shapely.get_rings(polygon_with_hole)\n    assert (len(rings) == 2)\n    assert (rings[0] == shapely.get_exterior_ring(polygon_with_hole))\n    assert (rings[1] == shapely.get_interior_ring(polygon_with_hole, 0))", "masked_code": "def test_get_rings_holes():\n    rings = shapely.get_rings(polygon_with_hole)\n    assert (len(rings) == 2)\n    assert (rings[0] == shapely.get_exterior_ring(polygon_with_hole))\n    assert (rings[1] == '???')", "ground_truth": ["<LINEARRING (2 2, 2 4, 4 4, 4 2, 2 2)>", "shapely.get_interior_ring(polygon_with_hole, 0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_81", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_rings_return_index", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "def test_get_rings_return_index():\n    geom = np.array([polygon, None, empty_polygon, polygon_with_hole])\n    expected_parts = []\n    expected_index = []\n    for (i, g) in enumerate(geom):\n        if ((g is None) or shapely.is_empty(g)):\n            continue\n        expected_parts.append(shapely.get_exterior_ring(g))\n        expected_index.append(i)\n        for j in range(shapely.get_num_interior_rings(g)):\n            expected_parts.append(shapely.get_interior_ring(g, j))\n            expected_index.append(i)\n    (parts, index) = shapely.get_rings(geom, return_index=True)\n    assert (len(parts) == len(expected_parts))\n    assert_geometries_equal(parts, expected_parts)\n    assert np.array_equal(index, expected_index)", "masked_code": "def test_get_rings_return_index():\n    geom = np.array([polygon, None, empty_polygon, polygon_with_hole])\n    expected_parts = []\n    expected_index = []\n    for (i, g) in enumerate(geom):\n        if ((g is None) or shapely.is_empty(g)):\n            continue\n        expected_parts.append(shapely.get_exterior_ring(g))\n        expected_index.append(i)\n        for j in range(shapely.get_num_interior_rings(g)):\n            expected_parts.append(shapely.get_interior_ring(g, j))\n            expected_index.append(i)\n    (parts, index) = shapely.get_rings(geom, return_index=True)\n    assert (len(parts) == '???')\n    assert_geometries_equal(parts, expected_parts)\n    assert np.array_equal(index, expected_index)", "ground_truth": ["3", "len(expected_parts)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_68", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_set_srid", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "def test_get_set_srid():\n    actual = shapely.set_srid(point, 4326)\n    assert (shapely.get_srid(point) == 0)\n    assert (shapely.get_srid(actual) == 4326)", "masked_code": "def test_get_set_srid():\n    actual = shapely.set_srid(point, 4326)\n    assert (shapely.get_srid(point) == 0)\n    assert (shapely.get_srid(actual) == '???')", "ground_truth": ["4326"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_69", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_x", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "def test_get_x():\n    assert (shapely.get_x([point, point_z]).tolist() == [2.0, 2.0])", "masked_code": "def test_get_x():\n    assert (shapely.get_x([point, point_z]).tolist() == '???')", "ground_truth": ["[2.0, 2.0]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_70", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_y", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "def test_get_y():\n    assert (shapely.get_y([point, point_z]).tolist() == [3.0, 3.0])", "masked_code": "def test_get_y():\n    assert (shapely.get_y([point, point_z]).tolist() == '???')", "ground_truth": ["[3.0, 3.0]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_71", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_z", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "def test_get_z():\n    assert (shapely.get_z([point_z]).tolist() == [4.0])", "masked_code": "def test_get_z():\n    assert (shapely.get_z([point_z]).tolist() == '???')", "ground_truth": ["[4.0]"], "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_82", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_set_precision_intersection", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z"], "code": "def test_set_precision_intersection():\n    'Operations should use the most precise precision grid size of the inputs'\n    box1 = shapely.normalize(shapely.box(0, 0, 0.9, 0.9))\n    box2 = shapely.normalize(shapely.box(0.75, 0, 1.75, 0.75))\n    assert (shapely.get_precision(shapely.intersection(box1, box2)) == 0)\n    box1 = shapely.set_precision(box1, 0.5)\n    box2 = shapely.set_precision(box2, 1)\n    out = shapely.intersection(box1, box2)\n    assert (shapely.get_precision(out) == 0.5)\n    assert_geometries_equal(out, LineString([(1, 1), (1, 0)]))", "masked_code": "def test_set_precision_intersection():\n    'Operations should use the most precise precision grid size of the inputs'\n    box1 = shapely.normalize(shapely.box(0, 0, 0.9, 0.9))\n    box2 = shapely.normalize(shapely.box(0.75, 0, 1.75, 0.75))\n    assert (shapely.get_precision(shapely.intersection(box1, box2)) == 0)\n    box1 = shapely.set_precision(box1, 0.5)\n    box2 = shapely.set_precision(box2, 1)\n    out = shapely.intersection(box1, box2)\n    assert (shapely.get_precision(out) == '???')\n    assert_geometries_equal(out, LineString([(1, 1), (1, 0)]))", "ground_truth": ["0.5"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_275", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_geometry_base.py", "testname": "test_geometry_base.py", "funcname": "test_reverse", "imports": ["import platform", "import weakref", "import numpy as np", "import pytest", "import shapely", "from shapely import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.errors import ShapelyDeprecationWarning", "from shapely.testing import assert_geometries_equal"], "code": "def test_reverse():\n    coords = [(0, 0), (1, 2)]\n    line = LineString(coords)\n    result = line.reverse()\n    assert (result.coords[:] == coords[::(- 1)])", "masked_code": "def test_reverse():\n    coords = [(0, 0), (1, 2)]\n    line = LineString(coords)\n    result = line.reverse()\n    assert (result.coords[:] == '???')", "ground_truth": ["[[1, 2], [0, 0]]", "coords[::(- 1)]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_495", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linear_referencing.py", "testname": "test_linear_referencing.py", "funcname": "test_multiline_project", "imports": ["import unittest", "import pytest", "import shapely", "from shapely.geometry import LineString, MultiLineString, Point"], "code": "def test_multiline_project(self):\n    assert (self.multiline.project(self.point) == 1.0)\n    assert (self.multiline.project(self.point, normalized=True) == 0.125)", "masked_code": "def test_multiline_project(self):\n    assert (self.multiline.project(self.point) == 1.0)\n    assert (self.multiline.project(self.point, normalized=True) == '???')", "ground_truth": ["0.125"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LinearReferencingTestCase"}
{"task_id": "shapely_496", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == '???')\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_497", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == '???')\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "ground_truth": ["(0.0, 0.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_498", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == '???')\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "ground_truth": ["(2.0, 0.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_499", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == '???')\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "ground_truth": ["5"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_500", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == '???')\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_501", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == '???')\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "ground_truth": ["(0.0, 1.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_502", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == '???')\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "ground_truth": ["(1.0, 1.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_503", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == 'MultiLineString')", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[(0, 0), (1, 1)], [(2, 0), (2, 1), (1, 1)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    assert (result.coords[0] == (0.0, 0.0))\n    assert (result.coords[3] == (2.0, 0.0))\n    lines2 = MultiLineString([((0, 0), (1, 1)), ((0, 0), (2, 0), (2, 1), (1, 1))])\n    result = linemerge(lines2)\n    assert result.is_ring\n    assert (len(result.coords) == 5)\n    lines3 = [LineString([(0, 0), (1, 1)]), LineString([(0, 0), (0, 1)])]\n    result = linemerge(lines3)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 3)\n    assert (result.coords[0] == (0.0, 1.0))\n    assert (result.coords[2] == (1.0, 1.0))\n    lines4 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)]]\n    assert result.equals(linemerge(lines4))\n    lines5 = [((0, 0), (1, 1)), ((1, 0), (0, 1))]\n    result = linemerge(lines5)\n    assert (result.geom_type == '???')", "ground_truth": ["'MultiLineString'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_276", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_coordinate_sequence", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_coordinate_sequence():\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])", "masked_code": "def test_from_coordinate_sequence():\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == '???')\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])", "ground_truth": ["[(1.0, 2.0), (3.0, 4.0)]", "[[1.0, 2.0], [3.0, 4.0]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_277", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_coordinate_sequence", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_coordinate_sequence():\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])", "masked_code": "def test_from_coordinate_sequence():\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (line.coords[:] == '???')", "ground_truth": ["[(1.0, 2.0), (3.0, 4.0)]", "[[1.0, 2.0], [3.0, 4.0]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_278", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_coordinate_sequence_z", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_coordinate_sequence_z():\n    line = LineString([(1.0, 2.0, 3.0), (3.0, 4.0, 5.0)])\n    assert line.has_z\n    assert (line.coords[:] == [(1.0, 2.0, 3.0), (3.0, 4.0, 5.0)])", "masked_code": "def test_from_coordinate_sequence_z():\n    line = LineString([(1.0, 2.0, 3.0), (3.0, 4.0, 5.0)])\n    assert line.has_z\n    assert (line.coords[:] == '???')", "ground_truth": ["[(1.0, 2.0, 3.0), (3.0, 4.0, 5.0)]", "[[1.0, 2.0, 3.0], [3.0, 4.0, 5.0]]"], "quality_analysis": {"complexity_score": 17, "left_complexity": 5, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_289", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_empty():\n    line = LineString()\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])\n    line = LineString([])\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])", "masked_code": "def test_from_empty():\n    line = LineString()\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == '???')\n    line = LineString([])\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])", "ground_truth": ["[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_290", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_empty():\n    line = LineString()\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])\n    line = LineString([])\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])", "masked_code": "def test_from_empty():\n    line = LineString()\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])\n    line = LineString([])\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == '???')", "ground_truth": ["[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_288", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_generator", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_generator():\n    gen = (coord for coord in [(1.0, 2.0), (3.0, 4.0)])\n    line = LineString(gen)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])", "masked_code": "def test_from_generator():\n    gen = (coord for coord in [(1.0, 2.0), (3.0, 4.0)])\n    line = LineString(gen)\n    assert (line.coords[:] == '???')", "ground_truth": ["[(1.0, 2.0), (3.0, 4.0)]", "[[1.0, 2.0], [3.0, 4.0]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_284", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_linearring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_linearring():\n    coords = [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 0.0)]\n    ring = LinearRing(coords)\n    copy = LineString(ring)\n    assert (copy.coords[:] == coords)\n    assert (copy.geom_type == 'LineString')", "masked_code": "def test_from_linearring():\n    coords = [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 0.0)]\n    ring = LinearRing(coords)\n    copy = LineString(ring)\n    assert (copy.coords[:] == '???')\n    assert (copy.geom_type == 'LineString')", "ground_truth": ["coords"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_285", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_linearring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_linearring():\n    coords = [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 0.0)]\n    ring = LinearRing(coords)\n    copy = LineString(ring)\n    assert (copy.coords[:] == coords)\n    assert (copy.geom_type == 'LineString')", "masked_code": "def test_from_linearring():\n    coords = [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 0.0)]\n    ring = LinearRing(coords)\n    copy = LineString(ring)\n    assert (copy.coords[:] == coords)\n    assert (copy.geom_type == '???')", "ground_truth": ["'LineString'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_282", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_linestring():\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    copy = LineString(line)\n    assert (copy.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (copy.geom_type == 'LineString')", "masked_code": "def test_from_linestring():\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    copy = LineString(line)\n    assert (copy.coords[:] == '???')\n    assert (copy.geom_type == 'LineString')", "ground_truth": ["[(1.0, 2.0), (3.0, 4.0)]", "[[1.0, 2.0], [3.0, 4.0]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_283", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_linestring():\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    copy = LineString(line)\n    assert (copy.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (copy.geom_type == 'LineString')", "masked_code": "def test_from_linestring():\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    copy = LineString(line)\n    assert (copy.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (copy.geom_type == '???')", "ground_truth": ["'LineString'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_286", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_linestring_z", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_linestring_z():\n    coords = [(1.0, 2.0, 3.0), (4.0, 5.0, 6.0)]\n    line = LineString(coords)\n    copy = LineString(line)\n    assert (copy.coords[:] == coords)\n    assert (copy.geom_type == 'LineString')", "masked_code": "def test_from_linestring_z():\n    coords = [(1.0, 2.0, 3.0), (4.0, 5.0, 6.0)]\n    line = LineString(coords)\n    copy = LineString(line)\n    assert (copy.coords[:] == '???')\n    assert (copy.geom_type == 'LineString')", "ground_truth": ["coords"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_287", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_linestring_z", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_linestring_z():\n    coords = [(1.0, 2.0, 3.0), (4.0, 5.0, 6.0)]\n    line = LineString(coords)\n    copy = LineString(line)\n    assert (copy.coords[:] == coords)\n    assert (copy.geom_type == 'LineString')", "masked_code": "def test_from_linestring_z():\n    coords = [(1.0, 2.0, 3.0), (4.0, 5.0, 6.0)]\n    line = LineString(coords)\n    copy = LineString(line)\n    assert (copy.coords[:] == coords)\n    assert (copy.geom_type == '???')", "ground_truth": ["'LineString'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_281", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_mix", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_mix():\n    line = LineString([Point(1.0, 2.0), (2.0, 3.0), Point(3.0, 4.0)])\n    assert (line.coords[:] == [(1.0, 2.0), (2.0, 3.0), (3.0, 4.0)])", "masked_code": "def test_from_mix():\n    line = LineString([Point(1.0, 2.0), (2.0, 3.0), Point(3.0, 4.0)])\n    assert (line.coords[:] == '???')", "ground_truth": ["[(1.0, 2.0), (2.0, 3.0), (3.0, 4.0)]", "[[1.0, 2.0], [2.0, 3.0], [3.0, 4.0]]"], "quality_analysis": {"complexity_score": 19, "left_complexity": 5, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_291", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_numpy", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_numpy():\n    line = LineString(np.array([[1.0, 2.0], [3.0, 4.0]]))\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])", "masked_code": "def test_from_numpy():\n    line = LineString(np.array([[1.0, 2.0], [3.0, 4.0]]))\n    assert (line.coords[:] == '???')", "ground_truth": ["[(1.0, 2.0), (3.0, 4.0)]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_279", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_points", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_points():\n    line = LineString([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    line = LineString([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])", "masked_code": "def test_from_points():\n    line = LineString([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (line.coords[:] == '???')\n    line = LineString([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])", "ground_truth": ["[(1.0, 2.0), (3.0, 4.0)]", "[[1.0, 2.0], [3.0, 4.0]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_280", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_points", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_points():\n    line = LineString([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    line = LineString([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])", "masked_code": "def test_from_points():\n    line = LineString([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    line = LineString([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (line.coords[:] == '???')", "ground_truth": ["[(1.0, 2.0), (3.0, 4.0)]", "[[1.0, 2.0], [3.0, 4.0]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_296", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring(self):\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (line.bounds == (1.0, 2.0, 3.0, 4.0))\n    assert (tuple(line.coords) == ((1.0, 2.0), (3.0, 4.0)))\n    assert (line.coords[0] == (1.0, 2.0))\n    assert (line.coords[1] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        line.coords[2]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "masked_code": "def test_linestring(self):\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == '???')\n    assert (line.bounds == (1.0, 2.0, 3.0, 4.0))\n    assert (tuple(line.coords) == ((1.0, 2.0), (3.0, 4.0)))\n    assert (line.coords[0] == (1.0, 2.0))\n    assert (line.coords[1] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        line.coords[2]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "ground_truth": ["[(1.0, 2.0), (3.0, 4.0)]", "[[1.0, 2.0], [3.0, 4.0]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_297", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring(self):\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (line.bounds == (1.0, 2.0, 3.0, 4.0))\n    assert (tuple(line.coords) == ((1.0, 2.0), (3.0, 4.0)))\n    assert (line.coords[0] == (1.0, 2.0))\n    assert (line.coords[1] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        line.coords[2]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "masked_code": "def test_linestring(self):\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (line.bounds == '???')\n    assert (tuple(line.coords) == ((1.0, 2.0), (3.0, 4.0)))\n    assert (line.coords[0] == (1.0, 2.0))\n    assert (line.coords[1] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        line.coords[2]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "ground_truth": ["(1.0, 2.0, 3.0, 4.0)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_298", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring(self):\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (line.bounds == (1.0, 2.0, 3.0, 4.0))\n    assert (tuple(line.coords) == ((1.0, 2.0), (3.0, 4.0)))\n    assert (line.coords[0] == (1.0, 2.0))\n    assert (line.coords[1] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        line.coords[2]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "masked_code": "def test_linestring(self):\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (line.bounds == (1.0, 2.0, 3.0, 4.0))\n    assert (tuple(line.coords) == '???')\n    assert (line.coords[0] == (1.0, 2.0))\n    assert (line.coords[1] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        line.coords[2]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "ground_truth": ["((1.0, 2.0), (3.0, 4.0))", "([1.0, 2.0], [3.0, 4.0])"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_299", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring(self):\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (line.bounds == (1.0, 2.0, 3.0, 4.0))\n    assert (tuple(line.coords) == ((1.0, 2.0), (3.0, 4.0)))\n    assert (line.coords[0] == (1.0, 2.0))\n    assert (line.coords[1] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        line.coords[2]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "masked_code": "def test_linestring(self):\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (line.bounds == (1.0, 2.0, 3.0, 4.0))\n    assert (tuple(line.coords) == ((1.0, 2.0), (3.0, 4.0)))\n    assert (line.coords[0] == '???')\n    assert (line.coords[1] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        line.coords[2]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "ground_truth": ["(1.0, 2.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_300", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring(self):\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (line.bounds == (1.0, 2.0, 3.0, 4.0))\n    assert (tuple(line.coords) == ((1.0, 2.0), (3.0, 4.0)))\n    assert (line.coords[0] == (1.0, 2.0))\n    assert (line.coords[1] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        line.coords[2]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "masked_code": "def test_linestring(self):\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (line.bounds == (1.0, 2.0, 3.0, 4.0))\n    assert (tuple(line.coords) == ((1.0, 2.0), (3.0, 4.0)))\n    assert (line.coords[0] == (1.0, 2.0))\n    assert (line.coords[1] == '???')\n    with pytest.raises(IndexError):\n        line.coords[2]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "ground_truth": ["(3.0, 4.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_301", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring(self):\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (line.bounds == (1.0, 2.0, 3.0, 4.0))\n    assert (tuple(line.coords) == ((1.0, 2.0), (3.0, 4.0)))\n    assert (line.coords[0] == (1.0, 2.0))\n    assert (line.coords[1] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        line.coords[2]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "masked_code": "def test_linestring(self):\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(line.coords) == 2)\n    assert (line.coords[:] == [(1.0, 2.0), (3.0, 4.0)])\n    assert (line.bounds == (1.0, 2.0, 3.0, 4.0))\n    assert (tuple(line.coords) == ((1.0, 2.0), (3.0, 4.0)))\n    assert (line.coords[0] == (1.0, 2.0))\n    assert (line.coords[1] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        line.coords[2]\n    assert (line.__geo_interface__ == '???')", "ground_truth": ["{'type': 'LineString', 'coordinates': ((1.0, 2.0), (3.0, 4.0))}", "{'type': 'LineString', 'coordinates': [[1.0, 2.0], [3.0, 4.0]]}"], "quality_analysis": {"complexity_score": 18, "left_complexity": 2, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_294", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring_array_coercion", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring_array_coercion():\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    arr = np.array(line)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == line)", "masked_code": "def test_linestring_array_coercion():\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    arr = np.array(line)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == '???')\n    assert (arr.item() == line)", "ground_truth": ["dtype('O')", "np.dtype('object')"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_295", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring_array_coercion", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring_array_coercion():\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    arr = np.array(line)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == line)", "masked_code": "def test_linestring_array_coercion():\n    line = LineString([(1.0, 2.0), (3.0, 4.0)])\n    arr = np.array(line)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == '???')", "ground_truth": ["<LINESTRING (1 2, 3 4)>", "line"], "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_302", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring_empty(self):\n    l_null = LineString()\n    assert (l_null.wkt == 'LINESTRING EMPTY')\n    assert (l_null.length == 0.0)", "masked_code": "def test_linestring_empty(self):\n    l_null = LineString()\n    assert (l_null.wkt == '???')\n    assert (l_null.length == 0.0)", "ground_truth": ["'LINESTRING EMPTY'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_292", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_numpy_empty_linestring_coords", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_numpy_empty_linestring_coords():\n    line = LineString([])\n    la = np.asarray(line.coords)\n    assert (la.shape == (0, 2))", "masked_code": "def test_numpy_empty_linestring_coords():\n    line = LineString([])\n    la = np.asarray(line.coords)\n    assert (la.shape == '???')", "ground_truth": ["(0, 2)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_293", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_numpy_object_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_numpy_object_array():\n    geom = LineString([(0.0, 0.0), (0.0, 1.0)])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == geom)", "masked_code": "def test_numpy_object_array():\n    geom = LineString([(0.0, 0.0), (0.0, 1.0)])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == '???')", "ground_truth": ["<LINESTRING (0 0, 0 1)>", "geom"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_504", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_make_valid.py", "testname": "test_make_valid.py", "funcname": "test_make_valid_input", "imports": ["from shapely.geometry import Polygon", "from shapely.validation import make_valid"], "code": "def test_make_valid_input():\n    geom = Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])\n    valid = make_valid(geom)\n    assert (id(valid) == id(geom))", "masked_code": "def test_make_valid_input():\n    geom = Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])\n    valid = make_valid(geom)\n    assert (id(valid) == '???')", "ground_truth": ["140522219288576", "id(geom)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_505", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_mapping.py", "testname": "test_mapping.py", "funcname": "test_point", "imports": ["import unittest", "from shapely.geometry import Point, Polygon, mapping"], "code": "def test_point(self):\n    m = mapping(Point(0, 0))\n    assert (m['type'] == 'Point')\n    assert (m['coordinates'] == (0.0, 0.0))", "masked_code": "def test_point(self):\n    m = mapping(Point(0, 0))\n    assert (m['type'] == '???')\n    assert (m['coordinates'] == (0.0, 0.0))", "ground_truth": ["'Point'"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "MappingTestCase"}
{"task_id": "shapely_506", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_mapping.py", "testname": "test_mapping.py", "funcname": "test_point", "imports": ["import unittest", "from shapely.geometry import Point, Polygon, mapping"], "code": "def test_point(self):\n    m = mapping(Point(0, 0))\n    assert (m['type'] == 'Point')\n    assert (m['coordinates'] == (0.0, 0.0))", "masked_code": "def test_point(self):\n    m = mapping(Point(0, 0))\n    assert (m['type'] == 'Point')\n    assert (m['coordinates'] == '???')", "ground_truth": ["(0.0, 0.0)"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "MappingTestCase"}
{"task_id": "shapely_164", "reponame": "shapely", "testpath": "shapely/tests/test_measurement.py", "testname": "test_measurement.py", "funcname": "test_area", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_array_equal", "import shapely", "from shapely import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.tests.common import empty, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, point_polygon_testdata, polygon, polygon_with_hole"], "code": "def test_area():\n    actual = shapely.area([polygon, polygon_with_hole, multi_polygon])\n    assert (actual.tolist() == [4.0, 96.0, 1.01])", "masked_code": "def test_area():\n    actual = shapely.area([polygon, polygon_with_hole, multi_polygon])\n    assert (actual.tolist() == '???')", "ground_truth": ["[4.0, 96.0, 1.01]"], "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_165", "reponame": "shapely", "testpath": "shapely/tests/test_measurement.py", "testname": "test_measurement.py", "funcname": "test_bounds_dimensions", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_array_equal", "import shapely", "from shapely import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.tests.common import empty, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, point_polygon_testdata, polygon, polygon_with_hole"], "code": "@pytest.mark.parametrize('geom,shape', [(point, (4,)), (None, (4,)), ([point, multi_point], (2, 4)), ([[point, multi_point], [polygon, point]], (2, 2, 4)), ([[[point, multi_point]], [[polygon, point]]], (2, 1, 2, 4))])\ndef test_bounds_dimensions(geom, shape):\n    assert (shapely.bounds(geom).shape == shape)", "masked_code": "@pytest.mark.parametrize('geom,shape', [(point, (4,)), (None, (4,)), ([point, multi_point], (2, 4)), ([[point, multi_point], [polygon, point]], (2, 2, 4)), ([[[point, multi_point]], [[polygon, point]]], (2, 1, 2, 4))])\ndef test_bounds_dimensions(geom, shape):\n    assert (shapely.bounds(geom).shape == '???')", "ground_truth": ["(4,)", "shape"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_166", "reponame": "shapely", "testpath": "shapely/tests/test_measurement.py", "testname": "test_measurement.py", "funcname": "test_total_bounds_dimensions", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_array_equal", "import shapely", "from shapely import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.tests.common import empty, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, point_polygon_testdata, polygon, polygon_with_hole"], "code": "@pytest.mark.parametrize('geom', [point, None, [point, multi_point], [[point, multi_point], [polygon, point]], [[[point, multi_point]], [[polygon, point]]]])\ndef test_total_bounds_dimensions(geom):\n    assert (shapely.total_bounds(geom).shape == (4,))", "masked_code": "@pytest.mark.parametrize('geom', [point, None, [point, multi_point], [[point, multi_point], [polygon, point]], [[[point, multi_point]], [[polygon, point]]]])\ndef test_total_bounds_dimensions(geom):\n    assert (shapely.total_bounds(geom).shape == '???')", "ground_truth": ["(4,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_508", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_minimum_clearance.py", "testname": "test_minimum_clearance.py", "funcname": "test_linestring", "imports": ["import math", "from shapely.wkt import loads as load_wkt"], "code": "def test_linestring():\n    line = load_wkt('LINESTRING (0 0, 1 1, 2 2)')\n    assert (round(line.minimum_clearance, 6) == 1.414214)", "masked_code": "def test_linestring():\n    line = load_wkt('LINESTRING (0 0, 1 1, 2 2)')\n    assert (round(line.minimum_clearance, 6) == '???')", "ground_truth": ["1.414214"], "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_509", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_minimum_clearance.py", "testname": "test_minimum_clearance.py", "funcname": "test_more_complicated_polygon", "imports": ["import math", "from shapely.wkt import loads as load_wkt"], "code": "def test_more_complicated_polygon():\n    poly = load_wkt('POLYGON ((20 20, 34 124, 70 140, 130 130, 70 100, 110 70, 170 20, 90 10, 20 20))')\n    assert (round(poly.minimum_clearance, 6) == 35.777088)", "masked_code": "def test_more_complicated_polygon():\n    poly = load_wkt('POLYGON ((20 20, 34 124, 70 140, 130 130, 70 100, 110 70, 170 20, 90 10, 20 20))')\n    assert (round(poly.minimum_clearance, 6) == '???')", "ground_truth": ["35.777088"], "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_507", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_minimum_clearance.py", "testname": "test_minimum_clearance.py", "funcname": "test_point", "imports": ["import math", "from shapely.wkt import loads as load_wkt"], "code": "def test_point():\n    point = load_wkt('POINT (0 0)')\n    assert (point.minimum_clearance == math.inf)", "masked_code": "def test_point():\n    point = load_wkt('POINT (0 0)')\n    assert (point.minimum_clearance == '???')", "ground_truth": ["inf", "math.inf"], "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_172", "reponame": "shapely", "testpath": "shapely/tests/test_misc.py", "testname": "test_misc.py", "funcname": "test_multithreading_enabled_ok", "imports": ["import os", "import sys", "from inspect import cleandoc", "from itertools import chain", "from string import ascii_letters, digits", "from unittest import mock", "import numpy as np", "import pytest", "import shapely", "from shapely.decorators import multithreading_enabled, requires_geos"], "code": "@pytest.mark.parametrize('args,kwargs', [((np.empty((1,), dtype=float),), {}), ((), {'a': np.empty((1,), dtype=float)}), (([1],), {}), ((), {'a': [1]}), ((), {'out': np.empty((1,), dtype=object)}), ((), {'where': np.empty((1,), dtype=object)})])\ndef test_multithreading_enabled_ok(args, kwargs):\n    result = set_first_element(42, *args, **kwargs)\n    assert (result[0] == 42)", "masked_code": "@pytest.mark.parametrize('args,kwargs', [((np.empty((1,), dtype=float),), {}), ((), {'a': np.empty((1,), dtype=float)}), (([1],), {}), ((), {'a': [1]}), ((), {'out': np.empty((1,), dtype=object)}), ((), {'where': np.empty((1,), dtype=object)})])\ndef test_multithreading_enabled_ok(args, kwargs):\n    result = set_first_element(42, *args, **kwargs)\n    assert (result[0] == '???')", "ground_truth": ["42"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_171", "reponame": "shapely", "testpath": "shapely/tests/test_misc.py", "testname": "test_misc.py", "funcname": "test_multithreading_enabled_raises_arg", "imports": ["import os", "import sys", "from inspect import cleandoc", "from itertools import chain", "from string import ascii_letters, digits", "from unittest import mock", "import numpy as np", "import pytest", "import shapely", "from shapely.decorators import multithreading_enabled, requires_geos"], "code": "def test_multithreading_enabled_raises_arg():\n    arr = np.empty((1,), dtype=object)\n    with pytest.raises(ValueError):\n        set_first_element(42, arr)\n    arr[0] = 42\n    assert (arr[0] == 42)", "masked_code": "def test_multithreading_enabled_raises_arg():\n    arr = np.empty((1,), dtype=object)\n    with pytest.raises(ValueError):\n        set_first_element(42, arr)\n    arr[0] = 42\n    assert (arr[0] == '???')", "ground_truth": ["42"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_169", "reponame": "shapely", "testpath": "shapely/tests/test_misc.py", "testname": "test_misc.py", "funcname": "test_requires_geos_doc_build", "imports": ["import os", "import sys", "from inspect import cleandoc", "from itertools import chain", "from string import ascii_letters, digits", "from unittest import mock", "import numpy as np", "import pytest", "import shapely", "from shapely.decorators import multithreading_enabled, requires_geos"], "code": "@pytest.mark.parametrize('version', ['3.9.0', '3.10.0'])\ndef test_requires_geos_doc_build(version, mocked_geos_version, sphinx_doc_build):\n    'The requires_geos decorator always adapts the docstring.'\n    wrapped = requires_geos(version)(func)\n    assert (wrapped.__doc__ == expected_docstring(version=version, indent=(' ' * 4)))", "masked_code": "@pytest.mark.parametrize('version', ['3.9.0', '3.10.0'])\ndef test_requires_geos_doc_build(version, mocked_geos_version, sphinx_doc_build):\n    'The requires_geos decorator always adapts the docstring.'\n    wrapped = requires_geos(version)(func)\n    assert (wrapped.__doc__ == '???')", "ground_truth": ["\"Docstring that will be mocked.\\n    A multiline.\\n\\n    .. note:: 'func' requires at least GEOS 3.9.0.\\n\\n    Some description.\\n    \"", "expected_docstring(version=version, indent=(' ' * 4))"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_170", "reponame": "shapely", "testpath": "shapely/tests/test_misc.py", "testname": "test_misc.py", "funcname": "test_requires_geos_method", "imports": ["import os", "import sys", "from inspect import cleandoc", "from itertools import chain", "from string import ascii_letters, digits", "from unittest import mock", "import numpy as np", "import pytest", "import shapely", "from shapely.decorators import multithreading_enabled, requires_geos"], "code": "@pytest.mark.parametrize('version', ['3.9.0', '3.10.0'])\ndef test_requires_geos_method(version, mocked_geos_version, sphinx_doc_build):\n    'The requires_geos decorator adjusts methods docstrings correctly'\n    wrapped = requires_geos(version)(SomeClass.func)\n    assert (wrapped.__doc__ == expected_docstring(version=version, indent=(' ' * 8)))", "masked_code": "@pytest.mark.parametrize('version', ['3.9.0', '3.10.0'])\ndef test_requires_geos_method(version, mocked_geos_version, sphinx_doc_build):\n    'The requires_geos decorator adjusts methods docstrings correctly'\n    wrapped = requires_geos(version)(SomeClass.func)\n    assert (wrapped.__doc__ == '???')", "ground_truth": ["\"Docstring that will be mocked.\\n        A multiline.\\n\\n        .. note:: 'func' requires at least GEOS 3.9.0.\\n\\n        Some description.\\n        \"", "expected_docstring(version=version, indent=(' ' * 8))"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_168", "reponame": "shapely", "testpath": "shapely/tests/test_misc.py", "testname": "test_misc.py", "funcname": "test_requires_geos_not_ok", "imports": ["import os", "import sys", "from inspect import cleandoc", "from itertools import chain", "from string import ascii_letters, digits", "from unittest import mock", "import numpy as np", "import pytest", "import shapely", "from shapely.decorators import multithreading_enabled, requires_geos"], "code": "@pytest.mark.parametrize('version', ['3.10.2', '3.11.0', '3.11.1'])\ndef test_requires_geos_not_ok(version, mocked_geos_version):\n    wrapped = requires_geos(version)(func)\n    with pytest.raises(shapely.errors.UnsupportedGEOSVersionError):\n        wrapped()\n    assert (wrapped.__doc__ == expected_docstring(version=version, indent=(' ' * 4)))", "masked_code": "@pytest.mark.parametrize('version', ['3.10.2', '3.11.0', '3.11.1'])\ndef test_requires_geos_not_ok(version, mocked_geos_version):\n    wrapped = requires_geos(version)(func)\n    with pytest.raises(shapely.errors.UnsupportedGEOSVersionError):\n        wrapped()\n    assert (wrapped.__doc__ == '???')", "ground_truth": ["expected_docstring(version=version, indent=(' ' * 4))"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_309", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_from_multilinestring_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_from_multilinestring_z(self):\n    coords1 = [(0.0, 1.0, 2.0), (3.0, 4.0, 5.0)]\n    coords2 = [(6.0, 7.0, 8.0), (9.0, 10.0, 11.0)]\n    ml = MultiLineString([coords1, coords2])\n    copy = MultiLineString(ml)\n    assert isinstance(copy, MultiLineString)\n    assert (copy.geom_type == 'MultiLineString')\n    assert (len(copy.geoms) == 2)\n    assert (dump_coords(copy.geoms[0]) == coords1)\n    assert (dump_coords(copy.geoms[1]) == coords2)", "masked_code": "def test_from_multilinestring_z(self):\n    coords1 = [(0.0, 1.0, 2.0), (3.0, 4.0, 5.0)]\n    coords2 = [(6.0, 7.0, 8.0), (9.0, 10.0, 11.0)]\n    ml = MultiLineString([coords1, coords2])\n    copy = MultiLineString(ml)\n    assert isinstance(copy, MultiLineString)\n    assert (copy.geom_type == '???')\n    assert (len(copy.geoms) == 2)\n    assert (dump_coords(copy.geoms[0]) == coords1)\n    assert (dump_coords(copy.geoms[1]) == coords2)", "ground_truth": ["'MultiLineString'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_310", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_from_multilinestring_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_from_multilinestring_z(self):\n    coords1 = [(0.0, 1.0, 2.0), (3.0, 4.0, 5.0)]\n    coords2 = [(6.0, 7.0, 8.0), (9.0, 10.0, 11.0)]\n    ml = MultiLineString([coords1, coords2])\n    copy = MultiLineString(ml)\n    assert isinstance(copy, MultiLineString)\n    assert (copy.geom_type == 'MultiLineString')\n    assert (len(copy.geoms) == 2)\n    assert (dump_coords(copy.geoms[0]) == coords1)\n    assert (dump_coords(copy.geoms[1]) == coords2)", "masked_code": "def test_from_multilinestring_z(self):\n    coords1 = [(0.0, 1.0, 2.0), (3.0, 4.0, 5.0)]\n    coords2 = [(6.0, 7.0, 8.0), (9.0, 10.0, 11.0)]\n    ml = MultiLineString([coords1, coords2])\n    copy = MultiLineString(ml)\n    assert isinstance(copy, MultiLineString)\n    assert (copy.geom_type == 'MultiLineString')\n    assert (len(copy.geoms) == 2)\n    assert (dump_coords(copy.geoms[0]) == '???')\n    assert (dump_coords(copy.geoms[1]) == coords2)", "ground_truth": ["[[0.0, 1.0, 2.0], [3.0, 4.0, 5.0]]", "coords1"], "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_311", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_from_multilinestring_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_from_multilinestring_z(self):\n    coords1 = [(0.0, 1.0, 2.0), (3.0, 4.0, 5.0)]\n    coords2 = [(6.0, 7.0, 8.0), (9.0, 10.0, 11.0)]\n    ml = MultiLineString([coords1, coords2])\n    copy = MultiLineString(ml)\n    assert isinstance(copy, MultiLineString)\n    assert (copy.geom_type == 'MultiLineString')\n    assert (len(copy.geoms) == 2)\n    assert (dump_coords(copy.geoms[0]) == coords1)\n    assert (dump_coords(copy.geoms[1]) == coords2)", "masked_code": "def test_from_multilinestring_z(self):\n    coords1 = [(0.0, 1.0, 2.0), (3.0, 4.0, 5.0)]\n    coords2 = [(6.0, 7.0, 8.0), (9.0, 10.0, 11.0)]\n    ml = MultiLineString([coords1, coords2])\n    copy = MultiLineString(ml)\n    assert isinstance(copy, MultiLineString)\n    assert (copy.geom_type == 'MultiLineString')\n    assert (len(copy.geoms) == 2)\n    assert (dump_coords(copy.geoms[0]) == coords1)\n    assert (dump_coords(copy.geoms[1]) == '???')", "ground_truth": ["[[6.0, 7.0, 8.0], [9.0, 10.0, 11.0]]", "coords2"], "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_304", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_multilinestring", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multilinestring(self):\n    geom = MultiLineString([[(1.0, 2.0), (3.0, 4.0)]])\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(1.0, 2.0), (3.0, 4.0)]])\n    a = LineString([(1.0, 2.0), (3.0, 4.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[(1.0, 2.0), (3.0, 4.0)]])\n    ml2 = MultiLineString(ml)\n    assert (len(ml2.geoms) == 1)\n    assert (dump_coords(ml2) == [[(1.0, 2.0), (3.0, 4.0)]])\n    geom = MultiLineString([((0.0, 0.0), (1.0, 2.0))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (1.0, 2.0)])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})", "masked_code": "def test_multilinestring(self):\n    geom = MultiLineString([[(1.0, 2.0), (3.0, 4.0)]])\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == '???')\n    a = LineString([(1.0, 2.0), (3.0, 4.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[(1.0, 2.0), (3.0, 4.0)]])\n    ml2 = MultiLineString(ml)\n    assert (len(ml2.geoms) == 1)\n    assert (dump_coords(ml2) == [[(1.0, 2.0), (3.0, 4.0)]])\n    geom = MultiLineString([((0.0, 0.0), (1.0, 2.0))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (1.0, 2.0)])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})", "ground_truth": ["[[(1.0, 2.0), (3.0, 4.0)]]", "[[[1.0, 2.0], [3.0, 4.0]]]"], "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_305", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_multilinestring", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multilinestring(self):\n    geom = MultiLineString([[(1.0, 2.0), (3.0, 4.0)]])\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(1.0, 2.0), (3.0, 4.0)]])\n    a = LineString([(1.0, 2.0), (3.0, 4.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[(1.0, 2.0), (3.0, 4.0)]])\n    ml2 = MultiLineString(ml)\n    assert (len(ml2.geoms) == 1)\n    assert (dump_coords(ml2) == [[(1.0, 2.0), (3.0, 4.0)]])\n    geom = MultiLineString([((0.0, 0.0), (1.0, 2.0))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (1.0, 2.0)])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})", "masked_code": "def test_multilinestring(self):\n    geom = MultiLineString([[(1.0, 2.0), (3.0, 4.0)]])\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(1.0, 2.0), (3.0, 4.0)]])\n    a = LineString([(1.0, 2.0), (3.0, 4.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == '???')\n    ml2 = MultiLineString(ml)\n    assert (len(ml2.geoms) == 1)\n    assert (dump_coords(ml2) == [[(1.0, 2.0), (3.0, 4.0)]])\n    geom = MultiLineString([((0.0, 0.0), (1.0, 2.0))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (1.0, 2.0)])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})", "ground_truth": ["[[(1.0, 2.0), (3.0, 4.0)]]", "[[[1.0, 2.0], [3.0, 4.0]]]"], "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_306", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_multilinestring", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multilinestring(self):\n    geom = MultiLineString([[(1.0, 2.0), (3.0, 4.0)]])\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(1.0, 2.0), (3.0, 4.0)]])\n    a = LineString([(1.0, 2.0), (3.0, 4.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[(1.0, 2.0), (3.0, 4.0)]])\n    ml2 = MultiLineString(ml)\n    assert (len(ml2.geoms) == 1)\n    assert (dump_coords(ml2) == [[(1.0, 2.0), (3.0, 4.0)]])\n    geom = MultiLineString([((0.0, 0.0), (1.0, 2.0))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (1.0, 2.0)])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})", "masked_code": "def test_multilinestring(self):\n    geom = MultiLineString([[(1.0, 2.0), (3.0, 4.0)]])\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(1.0, 2.0), (3.0, 4.0)]])\n    a = LineString([(1.0, 2.0), (3.0, 4.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[(1.0, 2.0), (3.0, 4.0)]])\n    ml2 = MultiLineString(ml)\n    assert (len(ml2.geoms) == 1)\n    assert (dump_coords(ml2) == '???')\n    geom = MultiLineString([((0.0, 0.0), (1.0, 2.0))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (1.0, 2.0)])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})", "ground_truth": ["[[(1.0, 2.0), (3.0, 4.0)]]", "[[[1.0, 2.0], [3.0, 4.0]]]"], "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_307", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_multilinestring", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multilinestring(self):\n    geom = MultiLineString([[(1.0, 2.0), (3.0, 4.0)]])\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(1.0, 2.0), (3.0, 4.0)]])\n    a = LineString([(1.0, 2.0), (3.0, 4.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[(1.0, 2.0), (3.0, 4.0)]])\n    ml2 = MultiLineString(ml)\n    assert (len(ml2.geoms) == 1)\n    assert (dump_coords(ml2) == [[(1.0, 2.0), (3.0, 4.0)]])\n    geom = MultiLineString([((0.0, 0.0), (1.0, 2.0))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (1.0, 2.0)])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})", "masked_code": "def test_multilinestring(self):\n    geom = MultiLineString([[(1.0, 2.0), (3.0, 4.0)]])\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(1.0, 2.0), (3.0, 4.0)]])\n    a = LineString([(1.0, 2.0), (3.0, 4.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[(1.0, 2.0), (3.0, 4.0)]])\n    ml2 = MultiLineString(ml)\n    assert (len(ml2.geoms) == 1)\n    assert (dump_coords(ml2) == [[(1.0, 2.0), (3.0, 4.0)]])\n    geom = MultiLineString([((0.0, 0.0), (1.0, 2.0))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == '???')\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)),)})", "ground_truth": ["[(0.0, 0.0), (1.0, 2.0)]", "[[0.0, 0.0], [1.0, 2.0]]"], "quality_analysis": {"complexity_score": 19, "left_complexity": 9, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_303", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_numpy_object_array", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_numpy_object_array():\n    geom = MultiLineString([[[5.0, 6.0], [7.0, 8.0]]])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == geom)", "masked_code": "def test_numpy_object_array():\n    geom = MultiLineString([[[5.0, 6.0], [7.0, 8.0]]])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == '???')", "ground_truth": ["<MULTILINESTRING ((5 6, 7 8))>", "geom"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_316", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint(self):\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom = MultiPoint([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 1.0)\n    assert (geom.geoms[0].y == 2.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "masked_code": "def test_multipoint(self):\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == '???')\n    geom = MultiPoint([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 1.0)\n    assert (geom.geoms[0].y == 2.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "ground_truth": ["[[(1.0, 2.0)], [(3.0, 4.0)]]", "[[[1.0, 2.0]], [[3.0, 4.0]]]"], "quality_analysis": {"complexity_score": 18, "left_complexity": 4, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPoint"}
{"task_id": "shapely_317", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint(self):\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom = MultiPoint([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 1.0)\n    assert (geom.geoms[0].y == 2.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "masked_code": "def test_multipoint(self):\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom = MultiPoint([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == '???')\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 1.0)\n    assert (geom.geoms[0].y == 2.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "ground_truth": ["[[(1.0, 2.0)], [(3.0, 4.0)]]", "[[[1.0, 2.0]], [[3.0, 4.0]]]"], "quality_analysis": {"complexity_score": 18, "left_complexity": 4, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPoint"}
{"task_id": "shapely_318", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint(self):\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom = MultiPoint([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 1.0)\n    assert (geom.geoms[0].y == 2.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "masked_code": "def test_multipoint(self):\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom = MultiPoint([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == '???')\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 1.0)\n    assert (geom.geoms[0].y == 2.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "ground_truth": ["[[(1.0, 2.0)], [(3.0, 4.0)]]", "[[[1.0, 2.0]], [[3.0, 4.0]]]"], "quality_analysis": {"complexity_score": 18, "left_complexity": 4, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPoint"}
{"task_id": "shapely_319", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint(self):\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom = MultiPoint([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 1.0)\n    assert (geom.geoms[0].y == 2.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))})", "masked_code": "def test_multipoint(self):\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom = MultiPoint([Point(1.0, 2.0), Point(3.0, 4.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(1.0, 2.0)], [(3.0, 4.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 1.0)\n    assert (geom.geoms[0].y == 2.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == '???')", "ground_truth": ["{'type': 'MultiPoint', 'coordinates': ((1.0, 2.0), (3.0, 4.0))}", "{'type': 'MultiPoint', 'coordinates': [[1.0, 2.0], [3.0, 4.0]]}"], "quality_analysis": {"complexity_score": 18, "left_complexity": 2, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPoint"}
{"task_id": "shapely_313", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint_array_coercion", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint_array_coercion():\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    arr = np.array(geom)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == geom)", "masked_code": "def test_multipoint_array_coercion():\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    arr = np.array(geom)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == '???')\n    assert (arr.item() == geom)", "ground_truth": ["dtype('O')", "np.dtype('object')"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_314", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint_array_coercion", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint_array_coercion():\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    arr = np.array(geom)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == geom)", "masked_code": "def test_multipoint_array_coercion():\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    arr = np.array(geom)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == '???')", "ground_truth": ["<MULTIPOINT (1 2, 3 4)>", "geom"], "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_320", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint_from_numpy", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint_from_numpy(self):\n    geom = MultiPoint(np.array([[0.0, 0.0], [1.0, 2.0]]))\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(0.0, 0.0)], [(1.0, 2.0)]])", "masked_code": "def test_multipoint_from_numpy(self):\n    geom = MultiPoint(np.array([[0.0, 0.0], [1.0, 2.0]]))\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == '???')", "ground_truth": ["[[(0.0, 0.0)], [(1.0, 2.0)]]", "[[[0.0, 0.0]], [[1.0, 2.0]]]"], "quality_analysis": {"complexity_score": 18, "left_complexity": 4, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPoint"}
{"task_id": "shapely_315", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_numpy_object_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_numpy_object_array():\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == geom)", "masked_code": "def test_numpy_object_array():\n    geom = MultiPoint([(1.0, 2.0), (3.0, 4.0)])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == '???')", "ground_truth": ["<MULTIPOINT (1 2, 3 4)>", "geom"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_322", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_multipolygon", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]])\n    p = Polygon(((0, 0), (0, 1), (1, 1), (1, 0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    geom_multiple_from_list = MultiPolygon([p, p])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert all(((p == geom.geoms[0]) for p in geom_multiple_from_list.geoms))\n    geom_multiple_from_array = MultiPolygon(np.array([p, p]))\n    assert (geom_multiple_from_array == geom_multiple_from_list)\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)))]})", "masked_code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == '???')\n    coords2 = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]])\n    p = Polygon(((0, 0), (0, 1), (1, 1), (1, 0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    geom_multiple_from_list = MultiPolygon([p, p])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert all(((p == geom.geoms[0]) for p in geom_multiple_from_list.geoms))\n    geom_multiple_from_array = MultiPolygon(np.array([p, p]))\n    assert (geom_multiple_from_array == geom_multiple_from_list)\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)))]})", "ground_truth": ["[[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]]", "[[[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0], [0.0, 0.0], [[0.25, 0.25], [0.25, 0.5], [0.5, 0.5], [0.5, 0.25], [0.25, 0.25]]]]"], "quality_analysis": {"complexity_score": 50, "left_complexity": 4, "right_complexity": 46, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPolygon"}
{"task_id": "shapely_323", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_multipolygon", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]])\n    p = Polygon(((0, 0), (0, 1), (1, 1), (1, 0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    geom_multiple_from_list = MultiPolygon([p, p])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert all(((p == geom.geoms[0]) for p in geom_multiple_from_list.geoms))\n    geom_multiple_from_array = MultiPolygon(np.array([p, p]))\n    assert (geom_multiple_from_array == geom_multiple_from_list)\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)))]})", "masked_code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == '???')\n    p = Polygon(((0, 0), (0, 1), (1, 1), (1, 0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    geom_multiple_from_list = MultiPolygon([p, p])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert all(((p == geom.geoms[0]) for p in geom_multiple_from_list.geoms))\n    geom_multiple_from_array = MultiPolygon(np.array([p, p]))\n    assert (geom_multiple_from_array == geom_multiple_from_list)\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)))]})", "ground_truth": ["[[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]]", "[[[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0], [0.0, 0.0], [[0.25, 0.25], [0.25, 0.5], [0.5, 0.5], [0.5, 0.25], [0.25, 0.25]]]]"], "quality_analysis": {"complexity_score": 28, "left_complexity": 4, "right_complexity": 24, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPolygon"}
{"task_id": "shapely_324", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_multipolygon", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]])\n    p = Polygon(((0, 0), (0, 1), (1, 1), (1, 0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    geom_multiple_from_list = MultiPolygon([p, p])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert all(((p == geom.geoms[0]) for p in geom_multiple_from_list.geoms))\n    geom_multiple_from_array = MultiPolygon(np.array([p, p]))\n    assert (geom_multiple_from_array == geom_multiple_from_list)\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)))]})", "masked_code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]])\n    p = Polygon(((0, 0), (0, 1), (1, 1), (1, 0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == '???')\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    geom_multiple_from_list = MultiPolygon([p, p])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert all(((p == geom.geoms[0]) for p in geom_multiple_from_list.geoms))\n    geom_multiple_from_array = MultiPolygon(np.array([p, p]))\n    assert (geom_multiple_from_array == geom_multiple_from_list)\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)))]})", "ground_truth": ["[[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]]", "[[[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0], [0.0, 0.0], [[0.25, 0.25], [0.25, 0.5], [0.5, 0.5], [0.5, 0.25], [0.25, 0.25]]]]"], "quality_analysis": {"complexity_score": 50, "left_complexity": 4, "right_complexity": 46, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPolygon"}
{"task_id": "shapely_325", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_multipolygon", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]])\n    p = Polygon(((0, 0), (0, 1), (1, 1), (1, 0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    geom_multiple_from_list = MultiPolygon([p, p])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert all(((p == geom.geoms[0]) for p in geom_multiple_from_list.geoms))\n    geom_multiple_from_array = MultiPolygon(np.array([p, p]))\n    assert (geom_multiple_from_array == geom_multiple_from_list)\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)))]})", "masked_code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]])\n    p = Polygon(((0, 0), (0, 1), (1, 1), (1, 0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    geom_multiple_from_list = MultiPolygon([p, p])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert all(((p == geom.geoms[0]) for p in geom_multiple_from_list.geoms))\n    geom_multiple_from_array = MultiPolygon(np.array([p, p]))\n    assert (geom_multiple_from_array == geom_multiple_from_list)\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == '???')\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)))]})", "ground_truth": ["[[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]]", "[[[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0], [0.0, 0.0], [[0.25, 0.25], [0.25, 0.5], [0.5, 0.5], [0.5, 0.25], [0.25, 0.25]]]]"], "quality_analysis": {"complexity_score": 50, "left_complexity": 4, "right_complexity": 46, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPolygon"}
{"task_id": "shapely_326", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_multipolygon", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]])\n    p = Polygon(((0, 0), (0, 1), (1, 1), (1, 0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    geom_multiple_from_list = MultiPolygon([p, p])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert all(((p == geom.geoms[0]) for p in geom_multiple_from_list.geoms))\n    geom_multiple_from_array = MultiPolygon(np.array([p, p]))\n    assert (geom_multiple_from_array == geom_multiple_from_list)\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)))]})", "masked_code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]])\n    p = Polygon(((0, 0), (0, 1), (1, 1), (1, 0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    geom_multiple_from_list = MultiPolygon([p, p])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert all(((p == geom.geoms[0]) for p in geom_multiple_from_list.geoms))\n    geom_multiple_from_array = MultiPolygon(np.array([p, p]))\n    assert (geom_multiple_from_array == geom_multiple_from_list)\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == '???')\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)))]})", "ground_truth": ["[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]", "[[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0], [0.0, 0.0], [[0.25, 0.25], [0.25, 0.5], [0.5, 0.5], [0.5, 0.25], [0.25, 0.25]]]"], "quality_analysis": {"complexity_score": 53, "left_complexity": 9, "right_complexity": 44, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPolygon"}
{"task_id": "shapely_327", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_multipolygon", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]])\n    p = Polygon(((0, 0), (0, 1), (1, 1), (1, 0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    geom_multiple_from_list = MultiPolygon([p, p])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert all(((p == geom.geoms[0]) for p in geom_multiple_from_list.geoms))\n    geom_multiple_from_array = MultiPolygon(np.array([p, p]))\n    assert (geom_multiple_from_array == geom_multiple_from_list)\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)))]})", "masked_code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]])\n    p = Polygon(((0, 0), (0, 1), (1, 1), (1, 0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    geom_multiple_from_list = MultiPolygon([p, p])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert all(((p == geom.geoms[0]) for p in geom_multiple_from_list.geoms))\n    geom_multiple_from_array = MultiPolygon(np.array([p, p]))\n    assert (geom_multiple_from_array == geom_multiple_from_list)\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0), [(0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == '???')", "ground_truth": ["{'type': 'MultiPolygon', 'coordinates': [(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)), ((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25), (0.25, 0.25)))]}", "{'type': 'MultiPolygon', 'coordinates': [[[[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0], [0.0, 0.0]], [[0.25, 0.25], [0.25, 0.5], [0.5, 0.5], [0.5, 0.25], [0.25, 0.25]]]]}"], "quality_analysis": {"complexity_score": 56, "left_complexity": 2, "right_complexity": 54, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPolygon"}
{"task_id": "shapely_321", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_numpy_object_array", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_numpy_object_array():\n    geom = MultiPolygon([(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == geom)", "masked_code": "def test_numpy_object_array():\n    geom = MultiPolygon([(((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0)), [((0.25, 0.25), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == '???')", "ground_truth": ["<MULTIPOLYGON (((0 0, 0 1, 1 1, 1 0, 0 0), (0.25 0.25, 0.25 0.5, 0.5 0.5, 0....>", "geom"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_510", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_ndarrays.py", "testname": "test_ndarrays.py", "funcname": "test_linestring", "imports": ["import unittest", "from functools import reduce", "import numpy as np", "from shapely import geometry"], "code": "def test_linestring(self):\n    a = np.array([[1.0, 1.0, 2.0, 2.0, 1.0], [3.0, 4.0, 4.0, 3.0, 3.0]])\n    t = a.T\n    s = geometry.LineString(t)\n    assert (list(s.coords) == [(1.0, 3.0), (1.0, 4.0), (2.0, 4.0), (2.0, 3.0), (1.0, 3.0)])", "masked_code": "def test_linestring(self):\n    a = np.array([[1.0, 1.0, 2.0, 2.0, 1.0], [3.0, 4.0, 4.0, 3.0, 3.0]])\n    t = a.T\n    s = geometry.LineString(t)\n    assert (list(s.coords) == '???')", "ground_truth": ["[(1.0, 3.0), (1.0, 4.0), (2.0, 4.0), (2.0, 3.0), (1.0, 3.0)]", "[[1.0, 3.0], [1.0, 4.0], [2.0, 4.0], [2.0, 3.0], [1.0, 3.0]]"], "quality_analysis": {"complexity_score": 27, "left_complexity": 5, "right_complexity": 22, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransposeTestCase"}
{"task_id": "shapely_511", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_ndarrays.py", "testname": "test_ndarrays.py", "funcname": "test_polygon", "imports": ["import unittest", "from functools import reduce", "import numpy as np", "from shapely import geometry"], "code": "def test_polygon(self):\n    a = np.array([[1.0, 1.0, 2.0, 2.0, 1.0], [3.0, 4.0, 4.0, 3.0, 3.0]])\n    t = a.T\n    s = geometry.Polygon(t)\n    assert (list(s.exterior.coords) == [(1.0, 3.0), (1.0, 4.0), (2.0, 4.0), (2.0, 3.0), (1.0, 3.0)])", "masked_code": "def test_polygon(self):\n    a = np.array([[1.0, 1.0, 2.0, 2.0, 1.0], [3.0, 4.0, 4.0, 3.0, 3.0]])\n    t = a.T\n    s = geometry.Polygon(t)\n    assert (list(s.exterior.coords) == '???')", "ground_truth": ["[(1.0, 3.0), (1.0, 4.0), (2.0, 4.0), (2.0, 3.0), (1.0, 3.0)]", "[[1.0, 3.0], [1.0, 4.0], [2.0, 4.0], [2.0, 3.0], [1.0, 3.0]]"], "quality_analysis": {"complexity_score": 27, "left_complexity": 5, "right_complexity": 22, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransposeTestCase"}
{"task_id": "shapely_516", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_operations.py", "testname": "test_operations.py", "funcname": "test_operations", "imports": ["import unittest", "import pytest", "import shapely", "from shapely import geos_version", "from shapely.errors import TopologicalError", "from shapely.geometry import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.wkt import loads"], "code": "def test_operations(self):\n    point = Point(0.0, 0.0)\n    assert (point.area == 0.0)\n    assert (point.length == 0.0)\n    assert (point.distance(Point((- 1.0), (- 1.0))) == pytest.approx(1.4142135623730951))\n    assert isinstance(point.envelope, Point)\n    assert point.intersection(Point((- 1), (- 1))).is_empty\n    assert isinstance(point.buffer(10.0), Polygon)\n    assert isinstance(point.buffer(10.0, quad_segs=32), Polygon)\n    p = loads('POLYGON ((120 120, 140 199, 160 200, 180 199, 220 120, 122 122, 121 121, 120 120))')\n    expected = loads('POLYGON ((120 120, 140 199, 160 200, 180 199, 220 120, 120 120))')\n    s = p.simplify(10.0, preserve_topology=False)\n    assert s.equals_exact(expected, 0.001)\n    p = loads('POLYGON ((80 200, 240 200, 240 60, 80 60, 80 200),(120 120, 220 120, 180 199, 160 200, 140 199, 120 120))')\n    expected = loads('POLYGON ((80 200, 240 200, 240 60, 80 60, 80 200),(120 120, 220 120, 180 199, 160 200, 140 199, 120 120))')\n    s = p.simplify(10.0, preserve_topology=True)\n    assert s.equals_exact(expected, 0.001)\n    assert isinstance(point.convex_hull, Point)\n    assert isinstance(point.difference(Point((- 1), 1)), Point)\n    assert isinstance(point.symmetric_difference(Point((- 1), 1)), MultiPoint)\n    assert isinstance(point.boundary, GeometryCollection)\n    assert isinstance(point.union(Point((- 1), 1)), MultiPoint)\n    assert isinstance(point.representative_point(), Point)\n    assert isinstance(point.point_on_surface(), Point)\n    assert (point.representative_point() == point.point_on_surface())\n    assert isinstance(point.centroid, Point)", "masked_code": "def test_operations(self):\n    point = Point(0.0, 0.0)\n    assert (point.area == 0.0)\n    assert (point.length == 0.0)\n    assert (point.distance(Point((- 1.0), (- 1.0))) == '???')\n    assert isinstance(point.envelope, Point)\n    assert point.intersection(Point((- 1), (- 1))).is_empty\n    assert isinstance(point.buffer(10.0), Polygon)\n    assert isinstance(point.buffer(10.0, quad_segs=32), Polygon)\n    p = loads('POLYGON ((120 120, 140 199, 160 200, 180 199, 220 120, 122 122, 121 121, 120 120))')\n    expected = loads('POLYGON ((120 120, 140 199, 160 200, 180 199, 220 120, 120 120))')\n    s = p.simplify(10.0, preserve_topology=False)\n    assert s.equals_exact(expected, 0.001)\n    p = loads('POLYGON ((80 200, 240 200, 240 60, 80 60, 80 200),(120 120, 220 120, 180 199, 160 200, 140 199, 120 120))')\n    expected = loads('POLYGON ((80 200, 240 200, 240 60, 80 60, 80 200),(120 120, 220 120, 180 199, 160 200, 140 199, 120 120))')\n    s = p.simplify(10.0, preserve_topology=True)\n    assert s.equals_exact(expected, 0.001)\n    assert isinstance(point.convex_hull, Point)\n    assert isinstance(point.difference(Point((- 1), 1)), Point)\n    assert isinstance(point.symmetric_difference(Point((- 1), 1)), MultiPoint)\n    assert isinstance(point.boundary, GeometryCollection)\n    assert isinstance(point.union(Point((- 1), 1)), MultiPoint)\n    assert isinstance(point.representative_point(), Point)\n    assert isinstance(point.point_on_surface(), Point)\n    assert (point.representative_point() == point.point_on_surface())\n    assert isinstance(point.centroid, Point)", "ground_truth": ["1.4142135623730951", "pytest.approx(1.4142135623730951)"], "quality_analysis": {"complexity_score": 16, "left_complexity": 12, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "OperationsTestCase"}
{"task_id": "shapely_517", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_operations.py", "testname": "test_operations.py", "funcname": "test_operations", "imports": ["import unittest", "import pytest", "import shapely", "from shapely import geos_version", "from shapely.errors import TopologicalError", "from shapely.geometry import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.wkt import loads"], "code": "def test_operations(self):\n    point = Point(0.0, 0.0)\n    assert (point.area == 0.0)\n    assert (point.length == 0.0)\n    assert (point.distance(Point((- 1.0), (- 1.0))) == pytest.approx(1.4142135623730951))\n    assert isinstance(point.envelope, Point)\n    assert point.intersection(Point((- 1), (- 1))).is_empty\n    assert isinstance(point.buffer(10.0), Polygon)\n    assert isinstance(point.buffer(10.0, quad_segs=32), Polygon)\n    p = loads('POLYGON ((120 120, 140 199, 160 200, 180 199, 220 120, 122 122, 121 121, 120 120))')\n    expected = loads('POLYGON ((120 120, 140 199, 160 200, 180 199, 220 120, 120 120))')\n    s = p.simplify(10.0, preserve_topology=False)\n    assert s.equals_exact(expected, 0.001)\n    p = loads('POLYGON ((80 200, 240 200, 240 60, 80 60, 80 200),(120 120, 220 120, 180 199, 160 200, 140 199, 120 120))')\n    expected = loads('POLYGON ((80 200, 240 200, 240 60, 80 60, 80 200),(120 120, 220 120, 180 199, 160 200, 140 199, 120 120))')\n    s = p.simplify(10.0, preserve_topology=True)\n    assert s.equals_exact(expected, 0.001)\n    assert isinstance(point.convex_hull, Point)\n    assert isinstance(point.difference(Point((- 1), 1)), Point)\n    assert isinstance(point.symmetric_difference(Point((- 1), 1)), MultiPoint)\n    assert isinstance(point.boundary, GeometryCollection)\n    assert isinstance(point.union(Point((- 1), 1)), MultiPoint)\n    assert isinstance(point.representative_point(), Point)\n    assert isinstance(point.point_on_surface(), Point)\n    assert (point.representative_point() == point.point_on_surface())\n    assert isinstance(point.centroid, Point)", "masked_code": "def test_operations(self):\n    point = Point(0.0, 0.0)\n    assert (point.area == 0.0)\n    assert (point.length == 0.0)\n    assert (point.distance(Point((- 1.0), (- 1.0))) == pytest.approx(1.4142135623730951))\n    assert isinstance(point.envelope, Point)\n    assert point.intersection(Point((- 1), (- 1))).is_empty\n    assert isinstance(point.buffer(10.0), Polygon)\n    assert isinstance(point.buffer(10.0, quad_segs=32), Polygon)\n    p = loads('POLYGON ((120 120, 140 199, 160 200, 180 199, 220 120, 122 122, 121 121, 120 120))')\n    expected = loads('POLYGON ((120 120, 140 199, 160 200, 180 199, 220 120, 120 120))')\n    s = p.simplify(10.0, preserve_topology=False)\n    assert s.equals_exact(expected, 0.001)\n    p = loads('POLYGON ((80 200, 240 200, 240 60, 80 60, 80 200),(120 120, 220 120, 180 199, 160 200, 140 199, 120 120))')\n    expected = loads('POLYGON ((80 200, 240 200, 240 60, 80 60, 80 200),(120 120, 220 120, 180 199, 160 200, 140 199, 120 120))')\n    s = p.simplify(10.0, preserve_topology=True)\n    assert s.equals_exact(expected, 0.001)\n    assert isinstance(point.convex_hull, Point)\n    assert isinstance(point.difference(Point((- 1), 1)), Point)\n    assert isinstance(point.symmetric_difference(Point((- 1), 1)), MultiPoint)\n    assert isinstance(point.boundary, GeometryCollection)\n    assert isinstance(point.union(Point((- 1), 1)), MultiPoint)\n    assert isinstance(point.representative_point(), Point)\n    assert isinstance(point.point_on_surface(), Point)\n    assert (point.representative_point() == '???')\n    assert isinstance(point.centroid, Point)", "ground_truth": ["<POINT (0 0)>", "point.point_on_surface()"], "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "OperationsTestCase"}
{"task_id": "shapely_518", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_operations.py", "testname": "test_operations.py", "funcname": "test_relate", "imports": ["import unittest", "import pytest", "import shapely", "from shapely import geos_version", "from shapely.errors import TopologicalError", "from shapely.geometry import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.wkt import loads"], "code": "def test_relate(self):\n    assert (Point(0, 0).relate(Point((- 1), (- 1))) == 'FF0FFF0F2')\n    invalid_polygon = loads('POLYGON ((40 100, 80 100, 80 60, 40 60, 40 100), (60 60, 80 60, 80 40, 60 40, 60 60))')\n    assert (not invalid_polygon.is_valid)\n    if (geos_version < (3, 13, 0)):\n        with pytest.raises((TopologicalError, shapely.GEOSException)):\n            invalid_polygon.relate(invalid_polygon)\n    else:\n        assert (invalid_polygon.relate(invalid_polygon) == '2FFF1FFF2')", "masked_code": "def test_relate(self):\n    assert (Point(0, 0).relate(Point((- 1), (- 1))) == '???')\n    invalid_polygon = loads('POLYGON ((40 100, 80 100, 80 60, 40 60, 40 100), (60 60, 80 60, 80 40, 60 40, 60 60))')\n    assert (not invalid_polygon.is_valid)\n    if (geos_version < (3, 13, 0)):\n        with pytest.raises((TopologicalError, shapely.GEOSException)):\n            invalid_polygon.relate(invalid_polygon)\n    else:\n        assert (invalid_polygon.relate(invalid_polygon) == '2FFF1FFF2')", "ground_truth": ["'FF0FFF0F2'"], "quality_analysis": {"complexity_score": 13, "left_complexity": 12, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OperationsTestCase"}
{"task_id": "shapely_519", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_operations.py", "testname": "test_operations.py", "funcname": "test_relate", "imports": ["import unittest", "import pytest", "import shapely", "from shapely import geos_version", "from shapely.errors import TopologicalError", "from shapely.geometry import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.wkt import loads"], "code": "def test_relate(self):\n    assert (Point(0, 0).relate(Point((- 1), (- 1))) == 'FF0FFF0F2')\n    invalid_polygon = loads('POLYGON ((40 100, 80 100, 80 60, 40 60, 40 100), (60 60, 80 60, 80 40, 60 40, 60 60))')\n    assert (not invalid_polygon.is_valid)\n    if (geos_version < (3, 13, 0)):\n        with pytest.raises((TopologicalError, shapely.GEOSException)):\n            invalid_polygon.relate(invalid_polygon)\n    else:\n        assert (invalid_polygon.relate(invalid_polygon) == '2FFF1FFF2')", "masked_code": "def test_relate(self):\n    assert (Point(0, 0).relate(Point((- 1), (- 1))) == 'FF0FFF0F2')\n    invalid_polygon = loads('POLYGON ((40 100, 80 100, 80 60, 40 60, 40 100), (60 60, 80 60, 80 40, 60 40, 60 60))')\n    assert (not invalid_polygon.is_valid)\n    if (geos_version < (3, 13, 0)):\n        with pytest.raises((TopologicalError, shapely.GEOSException)):\n            invalid_polygon.relate(invalid_polygon)\n    else:\n        assert (invalid_polygon.relate(invalid_polygon) == '???')", "ground_truth": ["'2FFF1FFF2'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OperationsTestCase"}
{"task_id": "shapely_530", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_empty_polygon", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_empty_polygon(self):\n    polygon = Polygon()\n    assert (orient(polygon) == polygon)", "masked_code": "def test_empty_polygon(self):\n    polygon = Polygon()\n    assert (orient(polygon) == '???')", "ground_truth": ["<POLYGON EMPTY>", "polygon"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_535", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_geometrycollection", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_geometrycollection(self):\n    polygon = Polygon([(0, 0), (0, 1), (1, 0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    collection = GeometryCollection([polygon])\n    assert (orient(collection, 1) == GeometryCollection([polygon_reversed]))\n    assert (orient(collection, (- 1)) == GeometryCollection([polygon]))", "masked_code": "def test_geometrycollection(self):\n    polygon = Polygon([(0, 0), (0, 1), (1, 0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    collection = GeometryCollection([polygon])\n    assert (orient(collection, 1) == '???')\n    assert (orient(collection, (- 1)) == GeometryCollection([polygon]))", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((0 0, 1 0, 0 1, 0 0)))>", "GeometryCollection([polygon_reversed])"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_536", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_geometrycollection", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_geometrycollection(self):\n    polygon = Polygon([(0, 0), (0, 1), (1, 0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    collection = GeometryCollection([polygon])\n    assert (orient(collection, 1) == GeometryCollection([polygon_reversed]))\n    assert (orient(collection, (- 1)) == GeometryCollection([polygon]))", "masked_code": "def test_geometrycollection(self):\n    polygon = Polygon([(0, 0), (0, 1), (1, 0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    collection = GeometryCollection([polygon])\n    assert (orient(collection, 1) == GeometryCollection([polygon_reversed]))\n    assert (orient(collection, (- 1)) == '???')", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((0 0, 0 1, 1 0, 0 0)))>", "GeometryCollection([polygon])"], "quality_analysis": {"complexity_score": 13, "left_complexity": 7, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_528", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_linearring", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_linearring(self):\n    linearring = LinearRing([(0, 0), (0, 1), (1, 0)])\n    assert (orient(linearring, 1) == linearring)\n    assert (orient(linearring, (- 1)) == linearring)", "masked_code": "def test_linearring(self):\n    linearring = LinearRing([(0, 0), (0, 1), (1, 0)])\n    assert (orient(linearring, 1) == '???')\n    assert (orient(linearring, (- 1)) == linearring)", "ground_truth": ["<LINEARRING (0 0, 0 1, 1 0, 0 0)>", "linearring"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_529", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_linearring", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_linearring(self):\n    linearring = LinearRing([(0, 0), (0, 1), (1, 0)])\n    assert (orient(linearring, 1) == linearring)\n    assert (orient(linearring, (- 1)) == linearring)", "masked_code": "def test_linearring(self):\n    linearring = LinearRing([(0, 0), (0, 1), (1, 0)])\n    assert (orient(linearring, 1) == linearring)\n    assert (orient(linearring, (- 1)) == '???')", "ground_truth": ["<LINEARRING (0 0, 0 1, 1 0, 0 0)>", "linearring"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_524", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_linestring", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_linestring(self):\n    linestring = LineString([(0, 0), (1, 1)])\n    assert (orient(linestring, 1) == linestring)\n    assert (orient(linestring, (- 1)) == linestring)", "masked_code": "def test_linestring(self):\n    linestring = LineString([(0, 0), (1, 1)])\n    assert (orient(linestring, 1) == '???')\n    assert (orient(linestring, (- 1)) == linestring)", "ground_truth": ["<LINESTRING (0 0, 1 1)>", "linestring"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_525", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_linestring", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_linestring(self):\n    linestring = LineString([(0, 0), (1, 1)])\n    assert (orient(linestring, 1) == linestring)\n    assert (orient(linestring, (- 1)) == linestring)", "masked_code": "def test_linestring(self):\n    linestring = LineString([(0, 0), (1, 1)])\n    assert (orient(linestring, 1) == linestring)\n    assert (orient(linestring, (- 1)) == '???')", "ground_truth": ["<LINESTRING (0 0, 1 1)>", "linestring"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_526", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_multilinestring", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_multilinestring(self):\n    multilinestring = MultiLineString([[(0, 0), (1, 1)], [(1, 0), (0, 1)]])\n    assert (orient(multilinestring, 1) == multilinestring)\n    assert (orient(multilinestring, (- 1)) == multilinestring)", "masked_code": "def test_multilinestring(self):\n    multilinestring = MultiLineString([[(0, 0), (1, 1)], [(1, 0), (0, 1)]])\n    assert (orient(multilinestring, 1) == '???')\n    assert (orient(multilinestring, (- 1)) == multilinestring)", "ground_truth": ["<MULTILINESTRING ((0 0, 1 1), (1 0, 0 1))>", "multilinestring"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_527", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_multilinestring", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_multilinestring(self):\n    multilinestring = MultiLineString([[(0, 0), (1, 1)], [(1, 0), (0, 1)]])\n    assert (orient(multilinestring, 1) == multilinestring)\n    assert (orient(multilinestring, (- 1)) == multilinestring)", "masked_code": "def test_multilinestring(self):\n    multilinestring = MultiLineString([[(0, 0), (1, 1)], [(1, 0), (0, 1)]])\n    assert (orient(multilinestring, 1) == multilinestring)\n    assert (orient(multilinestring, (- 1)) == '???')", "ground_truth": ["<MULTILINESTRING ((0 0, 1 1), (1 0, 0 1))>", "multilinestring"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_522", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_multipoint", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_multipoint(self):\n    multipoint = MultiPoint([(0, 0), (1, 1)])\n    assert (orient(multipoint, 1) == multipoint)\n    assert (orient(multipoint, (- 1)) == multipoint)", "masked_code": "def test_multipoint(self):\n    multipoint = MultiPoint([(0, 0), (1, 1)])\n    assert (orient(multipoint, 1) == '???')\n    assert (orient(multipoint, (- 1)) == multipoint)", "ground_truth": ["<MULTIPOINT (0 0, 1 1)>", "multipoint"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_523", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_multipoint", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_multipoint(self):\n    multipoint = MultiPoint([(0, 0), (1, 1)])\n    assert (orient(multipoint, 1) == multipoint)\n    assert (orient(multipoint, (- 1)) == multipoint)", "masked_code": "def test_multipoint(self):\n    multipoint = MultiPoint([(0, 0), (1, 1)])\n    assert (orient(multipoint, 1) == multipoint)\n    assert (orient(multipoint, (- 1)) == '???')", "ground_truth": ["<MULTIPOINT (0 0, 1 1)>", "multipoint"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_533", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_multipolygon", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_multipolygon(self):\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 0)])\n    polygon2 = Polygon([(1, 0), (2, 0), (2, 1)])\n    polygon1_reversed = Polygon(polygon1.exterior.coords[::(- 1)])\n    polygon2_reversed = Polygon(polygon2.exterior.coords[::(- 1)])\n    multipolygon = MultiPolygon([polygon1, polygon2])\n    assert (not polygon1.exterior.is_ccw)\n    assert polygon2.exterior.is_ccw\n    assert (orient(multipolygon, 1) == MultiPolygon([polygon1_reversed, polygon2]))\n    assert (orient(multipolygon, (- 1)) == MultiPolygon([polygon1, polygon2_reversed]))", "masked_code": "def test_multipolygon(self):\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 0)])\n    polygon2 = Polygon([(1, 0), (2, 0), (2, 1)])\n    polygon1_reversed = Polygon(polygon1.exterior.coords[::(- 1)])\n    polygon2_reversed = Polygon(polygon2.exterior.coords[::(- 1)])\n    multipolygon = MultiPolygon([polygon1, polygon2])\n    assert (not polygon1.exterior.is_ccw)\n    assert polygon2.exterior.is_ccw\n    assert (orient(multipolygon, 1) == '???')\n    assert (orient(multipolygon, (- 1)) == MultiPolygon([polygon1, polygon2_reversed]))", "ground_truth": ["<MULTIPOLYGON (((0 0, 1 0, 0 1, 0 0)), ((1 0, 2 0, 2 1, 1 0)))>", "MultiPolygon([polygon1_reversed, polygon2])"], "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_534", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_multipolygon", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_multipolygon(self):\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 0)])\n    polygon2 = Polygon([(1, 0), (2, 0), (2, 1)])\n    polygon1_reversed = Polygon(polygon1.exterior.coords[::(- 1)])\n    polygon2_reversed = Polygon(polygon2.exterior.coords[::(- 1)])\n    multipolygon = MultiPolygon([polygon1, polygon2])\n    assert (not polygon1.exterior.is_ccw)\n    assert polygon2.exterior.is_ccw\n    assert (orient(multipolygon, 1) == MultiPolygon([polygon1_reversed, polygon2]))\n    assert (orient(multipolygon, (- 1)) == MultiPolygon([polygon1, polygon2_reversed]))", "masked_code": "def test_multipolygon(self):\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 0)])\n    polygon2 = Polygon([(1, 0), (2, 0), (2, 1)])\n    polygon1_reversed = Polygon(polygon1.exterior.coords[::(- 1)])\n    polygon2_reversed = Polygon(polygon2.exterior.coords[::(- 1)])\n    multipolygon = MultiPolygon([polygon1, polygon2])\n    assert (not polygon1.exterior.is_ccw)\n    assert polygon2.exterior.is_ccw\n    assert (orient(multipolygon, 1) == MultiPolygon([polygon1_reversed, polygon2]))\n    assert (orient(multipolygon, (- 1)) == '???')", "ground_truth": ["<MULTIPOLYGON (((0 0, 0 1, 1 0, 0 0)), ((1 0, 2 1, 2 0, 1 0)))>", "MultiPolygon([polygon1, polygon2_reversed])"], "quality_analysis": {"complexity_score": 14, "left_complexity": 7, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_520", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_point", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_point(self):\n    point = Point(0, 0)\n    assert (orient(point, 1) == point)\n    assert (orient(point, (- 1)) == point)", "masked_code": "def test_point(self):\n    point = Point(0, 0)\n    assert (orient(point, 1) == '???')\n    assert (orient(point, (- 1)) == point)", "ground_truth": ["<POINT (0 0)>", "point"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_521", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_point", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_point(self):\n    point = Point(0, 0)\n    assert (orient(point, 1) == point)\n    assert (orient(point, (- 1)) == point)", "masked_code": "def test_point(self):\n    point = Point(0, 0)\n    assert (orient(point, 1) == point)\n    assert (orient(point, (- 1)) == '???')", "ground_truth": ["<POINT (0 0)>", "point"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_531", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_polygon", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_polygon(self):\n    polygon = Polygon([(0, 0), (0, 1), (1, 0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    assert (orient(polygon, 1) == polygon_reversed)\n    assert (orient(polygon, (- 1)) == polygon)", "masked_code": "def test_polygon(self):\n    polygon = Polygon([(0, 0), (0, 1), (1, 0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    assert (orient(polygon, 1) == '???')\n    assert (orient(polygon, (- 1)) == polygon)", "ground_truth": ["<POLYGON ((0 0, 1 0, 0 1, 0 0))>", "polygon_reversed"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_532", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_polygon", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_polygon(self):\n    polygon = Polygon([(0, 0), (0, 1), (1, 0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    assert (orient(polygon, 1) == polygon_reversed)\n    assert (orient(polygon, (- 1)) == polygon)", "masked_code": "def test_polygon(self):\n    polygon = Polygon([(0, 0), (0, 1), (1, 0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    assert (orient(polygon, 1) == polygon_reversed)\n    assert (orient(polygon, (- 1)) == '???')", "ground_truth": ["<POLYGON ((0 0, 0 1, 1 0, 0 0))>", "polygon"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_537", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_persist.py", "testname": "test_persist.py", "funcname": "test_wkb_dumps_endianness", "imports": ["import pickle", "import struct", "import unittest", "from shapely import wkb, wkt", "from shapely.geometry import Point"], "code": "def test_wkb_dumps_endianness(self):\n    p = Point(0.5, 2.0)\n    wkb_big_endian = wkb.dumps(p, big_endian=True)\n    wkb_little_endian = wkb.dumps(p, big_endian=False)\n    assert (wkb_big_endian != wkb_little_endian)\n    assert (wkb_big_endian[0] == 0)\n    assert (wkb_little_endian[0] == 1)\n    double_size = struct.calcsize('d')\n    assert (wkb_big_endian[((- 2) * double_size):] == struct.pack('>2d', p.x, p.y))\n    assert (wkb_little_endian[((- 2) * double_size):] == struct.pack('<2d', p.x, p.y))", "masked_code": "def test_wkb_dumps_endianness(self):\n    p = Point(0.5, 2.0)\n    wkb_big_endian = wkb.dumps(p, big_endian=True)\n    wkb_little_endian = wkb.dumps(p, big_endian=False)\n    assert (wkb_big_endian != wkb_little_endian)\n    assert (wkb_big_endian[0] == 0)\n    assert (wkb_little_endian[0] == 1)\n    double_size = struct.calcsize('d')\n    assert (wkb_big_endian[((- 2) * double_size):] == '???')\n    assert (wkb_little_endian[((- 2) * double_size):] == struct.pack('<2d', p.x, p.y))", "ground_truth": ["b'?\\xe0\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "struct.pack('>2d', p.x, p.y)"], "quality_analysis": {"complexity_score": 12, "left_complexity": 4, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "PersistTestCase"}
{"task_id": "shapely_538", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_persist.py", "testname": "test_persist.py", "funcname": "test_wkb_dumps_endianness", "imports": ["import pickle", "import struct", "import unittest", "from shapely import wkb, wkt", "from shapely.geometry import Point"], "code": "def test_wkb_dumps_endianness(self):\n    p = Point(0.5, 2.0)\n    wkb_big_endian = wkb.dumps(p, big_endian=True)\n    wkb_little_endian = wkb.dumps(p, big_endian=False)\n    assert (wkb_big_endian != wkb_little_endian)\n    assert (wkb_big_endian[0] == 0)\n    assert (wkb_little_endian[0] == 1)\n    double_size = struct.calcsize('d')\n    assert (wkb_big_endian[((- 2) * double_size):] == struct.pack('>2d', p.x, p.y))\n    assert (wkb_little_endian[((- 2) * double_size):] == struct.pack('<2d', p.x, p.y))", "masked_code": "def test_wkb_dumps_endianness(self):\n    p = Point(0.5, 2.0)\n    wkb_big_endian = wkb.dumps(p, big_endian=True)\n    wkb_little_endian = wkb.dumps(p, big_endian=False)\n    assert (wkb_big_endian != wkb_little_endian)\n    assert (wkb_big_endian[0] == 0)\n    assert (wkb_little_endian[0] == 1)\n    double_size = struct.calcsize('d')\n    assert (wkb_big_endian[((- 2) * double_size):] == struct.pack('>2d', p.x, p.y))\n    assert (wkb_little_endian[((- 2) * double_size):] == '???')", "ground_truth": ["b'\\x00\\x00\\x00\\x00\\x00\\x00\\xe0?\\x00\\x00\\x00\\x00\\x00\\x00\\x00@'", "struct.pack('<2d', p.x, p.y)"], "quality_analysis": {"complexity_score": 12, "left_complexity": 4, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "PersistTestCase"}
{"task_id": "shapely_539", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_pickle.py", "testname": "test_pickle.py", "funcname": "test_pickle_round_trip", "imports": ["import pathlib", "import pickle", "import warnings", "from pickle import HIGHEST_PROTOCOL, dumps, loads", "import pytest", "import shapely", "from shapely import wkt", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, box"], "code": "@pytest.mark.parametrize('geom1', TEST_GEOMS, ids=TEST_NAMES)\ndef test_pickle_round_trip(geom1):\n    data = dumps(geom1, HIGHEST_PROTOCOL)\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        geom2 = loads(data)\n    assert (geom2.has_z == geom1.has_z)\n    assert (type(geom2) is type(geom1))\n    assert (geom2.geom_type == geom1.geom_type)\n    assert (geom2.wkt == geom1.wkt)", "masked_code": "@pytest.mark.parametrize('geom1', TEST_GEOMS, ids=TEST_NAMES)\ndef test_pickle_round_trip(geom1):\n    data = dumps(geom1, HIGHEST_PROTOCOL)\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        geom2 = loads(data)\n    assert (geom2.has_z == '???')\n    assert (type(geom2) is type(geom1))\n    assert (geom2.geom_type == geom1.geom_type)\n    assert (geom2.wkt == geom1.wkt)", "ground_truth": ["False", "geom1.has_z"], "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_540", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_pickle.py", "testname": "test_pickle.py", "funcname": "test_pickle_round_trip", "imports": ["import pathlib", "import pickle", "import warnings", "from pickle import HIGHEST_PROTOCOL, dumps, loads", "import pytest", "import shapely", "from shapely import wkt", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, box"], "code": "@pytest.mark.parametrize('geom1', TEST_GEOMS, ids=TEST_NAMES)\ndef test_pickle_round_trip(geom1):\n    data = dumps(geom1, HIGHEST_PROTOCOL)\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        geom2 = loads(data)\n    assert (geom2.has_z == geom1.has_z)\n    assert (type(geom2) is type(geom1))\n    assert (geom2.geom_type == geom1.geom_type)\n    assert (geom2.wkt == geom1.wkt)", "masked_code": "@pytest.mark.parametrize('geom1', TEST_GEOMS, ids=TEST_NAMES)\ndef test_pickle_round_trip(geom1):\n    data = dumps(geom1, HIGHEST_PROTOCOL)\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        geom2 = loads(data)\n    assert (geom2.has_z == geom1.has_z)\n    assert (type(geom2) is type(geom1))\n    assert (geom2.geom_type == '???')\n    assert (geom2.wkt == geom1.wkt)", "ground_truth": ["'Point'", "geom1.geom_type"], "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_541", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_pickle.py", "testname": "test_pickle.py", "funcname": "test_pickle_round_trip", "imports": ["import pathlib", "import pickle", "import warnings", "from pickle import HIGHEST_PROTOCOL, dumps, loads", "import pytest", "import shapely", "from shapely import wkt", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, box"], "code": "@pytest.mark.parametrize('geom1', TEST_GEOMS, ids=TEST_NAMES)\ndef test_pickle_round_trip(geom1):\n    data = dumps(geom1, HIGHEST_PROTOCOL)\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        geom2 = loads(data)\n    assert (geom2.has_z == geom1.has_z)\n    assert (type(geom2) is type(geom1))\n    assert (geom2.geom_type == geom1.geom_type)\n    assert (geom2.wkt == geom1.wkt)", "masked_code": "@pytest.mark.parametrize('geom1', TEST_GEOMS, ids=TEST_NAMES)\ndef test_pickle_round_trip(geom1):\n    data = dumps(geom1, HIGHEST_PROTOCOL)\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        geom2 = loads(data)\n    assert (geom2.has_z == geom1.has_z)\n    assert (type(geom2) is type(geom1))\n    assert (geom2.geom_type == geom1.geom_type)\n    assert (geom2.wkt == '???')", "ground_truth": ["'POINT (1 2)'", "geom1.wkt"], "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_363", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_coords", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_coords(self):\n    p = Point(0.0, 0.0, 1.0)\n    coords = p.coords[0]\n    assert (coords == (0.0, 0.0, 1.0))\n    a = np.asarray(coords)\n    assert (a.ndim == 1)\n    assert (a.size == 3)\n    assert (a.shape == (3,))", "masked_code": "def test_coords(self):\n    p = Point(0.0, 0.0, 1.0)\n    coords = p.coords[0]\n    assert (coords == (0.0, 0.0, 1.0))\n    a = np.asarray(coords)\n    assert (a.ndim == 1)\n    assert (a.size == '???')\n    assert (a.shape == (3,))", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_364", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_coords", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_coords(self):\n    p = Point(0.0, 0.0, 1.0)\n    coords = p.coords[0]\n    assert (coords == (0.0, 0.0, 1.0))\n    a = np.asarray(coords)\n    assert (a.ndim == 1)\n    assert (a.size == 3)\n    assert (a.shape == (3,))", "masked_code": "def test_coords(self):\n    p = Point(0.0, 0.0, 1.0)\n    coords = p.coords[0]\n    assert (coords == (0.0, 0.0, 1.0))\n    a = np.asarray(coords)\n    assert (a.ndim == 1)\n    assert (a.size == 3)\n    assert (a.shape == '???')", "ground_truth": ["(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_328", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_coordinates", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_coordinates():\n    p = Point(1.0, 2.0)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (p.has_z is False)\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert p.has_z\n    p = Point()\n    assert p.is_empty\n    assert isinstance(p.coords, CoordinateSequence)\n    assert (p.coords[:] == [])", "masked_code": "def test_from_coordinates():\n    p = Point(1.0, 2.0)\n    assert (p.coords[:] == '???')\n    assert (p.has_z is False)\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert p.has_z\n    p = Point()\n    assert p.is_empty\n    assert isinstance(p.coords, CoordinateSequence)\n    assert (p.coords[:] == [])", "ground_truth": ["[(1.0, 2.0)]", "[[1.0, 2.0]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_329", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_coordinates", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_coordinates():\n    p = Point(1.0, 2.0)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (p.has_z is False)\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert p.has_z\n    p = Point()\n    assert p.is_empty\n    assert isinstance(p.coords, CoordinateSequence)\n    assert (p.coords[:] == [])", "masked_code": "def test_from_coordinates():\n    p = Point(1.0, 2.0)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (p.has_z is False)\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == '???')\n    assert p.has_z\n    p = Point()\n    assert p.is_empty\n    assert isinstance(p.coords, CoordinateSequence)\n    assert (p.coords[:] == [])", "ground_truth": ["[(1.0, 2.0, 3.0)]", "[[1.0, 2.0, 3.0]]"], "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_330", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_coordinates", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_coordinates():\n    p = Point(1.0, 2.0)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (p.has_z is False)\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert p.has_z\n    p = Point()\n    assert p.is_empty\n    assert isinstance(p.coords, CoordinateSequence)\n    assert (p.coords[:] == [])", "masked_code": "def test_from_coordinates():\n    p = Point(1.0, 2.0)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (p.has_z is False)\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert p.has_z\n    p = Point()\n    assert p.is_empty\n    assert isinstance(p.coords, CoordinateSequence)\n    assert (p.coords[:] == '???')", "ground_truth": ["[[1.0, 2.0, 3.0]]", "[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_344", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_generator", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_generator():\n    gen = (coord for coord in [(1.0, 2.0)])\n    p = Point(gen)\n    assert (p.coords[:] == [(1.0, 2.0)])", "masked_code": "def test_from_generator():\n    gen = (coord for coord in [(1.0, 2.0)])\n    p = Point(gen)\n    assert (p.coords[:] == '???')", "ground_truth": ["[(1.0, 2.0)]", "[[1.0, 2.0]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_338", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_numpy", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_numpy():\n    p = Point(np.array([1.0, 2.0]))\n    assert (p.coords[:] == [(1.0, 2.0)])\n    p = Point(np.array([1.0, 2.0, 3.0]))\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])", "masked_code": "def test_from_numpy():\n    p = Point(np.array([1.0, 2.0]))\n    assert (p.coords[:] == '???')\n    p = Point(np.array([1.0, 2.0, 3.0]))\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])", "ground_truth": ["[(1.0, 2.0)]", "[[1.0, 2.0]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_339", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_numpy", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_numpy():\n    p = Point(np.array([1.0, 2.0]))\n    assert (p.coords[:] == [(1.0, 2.0)])\n    p = Point(np.array([1.0, 2.0, 3.0]))\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])", "masked_code": "def test_from_numpy():\n    p = Point(np.array([1.0, 2.0]))\n    assert (p.coords[:] == [(1.0, 2.0)])\n    p = Point(np.array([1.0, 2.0, 3.0]))\n    assert (p.coords[:] == '???')", "ground_truth": ["[(1.0, 2.0, 3.0)]", "[[1.0, 2.0, 3.0]]"], "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_340", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_numpy_xy", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_numpy_xy():\n    p = Point(np.array([1.0]), np.array([2.0]))\n    assert (p.coords[:] == [(1.0, 2.0)])\n    p = Point(np.array([1.0]), np.array([2.0]), np.array([3.0]))\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])", "masked_code": "def test_from_numpy_xy():\n    p = Point(np.array([1.0]), np.array([2.0]))\n    assert (p.coords[:] == '???')\n    p = Point(np.array([1.0]), np.array([2.0]), np.array([3.0]))\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])", "ground_truth": ["[(1.0, 2.0)]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_341", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_numpy_xy", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_numpy_xy():\n    p = Point(np.array([1.0]), np.array([2.0]))\n    assert (p.coords[:] == [(1.0, 2.0)])\n    p = Point(np.array([1.0]), np.array([2.0]), np.array([3.0]))\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])", "masked_code": "def test_from_numpy_xy():\n    p = Point(np.array([1.0]), np.array([2.0]))\n    assert (p.coords[:] == [(1.0, 2.0)])\n    p = Point(np.array([1.0]), np.array([2.0]), np.array([3.0]))\n    assert (p.coords[:] == '???')", "ground_truth": ["[(1.0, 2.0, 3.0)]", "[[1.0, 2.0, 3.0]]"], "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_342", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_point():\n    p = Point(3.0, 4.0)\n    q = Point(p)\n    assert (q.coords[:] == [(3.0, 4.0)])\n    p = Point(3.0, 4.0, 5.0)\n    q = Point(p)\n    assert (q.coords[:] == [(3.0, 4.0, 5.0)])", "masked_code": "def test_from_point():\n    p = Point(3.0, 4.0)\n    q = Point(p)\n    assert (q.coords[:] == '???')\n    p = Point(3.0, 4.0, 5.0)\n    q = Point(p)\n    assert (q.coords[:] == [(3.0, 4.0, 5.0)])", "ground_truth": ["[(3.0, 4.0)]", "[[3.0, 4.0]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_343", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_point():\n    p = Point(3.0, 4.0)\n    q = Point(p)\n    assert (q.coords[:] == [(3.0, 4.0)])\n    p = Point(3.0, 4.0, 5.0)\n    q = Point(p)\n    assert (q.coords[:] == [(3.0, 4.0, 5.0)])", "masked_code": "def test_from_point():\n    p = Point(3.0, 4.0)\n    q = Point(p)\n    assert (q.coords[:] == [(3.0, 4.0)])\n    p = Point(3.0, 4.0, 5.0)\n    q = Point(p)\n    assert (q.coords[:] == '???')", "ground_truth": ["[(3.0, 4.0, 5.0)]", "[[3.0, 4.0]]"], "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_331", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])", "masked_code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == '???')\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])", "ground_truth": ["[(3.0, 4.0)]", "[[3.0, 4.0]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_332", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])", "masked_code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == '???')\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])", "ground_truth": ["[(3.0, 4.0)]", "[[3.0, 4.0]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_333", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])", "masked_code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == '???')\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])", "ground_truth": ["[(3.0, 4.0)]", "[[3.0, 4.0]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_334", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])", "masked_code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == '???')\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])", "ground_truth": ["[(3.0, 4.0)]", "[[3.0, 4.0]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_335", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])", "masked_code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == '???')\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])", "ground_truth": ["[(3.0, 4.0, 5.0)]", "[[3.0, 4.0, 5.0]]"], "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_336", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])", "masked_code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == '???')\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])", "ground_truth": ["[(3.0, 4.0, 5.0)]", "[[3.0, 4.0, 5.0]]"], "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_337", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])", "masked_code": "def test_from_sequence():\n    p = Point((3.0, 4.0))\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([3.0, 4.0])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([(3.0, 4.0)])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point([[3.0, 4.0]])\n    assert (p.coords[:] == [(3.0, 4.0)])\n    p = Point((3.0, 4.0, 5.0))\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([3.0, 4.0, 5.0])\n    assert (p.coords[:] == [(3.0, 4.0, 5.0)])\n    p = Point([(3.0, 4.0, 5.0)])\n    assert (p.coords[:] == '???')", "ground_truth": ["[(3.0, 4.0, 5.0)]", "[[3.0, 4.0, 5.0]]"], "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_347", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_numpy_empty_point_coords", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_numpy_empty_point_coords():\n    pe = Point()\n    a = np.asarray(pe.coords)\n    assert (a.shape == (0, 2))", "masked_code": "def test_numpy_empty_point_coords():\n    pe = Point()\n    a = np.asarray(pe.coords)\n    assert (a.shape == '???')", "ground_truth": ["(0, 2)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_348", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_numpy_object_array", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_numpy_object_array():\n    geom = Point(3.0, 4.0)\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == geom)", "masked_code": "def test_numpy_object_array():\n    geom = Point(3.0, 4.0)\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == '???')", "ground_truth": ["<POINT (3 4)>", "geom"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_349", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "masked_code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == '???')\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "ground_truth": ["[(1.0, 2.0)]", "[[1.0, 2.0]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_350", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "masked_code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == '???')\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "ground_truth": ["'POINT (1 2)'", "p.wkt"], "quality_analysis": {"complexity_score": 6, "left_complexity": 4, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_351", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "masked_code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == '???')\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "ground_truth": ["[(1.0, 2.0, 3.0)]", "[[1.0, 2.0, 3.0]]"], "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_352", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "masked_code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == '???')\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "ground_truth": ["'POINT (1 2)'", "p.wkt"], "quality_analysis": {"complexity_score": 6, "left_complexity": 4, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_353", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "masked_code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == '???')\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "ground_truth": ["3.0"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_354", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "masked_code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == '???')\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "ground_truth": ["3.0"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_355", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "masked_code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == '???')\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "ground_truth": ["4.0"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_356", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "masked_code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == '???')\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "ground_truth": ["((3.0, 4.0),)", "([3.0, 4.0],)"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_357", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "masked_code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == '???')\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "ground_truth": ["(3.0, 4.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_358", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "masked_code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == '???')\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "ground_truth": ["(3.0, 4.0, 3.0, 4.0)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_359", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': (3.0, 4.0)})", "masked_code": "def test_point(self):\n    p = Point(1.0, 2.0)\n    assert (p.x == 1.0)\n    assert (type(p.x) is float)\n    assert (p.y == 2.0)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [(1.0, 2.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(1.0, 2.0, 3.0)\n    assert (p.coords[:] == [(1.0, 2.0, 3.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 3.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point((3.0, 4.0))\n    assert (p.x == 3.0)\n    assert (p.y == 4.0)\n    assert (tuple(p.coords) == ((3.0, 4.0),))\n    assert (p.coords[0] == (3.0, 4.0))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == (3.0, 4.0, 3.0, 4.0))\n    assert (p.__geo_interface__ == '???')", "ground_truth": ["{'type': 'Point', 'coordinates': (3.0, 4.0)}", "{'type': 'Point', 'coordinates': [3.0, 4.0]}"], "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_345", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point_array_coercion", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point_array_coercion():\n    p = Point(3.0, 4.0)\n    arr = np.array(p)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == p)", "masked_code": "def test_point_array_coercion():\n    p = Point(3.0, 4.0)\n    arr = np.array(p)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == '???')\n    assert (arr.item() == p)", "ground_truth": ["dtype('O')", "np.dtype('object')"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_346", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point_array_coercion", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point_array_coercion():\n    p = Point(3.0, 4.0)\n    arr = np.array(p)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == p)", "masked_code": "def test_point_array_coercion():\n    p = Point(3.0, 4.0)\n    arr = np.array(p)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == '???')", "ground_truth": ["<POINT (3 4)>", "p"], "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_360", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point_empty", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point_empty(self):\n    p_null = Point()\n    assert (p_null.wkt == 'POINT EMPTY')\n    assert (p_null.coords[:] == [])\n    assert (p_null.area == 0.0)\n    assert (p_null.__geo_interface__ == {'type': 'Point', 'coordinates': ()})", "masked_code": "def test_point_empty(self):\n    p_null = Point()\n    assert (p_null.wkt == '???')\n    assert (p_null.coords[:] == [])\n    assert (p_null.area == 0.0)\n    assert (p_null.__geo_interface__ == {'type': 'Point', 'coordinates': ()})", "ground_truth": ["'POINT EMPTY'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_361", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point_empty", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point_empty(self):\n    p_null = Point()\n    assert (p_null.wkt == 'POINT EMPTY')\n    assert (p_null.coords[:] == [])\n    assert (p_null.area == 0.0)\n    assert (p_null.__geo_interface__ == {'type': 'Point', 'coordinates': ()})", "masked_code": "def test_point_empty(self):\n    p_null = Point()\n    assert (p_null.wkt == 'POINT EMPTY')\n    assert (p_null.coords[:] == '???')\n    assert (p_null.area == 0.0)\n    assert (p_null.__geo_interface__ == {'type': 'Point', 'coordinates': ()})", "ground_truth": ["[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_362", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point_empty", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point_empty(self):\n    p_null = Point()\n    assert (p_null.wkt == 'POINT EMPTY')\n    assert (p_null.coords[:] == [])\n    assert (p_null.area == 0.0)\n    assert (p_null.__geo_interface__ == {'type': 'Point', 'coordinates': ()})", "masked_code": "def test_point_empty(self):\n    p_null = Point()\n    assert (p_null.wkt == 'POINT EMPTY')\n    assert (p_null.coords[:] == [])\n    assert (p_null.area == 0.0)\n    assert (p_null.__geo_interface__ == '???')", "ground_truth": ["{'type': 'Point', 'coordinates': ()}", "{'type': 'Point', 'coordinates': []}"], "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_542", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polygonize.py", "testname": "test_polygonize.py", "funcname": "test_polygonize_full", "imports": ["import unittest", "from shapely.geometry import LineString, Point, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.ops import polygonize, polygonize_full"], "code": "def test_polygonize_full(self):\n    lines2 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)], [(0, 1), (1, 1)], [(1, 1), (1, 0)], [(1, 0), (0, 0)], [(5, 5), (6, 6)], [(1, 1), (100, 100)]]\n    (result2, cuts, dangles, invalids) = polygonize_full(lines2)\n    assert (len(result2.geoms) == 2)\n    assert all((isinstance(x, Polygon) for x in result2.geoms))\n    assert (list(cuts.geoms) == [])\n    assert all((isinstance(x, LineString) for x in dangles.geoms))\n    assert (dump_coords(dangles) == [[(1.0, 1.0), (100.0, 100.0)], [(5.0, 5.0), (6.0, 6.0)]])\n    assert (list(invalids.geoms) == [])", "masked_code": "def test_polygonize_full(self):\n    lines2 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)], [(0, 1), (1, 1)], [(1, 1), (1, 0)], [(1, 0), (0, 0)], [(5, 5), (6, 6)], [(1, 1), (100, 100)]]\n    (result2, cuts, dangles, invalids) = polygonize_full(lines2)\n    assert (len(result2.geoms) == 2)\n    assert all((isinstance(x, Polygon) for x in result2.geoms))\n    assert (list(cuts.geoms) == '???')\n    assert all((isinstance(x, LineString) for x in dangles.geoms))\n    assert (dump_coords(dangles) == [[(1.0, 1.0), (100.0, 100.0)], [(5.0, 5.0), (6.0, 6.0)]])\n    assert (list(invalids.geoms) == [])", "ground_truth": ["[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolygonizeTestCase"}
{"task_id": "shapely_543", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polygonize.py", "testname": "test_polygonize.py", "funcname": "test_polygonize_full", "imports": ["import unittest", "from shapely.geometry import LineString, Point, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.ops import polygonize, polygonize_full"], "code": "def test_polygonize_full(self):\n    lines2 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)], [(0, 1), (1, 1)], [(1, 1), (1, 0)], [(1, 0), (0, 0)], [(5, 5), (6, 6)], [(1, 1), (100, 100)]]\n    (result2, cuts, dangles, invalids) = polygonize_full(lines2)\n    assert (len(result2.geoms) == 2)\n    assert all((isinstance(x, Polygon) for x in result2.geoms))\n    assert (list(cuts.geoms) == [])\n    assert all((isinstance(x, LineString) for x in dangles.geoms))\n    assert (dump_coords(dangles) == [[(1.0, 1.0), (100.0, 100.0)], [(5.0, 5.0), (6.0, 6.0)]])\n    assert (list(invalids.geoms) == [])", "masked_code": "def test_polygonize_full(self):\n    lines2 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)], [(0, 1), (1, 1)], [(1, 1), (1, 0)], [(1, 0), (0, 0)], [(5, 5), (6, 6)], [(1, 1), (100, 100)]]\n    (result2, cuts, dangles, invalids) = polygonize_full(lines2)\n    assert (len(result2.geoms) == 2)\n    assert all((isinstance(x, Polygon) for x in result2.geoms))\n    assert (list(cuts.geoms) == [])\n    assert all((isinstance(x, LineString) for x in dangles.geoms))\n    assert (dump_coords(dangles) == '???')\n    assert (list(invalids.geoms) == [])", "ground_truth": ["[[(1.0, 1.0), (100.0, 100.0)], [(5.0, 5.0), (6.0, 6.0)]]", "[[[1.0, 1.0], [100.0, 100.0]], [[5.0, 5.0], [6.0, 6.0]]]"], "quality_analysis": {"complexity_score": 26, "left_complexity": 4, "right_complexity": 22, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolygonizeTestCase"}
{"task_id": "shapely_544", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polygonize.py", "testname": "test_polygonize.py", "funcname": "test_polygonize_full", "imports": ["import unittest", "from shapely.geometry import LineString, Point, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.ops import polygonize, polygonize_full"], "code": "def test_polygonize_full(self):\n    lines2 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)], [(0, 1), (1, 1)], [(1, 1), (1, 0)], [(1, 0), (0, 0)], [(5, 5), (6, 6)], [(1, 1), (100, 100)]]\n    (result2, cuts, dangles, invalids) = polygonize_full(lines2)\n    assert (len(result2.geoms) == 2)\n    assert all((isinstance(x, Polygon) for x in result2.geoms))\n    assert (list(cuts.geoms) == [])\n    assert all((isinstance(x, LineString) for x in dangles.geoms))\n    assert (dump_coords(dangles) == [[(1.0, 1.0), (100.0, 100.0)], [(5.0, 5.0), (6.0, 6.0)]])\n    assert (list(invalids.geoms) == [])", "masked_code": "def test_polygonize_full(self):\n    lines2 = [[(0, 0), (1, 1)], [(0, 0), (0, 1)], [(0, 1), (1, 1)], [(1, 1), (1, 0)], [(1, 0), (0, 0)], [(5, 5), (6, 6)], [(1, 1), (100, 100)]]\n    (result2, cuts, dangles, invalids) = polygonize_full(lines2)\n    assert (len(result2.geoms) == 2)\n    assert all((isinstance(x, Polygon) for x in result2.geoms))\n    assert (list(cuts.geoms) == [])\n    assert all((isinstance(x, LineString) for x in dangles.geoms))\n    assert (dump_coords(dangles) == [[(1.0, 1.0), (100.0, 100.0)], [(5.0, 5.0), (6.0, 6.0)]])\n    assert (list(invalids.geoms) == '???')", "ground_truth": ["[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolygonizeTestCase"}
{"task_id": "shapely_548", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polylabel.py", "testname": "test_polylabel.py", "funcname": "test_polygon_with_hole", "imports": ["import unittest", "import pytest", "import shapely", "from shapely.algorithms.polylabel import polylabel", "from shapely.geometry import LineString, Point, Polygon"], "code": "def test_polygon_with_hole(self):\n    '\\n        Finds pole of inaccessibility for a polygon with a hole\\n        https://github.com/shapely/shapely/issues/817\\n        '\n    polygon = Polygon(shell=[(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)], holes=[[(2, 2), (6, 2), (6, 6), (2, 6), (2, 2)]])\n    label = polylabel(polygon, 0.05)\n    assert (label.x == pytest.approx(7.65625))\n    assert (label.y == pytest.approx(7.65625))", "masked_code": "def test_polygon_with_hole(self):\n    '\\n        Finds pole of inaccessibility for a polygon with a hole\\n        https://github.com/shapely/shapely/issues/817\\n        '\n    polygon = Polygon(shell=[(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)], holes=[[(2, 2), (6, 2), (6, 6), (2, 6), (2, 2)]])\n    label = polylabel(polygon, 0.05)\n    assert (label.x == '???')\n    assert (label.y == pytest.approx(7.65625))", "ground_truth": ["7.65625", "pytest.approx(7.65625)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolylabelTestCase"}
{"task_id": "shapely_549", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polylabel.py", "testname": "test_polylabel.py", "funcname": "test_polygon_with_hole", "imports": ["import unittest", "import pytest", "import shapely", "from shapely.algorithms.polylabel import polylabel", "from shapely.geometry import LineString, Point, Polygon"], "code": "def test_polygon_with_hole(self):\n    '\\n        Finds pole of inaccessibility for a polygon with a hole\\n        https://github.com/shapely/shapely/issues/817\\n        '\n    polygon = Polygon(shell=[(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)], holes=[[(2, 2), (6, 2), (6, 6), (2, 6), (2, 2)]])\n    label = polylabel(polygon, 0.05)\n    assert (label.x == pytest.approx(7.65625))\n    assert (label.y == pytest.approx(7.65625))", "masked_code": "def test_polygon_with_hole(self):\n    '\\n        Finds pole of inaccessibility for a polygon with a hole\\n        https://github.com/shapely/shapely/issues/817\\n        '\n    polygon = Polygon(shell=[(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)], holes=[[(2, 2), (6, 2), (6, 6), (2, 6), (2, 2)]])\n    label = polylabel(polygon, 0.05)\n    assert (label.x == pytest.approx(7.65625))\n    assert (label.y == '???')", "ground_truth": ["7.65625", "pytest.approx(7.65625)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolylabelTestCase"}
{"task_id": "shapely_545", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polylabel.py", "testname": "test_polylabel.py", "funcname": "test_rectangle_special_case", "imports": ["import unittest", "import pytest", "import shapely", "from shapely.algorithms.polylabel import polylabel", "from shapely.geometry import LineString, Point, Polygon"], "code": "def test_rectangle_special_case(self):\n    '\\n        The centroid algorithm used is vulnerable to floating point errors\\n        and can give unexpected results for rectangular polygons. Test\\n        that this special case is handled correctly.\\n        https://github.com/mapbox/polylabel/issues/3\\n        '\n    polygon = Polygon([(32.71997, (- 117.1931)), (32.71997, (- 117.21065)), (32.72408, (- 117.21065)), (32.72408, (- 117.1931))])\n    label = polylabel(polygon)\n    if (shapely.geos_version >= (3, 14, 0)):\n        assert (label.coords[:] == [(32.722025, (- 117.195155))])\n    elif (shapely.geos_version >= (3, 12, 0)):\n        assert (label.coords[:] == [(32.722025, (- 117.201875))])\n    else:\n        assert (label.coords[:] == [(32.722025, (- 117.208595))])", "masked_code": "def test_rectangle_special_case(self):\n    '\\n        The centroid algorithm used is vulnerable to floating point errors\\n        and can give unexpected results for rectangular polygons. Test\\n        that this special case is handled correctly.\\n        https://github.com/mapbox/polylabel/issues/3\\n        '\n    polygon = Polygon([(32.71997, (- 117.1931)), (32.71997, (- 117.21065)), (32.72408, (- 117.21065)), (32.72408, (- 117.1931))])\n    label = polylabel(polygon)\n    if (shapely.geos_version >= (3, 14, 0)):\n        assert (label.coords[:] == '???')\n    elif (shapely.geos_version >= (3, 12, 0)):\n        assert (label.coords[:] == [(32.722025, (- 117.201875))])\n    else:\n        assert (label.coords[:] == [(32.722025, (- 117.208595))])", "ground_truth": ["[(32.722025, (- 117.195155))]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolylabelTestCase"}
{"task_id": "shapely_546", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polylabel.py", "testname": "test_polylabel.py", "funcname": "test_rectangle_special_case", "imports": ["import unittest", "import pytest", "import shapely", "from shapely.algorithms.polylabel import polylabel", "from shapely.geometry import LineString, Point, Polygon"], "code": "def test_rectangle_special_case(self):\n    '\\n        The centroid algorithm used is vulnerable to floating point errors\\n        and can give unexpected results for rectangular polygons. Test\\n        that this special case is handled correctly.\\n        https://github.com/mapbox/polylabel/issues/3\\n        '\n    polygon = Polygon([(32.71997, (- 117.1931)), (32.71997, (- 117.21065)), (32.72408, (- 117.21065)), (32.72408, (- 117.1931))])\n    label = polylabel(polygon)\n    if (shapely.geos_version >= (3, 14, 0)):\n        assert (label.coords[:] == [(32.722025, (- 117.195155))])\n    elif (shapely.geos_version >= (3, 12, 0)):\n        assert (label.coords[:] == [(32.722025, (- 117.201875))])\n    else:\n        assert (label.coords[:] == [(32.722025, (- 117.208595))])", "masked_code": "def test_rectangle_special_case(self):\n    '\\n        The centroid algorithm used is vulnerable to floating point errors\\n        and can give unexpected results for rectangular polygons. Test\\n        that this special case is handled correctly.\\n        https://github.com/mapbox/polylabel/issues/3\\n        '\n    polygon = Polygon([(32.71997, (- 117.1931)), (32.71997, (- 117.21065)), (32.72408, (- 117.21065)), (32.72408, (- 117.1931))])\n    label = polylabel(polygon)\n    if (shapely.geos_version >= (3, 14, 0)):\n        assert (label.coords[:] == [(32.722025, (- 117.195155))])\n    elif (shapely.geos_version >= (3, 12, 0)):\n        assert (label.coords[:] == '???')\n    else:\n        assert (label.coords[:] == [(32.722025, (- 117.208595))])", "ground_truth": ["[(32.722025, (- 117.201875))]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolylabelTestCase"}
{"task_id": "shapely_547", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polylabel.py", "testname": "test_polylabel.py", "funcname": "test_rectangle_special_case", "imports": ["import unittest", "import pytest", "import shapely", "from shapely.algorithms.polylabel import polylabel", "from shapely.geometry import LineString, Point, Polygon"], "code": "def test_rectangle_special_case(self):\n    '\\n        The centroid algorithm used is vulnerable to floating point errors\\n        and can give unexpected results for rectangular polygons. Test\\n        that this special case is handled correctly.\\n        https://github.com/mapbox/polylabel/issues/3\\n        '\n    polygon = Polygon([(32.71997, (- 117.1931)), (32.71997, (- 117.21065)), (32.72408, (- 117.21065)), (32.72408, (- 117.1931))])\n    label = polylabel(polygon)\n    if (shapely.geos_version >= (3, 14, 0)):\n        assert (label.coords[:] == [(32.722025, (- 117.195155))])\n    elif (shapely.geos_version >= (3, 12, 0)):\n        assert (label.coords[:] == [(32.722025, (- 117.201875))])\n    else:\n        assert (label.coords[:] == [(32.722025, (- 117.208595))])", "masked_code": "def test_rectangle_special_case(self):\n    '\\n        The centroid algorithm used is vulnerable to floating point errors\\n        and can give unexpected results for rectangular polygons. Test\\n        that this special case is handled correctly.\\n        https://github.com/mapbox/polylabel/issues/3\\n        '\n    polygon = Polygon([(32.71997, (- 117.1931)), (32.71997, (- 117.21065)), (32.72408, (- 117.21065)), (32.72408, (- 117.1931))])\n    label = polylabel(polygon)\n    if (shapely.geos_version >= (3, 14, 0)):\n        assert (label.coords[:] == [(32.722025, (- 117.195155))])\n    elif (shapely.geos_version >= (3, 12, 0)):\n        assert (label.coords[:] == [(32.722025, (- 117.201875))])\n    else:\n        assert (label.coords[:] == '???')", "ground_truth": ["[(32.722025, (- 117.208595))]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolylabelTestCase"}
{"task_id": "shapely_553", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == '???')\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["False", "prepared_polygon1.disjoint(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_554", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == '???')\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["False", "prepared_polygon1.touches(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_555", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == '???')\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["True", "prepared_polygon1.intersects(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_556", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == '???')\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["False", "prepared_polygon1.crosses(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_557", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == '???')\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["False", "prepared_polygon1.within(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_558", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == '???')\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["False", "prepared_polygon1.contains(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_559", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == '???')\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["False", "prepared_polygon1.contains_properly(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_560", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)])\n    polygon2 = Polygon([(0.5, 0.5), (1.5, 0.5), (1.0, 1.0), (0.5, 0.5)])\n    point2 = Point(0.5, 0.5)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == '???')", "ground_truth": ["True", "prepared_polygon1.overlaps(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_561", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_products_z.py", "testname": "test_products_z.py", "funcname": "test_line_intersection", "imports": ["import unittest", "from shapely.geometry import LineString"], "code": "def test_line_intersection(self):\n    line1 = LineString([(0, 0, 0), (1, 1, 1)])\n    line2 = LineString([(0, 1, 1), (1, 0, 0)])\n    interxn = line1.intersection(line2)\n    assert interxn.has_z\n    assert (interxn._ndim == 3)\n    assert (0.0 <= interxn.z <= 1.0)", "masked_code": "def test_line_intersection(self):\n    line1 = LineString([(0, 0, 0), (1, 1, 1)])\n    line2 = LineString([(0, 1, 1), (1, 0, 0)])\n    interxn = line1.intersection(line2)\n    assert interxn.has_z\n    assert (interxn._ndim == '???')\n    assert (0.0 <= interxn.z <= 1.0)", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "ProductZTestCase"}
{"task_id": "shapely_226", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_coverage_union_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "def test_coverage_union_reduce_axis():\n    data = [[shapely.box(i, j, (i + 1), (j + 1)) for i in range(2)] for j in range(3)]\n    actual = shapely.coverage_union_all(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = shapely.coverage_union_all(data, axis=0)\n    assert (actual.shape == (2,))\n    actual = shapely.coverage_union_all(data, axis=1)\n    assert (actual.shape == (3,))\n    actual = shapely.coverage_union_all(data, axis=(- 1))\n    assert (actual.shape == (3,))", "masked_code": "def test_coverage_union_reduce_axis():\n    data = [[shapely.box(i, j, (i + 1), (j + 1)) for i in range(2)] for j in range(3)]\n    actual = shapely.coverage_union_all(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = shapely.coverage_union_all(data, axis=0)\n    assert (actual.shape == '???')\n    actual = shapely.coverage_union_all(data, axis=1)\n    assert (actual.shape == (3,))\n    actual = shapely.coverage_union_all(data, axis=(- 1))\n    assert (actual.shape == (3,))", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_227", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_coverage_union_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "def test_coverage_union_reduce_axis():\n    data = [[shapely.box(i, j, (i + 1), (j + 1)) for i in range(2)] for j in range(3)]\n    actual = shapely.coverage_union_all(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = shapely.coverage_union_all(data, axis=0)\n    assert (actual.shape == (2,))\n    actual = shapely.coverage_union_all(data, axis=1)\n    assert (actual.shape == (3,))\n    actual = shapely.coverage_union_all(data, axis=(- 1))\n    assert (actual.shape == (3,))", "masked_code": "def test_coverage_union_reduce_axis():\n    data = [[shapely.box(i, j, (i + 1), (j + 1)) for i in range(2)] for j in range(3)]\n    actual = shapely.coverage_union_all(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = shapely.coverage_union_all(data, axis=0)\n    assert (actual.shape == (2,))\n    actual = shapely.coverage_union_all(data, axis=1)\n    assert (actual.shape == '???')\n    actual = shapely.coverage_union_all(data, axis=(- 1))\n    assert (actual.shape == (3,))", "ground_truth": ["(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_228", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_coverage_union_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "def test_coverage_union_reduce_axis():\n    data = [[shapely.box(i, j, (i + 1), (j + 1)) for i in range(2)] for j in range(3)]\n    actual = shapely.coverage_union_all(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = shapely.coverage_union_all(data, axis=0)\n    assert (actual.shape == (2,))\n    actual = shapely.coverage_union_all(data, axis=1)\n    assert (actual.shape == (3,))\n    actual = shapely.coverage_union_all(data, axis=(- 1))\n    assert (actual.shape == (3,))", "masked_code": "def test_coverage_union_reduce_axis():\n    data = [[shapely.box(i, j, (i + 1), (j + 1)) for i in range(2)] for j in range(3)]\n    actual = shapely.coverage_union_all(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = shapely.coverage_union_all(data, axis=0)\n    assert (actual.shape == (2,))\n    actual = shapely.coverage_union_all(data, axis=1)\n    assert (actual.shape == (3,))\n    actual = shapely.coverage_union_all(data, axis=(- 1))\n    assert (actual.shape == '???')", "ground_truth": ["(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_211", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('a', all_types)\n@pytest.mark.parametrize('func', SET_OPERATIONS)\ndef test_set_operation_array(a, func):\n    actual = func(a, point)\n    assert isinstance(actual, Geometry)\n    actual = func([a, a], point)\n    assert (actual.shape == (2,))\n    assert isinstance(actual[0], Geometry)", "masked_code": "@pytest.mark.parametrize('a', all_types)\n@pytest.mark.parametrize('func', SET_OPERATIONS)\ndef test_set_operation_array(a, func):\n    actual = func(a, point)\n    assert isinstance(actual, Geometry)\n    actual = func([a, a], point)\n    assert (actual.shape == '???')\n    assert isinstance(actual[0], Geometry)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_212", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_prec_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('a', all_single_types)\n@pytest.mark.parametrize('func', SET_OPERATIONS)\n@pytest.mark.parametrize('grid_size', [0, 1, 2])\ndef test_set_operation_prec_array(a, func, grid_size):\n    if (func is shapely.disjoint_subset_union):\n        pytest.skip('disjoint_subset_union does not support grid_size')\n    actual = func([a, a], point, grid_size=grid_size)\n    assert (actual.shape == (2,))\n    assert isinstance(actual[0], Geometry)\n    b = shapely.set_precision(a, grid_size=grid_size)\n    point2 = shapely.set_precision(point, grid_size=grid_size)\n    expected = func([b, b], point2)\n    assert shapely.equals(shapely.normalize(actual), shapely.normalize(expected)).all()", "masked_code": "@pytest.mark.parametrize('a', all_single_types)\n@pytest.mark.parametrize('func', SET_OPERATIONS)\n@pytest.mark.parametrize('grid_size', [0, 1, 2])\ndef test_set_operation_prec_array(a, func, grid_size):\n    if (func is shapely.disjoint_subset_union):\n        pytest.skip('disjoint_subset_union does not support grid_size')\n    actual = func([a, a], point, grid_size=grid_size)\n    assert (actual.shape == '???')\n    assert isinstance(actual[0], Geometry)\n    b = shapely.set_precision(a, grid_size=grid_size)\n    point2 = shapely.set_precision(point, grid_size=grid_size)\n    expected = func([b, b], point2)\n    assert shapely.equals(shapely.normalize(actual), shapely.normalize(expected)).all()", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_223", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_prec_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS_PREC)\ndef test_set_operation_prec_reduce_axis(func, related_func):\n    data = ([([point] * 2)] * 3)\n    actual = func(data, grid_size=1, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, grid_size=1, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, grid_size=1, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, grid_size=1, axis=(- 1))\n    assert (actual.shape == (3,))", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS_PREC)\ndef test_set_operation_prec_reduce_axis(func, related_func):\n    data = ([([point] * 2)] * 3)\n    actual = func(data, grid_size=1, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, grid_size=1, axis=0)\n    assert (actual.shape == '???')\n    actual = func(data, grid_size=1, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, grid_size=1, axis=(- 1))\n    assert (actual.shape == (3,))", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_224", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_prec_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS_PREC)\ndef test_set_operation_prec_reduce_axis(func, related_func):\n    data = ([([point] * 2)] * 3)\n    actual = func(data, grid_size=1, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, grid_size=1, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, grid_size=1, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, grid_size=1, axis=(- 1))\n    assert (actual.shape == (3,))", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS_PREC)\ndef test_set_operation_prec_reduce_axis(func, related_func):\n    data = ([([point] * 2)] * 3)\n    actual = func(data, grid_size=1, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, grid_size=1, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, grid_size=1, axis=1)\n    assert (actual.shape == '???')\n    actual = func(data, grid_size=1, axis=(- 1))\n    assert (actual.shape == (3,))", "ground_truth": ["(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_225", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_prec_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS_PREC)\ndef test_set_operation_prec_reduce_axis(func, related_func):\n    data = ([([point] * 2)] * 3)\n    actual = func(data, grid_size=1, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, grid_size=1, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, grid_size=1, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, grid_size=1, axis=(- 1))\n    assert (actual.shape == (3,))", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS_PREC)\ndef test_set_operation_prec_reduce_axis(func, related_func):\n    data = ([([point] * 2)] * 3)\n    actual = func(data, grid_size=1, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, grid_size=1, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, grid_size=1, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, grid_size=1, axis=(- 1))\n    assert (actual.shape == '???')", "ground_truth": ["(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_221", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_all_none_arr", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('n', range(1, 3))\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_all_none_arr(n, func, related_func):\n    assert (func(([([None] * n)] * 2), axis=1).tolist() == [empty, empty])\n    assert (func(([([None] * 2)] * n), axis=0).tolist() == [empty, empty])", "masked_code": "@pytest.mark.parametrize('n', range(1, 3))\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_all_none_arr(n, func, related_func):\n    assert (func(([([None] * n)] * 2), axis=1).tolist() == '???')\n    assert (func(([([None] * 2)] * n), axis=0).tolist() == [empty, empty])", "ground_truth": ["[<GEOMETRYCOLLECTION EMPTY>, <GEOMETRYCOLLECTION EMPTY>]", "[empty, empty]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_222", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_all_none_arr", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('n', range(1, 3))\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_all_none_arr(n, func, related_func):\n    assert (func(([([None] * n)] * 2), axis=1).tolist() == [empty, empty])\n    assert (func(([([None] * 2)] * n), axis=0).tolist() == [empty, empty])", "masked_code": "@pytest.mark.parametrize('n', range(1, 3))\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_all_none_arr(n, func, related_func):\n    assert (func(([([None] * n)] * 2), axis=1).tolist() == [empty, empty])\n    assert (func(([([None] * 2)] * n), axis=0).tolist() == '???')", "ground_truth": ["[<GEOMETRYCOLLECTION EMPTY>, <GEOMETRYCOLLECTION EMPTY>]", "[empty, empty]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_213", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_axis(func, related_func):\n    data = ([([point] * 2)] * 3)\n    actual = func(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, axis=(- 1))\n    assert (actual.shape == (3,))", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_axis(func, related_func):\n    data = ([([point] * 2)] * 3)\n    actual = func(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, axis=0)\n    assert (actual.shape == '???')\n    actual = func(data, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, axis=(- 1))\n    assert (actual.shape == (3,))", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_214", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_axis(func, related_func):\n    data = ([([point] * 2)] * 3)\n    actual = func(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, axis=(- 1))\n    assert (actual.shape == (3,))", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_axis(func, related_func):\n    data = ([([point] * 2)] * 3)\n    actual = func(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, axis=1)\n    assert (actual.shape == '???')\n    actual = func(data, axis=(- 1))\n    assert (actual.shape == (3,))", "ground_truth": ["(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_215", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_axis(func, related_func):\n    data = ([([point] * 2)] * 3)\n    actual = func(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, axis=(- 1))\n    assert (actual.shape == (3,))", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_axis(func, related_func):\n    data = ([([point] * 2)] * 3)\n    actual = func(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, axis=(- 1))\n    assert (actual.shape == '???')", "ground_truth": ["(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_216", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    assert (func(np.empty((0,), dtype=object)) == empty)\n    arr_empty_2D = np.empty((0, 2), dtype=object)\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 2))\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    assert (func(np.empty((0,), dtype=object)) == '???')\n    arr_empty_2D = np.empty((0, 2), dtype=object)\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 2))\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "ground_truth": ["<GEOMETRYCOLLECTION EMPTY>", "empty"], "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_217", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    assert (func(np.empty((0,), dtype=object)) == empty)\n    arr_empty_2D = np.empty((0, 2), dtype=object)\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 2))\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    assert (func(np.empty((0,), dtype=object)) == empty)\n    arr_empty_2D = np.empty((0, 2), dtype=object)\n    assert (func(arr_empty_2D) == '???')\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 2))\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "ground_truth": ["<GEOMETRYCOLLECTION EMPTY>", "empty"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_218", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    assert (func(np.empty((0,), dtype=object)) == empty)\n    arr_empty_2D = np.empty((0, 2), dtype=object)\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 2))\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    assert (func(np.empty((0,), dtype=object)) == empty)\n    arr_empty_2D = np.empty((0, 2), dtype=object)\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == '???')\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "ground_truth": ["([empty] * 2)", "[<GEOMETRYCOLLECTION EMPTY>, <GEOMETRYCOLLECTION EMPTY>]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_219", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    assert (func(np.empty((0,), dtype=object)) == empty)\n    arr_empty_2D = np.empty((0, 2), dtype=object)\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 2))\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    assert (func(np.empty((0,), dtype=object)) == empty)\n    arr_empty_2D = np.empty((0, 2), dtype=object)\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 2))\n    assert (func(arr_empty_2D, axis=1).tolist() == '???')", "ground_truth": ["[<GEOMETRYCOLLECTION EMPTY>, <GEOMETRYCOLLECTION EMPTY>]", "[]"], "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_220", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_some_none_len2", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_some_none_len2(func, related_func):\n    assert (func([empty, None]) == empty)", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_some_none_len2(func, related_func):\n    assert (func([empty, None]) == '???')", "ground_truth": ["<GEOMETRYCOLLECTION EMPTY>", "empty"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_564", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_shape.py", "testname": "test_shape.py", "funcname": "test_multilinestring_empty", "imports": ["import pytest", "from shapely.geometry import MultiLineString, Point, Polygon, shape", "from shapely.geometry.geo import _is_coordinates_empty"], "code": "@pytest.mark.parametrize('geom', [{'type': 'MultiLineString', 'coordinates': []}, {'type': 'MultiLineString', 'coordinates': [[]]}, {'type': 'MultiLineString', 'coordinates': None}])\ndef test_multilinestring_empty(geom):\n    assert (shape(geom) == MultiLineString())", "masked_code": "@pytest.mark.parametrize('geom', [{'type': 'MultiLineString', 'coordinates': []}, {'type': 'MultiLineString', 'coordinates': [[]]}, {'type': 'MultiLineString', 'coordinates': None}])\ndef test_multilinestring_empty(geom):\n    assert (shape(geom) == '???')", "ground_truth": ["<MULTILINESTRING EMPTY>", "MultiLineString()"], "quality_analysis": {"complexity_score": 7, "left_complexity": 4, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_563", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_shape.py", "testname": "test_shape.py", "funcname": "test_polygon_empty_np_array", "imports": ["import pytest", "from shapely.geometry import MultiLineString, Point, Polygon, shape", "from shapely.geometry.geo import _is_coordinates_empty"], "code": "def test_polygon_empty_np_array():\n    np = pytest.importorskip('numpy')\n    geom = {'type': 'Polygon', 'coordinates': np.array([])}\n    assert (shape(geom) == Polygon())", "masked_code": "def test_polygon_empty_np_array():\n    np = pytest.importorskip('numpy')\n    geom = {'type': 'Polygon', 'coordinates': np.array([])}\n    assert (shape(geom) == '???')", "ground_truth": ["<POLYGON EMPTY>", "Polygon()"], "quality_analysis": {"complexity_score": 7, "left_complexity": 4, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_562", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_shape.py", "testname": "test_shape.py", "funcname": "test_polygon_no_coords", "imports": ["import pytest", "from shapely.geometry import MultiLineString, Point, Polygon, shape", "from shapely.geometry.geo import _is_coordinates_empty"], "code": "@pytest.mark.parametrize('geom', [{'type': 'Polygon', 'coordinates': None}, {'type': 'Polygon', 'coordinates': []}])\ndef test_polygon_no_coords(geom):\n    assert (shape(geom) == Polygon())", "masked_code": "@pytest.mark.parametrize('geom', [{'type': 'Polygon', 'coordinates': None}, {'type': 'Polygon', 'coordinates': []}])\ndef test_polygon_no_coords(geom):\n    assert (shape(geom) == '???')", "ground_truth": ["<POLYGON EMPTY>", "Polygon()"], "quality_analysis": {"complexity_score": 7, "left_complexity": 4, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_565", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_shared_paths.py", "testname": "test_shared_paths.py", "funcname": "test_shared_paths_forward", "imports": ["import unittest", "import pytest", "from shapely.errors import GeometryTypeError", "from shapely.geometry import GeometryCollection, LineString, MultiLineString, Point", "from shapely.ops import shared_paths"], "code": "def test_shared_paths_forward(self):\n    g1 = LineString([(0, 0), (10, 0), (10, 5), (20, 5)])\n    g2 = LineString([(5, 0), (15, 0)])\n    result = shared_paths(g1, g2)\n    assert isinstance(result, GeometryCollection)\n    assert (len(result.geoms) == 2)\n    (a, b) = result.geoms\n    assert isinstance(a, MultiLineString)\n    assert (len(a.geoms) == 1)\n    assert (a.geoms[0].coords[:] == [(5, 0), (10, 0)])\n    assert b.is_empty", "masked_code": "def test_shared_paths_forward(self):\n    g1 = LineString([(0, 0), (10, 0), (10, 5), (20, 5)])\n    g2 = LineString([(5, 0), (15, 0)])\n    result = shared_paths(g1, g2)\n    assert isinstance(result, GeometryCollection)\n    assert (len(result.geoms) == 2)\n    (a, b) = result.geoms\n    assert isinstance(a, MultiLineString)\n    assert (len(a.geoms) == 1)\n    assert (a.geoms[0].coords[:] == '???')\n    assert b.is_empty", "ground_truth": ["[(5, 0), (10, 0)]", "[[5, 0], [10, 0]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "SharedPaths"}
{"task_id": "shapely_566", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_shared_paths.py", "testname": "test_shared_paths.py", "funcname": "test_shared_paths_forward2", "imports": ["import unittest", "import pytest", "from shapely.errors import GeometryTypeError", "from shapely.geometry import GeometryCollection, LineString, MultiLineString, Point", "from shapely.ops import shared_paths"], "code": "def test_shared_paths_forward2(self):\n    g1 = LineString([(0, 0), (10, 0), (10, 5), (20, 5)])\n    g2 = LineString([(15, 0), (5, 0)])\n    result = shared_paths(g1, g2)\n    assert isinstance(result, GeometryCollection)\n    assert (len(result.geoms) == 2)\n    (a, b) = result.geoms\n    assert isinstance(b, MultiLineString)\n    assert (len(b.geoms) == 1)\n    assert (b.geoms[0].coords[:] == [(5, 0), (10, 0)])\n    assert a.is_empty", "masked_code": "def test_shared_paths_forward2(self):\n    g1 = LineString([(0, 0), (10, 0), (10, 5), (20, 5)])\n    g2 = LineString([(15, 0), (5, 0)])\n    result = shared_paths(g1, g2)\n    assert isinstance(result, GeometryCollection)\n    assert (len(result.geoms) == 2)\n    (a, b) = result.geoms\n    assert isinstance(b, MultiLineString)\n    assert (len(b.geoms) == 1)\n    assert (b.geoms[0].coords[:] == '???')\n    assert a.is_empty", "ground_truth": ["[(5, 0), (10, 0)]", "[[5, 0], [10, 0]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "SharedPaths"}
{"task_id": "shapely_567", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_singularity.py", "testname": "test_singularity.py", "funcname": "test_polygon_3", "imports": ["import unittest", "from shapely.geometry import Polygon"], "code": "def test_polygon_3(self):\n    p = (1.0, 1.0)\n    poly = Polygon([p, p, p])\n    assert (poly.bounds == (1.0, 1.0, 1.0, 1.0))", "masked_code": "def test_polygon_3(self):\n    p = (1.0, 1.0)\n    poly = Polygon([p, p, p])\n    assert (poly.bounds == '???')", "ground_truth": ["(1.0, 1.0, 1.0, 1.0)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolygonTestCase"}
{"task_id": "shapely_568", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_singularity.py", "testname": "test_singularity.py", "funcname": "test_polygon_5", "imports": ["import unittest", "from shapely.geometry import Polygon"], "code": "def test_polygon_5(self):\n    p = (1.0, 1.0)\n    poly = Polygon([p, p, p, p, p])\n    assert (poly.bounds == (1.0, 1.0, 1.0, 1.0))", "masked_code": "def test_polygon_5(self):\n    p = (1.0, 1.0)\n    poly = Polygon([p, p, p, p, p])\n    assert (poly.bounds == '???')", "ground_truth": ["(1.0, 1.0, 1.0, 1.0)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolygonTestCase"}
{"task_id": "shapely_569", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_snap.py", "testname": "test_snap.py", "funcname": "test_snap", "imports": ["import unittest", "from shapely.geometry import LineString, Polygon", "from shapely.ops import snap"], "code": "def test_snap(self):\n    square = Polygon([(1, 1), (2, 1), (2, 2), (1, 2), (1, 1)])\n    line = LineString([(0, 0), (0.8, 0.8), (1.8, 0.95), (2.6, 0.5)])\n    square_coords = square.exterior.coords[:]\n    line_coords = line.coords[:]\n    result = snap(line, square, 0.5)\n    assert isinstance(result, LineString)\n    assert (result.coords[:] == [(0.0, 0.0), (1.0, 1.0), (2.0, 1.0), (2.6, 0.5)])\n    assert (square.exterior.coords[:] == square_coords)\n    assert (line.coords[:] == line_coords)", "masked_code": "def test_snap(self):\n    square = Polygon([(1, 1), (2, 1), (2, 2), (1, 2), (1, 1)])\n    line = LineString([(0, 0), (0.8, 0.8), (1.8, 0.95), (2.6, 0.5)])\n    square_coords = square.exterior.coords[:]\n    line_coords = line.coords[:]\n    result = snap(line, square, 0.5)\n    assert isinstance(result, LineString)\n    assert (result.coords[:] == '???')\n    assert (square.exterior.coords[:] == square_coords)\n    assert (line.coords[:] == line_coords)", "ground_truth": ["[(0.0, 0.0), (1.0, 1.0), (2.0, 1.0), (2.6, 0.5)]", "[[0.0, 0.0], [1.0, 1.0], [2.0, 1.0], [2.6, 0.5]]"], "quality_analysis": {"complexity_score": 23, "left_complexity": 5, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}, "classname": "Snap"}
{"task_id": "shapely_570", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_snap.py", "testname": "test_snap.py", "funcname": "test_snap", "imports": ["import unittest", "from shapely.geometry import LineString, Polygon", "from shapely.ops import snap"], "code": "def test_snap(self):\n    square = Polygon([(1, 1), (2, 1), (2, 2), (1, 2), (1, 1)])\n    line = LineString([(0, 0), (0.8, 0.8), (1.8, 0.95), (2.6, 0.5)])\n    square_coords = square.exterior.coords[:]\n    line_coords = line.coords[:]\n    result = snap(line, square, 0.5)\n    assert isinstance(result, LineString)\n    assert (result.coords[:] == [(0.0, 0.0), (1.0, 1.0), (2.0, 1.0), (2.6, 0.5)])\n    assert (square.exterior.coords[:] == square_coords)\n    assert (line.coords[:] == line_coords)", "masked_code": "def test_snap(self):\n    square = Polygon([(1, 1), (2, 1), (2, 2), (1, 2), (1, 1)])\n    line = LineString([(0, 0), (0.8, 0.8), (1.8, 0.95), (2.6, 0.5)])\n    square_coords = square.exterior.coords[:]\n    line_coords = line.coords[:]\n    result = snap(line, square, 0.5)\n    assert isinstance(result, LineString)\n    assert (result.coords[:] == [(0.0, 0.0), (1.0, 1.0), (2.0, 1.0), (2.6, 0.5)])\n    assert (square.exterior.coords[:] == '???')\n    assert (line.coords[:] == line_coords)", "ground_truth": ["[[1.0, 1.0], [2.0, 1.0], [2.0, 2.0], [1.0, 2.0], [1.0, 1.0]]", "square_coords"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Snap"}
{"task_id": "shapely_571", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_snap.py", "testname": "test_snap.py", "funcname": "test_snap", "imports": ["import unittest", "from shapely.geometry import LineString, Polygon", "from shapely.ops import snap"], "code": "def test_snap(self):\n    square = Polygon([(1, 1), (2, 1), (2, 2), (1, 2), (1, 1)])\n    line = LineString([(0, 0), (0.8, 0.8), (1.8, 0.95), (2.6, 0.5)])\n    square_coords = square.exterior.coords[:]\n    line_coords = line.coords[:]\n    result = snap(line, square, 0.5)\n    assert isinstance(result, LineString)\n    assert (result.coords[:] == [(0.0, 0.0), (1.0, 1.0), (2.0, 1.0), (2.6, 0.5)])\n    assert (square.exterior.coords[:] == square_coords)\n    assert (line.coords[:] == line_coords)", "masked_code": "def test_snap(self):\n    square = Polygon([(1, 1), (2, 1), (2, 2), (1, 2), (1, 1)])\n    line = LineString([(0, 0), (0.8, 0.8), (1.8, 0.95), (2.6, 0.5)])\n    square_coords = square.exterior.coords[:]\n    line_coords = line.coords[:]\n    result = snap(line, square, 0.5)\n    assert isinstance(result, LineString)\n    assert (result.coords[:] == [(0.0, 0.0), (1.0, 1.0), (2.0, 1.0), (2.6, 0.5)])\n    assert (square.exterior.coords[:] == square_coords)\n    assert (line.coords[:] == '???')", "ground_truth": ["[[0.0, 0.0], [0.8, 0.8], [1.8, 0.95], [2.6, 0.5]]", "line_coords"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Snap"}
{"task_id": "shapely_229", "reponame": "shapely", "testpath": "shapely/tests/test_strtree.py", "testname": "test_strtree.py", "funcname": "test_init", "imports": ["import itertools", "import math", "import pickle", "import subprocess", "import sys", "from concurrent.futures import ThreadPoolExecutor", "import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import LineString, MultiPoint, Point, STRtree, box, geos_version", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty, empty_line_string, empty_point, ignore_invalid, point"], "code": "@pytest.mark.parametrize('geometry,count, hits', [([], 0, 0), ([point], 1, 1), ([None], 0, 0), ([point, None], 1, 1), ([empty, empty_point, empty_line_string], 0, 0), ([empty, point, empty_point, empty_line_string], 1, 1)])\ndef test_init(geometry, count, hits):\n    tree = STRtree(geometry)\n    assert (len(tree) == count)\n    assert (tree.query(box(0, 0, 100, 100)).size == hits)", "masked_code": "@pytest.mark.parametrize('geometry,count, hits', [([], 0, 0), ([point], 1, 1), ([None], 0, 0), ([point, None], 1, 1), ([empty, empty_point, empty_line_string], 0, 0), ([empty, point, empty_point, empty_line_string], 1, 1)])\ndef test_init(geometry, count, hits):\n    tree = STRtree(geometry)\n    assert (len(tree) == '???')\n    assert (tree.query(box(0, 0, 100, 100)).size == hits)", "ground_truth": ["0", "count"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_230", "reponame": "shapely", "testpath": "shapely/tests/test_strtree.py", "testname": "test_strtree.py", "funcname": "test_init", "imports": ["import itertools", "import math", "import pickle", "import subprocess", "import sys", "from concurrent.futures import ThreadPoolExecutor", "import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import LineString, MultiPoint, Point, STRtree, box, geos_version", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty, empty_line_string, empty_point, ignore_invalid, point"], "code": "@pytest.mark.parametrize('geometry,count, hits', [([], 0, 0), ([point], 1, 1), ([None], 0, 0), ([point, None], 1, 1), ([empty, empty_point, empty_line_string], 0, 0), ([empty, point, empty_point, empty_line_string], 1, 1)])\ndef test_init(geometry, count, hits):\n    tree = STRtree(geometry)\n    assert (len(tree) == count)\n    assert (tree.query(box(0, 0, 100, 100)).size == hits)", "masked_code": "@pytest.mark.parametrize('geometry,count, hits', [([], 0, 0), ([point], 1, 1), ([None], 0, 0), ([point, None], 1, 1), ([empty, empty_point, empty_line_string], 0, 0), ([empty, point, empty_point, empty_line_string], 1, 1)])\ndef test_init(geometry, count, hits):\n    tree = STRtree(geometry)\n    assert (len(tree) == count)\n    assert (tree.query(box(0, 0, 100, 100)).size == '???')", "ground_truth": ["0", "hits"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_231", "reponame": "shapely", "testpath": "shapely/tests/test_strtree.py", "testname": "test_strtree.py", "funcname": "test_references", "imports": ["import itertools", "import math", "import pickle", "import subprocess", "import sys", "from concurrent.futures import ThreadPoolExecutor", "import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import LineString, MultiPoint, Point, STRtree, box, geos_version", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty, empty_line_string, empty_point, ignore_invalid, point"], "code": "def test_references():\n    point1 = Point()\n    point2 = Point(0, 1)\n    geoms = [point1, point2]\n    tree = STRtree(geoms)\n    point1 = None\n    point2 = None\n    import gc\n    gc.collect()\n    assert (tree.query(box(0, 0, 1, 1)).tolist() == [1])", "masked_code": "def test_references():\n    point1 = Point()\n    point2 = Point(0, 1)\n    geoms = [point1, point2]\n    tree = STRtree(geoms)\n    point1 = None\n    point2 = None\n    import gc\n    gc.collect()\n    assert (tree.query(box(0, 0, 1, 1)).tolist() == '???')", "ground_truth": ["[1]"], "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_618", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_line", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_line(self):\n    g = geometry.LineString([(0, 1), (2, 3)])\n    h = transform(self.func, g)\n    assert (h.geom_type == 'LineString')\n    assert (list(h.coords) == [(0, 1), (2, 3)])", "masked_code": "def test_line(self):\n    g = geometry.LineString([(0, 1), (2, 3)])\n    h = transform(self.func, g)\n    assert (h.geom_type == '???')\n    assert (list(h.coords) == [(0, 1), (2, 3)])", "ground_truth": ["'LineString'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_619", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_line", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_line(self):\n    g = geometry.LineString([(0, 1), (2, 3)])\n    h = transform(self.func, g)\n    assert (h.geom_type == 'LineString')\n    assert (list(h.coords) == [(0, 1), (2, 3)])", "masked_code": "def test_line(self):\n    g = geometry.LineString([(0, 1), (2, 3)])\n    h = transform(self.func, g)\n    assert (h.geom_type == 'LineString')\n    assert (list(h.coords) == '???')", "ground_truth": ["[(0, 1), (2, 3)]", "[[0, 1], [2, 3]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_628", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_line", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_line(self):\n    g = geometry.LineString([(0, 1), (2, 3)])\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'LineString')\n    assert (list(h.coords) == [(1.0, 2.0), (3.0, 4.0)])", "masked_code": "def test_line(self):\n    g = geometry.LineString([(0, 1), (2, 3)])\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == '???')\n    assert (list(h.coords) == [(1.0, 2.0), (3.0, 4.0)])", "ground_truth": ["'LineString'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_629", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_line", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_line(self):\n    g = geometry.LineString([(0, 1), (2, 3)])\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'LineString')\n    assert (list(h.coords) == [(1.0, 2.0), (3.0, 4.0)])", "masked_code": "def test_line(self):\n    g = geometry.LineString([(0, 1), (2, 3)])\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'LineString')\n    assert (list(h.coords) == '???')", "ground_truth": ["[(1.0, 2.0), (3.0, 4.0)]", "[[1.0, 2.0], [3.0, 4.0]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_620", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_linearring", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_linearring(self):\n    g = geometry.LinearRing([(0, 1), (2, 3), (2, 2), (0, 1)])\n    h = transform(self.func, g)\n    assert (h.geom_type == 'LinearRing')\n    assert (list(h.coords) == [(0, 1), (2, 3), (2, 2), (0, 1)])", "masked_code": "def test_linearring(self):\n    g = geometry.LinearRing([(0, 1), (2, 3), (2, 2), (0, 1)])\n    h = transform(self.func, g)\n    assert (h.geom_type == '???')\n    assert (list(h.coords) == [(0, 1), (2, 3), (2, 2), (0, 1)])", "ground_truth": ["'LinearRing'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_621", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_linearring", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_linearring(self):\n    g = geometry.LinearRing([(0, 1), (2, 3), (2, 2), (0, 1)])\n    h = transform(self.func, g)\n    assert (h.geom_type == 'LinearRing')\n    assert (list(h.coords) == [(0, 1), (2, 3), (2, 2), (0, 1)])", "masked_code": "def test_linearring(self):\n    g = geometry.LinearRing([(0, 1), (2, 3), (2, 2), (0, 1)])\n    h = transform(self.func, g)\n    assert (h.geom_type == 'LinearRing')\n    assert (list(h.coords) == '???')", "ground_truth": ["[(0, 1), (2, 3), (2, 2), (0, 1)]", "[[0, 1], [2, 3], [2, 2], [0, 1]]"], "quality_analysis": {"complexity_score": 23, "left_complexity": 5, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_624", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_multipolygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([(0, 1), (0, 4)]).buffer(1.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(h.area))", "masked_code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([(0, 1), (0, 4)]).buffer(1.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == '???')\n    assert (g.area == pytest.approx(h.area))", "ground_truth": ["'MultiPolygon'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_625", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_multipolygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([(0, 1), (0, 4)]).buffer(1.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(h.area))", "masked_code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([(0, 1), (0, 4)]).buffer(1.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == '???')", "ground_truth": ["6.273096981091877", "pytest.approx(h.area)"], "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_634", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_multipolygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([(0, 1), (0, 4)]).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == pytest.approx(3.5))", "masked_code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([(0, 1), (0, 4)]).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == '???')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == pytest.approx(3.5))", "ground_truth": ["'MultiPolygon'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_635", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_multipolygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([(0, 1), (0, 4)]).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == pytest.approx(3.5))", "masked_code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([(0, 1), (0, 4)]).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == '???')\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == pytest.approx(3.5))", "ground_truth": ["6.273096981091877", "pytest.approx(h.area)"], "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_636", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_multipolygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([(0, 1), (0, 4)]).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == pytest.approx(3.5))", "masked_code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([(0, 1), (0, 4)]).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == '???')\n    assert (h.centroid.y == pytest.approx(3.5))", "ground_truth": ["1", "1.0", "pytest.approx(1.0)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_637", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_multipolygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([(0, 1), (0, 4)]).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == pytest.approx(3.5))", "masked_code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([(0, 1), (0, 4)]).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == '???')", "ground_truth": ["3.5", "pytest.approx(3.5)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_616", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_point", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_point(self):\n    g = geometry.Point(0, 1)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'Point')\n    assert (list(h.coords) == [(0, 1)])", "masked_code": "def test_point(self):\n    g = geometry.Point(0, 1)\n    h = transform(self.func, g)\n    assert (h.geom_type == '???')\n    assert (list(h.coords) == [(0, 1)])", "ground_truth": ["'Point'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_617", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_point", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_point(self):\n    g = geometry.Point(0, 1)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'Point')\n    assert (list(h.coords) == [(0, 1)])", "masked_code": "def test_point(self):\n    g = geometry.Point(0, 1)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'Point')\n    assert (list(h.coords) == '???')", "ground_truth": ["[(0, 1)]", "[[0, 1]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_626", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_point", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_point(self):\n    g = geometry.Point(0, 1)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'Point')\n    assert (list(h.coords) == [(1.0, 2.0)])", "masked_code": "def test_point(self):\n    g = geometry.Point(0, 1)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == '???')\n    assert (list(h.coords) == [(1.0, 2.0)])", "ground_truth": ["'Point'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_627", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_point", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_point(self):\n    g = geometry.Point(0, 1)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'Point')\n    assert (list(h.coords) == [(1.0, 2.0)])", "masked_code": "def test_point(self):\n    g = geometry.Point(0, 1)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'Point')\n    assert (list(h.coords) == '???')", "ground_truth": ["[(1.0, 2.0)]", "[[1.0, 2.0]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_622", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_polygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_polygon(self):\n    g = geometry.Point(0, 1).buffer(1.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(h.area))", "masked_code": "def test_polygon(self):\n    g = geometry.Point(0, 1).buffer(1.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == '???')\n    assert (g.area == pytest.approx(h.area))", "ground_truth": ["'Polygon'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_623", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_polygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_polygon(self):\n    g = geometry.Point(0, 1).buffer(1.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(h.area))", "masked_code": "def test_polygon(self):\n    g = geometry.Point(0, 1).buffer(1.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == '???')", "ground_truth": ["3.136548490545939", "pytest.approx(h.area)"], "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_630", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_polygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_polygon(self):\n    g = geometry.Point(0, 1).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == pytest.approx(2.0))", "masked_code": "def test_polygon(self):\n    g = geometry.Point(0, 1).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == '???')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == pytest.approx(2.0))", "ground_truth": ["'Polygon'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_631", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_polygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_polygon(self):\n    g = geometry.Point(0, 1).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == pytest.approx(2.0))", "masked_code": "def test_polygon(self):\n    g = geometry.Point(0, 1).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == '???')\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == pytest.approx(2.0))", "ground_truth": ["3.136548490545939", "pytest.approx(h.area)"], "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_632", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_polygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_polygon(self):\n    g = geometry.Point(0, 1).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == pytest.approx(2.0))", "masked_code": "def test_polygon(self):\n    g = geometry.Point(0, 1).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == '???')\n    assert (h.centroid.y == pytest.approx(2.0))", "ground_truth": ["1", "1.0", "pytest.approx(1.0)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_633", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_polygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_polygon(self):\n    g = geometry.Point(0, 1).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == pytest.approx(2.0))", "masked_code": "def test_polygon(self):\n    g = geometry.Point(0, 1).buffer(1.0)\n    h = transform((lambda x, y, z=None: ((x + 1.0), (y + 1.0))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(h.area))\n    assert (h.centroid.x == pytest.approx(1.0))\n    assert (h.centroid.y == '???')", "ground_truth": ["2", "2.0", "pytest.approx(2.0)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_638", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_union.py", "testname": "test_union.py", "funcname": "test_unary_union", "imports": ["import random", "import unittest", "from functools import partial", "from itertools import islice", "import pytest", "from shapely.geometry import MultiPolygon, Point", "from shapely.ops import unary_union"], "code": "def test_unary_union(self):\n    patches = [Point(xy).buffer(0.05) for xy in self.coords]\n    u = unary_union(patches)\n    assert (u.geom_type == 'MultiPolygon')\n    assert (u.area == pytest.approx(0.718572540569))", "masked_code": "def test_unary_union(self):\n    patches = [Point(xy).buffer(0.05) for xy in self.coords]\n    u = unary_union(patches)\n    assert (u.geom_type == '???')\n    assert (u.area == pytest.approx(0.718572540569))", "ground_truth": ["'MultiPolygon'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "UnionTestCase"}
{"task_id": "shapely_639", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_union.py", "testname": "test_union.py", "funcname": "test_unary_union", "imports": ["import random", "import unittest", "from functools import partial", "from itertools import islice", "import pytest", "from shapely.geometry import MultiPolygon, Point", "from shapely.ops import unary_union"], "code": "def test_unary_union(self):\n    patches = [Point(xy).buffer(0.05) for xy in self.coords]\n    u = unary_union(patches)\n    assert (u.geom_type == 'MultiPolygon')\n    assert (u.area == pytest.approx(0.718572540569))", "masked_code": "def test_unary_union(self):\n    patches = [Point(xy).buffer(0.05) for xy in self.coords]\n    u = unary_union(patches)\n    assert (u.geom_type == 'MultiPolygon')\n    assert (u.area == '???')", "ground_truth": ["0.718572540569", "pytest.approx(0.718572540569)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "UnionTestCase"}
{"task_id": "shapely_640", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_union.py", "testname": "test_union.py", "funcname": "test_unary_union_multi", "imports": ["import random", "import unittest", "from functools import partial", "from itertools import islice", "import pytest", "from shapely.geometry import MultiPolygon, Point", "from shapely.ops import unary_union"], "code": "def test_unary_union_multi(self):\n    patches = MultiPolygon([Point(xy).buffer(0.05) for xy in self.coords])\n    assert (unary_union(patches).area == pytest.approx(0.71857254056))\n    assert (unary_union([patches, patches]).area == pytest.approx(0.71857254056))", "masked_code": "def test_unary_union_multi(self):\n    patches = MultiPolygon([Point(xy).buffer(0.05) for xy in self.coords])\n    assert (unary_union(patches).area == '???')\n    assert (unary_union([patches, patches]).area == pytest.approx(0.71857254056))", "ground_truth": ["0.71857254056", "pytest.approx(0.71857254056)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "UnionTestCase"}
{"task_id": "shapely_641", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_union.py", "testname": "test_union.py", "funcname": "test_unary_union_multi", "imports": ["import random", "import unittest", "from functools import partial", "from itertools import islice", "import pytest", "from shapely.geometry import MultiPolygon, Point", "from shapely.ops import unary_union"], "code": "def test_unary_union_multi(self):\n    patches = MultiPolygon([Point(xy).buffer(0.05) for xy in self.coords])\n    assert (unary_union(patches).area == pytest.approx(0.71857254056))\n    assert (unary_union([patches, patches]).area == pytest.approx(0.71857254056))", "masked_code": "def test_unary_union_multi(self):\n    patches = MultiPolygon([Point(xy).buffer(0.05) for xy in self.coords])\n    assert (unary_union(patches).area == pytest.approx(0.71857254056))\n    assert (unary_union([patches, patches]).area == '???')", "ground_truth": ["0.71857254056", "pytest.approx(0.71857254056)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "UnionTestCase"}
{"task_id": "shapely_642", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_validation.py", "testname": "test_validation.py", "funcname": "test_valid", "imports": ["import unittest", "from shapely.geometry import Point", "from shapely.validation import explain_validity"], "code": "def test_valid(self):\n    assert (explain_validity(Point(0, 0)) == 'Valid Geometry')", "masked_code": "def test_valid(self):\n    assert (explain_validity(Point(0, 0)) == '???')", "ground_truth": ["'Valid Geometry'"], "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "ValidationTestCase"}
{"task_id": "shapely_643", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_vectorized.py", "testname": "test_vectorized.py", "funcname": "test_array_2d", "imports": ["import unittest", "import numpy as np", "import pytest", "from shapely.geometry import MultiPolygon, Point, box"], "code": "def test_array_2d(self):\n    (y, x) = np.mgrid[((- 10):10:15j, (- 5):15:16j)]\n    result = self.assertContainsResults(self.construct_torus(), x, y)\n    assert (result.shape == x.shape)", "masked_code": "def test_array_2d(self):\n    (y, x) = np.mgrid[((- 10):10:15j, (- 5):15:16j)]\n    result = self.assertContainsResults(self.construct_torus(), x, y)\n    assert (result.shape == '???')", "ground_truth": ["x.shape"], "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": "VectorizedContainsTestCase"}
{"task_id": "shapely_646", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_voronoi_diagram.py", "testname": "test_voronoi_diagram.py", "funcname": "test_from_multipoint_without_tolerace_without_floating_point_coordinates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import MultiPoint", "from shapely.ops import voronoi_diagram", "from shapely.wkt import loads as load_wkt"], "code": "def test_from_multipoint_without_tolerace_without_floating_point_coordinates():\n    \"But it's fine without it.\"\n    mp = load_wkt('MULTIPOINT (0 0, 1 0, 1 2, 0 1)')\n    regions = voronoi_diagram(mp)\n    assert (len(regions.geoms) == 4)", "masked_code": "def test_from_multipoint_without_tolerace_without_floating_point_coordinates():\n    \"But it's fine without it.\"\n    mp = load_wkt('MULTIPOINT (0 0, 1 0, 1 2, 0 1)')\n    regions = voronoi_diagram(mp)\n    assert (len(regions.geoms) == '???')", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_645", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_voronoi_diagram.py", "testname": "test_voronoi_diagram.py", "funcname": "test_from_polygon", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import MultiPoint", "from shapely.ops import voronoi_diagram", "from shapely.wkt import loads as load_wkt"], "code": "def test_from_polygon():\n    poly = load_wkt('POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))')\n    regions = voronoi_diagram(poly)\n    assert (len(regions.geoms) == 4)", "masked_code": "def test_from_polygon():\n    poly = load_wkt('POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))')\n    regions = voronoi_diagram(poly)\n    assert (len(regions.geoms) == '???')", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_644", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_voronoi_diagram.py", "testname": "test_voronoi_diagram.py", "funcname": "test_larger_envelope", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import MultiPoint", "from shapely.ops import voronoi_diagram", "from shapely.wkt import loads as load_wkt"], "code": "def test_larger_envelope():\n    'When the envelope we specify is larger than the\\n    area of the input feature, the created regions should\\n    expand to fill that area.'\n    mp = MultiPoint(points=[(0.5, 0.5), (1.0, 1.0)])\n    poly = load_wkt('POLYGON ((0 0, 2 0, 2 2, 0 2, 0 0))')\n    regions = voronoi_diagram(mp, envelope=poly)\n    assert (len(regions.geoms) == 2)\n    assert (sum((r.area for r in regions.geoms)) == poly.area)", "masked_code": "def test_larger_envelope():\n    'When the envelope we specify is larger than the\\n    area of the input feature, the created regions should\\n    expand to fill that area.'\n    mp = MultiPoint(points=[(0.5, 0.5), (1.0, 1.0)])\n    poly = load_wkt('POLYGON ((0 0, 2 0, 2 2, 0 2, 0 0))')\n    regions = voronoi_diagram(mp, envelope=poly)\n    assert (len(regions.geoms) == 2)\n    assert (sum((r.area for r in regions.geoms)) == '???')", "ground_truth": ["4.0", "poly.area"], "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_649", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_dumps_endianness", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "def test_dumps_endianness(some_point):\n    result = dumps(some_point)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(some_point, big_endian=False)\n    assert (bin2hex(result) == '0101000000333333333333F33F3333333333330B40')\n    result = dumps(some_point, big_endian=True)\n    assert (bin2hex(result) == '00000000013FF3333333333333400B333333333333')", "masked_code": "def test_dumps_endianness(some_point):\n    result = dumps(some_point)\n    assert (bin2hex(result) == '???')\n    result = dumps(some_point, big_endian=False)\n    assert (bin2hex(result) == '0101000000333333333333F33F3333333333330B40')\n    result = dumps(some_point, big_endian=True)\n    assert (bin2hex(result) == '00000000013FF3333333333333400B333333333333')", "ground_truth": ["'0101000000333333333333F33F3333333333330B40'", "hostorder('BIdd', '0101000000333333333333F33F3333333333330B40')"], "quality_analysis": {"complexity_score": 9, "left_complexity": 4, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_650", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_dumps_endianness", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "def test_dumps_endianness(some_point):\n    result = dumps(some_point)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(some_point, big_endian=False)\n    assert (bin2hex(result) == '0101000000333333333333F33F3333333333330B40')\n    result = dumps(some_point, big_endian=True)\n    assert (bin2hex(result) == '00000000013FF3333333333333400B333333333333')", "masked_code": "def test_dumps_endianness(some_point):\n    result = dumps(some_point)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(some_point, big_endian=False)\n    assert (bin2hex(result) == '???')\n    result = dumps(some_point, big_endian=True)\n    assert (bin2hex(result) == '00000000013FF3333333333333400B333333333333')", "ground_truth": ["'0101000000333333333333F33F3333333333330B40'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_651", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_dumps_endianness", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "def test_dumps_endianness(some_point):\n    result = dumps(some_point)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(some_point, big_endian=False)\n    assert (bin2hex(result) == '0101000000333333333333F33F3333333333330B40')\n    result = dumps(some_point, big_endian=True)\n    assert (bin2hex(result) == '00000000013FF3333333333333400B333333333333')", "masked_code": "def test_dumps_endianness(some_point):\n    result = dumps(some_point)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(some_point, big_endian=False)\n    assert (bin2hex(result) == '0101000000333333333333F33F3333333333330B40')\n    result = dumps(some_point, big_endian=True)\n    assert (bin2hex(result) == '???')", "ground_truth": ["'00000000013FF3333333333333400B333333333333'", "'0101000000333333333333F33F3333333333330B40'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_647", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_dumps_srid", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_dumps_srid(some_point):\n    result = dumps(some_point)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(some_point, srid=4326)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020E6100000333333333333F33F3333333333330B40'))", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_dumps_srid(some_point):\n    result = dumps(some_point)\n    assert (bin2hex(result) == '???')\n    result = dumps(some_point, srid=4326)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020E6100000333333333333F33F3333333333330B40'))", "ground_truth": ["'0101000000333333333333F33F3333333333330B40'", "hostorder('BIdd', '0101000000333333333333F33F3333333333330B40')"], "quality_analysis": {"complexity_score": 9, "left_complexity": 4, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_648", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_dumps_srid", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_dumps_srid(some_point):\n    result = dumps(some_point)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(some_point, srid=4326)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020E6100000333333333333F33F3333333333330B40'))", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_dumps_srid(some_point):\n    result = dumps(some_point)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(some_point, srid=4326)\n    assert (bin2hex(result) == '???')", "ground_truth": ["'0101000020E6100000333333333333F33F3333333333330B40'", "hostorder('BIIdd', '0101000020E6100000333333333333F33F3333333333330B40')"], "quality_analysis": {"complexity_score": 9, "left_complexity": 4, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_656", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_loads_hex", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "def test_loads_hex(some_point):\n    assert (loads(dumps(some_point, hex=True), hex=True) == some_point)", "masked_code": "def test_loads_hex(some_point):\n    assert (loads(dumps(some_point, hex=True), hex=True) == '???')", "ground_truth": ["<POINT (1.2 3.4)>", "some_point"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_652", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_loads_srid", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('0101000020E6100000333333333333F33F3333333333330B40'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [(1.2, 3.4)])\n    result = dumps(geom)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(geom, include_srid=True)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020E6100000333333333333F33F3333333333330B40'))\n    result = dumps(geom, srid=27700)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020346C0000333333333333F33F3333333333330B40'))", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('0101000020E6100000333333333333F33F3333333333330B40'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == '???')\n    result = dumps(geom)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(geom, include_srid=True)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020E6100000333333333333F33F3333333333330B40'))\n    result = dumps(geom, srid=27700)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020346C0000333333333333F33F3333333333330B40'))", "ground_truth": ["[(1.2, 3.4)]", "[[1.2, 3.4]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_653", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_loads_srid", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('0101000020E6100000333333333333F33F3333333333330B40'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [(1.2, 3.4)])\n    result = dumps(geom)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(geom, include_srid=True)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020E6100000333333333333F33F3333333333330B40'))\n    result = dumps(geom, srid=27700)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020346C0000333333333333F33F3333333333330B40'))", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('0101000020E6100000333333333333F33F3333333333330B40'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [(1.2, 3.4)])\n    result = dumps(geom)\n    assert (bin2hex(result) == '???')\n    result = dumps(geom, include_srid=True)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020E6100000333333333333F33F3333333333330B40'))\n    result = dumps(geom, srid=27700)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020346C0000333333333333F33F3333333333330B40'))", "ground_truth": ["'0101000000333333333333F33F3333333333330B40'", "hostorder('BIdd', '0101000000333333333333F33F3333333333330B40')"], "quality_analysis": {"complexity_score": 9, "left_complexity": 4, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_654", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_loads_srid", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('0101000020E6100000333333333333F33F3333333333330B40'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [(1.2, 3.4)])\n    result = dumps(geom)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(geom, include_srid=True)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020E6100000333333333333F33F3333333333330B40'))\n    result = dumps(geom, srid=27700)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020346C0000333333333333F33F3333333333330B40'))", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('0101000020E6100000333333333333F33F3333333333330B40'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [(1.2, 3.4)])\n    result = dumps(geom)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(geom, include_srid=True)\n    assert (bin2hex(result) == '???')\n    result = dumps(geom, srid=27700)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020346C0000333333333333F33F3333333333330B40'))", "ground_truth": ["'0101000020E6100000333333333333F33F3333333333330B40'", "hostorder('BIIdd', '0101000020E6100000333333333333F33F3333333333330B40')"], "quality_analysis": {"complexity_score": 9, "left_complexity": 4, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_655", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_loads_srid", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('0101000020E6100000333333333333F33F3333333333330B40'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [(1.2, 3.4)])\n    result = dumps(geom)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(geom, include_srid=True)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020E6100000333333333333F33F3333333333330B40'))\n    result = dumps(geom, srid=27700)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020346C0000333333333333F33F3333333333330B40'))", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('0101000020E6100000333333333333F33F3333333333330B40'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [(1.2, 3.4)])\n    result = dumps(geom)\n    assert (bin2hex(result) == hostorder('BIdd', '0101000000333333333333F33F3333333333330B40'))\n    result = dumps(geom, include_srid=True)\n    assert (bin2hex(result) == hostorder('BIIdd', '0101000020E6100000333333333333F33F3333333333330B40'))\n    result = dumps(geom, srid=27700)\n    assert (bin2hex(result) == '???')", "ground_truth": ["'0101000020346C0000333333333333F33F3333333333330B40'", "hostorder('BIIdd', '0101000020346C0000333333333333F33F3333333333330B40')"], "quality_analysis": {"complexity_score": 9, "left_complexity": 4, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_657", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_point_empty", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "def test_point_empty():\n    g = wkt.loads('POINT EMPTY')\n    result = dumps(g, big_endian=False)\n    assert (result[:((- 2) * 8)] == b'\\x01\\x01\\x00\\x00\\x00')\n    coords = struct.unpack('<2d', result[((- 2) * 8):])\n    assert (len(coords) == 2)\n    assert all((math.isnan(val) for val in coords))", "masked_code": "def test_point_empty():\n    g = wkt.loads('POINT EMPTY')\n    result = dumps(g, big_endian=False)\n    assert (result[:((- 2) * 8)] == '???')\n    coords = struct.unpack('<2d', result[((- 2) * 8):])\n    assert (len(coords) == 2)\n    assert all((math.isnan(val) for val in coords))", "ground_truth": ["b'\\x01\\x01\\x00\\x00\\x00'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_658", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_point_z_empty", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_point_z_empty():\n    g = wkt.loads('POINT Z EMPTY')\n    assert (g.wkb_hex == hostorder('BIddd', '0101000080000000000000F87F000000000000F87F000000000000F87F'))", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_point_z_empty():\n    g = wkt.loads('POINT Z EMPTY')\n    assert (g.wkb_hex == '???')", "ground_truth": ["'0101000080000000000000F87F000000000000F87F000000000000F87F'", "hostorder('BIddd', '0101000080000000000000F87F000000000000F87F000000000000F87F')"], "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_661", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkt.py", "testname": "test_wkt.py", "funcname": "test_dumps_loads", "imports": ["from math import pi", "import pytest", "from shapely.geometry import Point", "from shapely.wkt import dump, dumps, load, loads"], "code": "def test_dumps_loads(some_point):\n    assert (dumps(some_point) == f'POINT ({pi:.16f} {(- pi):.16f})')\n    assert (loads(dumps(some_point)) == some_point)", "masked_code": "def test_dumps_loads(some_point):\n    assert (dumps(some_point) == '???')\n    assert (loads(dumps(some_point)) == some_point)", "ground_truth": ["'POINT (3.1415926535897931 -3.1415926535897931)'", "f'POINT ({pi:.16f} {(- pi):.16f})'"], "quality_analysis": {"complexity_score": 4, "left_complexity": 4, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_662", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkt.py", "testname": "test_wkt.py", "funcname": "test_dumps_loads", "imports": ["from math import pi", "import pytest", "from shapely.geometry import Point", "from shapely.wkt import dump, dumps, load, loads"], "code": "def test_dumps_loads(some_point):\n    assert (dumps(some_point) == f'POINT ({pi:.16f} {(- pi):.16f})')\n    assert (loads(dumps(some_point)) == some_point)", "masked_code": "def test_dumps_loads(some_point):\n    assert (dumps(some_point) == f'POINT ({pi:.16f} {(- pi):.16f})')\n    assert (loads(dumps(some_point)) == '???')", "ground_truth": ["<POINT (3.142 -3.142)>", "some_point"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_663", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkt.py", "testname": "test_wkt.py", "funcname": "test_dumps_loads_null_geometry", "imports": ["from math import pi", "import pytest", "from shapely.geometry import Point", "from shapely.wkt import dump, dumps, load, loads"], "code": "def test_dumps_loads_null_geometry(empty_geometry):\n    assert (dumps(empty_geometry) == 'POINT EMPTY')\n    assert loads(dumps(empty_geometry)).equals(empty_geometry)", "masked_code": "def test_dumps_loads_null_geometry(empty_geometry):\n    assert (dumps(empty_geometry) == '???')\n    assert loads(dumps(empty_geometry)).equals(empty_geometry)", "ground_truth": ["'POINT EMPTY'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_664", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkt.py", "testname": "test_wkt.py", "funcname": "test_dumps_precision", "imports": ["from math import pi", "import pytest", "from shapely.geometry import Point", "from shapely.wkt import dump, dumps, load, loads"], "code": "def test_dumps_precision(some_point):\n    assert (dumps(some_point, rounding_precision=4) == f'POINT ({pi:.4f} {(- pi):.4f})')", "masked_code": "def test_dumps_precision(some_point):\n    assert (dumps(some_point, rounding_precision=4) == '???')", "ground_truth": ["'POINT (3.1416 -3.1416)'", "f'POINT ({pi:.4f} {(- pi):.4f})'"], "quality_analysis": {"complexity_score": 4, "left_complexity": 4, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_659", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkt.py", "testname": "test_wkt.py", "funcname": "test_wkt", "imports": ["from math import pi", "import pytest", "from shapely.geometry import Point", "from shapely.wkt import dump, dumps, load, loads"], "code": "def test_wkt(some_point):\n    '.wkt and wkt.dumps() both do not trim by default.'\n    assert (some_point.wkt == f'POINT ({pi:.15f} {(- pi):.15f})')", "masked_code": "def test_wkt(some_point):\n    '.wkt and wkt.dumps() both do not trim by default.'\n    assert (some_point.wkt == '???')", "ground_truth": ["'POINT (3.141592653589793 -3.141592653589793)'", "f'POINT ({pi:.15f} {(- pi):.15f})'"], "quality_analysis": {"complexity_score": 2, "left_complexity": 2, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_660", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkt.py", "testname": "test_wkt.py", "funcname": "test_wkt_null", "imports": ["from math import pi", "import pytest", "from shapely.geometry import Point", "from shapely.wkt import dump, dumps, load, loads"], "code": "def test_wkt_null(empty_geometry):\n    assert (empty_geometry.wkt == 'POINT EMPTY')", "masked_code": "def test_wkt_null(empty_geometry):\n    assert (empty_geometry.wkt == '???')", "ground_truth": ["'POINT EMPTY'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
