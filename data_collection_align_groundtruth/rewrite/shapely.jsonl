{"task_id": "shapely_427", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_affinity.py", "testname": "test_affinity.py", "funcname": "test_rotate_angle_array", "imports": ["import unittest", "from math import pi", "import numpy as np", "import pytest", "from shapely import affinity", "from shapely.geometry import Point", "from shapely.wkt import loads as load_wkt"], "code": "def test_rotate_angle_array(self):\n    ls = load_wkt('LINESTRING(10 0, 10 10, 20 10)')\n    els = load_wkt('LINESTRING(20 0, 10 0, 10 10)')\n    theta = np.array(90.0)\n    rls = affinity.rotate(ls, theta)\n    assert (theta.item() == 90.0)\n    assert rls.equals(els)\n    theta_neg = np.array((- 90.0))\n    els_neg = load_wkt('LINESTRING(10 10, 20 10, 20 0)')\n    rls_neg = affinity.rotate(ls, theta_neg)\n    assert rls_neg.equals(els_neg)\n    theta_360 = np.array(360.0)\n    rls_360 = affinity.rotate(ls, theta_360)\n    assert rls_360.equals(ls)\n    theta_rad = np.array((pi / 2))\n    rls_rad = affinity.rotate(ls, theta_rad, use_radians=True)\n    assert (theta_rad.item() == (pi / 2))\n    assert rls_rad.equals(els)", "masked_code": "def test_rotate_angle_array(self):\n    ls = load_wkt('LINESTRING(10 0, 10 10, 20 10)')\n    els = load_wkt('LINESTRING(20 0, 10 0, 10 10)')\n    theta = np.array(90.0)\n    rls = affinity.rotate(ls, theta)\n    assert (theta.item() == '???')\n    assert rls.equals(els)\n    theta_neg = np.array((- 90.0))\n    els_neg = load_wkt('LINESTRING(10 10, 20 10, 20 0)')\n    rls_neg = affinity.rotate(ls, theta_neg)\n    assert rls_neg.equals(els_neg)\n    theta_360 = np.array(360.0)\n    rls_360 = affinity.rotate(ls, theta_360)\n    assert rls_360.equals(ls)\n    theta_rad = np.array((pi / 2))\n    rls_rad = affinity.rotate(ls, theta_rad, use_radians=True)\n    assert (theta_rad.item() == (pi / 2))\n    assert rls_rad.equals(els)", "ground_truth": ["90.0"], "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransformOpsTestCase"}
{"task_id": "shapely_428", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_affinity.py", "testname": "test_affinity.py", "funcname": "test_rotate_angle_array", "imports": ["import unittest", "from math import pi", "import numpy as np", "import pytest", "from shapely import affinity", "from shapely.geometry import Point", "from shapely.wkt import loads as load_wkt"], "code": "def test_rotate_angle_array(self):\n    ls = load_wkt('LINESTRING(10 0, 10 10, 20 10)')\n    els = load_wkt('LINESTRING(20 0, 10 0, 10 10)')\n    theta = np.array(90.0)\n    rls = affinity.rotate(ls, theta)\n    assert (theta.item() == 90.0)\n    assert rls.equals(els)\n    theta_neg = np.array((- 90.0))\n    els_neg = load_wkt('LINESTRING(10 10, 20 10, 20 0)')\n    rls_neg = affinity.rotate(ls, theta_neg)\n    assert rls_neg.equals(els_neg)\n    theta_360 = np.array(360.0)\n    rls_360 = affinity.rotate(ls, theta_360)\n    assert rls_360.equals(ls)\n    theta_rad = np.array((pi / 2))\n    rls_rad = affinity.rotate(ls, theta_rad, use_radians=True)\n    assert (theta_rad.item() == (pi / 2))\n    assert rls_rad.equals(els)", "masked_code": "def test_rotate_angle_array(self):\n    ls = load_wkt('LINESTRING(10 0, 10 10, 20 10)')\n    els = load_wkt('LINESTRING(20 0, 10 0, 10 10)')\n    theta = np.array(90.0)\n    rls = affinity.rotate(ls, theta)\n    assert (theta.item() == 90.0)\n    assert rls.equals(els)\n    theta_neg = np.array((- 90.0))\n    els_neg = load_wkt('LINESTRING(10 10, 20 10, 20 0)')\n    rls_neg = affinity.rotate(ls, theta_neg)\n    assert rls_neg.equals(els_neg)\n    theta_360 = np.array(360.0)\n    rls_360 = affinity.rotate(ls, theta_360)\n    assert rls_360.equals(ls)\n    theta_rad = np.array((pi / 2))\n    rls_rad = affinity.rotate(ls, theta_rad, use_radians=True)\n    assert (theta_rad.item() == '???')\n    assert rls_rad.equals(els)", "ground_truth": ["(pi / 2)", "1.5707963267948966"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransformOpsTestCase"}
{"task_id": "shapely_429", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_affinity.py", "testname": "test_affinity.py", "funcname": "test_skew_xs_ys_array", "imports": ["import unittest", "from math import pi", "import numpy as np", "import pytest", "from shapely import affinity", "from shapely.geometry import Point", "from shapely.wkt import loads as load_wkt"], "code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(0 0 0, 0 -100 0, -100 -100 0)')\n    els = load_wkt('LINESTRING (0.0 0.0, 0.0 -100.0, -100.0 -100.0)')\n    xs_ys = np.array([0.0, 0.0])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 0.0)\n    assert (xs_ys[1] == 0.0)\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys2 = np.array([30.0, (- 45.0)])\n    els2 = load_wkt('LINESTRING (28.867513459481287 -50, -28.867513459481287 -150, -128.8675134594813 -50)')\n    sls2 = affinity.skew(ls, xs_ys2[(0, ...)], xs_ys2[(1, ...)])\n    assert (xs_ys2[0] == 30.0)\n    assert (xs_ys2[1] == (- 45.0))\n    assert sls2.equals_exact(els2, 1e-06)\n    xs_ys3 = np.array([(pi / 4), ((- pi) / 2)])\n    els3 = load_wkt('LINESTRING Z (50 -816561967659768400 0, -50 -816561967659768600 0, -150 816561967659768500 0)')\n    sls3 = affinity.skew(ls, xs_ys3[(0, ...)], xs_ys3[(1, ...)], use_radians=True)\n    assert (xs_ys3[0] == (pi / 4))\n    assert (xs_ys3[1] == ((- pi) / 2))\n    assert sls3.equals_exact(els3, 1e-06)\n    xs_ys4 = np.array([180.0, 0.0])\n    els4 = load_wkt('LINESTRING Z (0 0 0, 0 -100 0, -100 -100 0)')\n    sls4 = affinity.skew(ls, xs_ys4[(0, ...)], xs_ys4[(1, ...)])\n    assert sls4.equals_exact(els4, 1e-06)", "masked_code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(0 0 0, 0 -100 0, -100 -100 0)')\n    els = load_wkt('LINESTRING (0.0 0.0, 0.0 -100.0, -100.0 -100.0)')\n    xs_ys = np.array([0.0, 0.0])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 0.0)\n    assert (xs_ys[1] == 0.0)\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys2 = np.array([30.0, (- 45.0)])\n    els2 = load_wkt('LINESTRING (28.867513459481287 -50, -28.867513459481287 -150, -128.8675134594813 -50)')\n    sls2 = affinity.skew(ls, xs_ys2[(0, ...)], xs_ys2[(1, ...)])\n    assert (xs_ys2[0] == '???')\n    assert (xs_ys2[1] == (- 45.0))\n    assert sls2.equals_exact(els2, 1e-06)\n    xs_ys3 = np.array([(pi / 4), ((- pi) / 2)])\n    els3 = load_wkt('LINESTRING Z (50 -816561967659768400 0, -50 -816561967659768600 0, -150 816561967659768500 0)')\n    sls3 = affinity.skew(ls, xs_ys3[(0, ...)], xs_ys3[(1, ...)], use_radians=True)\n    assert (xs_ys3[0] == (pi / 4))\n    assert (xs_ys3[1] == ((- pi) / 2))\n    assert sls3.equals_exact(els3, 1e-06)\n    xs_ys4 = np.array([180.0, 0.0])\n    els4 = load_wkt('LINESTRING Z (0 0 0, 0 -100 0, -100 -100 0)')\n    sls4 = affinity.skew(ls, xs_ys4[(0, ...)], xs_ys4[(1, ...)])\n    assert sls4.equals_exact(els4, 1e-06)", "ground_truth": ["30.0"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransformOpsTestCase"}
{"task_id": "shapely_430", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_affinity.py", "testname": "test_affinity.py", "funcname": "test_skew_xs_ys_array", "imports": ["import unittest", "from math import pi", "import numpy as np", "import pytest", "from shapely import affinity", "from shapely.geometry import Point", "from shapely.wkt import loads as load_wkt"], "code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(0 0 0, 0 -100 0, -100 -100 0)')\n    els = load_wkt('LINESTRING (0.0 0.0, 0.0 -100.0, -100.0 -100.0)')\n    xs_ys = np.array([0.0, 0.0])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 0.0)\n    assert (xs_ys[1] == 0.0)\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys2 = np.array([30.0, (- 45.0)])\n    els2 = load_wkt('LINESTRING (28.867513459481287 -50, -28.867513459481287 -150, -128.8675134594813 -50)')\n    sls2 = affinity.skew(ls, xs_ys2[(0, ...)], xs_ys2[(1, ...)])\n    assert (xs_ys2[0] == 30.0)\n    assert (xs_ys2[1] == (- 45.0))\n    assert sls2.equals_exact(els2, 1e-06)\n    xs_ys3 = np.array([(pi / 4), ((- pi) / 2)])\n    els3 = load_wkt('LINESTRING Z (50 -816561967659768400 0, -50 -816561967659768600 0, -150 816561967659768500 0)')\n    sls3 = affinity.skew(ls, xs_ys3[(0, ...)], xs_ys3[(1, ...)], use_radians=True)\n    assert (xs_ys3[0] == (pi / 4))\n    assert (xs_ys3[1] == ((- pi) / 2))\n    assert sls3.equals_exact(els3, 1e-06)\n    xs_ys4 = np.array([180.0, 0.0])\n    els4 = load_wkt('LINESTRING Z (0 0 0, 0 -100 0, -100 -100 0)')\n    sls4 = affinity.skew(ls, xs_ys4[(0, ...)], xs_ys4[(1, ...)])\n    assert sls4.equals_exact(els4, 1e-06)", "masked_code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(0 0 0, 0 -100 0, -100 -100 0)')\n    els = load_wkt('LINESTRING (0.0 0.0, 0.0 -100.0, -100.0 -100.0)')\n    xs_ys = np.array([0.0, 0.0])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 0.0)\n    assert (xs_ys[1] == 0.0)\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys2 = np.array([30.0, (- 45.0)])\n    els2 = load_wkt('LINESTRING (28.867513459481287 -50, -28.867513459481287 -150, -128.8675134594813 -50)')\n    sls2 = affinity.skew(ls, xs_ys2[(0, ...)], xs_ys2[(1, ...)])\n    assert (xs_ys2[0] == 30.0)\n    assert (xs_ys2[1] == '???')\n    assert sls2.equals_exact(els2, 1e-06)\n    xs_ys3 = np.array([(pi / 4), ((- pi) / 2)])\n    els3 = load_wkt('LINESTRING Z (50 -816561967659768400 0, -50 -816561967659768600 0, -150 816561967659768500 0)')\n    sls3 = affinity.skew(ls, xs_ys3[(0, ...)], xs_ys3[(1, ...)], use_radians=True)\n    assert (xs_ys3[0] == (pi / 4))\n    assert (xs_ys3[1] == ((- pi) / 2))\n    assert sls3.equals_exact(els3, 1e-06)\n    xs_ys4 = np.array([180.0, 0.0])\n    els4 = load_wkt('LINESTRING Z (0 0 0, 0 -100 0, -100 -100 0)')\n    sls4 = affinity.skew(ls, xs_ys4[(0, ...)], xs_ys4[(1, ...)])\n    assert sls4.equals_exact(els4, 1e-06)", "ground_truth": ["(- 45.0)", "-45.0"], "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransformOpsTestCase"}
{"task_id": "shapely_431", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_affinity.py", "testname": "test_affinity.py", "funcname": "test_skew_xs_ys_array", "imports": ["import unittest", "from math import pi", "import numpy as np", "import pytest", "from shapely import affinity", "from shapely.geometry import Point", "from shapely.wkt import loads as load_wkt"], "code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(0 0 0, 0 -100 0, -100 -100 0)')\n    els = load_wkt('LINESTRING (0.0 0.0, 0.0 -100.0, -100.0 -100.0)')\n    xs_ys = np.array([0.0, 0.0])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 0.0)\n    assert (xs_ys[1] == 0.0)\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys2 = np.array([30.0, (- 45.0)])\n    els2 = load_wkt('LINESTRING (28.867513459481287 -50, -28.867513459481287 -150, -128.8675134594813 -50)')\n    sls2 = affinity.skew(ls, xs_ys2[(0, ...)], xs_ys2[(1, ...)])\n    assert (xs_ys2[0] == 30.0)\n    assert (xs_ys2[1] == (- 45.0))\n    assert sls2.equals_exact(els2, 1e-06)\n    xs_ys3 = np.array([(pi / 4), ((- pi) / 2)])\n    els3 = load_wkt('LINESTRING Z (50 -816561967659768400 0, -50 -816561967659768600 0, -150 816561967659768500 0)')\n    sls3 = affinity.skew(ls, xs_ys3[(0, ...)], xs_ys3[(1, ...)], use_radians=True)\n    assert (xs_ys3[0] == (pi / 4))\n    assert (xs_ys3[1] == ((- pi) / 2))\n    assert sls3.equals_exact(els3, 1e-06)\n    xs_ys4 = np.array([180.0, 0.0])\n    els4 = load_wkt('LINESTRING Z (0 0 0, 0 -100 0, -100 -100 0)')\n    sls4 = affinity.skew(ls, xs_ys4[(0, ...)], xs_ys4[(1, ...)])\n    assert sls4.equals_exact(els4, 1e-06)", "masked_code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(0 0 0, 0 -100 0, -100 -100 0)')\n    els = load_wkt('LINESTRING (0.0 0.0, 0.0 -100.0, -100.0 -100.0)')\n    xs_ys = np.array([0.0, 0.0])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 0.0)\n    assert (xs_ys[1] == 0.0)\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys2 = np.array([30.0, (- 45.0)])\n    els2 = load_wkt('LINESTRING (28.867513459481287 -50, -28.867513459481287 -150, -128.8675134594813 -50)')\n    sls2 = affinity.skew(ls, xs_ys2[(0, ...)], xs_ys2[(1, ...)])\n    assert (xs_ys2[0] == 30.0)\n    assert (xs_ys2[1] == (- 45.0))\n    assert sls2.equals_exact(els2, 1e-06)\n    xs_ys3 = np.array([(pi / 4), ((- pi) / 2)])\n    els3 = load_wkt('LINESTRING Z (50 -816561967659768400 0, -50 -816561967659768600 0, -150 816561967659768500 0)')\n    sls3 = affinity.skew(ls, xs_ys3[(0, ...)], xs_ys3[(1, ...)], use_radians=True)\n    assert (xs_ys3[0] == '???')\n    assert (xs_ys3[1] == ((- pi) / 2))\n    assert sls3.equals_exact(els3, 1e-06)\n    xs_ys4 = np.array([180.0, 0.0])\n    els4 = load_wkt('LINESTRING Z (0 0 0, 0 -100 0, -100 -100 0)')\n    sls4 = affinity.skew(ls, xs_ys4[(0, ...)], xs_ys4[(1, ...)])\n    assert sls4.equals_exact(els4, 1e-06)", "ground_truth": ["(pi / 4)", "0.7853981633974483"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransformOpsTestCase"}
{"task_id": "shapely_432", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_affinity.py", "testname": "test_affinity.py", "funcname": "test_skew_xs_ys_array", "imports": ["import unittest", "from math import pi", "import numpy as np", "import pytest", "from shapely import affinity", "from shapely.geometry import Point", "from shapely.wkt import loads as load_wkt"], "code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(0 0 0, 0 -100 0, -100 -100 0)')\n    els = load_wkt('LINESTRING (0.0 0.0, 0.0 -100.0, -100.0 -100.0)')\n    xs_ys = np.array([0.0, 0.0])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 0.0)\n    assert (xs_ys[1] == 0.0)\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys2 = np.array([30.0, (- 45.0)])\n    els2 = load_wkt('LINESTRING (28.867513459481287 -50, -28.867513459481287 -150, -128.8675134594813 -50)')\n    sls2 = affinity.skew(ls, xs_ys2[(0, ...)], xs_ys2[(1, ...)])\n    assert (xs_ys2[0] == 30.0)\n    assert (xs_ys2[1] == (- 45.0))\n    assert sls2.equals_exact(els2, 1e-06)\n    xs_ys3 = np.array([(pi / 4), ((- pi) / 2)])\n    els3 = load_wkt('LINESTRING Z (50 -816561967659768400 0, -50 -816561967659768600 0, -150 816561967659768500 0)')\n    sls3 = affinity.skew(ls, xs_ys3[(0, ...)], xs_ys3[(1, ...)], use_radians=True)\n    assert (xs_ys3[0] == (pi / 4))\n    assert (xs_ys3[1] == ((- pi) / 2))\n    assert sls3.equals_exact(els3, 1e-06)\n    xs_ys4 = np.array([180.0, 0.0])\n    els4 = load_wkt('LINESTRING Z (0 0 0, 0 -100 0, -100 -100 0)')\n    sls4 = affinity.skew(ls, xs_ys4[(0, ...)], xs_ys4[(1, ...)])\n    assert sls4.equals_exact(els4, 1e-06)", "masked_code": "def test_skew_xs_ys_array(self):\n    ls = load_wkt('LINESTRING(0 0 0, 0 -100 0, -100 -100 0)')\n    els = load_wkt('LINESTRING (0.0 0.0, 0.0 -100.0, -100.0 -100.0)')\n    xs_ys = np.array([0.0, 0.0])\n    sls = affinity.skew(ls, xs_ys[(0, ...)], xs_ys[(1, ...)])\n    assert (xs_ys[0] == 0.0)\n    assert (xs_ys[1] == 0.0)\n    assert sls.equals_exact(els, 1e-06)\n    xs_ys2 = np.array([30.0, (- 45.0)])\n    els2 = load_wkt('LINESTRING (28.867513459481287 -50, -28.867513459481287 -150, -128.8675134594813 -50)')\n    sls2 = affinity.skew(ls, xs_ys2[(0, ...)], xs_ys2[(1, ...)])\n    assert (xs_ys2[0] == 30.0)\n    assert (xs_ys2[1] == (- 45.0))\n    assert sls2.equals_exact(els2, 1e-06)\n    xs_ys3 = np.array([(pi / 4), ((- pi) / 2)])\n    els3 = load_wkt('LINESTRING Z (50 -816561967659768400 0, -50 -816561967659768600 0, -150 816561967659768500 0)')\n    sls3 = affinity.skew(ls, xs_ys3[(0, ...)], xs_ys3[(1, ...)], use_radians=True)\n    assert (xs_ys3[0] == (pi / 4))\n    assert (xs_ys3[1] == '???')\n    assert sls3.equals_exact(els3, 1e-06)\n    xs_ys4 = np.array([180.0, 0.0])\n    els4 = load_wkt('LINESTRING Z (0 0 0, 0 -100 0, -100 -100 0)')\n    sls4 = affinity.skew(ls, xs_ys4[(0, ...)], xs_ys4[(1, ...)])\n    assert sls4.equals_exact(els4, 1e-06)", "ground_truth": ["((- pi) / 2)", "-1.5707963267948966"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransformOpsTestCase"}
{"task_id": "shapely_433", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_box.py", "testname": "test_box.py", "funcname": "test_ccw", "imports": ["import unittest", "from shapely import geometry"], "code": "def test_ccw(self):\n    b = geometry.box((- 2.0), (- 3.5), 4.5, 7.25, ccw=True)\n    assert (b.exterior.coords[0] == (4.5, (- 3.5)))\n    assert (b.exterior.coords[1] == (4.5, 7.25))", "masked_code": "def test_ccw(self):\n    b = geometry.box((- 2.0), (- 3.5), 4.5, 7.25, ccw=True)\n    assert (b.exterior.coords[0] == '???')\n    assert (b.exterior.coords[1] == (4.5, 7.25))", "ground_truth": ["(4.5, (- 3.5))", "(4.5, -3.5)"], "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "BoxTestCase"}
{"task_id": "shapely_434", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_box.py", "testname": "test_box.py", "funcname": "test_ccw", "imports": ["import unittest", "from shapely import geometry"], "code": "def test_ccw(self):\n    b = geometry.box((- 2.0), (- 3.5), 4.5, 7.25, ccw=True)\n    assert (b.exterior.coords[0] == (4.5, (- 3.5)))\n    assert (b.exterior.coords[1] == (4.5, 7.25))", "masked_code": "def test_ccw(self):\n    b = geometry.box((- 2.0), (- 3.5), 4.5, 7.25, ccw=True)\n    assert (b.exterior.coords[0] == (4.5, (- 3.5)))\n    assert (b.exterior.coords[1] == '???')", "ground_truth": ["(4.5, 7.25)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "BoxTestCase"}
{"task_id": "shapely_435", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_box.py", "testname": "test_box.py", "funcname": "test_ccw_default", "imports": ["import unittest", "from shapely import geometry"], "code": "def test_ccw_default(self):\n    b = geometry.box(1000, 2000, 10000, 15000)\n    assert (b.exterior.coords[0] == (10000.0, 2000.0))\n    assert (b.exterior.coords[1] == (10000.0, 15000.0))", "masked_code": "def test_ccw_default(self):\n    b = geometry.box(1000, 2000, 10000, 15000)\n    assert (b.exterior.coords[0] == '???')\n    assert (b.exterior.coords[1] == (10000.0, 15000.0))", "ground_truth": ["(10000.0, 2000.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "BoxTestCase"}
{"task_id": "shapely_436", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_box.py", "testname": "test_box.py", "funcname": "test_ccw_default", "imports": ["import unittest", "from shapely import geometry"], "code": "def test_ccw_default(self):\n    b = geometry.box(1000, 2000, 10000, 15000)\n    assert (b.exterior.coords[0] == (10000.0, 2000.0))\n    assert (b.exterior.coords[1] == (10000.0, 15000.0))", "masked_code": "def test_ccw_default(self):\n    b = geometry.box(1000, 2000, 10000, 15000)\n    assert (b.exterior.coords[0] == (10000.0, 2000.0))\n    assert (b.exterior.coords[1] == '???')", "ground_truth": ["(10000.0, 15000.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "BoxTestCase"}
{"task_id": "shapely_437", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_box.py", "testname": "test_box.py", "funcname": "test_cw", "imports": ["import unittest", "from shapely import geometry"], "code": "def test_cw(self):\n    b = geometry.box(5.0, (- 10.0), 5.0, 5.0, ccw=False)\n    assert (b.exterior.coords[0] == (5.0, (- 10.0)))\n    assert (b.exterior.coords[1] == (5.0, 5.0))", "masked_code": "def test_cw(self):\n    b = geometry.box(5.0, (- 10.0), 5.0, 5.0, ccw=False)\n    assert (b.exterior.coords[0] == '???')\n    assert (b.exterior.coords[1] == (5.0, 5.0))", "ground_truth": ["(5.0, (- 10.0))"], "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "BoxTestCase"}
{"task_id": "shapely_438", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_box.py", "testname": "test_box.py", "funcname": "test_cw", "imports": ["import unittest", "from shapely import geometry"], "code": "def test_cw(self):\n    b = geometry.box(5.0, (- 10.0), 5.0, 5.0, ccw=False)\n    assert (b.exterior.coords[0] == (5.0, (- 10.0)))\n    assert (b.exterior.coords[1] == (5.0, 5.0))", "masked_code": "def test_cw(self):\n    b = geometry.box(5.0, (- 10.0), 5.0, 5.0, ccw=False)\n    assert (b.exterior.coords[0] == (5.0, (- 10.0)))\n    assert (b.exterior.coords[1] == '???')", "ground_truth": ["(5.0, 5.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "BoxTestCase"}
{"task_id": "shapely_469", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_cga.py", "testname": "test_cga.py", "funcname": "test_square", "imports": ["import unittest", "import pytest", "from shapely.geometry.polygon import LinearRing, Polygon, orient, signed_area"], "code": "def test_square(self):\n    (xmin, xmax) = ((- 1000.5), 2000.75)\n    (ymin, ymax) = ((- 5000.25), 9000.125)\n    rect = LinearRing([(xmin, ymin), (xmax, ymin), (xmax, ymax), (xmin, ymax), (xmin, ymin)])\n    expected_area = ((2000.75 - (- 1000.5)) * (9000.125 - (- 5000.25)))\n    assert (signed_area(rect) == pytest.approx(expected_area))", "masked_code": "def test_square(self):\n    (xmin, xmax) = ((- 1000.5), 2000.75)\n    (ymin, ymax) = ((- 5000.25), 9000.125)\n    rect = LinearRing([(xmin, ymin), (xmax, ymin), (xmax, ymax), (xmin, ymax), (xmin, ymin)])\n    expected_area = ((2000.75 - (- 1000.5)) * (9000.125 - (- 5000.25)))\n    assert (signed_area(rect) == '???')", "ground_truth": ["42018625.46875", "pytest.approx(expected_area)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "SignedAreaTestCase"}
{"task_id": "shapely_468", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_cga.py", "testname": "test_cga.py", "funcname": "test_triangle", "imports": ["import unittest", "import pytest", "from shapely.geometry.polygon import LinearRing, Polygon, orient, signed_area"], "code": "def test_triangle(self):\n    tri = LinearRing([(0, 0), (10, 0), (20, 0)])\n    assert (signed_area(tri) == pytest.approx(0.0))", "masked_code": "def test_triangle(self):\n    tri = LinearRing([(0, 0), (10, 0), (20, 0)])\n    assert (signed_area(tri) == '???')", "ground_truth": ["0", "0.0", "pytest.approx(0.0)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "SignedAreaTestCase"}
{"task_id": "shapely_474", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_line_inside", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_line_inside():\n    'Line inside (augmented: float/negative coordinates inside the rectangle)'\n    geom1 = load_wkt('LINESTRING (-1.1 -2.2, 0.3 -0.4)')\n    geom2 = clip_by_rect(geom1, (- 2), (- 3), 1, 1)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'LINESTRING (-1 -2, 0 -0)')", "masked_code": "def test_line_inside():\n    'Line inside (augmented: float/negative coordinates inside the rectangle)'\n    geom1 = load_wkt('LINESTRING (-1.1 -2.2, 0.3 -0.4)')\n    geom2 = clip_by_rect(geom1, (- 2), (- 3), 1, 1)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'LINESTRING (-1 -2, 0 -0)'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_475", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_line_on_boundary", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_line_on_boundary():\n    'Line on boundary (augmented: horizontal along max y boundary)'\n    geom1 = load_wkt('LINESTRING (0 50, 10 50, 20 50)')\n    geom2 = clip_by_rect(geom1, 0, 0, 20, 50)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY')", "masked_code": "def test_line_on_boundary():\n    'Line on boundary (augmented: horizontal along max y boundary)'\n    geom1 = load_wkt('LINESTRING (0 50, 10 50, 20 50)')\n    geom2 = clip_by_rect(geom1, 0, 0, 20, 50)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'GEOMETRYCOLLECTION EMPTY'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_473", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_line_outside", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_line_outside():\n    'Line outside (augmented: vertical line completely out on the right, negative/positive)'\n    geom1 = load_wkt('LINESTRING (1000 1000, 2000 3000)')\n    geom2 = clip_by_rect(geom1, (- 100), (- 100), 100, 100)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY')", "masked_code": "def test_line_outside():\n    'Line outside (augmented: vertical line completely out on the right, negative/positive)'\n    geom1 = load_wkt('LINESTRING (1000 1000, 2000 3000)')\n    geom2 = clip_by_rect(geom1, (- 100), (- 100), 100, 100)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'GEOMETRYCOLLECTION EMPTY'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_476", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_line_splitting_rectangle", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_line_splitting_rectangle():\n    'Line splitting rectangle (augmented: line starts before and ends after rectangle, partly inside)'\n    geom1 = load_wkt('LINESTRING (-5 -5, 10 10, 25 25)')\n    geom2 = clip_by_rect(geom1, 0, 0, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'LINESTRING (0 0, 10 10, 20 20)')", "masked_code": "def test_line_splitting_rectangle():\n    'Line splitting rectangle (augmented: line starts before and ends after rectangle, partly inside)'\n    geom1 = load_wkt('LINESTRING (-5 -5, 10 10, 25 25)')\n    geom2 = clip_by_rect(geom1, 0, 0, 20, 20)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'LINESTRING (0 0, 10 10, 20 20)'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_471", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_point_inside", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_point_inside():\n    'Point inside (augmented for a large floating point)'\n    geom1 = load_wkt('POINT (250.9999 123.0001)')\n    geom2 = clip_by_rect(geom1, 200, 100, 300, 200)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'POINT (251 123)')", "masked_code": "def test_point_inside():\n    'Point inside (augmented for a large floating point)'\n    geom1 = load_wkt('POINT (250.9999 123.0001)')\n    geom2 = clip_by_rect(geom1, 200, 100, 300, 200)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'POINT (251 123)'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_472", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_point_on_boundary", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_point_on_boundary():\n    'Point on boundary (augmented: lower-left corner of rect boundary with negative numbers)'\n    geom1 = load_wkt('POINT (-10 -10)')\n    geom2 = clip_by_rect(geom1, (- 10), (- 10), 10, 10)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY')", "masked_code": "def test_point_on_boundary():\n    'Point on boundary (augmented: lower-left corner of rect boundary with negative numbers)'\n    geom1 = load_wkt('POINT (-10 -10)')\n    geom2 = clip_by_rect(geom1, (- 10), (- 10), 10, 10)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'GEOMETRYCOLLECTION EMPTY'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_470", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_point_outside", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "def test_point_outside():\n    'Point outside (augmented for larger and negative coordinates)'\n    geom1 = load_wkt('POINT (-1000.5 99999.5)')\n    geom2 = clip_by_rect(geom1, 0, 0, 500, 500)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY')", "masked_code": "def test_point_outside():\n    'Point outside (augmented for larger and negative coordinates)'\n    geom1 = load_wkt('POINT (-1000.5 99999.5)')\n    geom2 = clip_by_rect(geom1, 0, 0, 500, 500)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'GEOMETRYCOLLECTION EMPTY'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_478", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_polygon_shell_cc_fully_on_rectangle_boundary", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "@pytest.mark.xfail(reason='TODO issue to CW')\ndef test_polygon_shell_cc_fully_on_rectangle_boundary():\n    'Polygon shell (CW) fully on rectangle boundary, augmented with large square, reversed order'\n    geom1 = load_wkt('POLYGON ((-50 -50, -50 100, 100 100, 100 -50, -50 -50))')\n    geom2 = clip_by_rect(geom1, (- 50), (- 50), 100, 100)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'POLYGON ((-50 -50, 100 -50, 100 100, -50 100, -50 -50))')", "masked_code": "@pytest.mark.xfail(reason='TODO issue to CW')\ndef test_polygon_shell_cc_fully_on_rectangle_boundary():\n    'Polygon shell (CW) fully on rectangle boundary, augmented with large square, reversed order'\n    geom1 = load_wkt('POLYGON ((-50 -50, -50 100, 100 100, 100 -50, -50 -50))')\n    geom2 = clip_by_rect(geom1, (- 50), (- 50), 100, 100)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'POLYGON ((-50 -50, 100 -50, 100 100, -50 100, -50 -50))'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_477", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_clip_by_rect.py", "testname": "test_clip_by_rect.py", "funcname": "test_polygon_shell_ccw_fully_on_rectangle_boundary", "imports": ["import pytest", "from shapely.ops import clip_by_rect", "from shapely.wkt import dumps as dump_wkt, loads as load_wkt"], "code": "@pytest.mark.xfail(reason='TODO issue to CCW')\ndef test_polygon_shell_ccw_fully_on_rectangle_boundary():\n    'Polygon shell (CCW) fully on rectangle boundary, augmented with larger square'\n    geom1 = load_wkt('POLYGON ((-50 -50, 100 -50, 100 100, -50 100, -50 -50))')\n    geom2 = clip_by_rect(geom1, (- 50), (- 50), 100, 100)\n    assert (dump_wkt(geom2, rounding_precision=0) == 'POLYGON ((-50 -50, 100 -50, 100 100, -50 100, -50 -50))')", "masked_code": "@pytest.mark.xfail(reason='TODO issue to CCW')\ndef test_polygon_shell_ccw_fully_on_rectangle_boundary():\n    'Polygon shell (CCW) fully on rectangle boundary, augmented with larger square'\n    geom1 = load_wkt('POLYGON ((-50 -50, 100 -50, 100 100, -50 100, -50 -50))')\n    geom2 = clip_by_rect(geom1, (- 50), (- 50), 100, 100)\n    assert (dump_wkt(geom2, rounding_precision=0) == '???')", "ground_truth": ["'POLYGON ((-50 -50, 100 -50, 100 100, -50 100, -50 -50))'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_232", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_empty", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "@pytest.mark.parametrize('geom', [GeometryCollection(), GeometryCollection([]), shape({'type': 'GeometryCollection', 'geometries': []}), wkt.loads('GEOMETRYCOLLECTION EMPTY'), GeometryCollection(np.array([]))])\ndef test_empty(geom):\n    assert (geom.geom_type == 'GeometryCollection')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    assert (list(geom.geoms) == [])", "masked_code": "@pytest.mark.parametrize('geom', [GeometryCollection(), GeometryCollection([]), shape({'type': 'GeometryCollection', 'geometries': []}), wkt.loads('GEOMETRYCOLLECTION EMPTY'), GeometryCollection(np.array([]))])\ndef test_empty(geom):\n    assert (geom.geom_type == '???')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    assert (list(geom.geoms) == [])", "ground_truth": ["'GeometryCollection'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_233", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_empty", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "@pytest.mark.parametrize('geom', [GeometryCollection(), GeometryCollection([]), shape({'type': 'GeometryCollection', 'geometries': []}), wkt.loads('GEOMETRYCOLLECTION EMPTY'), GeometryCollection(np.array([]))])\ndef test_empty(geom):\n    assert (geom.geom_type == 'GeometryCollection')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    assert (list(geom.geoms) == [])", "masked_code": "@pytest.mark.parametrize('geom', [GeometryCollection(), GeometryCollection([]), shape({'type': 'GeometryCollection', 'geometries': []}), wkt.loads('GEOMETRYCOLLECTION EMPTY'), GeometryCollection(np.array([]))])\ndef test_empty(geom):\n    assert (geom.geom_type == 'GeometryCollection')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    assert (list(geom.geoms) == '???')", "ground_truth": ["[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_234", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_empty_subgeoms", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "def test_empty_subgeoms():\n    from shapely.geometry import MultiPoint, Polygon\n    geom = GeometryCollection([Point(), LineString(), MultiPoint(), Polygon()])\n    assert (geom.geom_type == 'GeometryCollection')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 4)\n    assert (list(geom.geoms) == [Point(), LineString(), MultiPoint(), Polygon()])", "masked_code": "def test_empty_subgeoms():\n    from shapely.geometry import MultiPoint, Polygon\n    geom = GeometryCollection([Point(), LineString(), MultiPoint(), Polygon()])\n    assert (geom.geom_type == '???')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 4)\n    assert (list(geom.geoms) == [Point(), LineString(), MultiPoint(), Polygon()])", "ground_truth": ["'GeometryCollection'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_235", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_empty_subgeoms", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "def test_empty_subgeoms():\n    from shapely.geometry import MultiPoint, Polygon\n    geom = GeometryCollection([Point(), LineString(), MultiPoint(), Polygon()])\n    assert (geom.geom_type == 'GeometryCollection')\n    assert geom.is_empty\n    assert (len(geom.geoms) == 4)\n    assert (list(geom.geoms) == [Point(), LineString(), MultiPoint(), Polygon()])", "masked_code": "def test_empty_subgeoms():\n    from shapely.geometry import MultiPoint, Polygon\n    geom = GeometryCollection([Point(), LineString(), MultiPoint(), Polygon()])\n    assert (geom.geom_type == 'GeometryCollection')\n    assert geom.is_empty\n    assert (len(geom.geoms) == '???')\n    assert (list(geom.geoms) == [Point(), LineString(), MultiPoint(), Polygon()])", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_236", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_from_geojson", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "def test_from_geojson(geometrycollection_geojson):\n    geom = shape(geometrycollection_geojson)\n    assert (geom.geom_type == 'GeometryCollection')\n    assert (len(geom.geoms) == 3)\n    geom_types = [g.geom_type for g in geom.geoms]\n    assert ('Point' in geom_types)\n    assert ('LineString' in geom_types)\n    assert ('Polygon' in geom_types)", "masked_code": "def test_from_geojson(geometrycollection_geojson):\n    geom = shape(geometrycollection_geojson)\n    assert (geom.geom_type == '???')\n    assert (len(geom.geoms) == 3)\n    geom_types = [g.geom_type for g in geom.geoms]\n    assert ('Point' in geom_types)\n    assert ('LineString' in geom_types)\n    assert ('Polygon' in geom_types)", "ground_truth": ["'GeometryCollection'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_237", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_geointerface", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "def test_geointerface(geometrycollection_geojson):\n    geom = shape(geometrycollection_geojson)\n    assert (geom.__geo_interface__ == geometrycollection_geojson)", "masked_code": "def test_geointerface(geometrycollection_geojson):\n    geom = shape(geometrycollection_geojson)\n    assert (geom.__geo_interface__ == '???')", "ground_truth": ["geometrycollection_geojson", "{'type': 'GeometryCollection', 'geometries': [{'type': 'Point', 'coordinates': [10000000000.0, -10000000000.0, 9999]}, {'type': 'LineString', 'coordinates': [[-1000, 0], [-500.5, -200.2], [0, 0]]}, {'type': 'Polygon', 'coordinates': [[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]]}]}"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_238", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_collection.py", "testname": "test_collection.py", "funcname": "test_numpy_object_array", "imports": ["import numpy as np", "import pytest", "from shapely import GeometryCollection, LineString, Point, wkt", "from shapely.geometry import shape"], "code": "def test_numpy_object_array():\n    complex_geom = GeometryCollection([LineString([(0, 0), (10000000000.0, (- 10000000000.0))]), Point(42, (- 42)), LineString([(3.3, 3.3), (4.4, 4.4)])])\n    ar = np.empty(1, object)\n    ar[:] = [complex_geom]\n    assert (ar[0] == complex_geom)", "masked_code": "def test_numpy_object_array():\n    complex_geom = GeometryCollection([LineString([(0, 0), (10000000000.0, (- 10000000000.0))]), Point(42, (- 42)), LineString([(3.3, 3.3), (4.4, 4.4)])])\n    ar = np.empty(1, object)\n    ar[:] = [complex_geom]\n    assert (ar[0] == '???')", "ground_truth": ["<GEOMETRYCOLLECTION (LINESTRING (0 0, 10000000000 -10000000000), POINT (42 -...>", "complex_geom"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_10", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_clip_by_rect_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', [LineString([(2, 2), (5, 8)]), Point(0, 0), empty])\ndef test_clip_by_rect_array(geometry):\n    if (geometry.is_empty and (shapely.get_type_id(geometry) == shapely.GeometryType.POINT) and ((geos_version < (3, 10, 6)) or ((3, 11, 0) <= geos_version < (3, 11, 3)))):\n        with pytest.raises(GEOSException):\n            shapely.clip_by_rect([geometry, geometry], 1.0, 2.0, 3.0, 4.0)\n        return\n    actual = shapely.clip_by_rect([geometry, geometry], 1.0, 2.0, 3.0, 4.0)\n    assert (actual.shape == (2,))\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))", "masked_code": "@pytest.mark.parametrize('geometry', [LineString([(2, 2), (5, 8)]), Point(0, 0), empty])\ndef test_clip_by_rect_array(geometry):\n    if (geometry.is_empty and (shapely.get_type_id(geometry) == shapely.GeometryType.POINT) and ((geos_version < (3, 10, 6)) or ((3, 11, 0) <= geos_version < (3, 11, 3)))):\n        with pytest.raises(GEOSException):\n            shapely.clip_by_rect([geometry, geometry], 1.0, 2.0, 3.0, 4.0)\n        return\n    actual = shapely.clip_by_rect([geometry, geometry], 1.0, 2.0, 3.0, 4.0)\n    assert (actual.shape == '???')\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_1", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_float_arg_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', [LineString([(0, 0), (10000000000.0, 10000000000.0)]), MultiPoint([(100000.0, (- 100000.0)), ((- 1000000000.0), 1000000000.0)])])\n@pytest.mark.parametrize('func', CONSTRUCTIVE_FLOAT_ARG)\ndef test_float_arg_array(geometry, func):\n    if ((func is shapely.offset_curve) and (shapely.get_type_id(geometry) not in [1, 2]) and (shapely.geos_version < (3, 11, 0))):\n        with pytest.raises(GEOSException, match='only accept linestrings'):\n            func([geometry, geometry], 0.0)\n        return\n    with ignore_invalid(((func is shapely.voronoi_polygons) and (shapely.get_type_id(geometry) == 0) and (shapely.geos_version < (3, 12, 0)))):\n        actual = func([geometry, geometry], 0.0)\n    assert (actual.shape == (2,))\n    assert isinstance(actual[0], Geometry)", "masked_code": "@pytest.mark.parametrize('geometry', [LineString([(0, 0), (10000000000.0, 10000000000.0)]), MultiPoint([(100000.0, (- 100000.0)), ((- 1000000000.0), 1000000000.0)])])\n@pytest.mark.parametrize('func', CONSTRUCTIVE_FLOAT_ARG)\ndef test_float_arg_array(geometry, func):\n    if ((func is shapely.offset_curve) and (shapely.get_type_id(geometry) not in [1, 2]) and (shapely.geos_version < (3, 11, 0))):\n        with pytest.raises(GEOSException, match='only accept linestrings'):\n            func([geometry, geometry], 0.0)\n        return\n    with ignore_invalid(((func is shapely.voronoi_polygons) and (shapely.get_type_id(geometry) == 0) and (shapely.geos_version < (3, 12, 0)))):\n        actual = func([geometry, geometry], 0.0)\n    assert (actual.shape == '???')\n    assert isinstance(actual[0], Geometry)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_3", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_make_valid", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geom,expected', [(LineString([(5.5, 5.5), (1.2, 7.8)]), LineString([(1.2, 7.8), (5.5, 5.5)])), (Polygon([(10, 10), (30, 30), (30, 10), (10, 30), (10, 10)]), MultiPolygon([Polygon([(20, 20), (30, 30), (30, 10), (20, 20)]), Polygon([(10, 10), (10, 30), (20, 20), (10, 10)])])), (empty, empty), ([empty], [empty])])\ndef test_make_valid(geom, expected):\n    actual = shapely.make_valid(geom)\n    assert (actual is not expected)\n    if (isinstance(geom, Polygon) and geom.equals(Polygon([(10, 10), (30, 30), (30, 10), (10, 30), (10, 10)]))):\n        expected = MultiPolygon([Polygon([(20, 20), (30, 30), (30, 10), (20, 20)]), Polygon([(10, 10), (10, 30), (20, 20), (10, 10)])])\n    assert (shapely.normalize(actual) == expected)", "masked_code": "@pytest.mark.parametrize('geom,expected', [(LineString([(5.5, 5.5), (1.2, 7.8)]), LineString([(1.2, 7.8), (5.5, 5.5)])), (Polygon([(10, 10), (30, 30), (30, 10), (10, 30), (10, 10)]), MultiPolygon([Polygon([(20, 20), (30, 30), (30, 10), (20, 20)]), Polygon([(10, 10), (10, 30), (20, 20), (10, 10)])])), (empty, empty), ([empty], [empty])])\ndef test_make_valid(geom, expected):\n    actual = shapely.make_valid(geom)\n    assert (actual is not expected)\n    if (isinstance(geom, Polygon) and geom.equals(Polygon([(10, 10), (30, 30), (30, 10), (10, 30), (10, 10)]))):\n        expected = MultiPolygon([Polygon([(20, 20), (30, 30), (30, 10), (20, 20)]), Polygon([(10, 10), (10, 30), (20, 20), (10, 10)])])\n    assert (shapely.normalize(actual) == '???')", "ground_truth": ["<LINESTRING (1.2 7.8, 5.5 5.5)>", "expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_4", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_make_valid_structure", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geom,expected', [(LineString([(5.5, 5.5), (1.2, 7.8)]), LineString([(1.2, 7.8), (5.5, 5.5)])), (Polygon([(2, 0), (2, 1), (2, 2), (2, 0)]), LineString([(2, 0), (2, 1), (2, 2), (2, 0)])), (Polygon([(0, 0), ((- 2), (- 2)), ((- 2), 0), (0, (- 2)), (0, 0)]), MultiPolygon([Polygon([((- 1), (- 1)), (0, 0), (0, (- 2)), ((- 1), (- 1))]), Polygon([((- 2), (- 2)), ((- 2), 0), ((- 1), (- 1)), ((- 2), (- 2))])])), (empty, empty), ([empty], [empty])])\ndef test_make_valid_structure(geom, expected):\n    actual = shapely.make_valid(geom, method='structure')\n    assert (actual is not expected)\n    assert (shapely.normalize(actual) == expected)", "masked_code": "@pytest.mark.parametrize('geom,expected', [(LineString([(5.5, 5.5), (1.2, 7.8)]), LineString([(1.2, 7.8), (5.5, 5.5)])), (Polygon([(2, 0), (2, 1), (2, 2), (2, 0)]), LineString([(2, 0), (2, 1), (2, 2), (2, 0)])), (Polygon([(0, 0), ((- 2), (- 2)), ((- 2), 0), (0, (- 2)), (0, 0)]), MultiPolygon([Polygon([((- 1), (- 1)), (0, 0), (0, (- 2)), ((- 1), (- 1))]), Polygon([((- 2), (- 2)), ((- 2), 0), ((- 1), (- 1)), ((- 2), (- 2))])])), (empty, empty), ([empty], [empty])])\ndef test_make_valid_structure(geom, expected):\n    actual = shapely.make_valid(geom, method='structure')\n    assert (actual is not expected)\n    assert (shapely.normalize(actual) == '???')", "ground_truth": ["<LINESTRING (1.2 7.8, 5.5 5.5)>", "expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_38", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_maximum_inscribed_circle_all_types", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', [MultiPolygon([Polygon([(1, 1), (10, 1), (5.5, 11), (1, 1)]), Polygon([(20, 20), (30, 20), (25, 35), (20, 20)])]), MultiPoint([(10000.0, 10000.0), ((- 10000.0), 10000.0), (0, 0)])])\ndef test_maximum_inscribed_circle_all_types(geometry):\n    if (shapely.get_type_id(geometry) not in [3, 6]):\n        with pytest.raises(GEOSException, match='Argument must be Polygonal or LinearRing|must be a Polygon or MultiPolygon|Operation not supported by GeometryCollection'):\n            shapely.maximum_inscribed_circle(geometry)\n        return\n    if geometry.is_empty:\n        with pytest.raises(GEOSException, match='Empty input(?: geometry)? is not supported'):\n            shapely.maximum_inscribed_circle(geometry)\n        return\n    actual = shapely.maximum_inscribed_circle([geometry, geometry])\n    assert (actual.shape == (2,))\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))\n    actual = shapely.maximum_inscribed_circle(None)\n    assert (actual is None)", "masked_code": "@pytest.mark.parametrize('geometry', [MultiPolygon([Polygon([(1, 1), (10, 1), (5.5, 11), (1, 1)]), Polygon([(20, 20), (30, 20), (25, 35), (20, 20)])]), MultiPoint([(10000.0, 10000.0), ((- 10000.0), 10000.0), (0, 0)])])\ndef test_maximum_inscribed_circle_all_types(geometry):\n    if (shapely.get_type_id(geometry) not in [3, 6]):\n        with pytest.raises(GEOSException, match='Argument must be Polygonal or LinearRing|must be a Polygon or MultiPolygon|Operation not supported by GeometryCollection'):\n            shapely.maximum_inscribed_circle(geometry)\n        return\n    if geometry.is_empty:\n        with pytest.raises(GEOSException, match='Empty input(?: geometry)? is not supported'):\n            shapely.maximum_inscribed_circle(geometry)\n        return\n    actual = shapely.maximum_inscribed_circle([geometry, geometry])\n    assert (actual.shape == '???')\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))\n    actual = shapely.maximum_inscribed_circle(None)\n    assert (actual is None)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_36", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_minimum_bounding_circle_all_types", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', [MultiPolygon([Polygon([(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)]), Polygon([(20, 20), (30, 20), (30, 30), (20, 30), (20, 20)])]), Point(42, 42)])\ndef test_minimum_bounding_circle_all_types(geometry):\n    actual = shapely.minimum_bounding_circle([geometry, geometry])\n    assert (actual.shape == (2,))\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))\n    actual = shapely.minimum_bounding_circle(None)\n    assert (actual is None)", "masked_code": "@pytest.mark.parametrize('geometry', [MultiPolygon([Polygon([(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)]), Polygon([(20, 20), (30, 20), (30, 30), (20, 30), (20, 20)])]), Point(42, 42)])\ndef test_minimum_bounding_circle_all_types(geometry):\n    actual = shapely.minimum_bounding_circle([geometry, geometry])\n    assert (actual.shape == '???')\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))\n    actual = shapely.minimum_bounding_circle(None)\n    assert (actual is None)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_0", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_no_args_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', [Polygon([(1000, 1000), (1000, 1010), (1010, 1010), (1010, 1000), (1000, 1000)]), empty])\n@pytest.mark.parametrize('func', CONSTRUCTIVE_NO_ARGS)\ndef test_no_args_array(geometry, func):\n    if (geometry.is_empty and (shapely.get_num_geometries(geometry) > 0) and (func is shapely.node) and (geos_version < (3, 10, 3))):\n        pytest.xfail('GEOS < 3.10.3 crashes with empty geometries')\n    actual = func([geometry, geometry])\n    assert (actual.shape == (2,))\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))", "masked_code": "@pytest.mark.parametrize('geometry', [Polygon([(1000, 1000), (1000, 1010), (1010, 1010), (1010, 1000), (1000, 1000)]), empty])\n@pytest.mark.parametrize('func', CONSTRUCTIVE_NO_ARGS)\ndef test_no_args_array(geometry, func):\n    if (geometry.is_empty and (shapely.get_num_geometries(geometry) > 0) and (func is shapely.node) and (geos_version < (3, 10, 3))):\n        pytest.xfail('GEOS < 3.10.3 crashes with empty geometries')\n    actual = func([geometry, geometry])\n    assert (actual.shape == '???')\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_6", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_offset_curve_distance_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_offset_curve_distance_array():\n    result = shapely.offset_curve([line_string, line_string], [200.0, (- 200.0)])\n    assert (result[0] == shapely.offset_curve(line_string, 200.0))\n    assert (result[1] == shapely.offset_curve(line_string, (- 200.0)))", "masked_code": "def test_offset_curve_distance_array():\n    result = shapely.offset_curve([line_string, line_string], [200.0, (- 200.0)])\n    assert (result[0] == '???')\n    assert (result[1] == shapely.offset_curve(line_string, (- 200.0)))", "ground_truth": ["<LINESTRING Z EMPTY>", "shapely.offset_curve(line_string, 200.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_7", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_offset_curve_distance_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_offset_curve_distance_array():\n    result = shapely.offset_curve([line_string, line_string], [200.0, (- 200.0)])\n    assert (result[0] == shapely.offset_curve(line_string, 200.0))\n    assert (result[1] == shapely.offset_curve(line_string, (- 200.0)))", "masked_code": "def test_offset_curve_distance_array():\n    result = shapely.offset_curve([line_string, line_string], [200.0, (- 200.0)])\n    assert (result[0] == shapely.offset_curve(line_string, 200.0))\n    assert (result[1] == '???')", "ground_truth": ["<LINESTRING (201 1, 201 0, 197.157 -39.018, 185.776 -76.537, 167.294 -111.11...>", "shapely.offset_curve(line_string, (- 200.0))"], "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_40", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_orient_polygons", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_orient_polygons():\n    polygon = Polygon([(10, 10), (10, 30), (30, 30), (30, 10), (10, 10)], holes=[[(13, 13), (13, 17), (17, 17), (17, 13), (13, 13)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(10, 10), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == Point(10, 10))\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "masked_code": "def test_orient_polygons():\n    polygon = Polygon([(10, 10), (10, 30), (30, 30), (30, 10), (10, 10)], holes=[[(13, 13), (13, 17), (17, 17), (17, 13), (13, 13)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(10, 10), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == '???')\n    assert (result.geoms[0] == Point(10, 10))\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_41", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_orient_polygons", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_orient_polygons():\n    polygon = Polygon([(10, 10), (10, 30), (30, 30), (30, 10), (10, 10)], holes=[[(13, 13), (13, 17), (17, 17), (17, 13), (13, 13)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(10, 10), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == Point(10, 10))\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "masked_code": "def test_orient_polygons():\n    polygon = Polygon([(10, 10), (10, 30), (30, 30), (30, 10), (10, 10)], holes=[[(13, 13), (13, 17), (17, 17), (17, 13), (13, 13)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(10, 10), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == '???')\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "ground_truth": ["<POINT (10 10)>", "Point(10, 10)"], "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_42", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_orient_polygons", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_orient_polygons():\n    polygon = Polygon([(10, 10), (10, 30), (30, 30), (30, 10), (10, 10)], holes=[[(13, 13), (13, 17), (17, 17), (17, 13), (13, 13)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(10, 10), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == Point(10, 10))\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "masked_code": "def test_orient_polygons():\n    polygon = Polygon([(10, 10), (10, 30), (30, 30), (30, 10), (10, 10)], holes=[[(13, 13), (13, 17), (17, 17), (17, 13), (13, 13)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(10, 10), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == Point(10, 10))\n    assert (result.geoms[1] == '???')\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "ground_truth": ["<POLYGON ((10 10, 30 10, 30 30, 10 30, 10 10), (13 13, 13 17, 17 17, 17 13, ...>", "shapely.orient_polygons(polygon)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_43", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_orient_polygons", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_orient_polygons():\n    polygon = Polygon([(10, 10), (10, 30), (30, 30), (30, 10), (10, 10)], holes=[[(13, 13), (13, 17), (17, 17), (17, 13), (13, 13)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(10, 10), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == Point(10, 10))\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == shapely.orient_polygons(mp))", "masked_code": "def test_orient_polygons():\n    polygon = Polygon([(10, 10), (10, 30), (30, 30), (30, 10), (10, 10)], holes=[[(13, 13), (13, 17), (17, 17), (17, 13), (13, 13)]])\n    result = shapely.orient_polygons(polygon)\n    assert result.exterior.is_ccw\n    assert (not result.interiors[0].is_ccw)\n    result = shapely.orient_polygons(polygon, exterior_cw=True)\n    assert (not result.exterior.is_ccw)\n    assert result.interiors[0].is_ccw\n    mp = MultiPolygon([polygon, polygon])\n    result = shapely.orient_polygons(mp)\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert geom.exterior.is_ccw\n        assert (not geom.interiors[0].is_ccw)\n    result = shapely.orient_polygons([mp], exterior_cw=True)[0]\n    assert (len(result.geoms) == 2)\n    for geom in result.geoms:\n        assert (not geom.exterior.is_ccw)\n        assert geom.interiors[0].is_ccw\n    gc = GeometryCollection([Point(10, 10), polygon, mp])\n    result = shapely.orient_polygons(gc)\n    assert (len(result.geoms) == 3)\n    assert (result.geoms[0] == Point(10, 10))\n    assert (result.geoms[1] == shapely.orient_polygons(polygon))\n    assert (result.geoms[2] == '???')", "ground_truth": ["<MULTIPOLYGON (((10 10, 30 10, 30 30, 10 30, 10 10), (13 13, 13 17, 17 17, 1...>", "shapely.orient_polygons(mp)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_39", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_orient_polygons_all_types", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', [GeometryCollection([Polygon([(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)]), Point(5, 5)]), MultiPolygon([Polygon([(1, 1), (1, 5), (5, 1), (1, 1)])])])\ndef test_orient_polygons_all_types(geometry):\n    actual = shapely.orient_polygons([geometry, geometry])\n    assert (actual.shape == (2,))\n    assert isinstance(actual[0], Geometry)\n    actual = shapely.orient_polygons(None)\n    assert (actual is None)", "masked_code": "@pytest.mark.parametrize('geometry', [GeometryCollection([Polygon([(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)]), Point(5, 5)]), MultiPolygon([Polygon([(1, 1), (1, 5), (5, 1), (1, 1)])])])\ndef test_orient_polygons_all_types(geometry):\n    actual = shapely.orient_polygons([geometry, geometry])\n    assert (actual.shape == '???')\n    assert isinstance(actual[0], Geometry)\n    actual = shapely.orient_polygons(None)\n    assert (actual is None)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_44", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_orient_polygons_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_orient_polygons_array():\n    polygon = Polygon([(50, 50), (50, 60), (60, 60), (60, 50), (50, 50)], holes=[[(52, 52), (52, 54), (54, 54), (54, 52), (52, 52)]])\n    geometries = np.array(([([polygon] * 3)] * 2))\n    actual = shapely.orient_polygons(geometries)\n    assert isinstance(actual, np.ndarray)\n    assert (actual.shape == (2, 3))\n    expected = shapely.orient_polygons(polygon)\n    assert (actual == expected).all()", "masked_code": "def test_orient_polygons_array():\n    polygon = Polygon([(50, 50), (50, 60), (60, 60), (60, 50), (50, 50)], holes=[[(52, 52), (52, 54), (54, 54), (54, 52), (52, 52)]])\n    geometries = np.array(([([polygon] * 3)] * 2))\n    actual = shapely.orient_polygons(geometries)\n    assert isinstance(actual, np.ndarray)\n    assert (actual.shape == '???')\n    expected = shapely.orient_polygons(polygon)\n    assert (actual == expected).all()", "ground_truth": ["(2, 3)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_37", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_oriented_envelope_all_types", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', [GeometryCollection([Polygon([(0, 5), (5, 10), (10, 5), (5, 0), (0, 5)]), LineString([(1, 0), (1, 10)])]), Point(9, 8)])\ndef test_oriented_envelope_all_types(geometry):\n    actual = shapely.oriented_envelope([geometry, geometry])\n    assert (actual.shape == (2,))\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))\n    actual = shapely.oriented_envelope(None)\n    assert (actual is None)", "masked_code": "@pytest.mark.parametrize('geometry', [GeometryCollection([Polygon([(0, 5), (5, 10), (10, 5), (5, 0), (0, 5)]), LineString([(1, 0), (1, 10)])]), Point(9, 8)])\ndef test_oriented_envelope_all_types(geometry):\n    actual = shapely.oriented_envelope([geometry, geometry])\n    assert (actual.shape == '???')\n    assert ((actual[0] is None) or isinstance(actual[0], Geometry))\n    actual = shapely.oriented_envelope(None)\n    assert (actual is None)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_11", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(1, 1), (1, 3)]), LineString([(1, 3), (0, 3)]), LineString([(0, 3), (0, 0)]), LineString([(5, 5), (6, 6)]), Point(0, 0), None]\n    result = shapely.polygonize(lines)\n    assert (shapely.get_type_id(result) == 7)\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 3), (1, 3), (1, 1)])])\n    assert (result == expected)", "masked_code": "def test_polygonize():\n    lines = [LineString([(0, 0), (1, 1)]), LineString([(1, 1), (1, 3)]), LineString([(1, 3), (0, 3)]), LineString([(0, 3), (0, 0)]), LineString([(5, 5), (6, 6)]), Point(0, 0), None]\n    result = shapely.polygonize(lines)\n    assert (shapely.get_type_id(result) == '???')\n    expected = GeometryCollection([Polygon([(1, 1), (0, 0), (0, 3), (1, 3), (1, 1)])])\n    assert (result == expected)", "ground_truth": ["7"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_12", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == '???')\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["(1,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_13", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == '???')\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((3 3, 2 2, 2 3, 3 3)))>", "expected"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_14", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == '???')\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["(2, 3)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_15", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == '???')\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_16", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == '???')\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((3 3, 2 2, 2 3, 3 3)))>", "expected"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_17", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == '???')\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((3 3, 2 2, 2 3, 3 3)))>", "expected"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_18", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == '???')\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["(3, 2, 3)"], "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_19", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (3, 2))\n    for res in result.flatten():\n        assert (res == expected)", "masked_code": "def test_polygonize_array():\n    lines = [LineString([(2, 2), (3, 3)]), LineString([(2, 2), (2, 3)]), LineString([(2, 3), (3, 3)])]\n    expected = GeometryCollection([Polygon([(3, 3), (2, 2), (2, 3), (3, 3)])])\n    result = shapely.polygonize(np.array(lines))\n    assert isinstance(result, shapely.Geometry)\n    assert (result == expected)\n    result = shapely.polygonize(np.array([lines]))\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (1,))\n    assert (result[0] == expected)\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == (2,))\n    assert (result[0] == expected)\n    assert (result[1] == expected)\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize(arr)\n    assert isinstance(result, np.ndarray)\n    assert (result.shape == '???')\n    for res in result.flatten():\n        assert (res == expected)", "ground_truth": ["(3, 2)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_20", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array_axis():\n    lines = [LineString([(10, 10), (20, 20)]), LineString([(10, 10), (10, 20)]), LineString([(10, 20), (20, 20)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize(arr, axis=1)\n    assert (result.shape == (2,))\n    result = shapely.polygonize(arr, axis=0)\n    assert (result.shape == (3,))", "masked_code": "def test_polygonize_array_axis():\n    lines = [LineString([(10, 10), (20, 20)]), LineString([(10, 10), (10, 20)]), LineString([(10, 20), (20, 20)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize(arr, axis=1)\n    assert (result.shape == '???')\n    result = shapely.polygonize(arr, axis=0)\n    assert (result.shape == (3,))", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_21", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_array_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_array_axis():\n    lines = [LineString([(10, 10), (20, 20)]), LineString([(10, 10), (10, 20)]), LineString([(10, 20), (20, 20)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize(arr, axis=1)\n    assert (result.shape == (2,))\n    result = shapely.polygonize(arr, axis=0)\n    assert (result.shape == (3,))", "masked_code": "def test_polygonize_array_axis():\n    lines = [LineString([(10, 10), (20, 20)]), LineString([(10, 10), (10, 20)]), LineString([(10, 20), (20, 20)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize(arr, axis=1)\n    assert (result.shape == (2,))\n    result = shapely.polygonize(arr, axis=0)\n    assert (result.shape == '???')", "ground_truth": ["(2,)", "(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_22", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full():\n    lines = [None, LineString([(1, 1), (2, 2)]), LineString([(1, 1), (1, 2)]), LineString([(1, 2), (2, 2)]), LineString([(5, 5), (6, 6)]), LineString([(1, 2), (100, 100)]), Point(0, 0), None]\n    result = shapely.polygonize_full(lines)\n    assert (len(result) == 4)\n    assert all(((shapely.get_type_id(geom) == 7) for geom in result))\n    (polygons, cuts, dangles, invalid) = result\n    expected_polygons = GeometryCollection([Polygon([(2, 2), (1, 1), (1, 2), (2, 2)])])\n    assert (polygons == expected_polygons)\n    assert (cuts == GeometryCollection())\n    expected_dangles = GeometryCollection([LineString([(1, 2), (100, 100)]), LineString([(5, 5), (6, 6)])])\n    assert (dangles == expected_dangles)\n    assert (invalid == GeometryCollection())", "masked_code": "def test_polygonize_full():\n    lines = [None, LineString([(1, 1), (2, 2)]), LineString([(1, 1), (1, 2)]), LineString([(1, 2), (2, 2)]), LineString([(5, 5), (6, 6)]), LineString([(1, 2), (100, 100)]), Point(0, 0), None]\n    result = shapely.polygonize_full(lines)\n    assert (len(result) == '???')\n    assert all(((shapely.get_type_id(geom) == 7) for geom in result))\n    (polygons, cuts, dangles, invalid) = result\n    expected_polygons = GeometryCollection([Polygon([(2, 2), (1, 1), (1, 2), (2, 2)])])\n    assert (polygons == expected_polygons)\n    assert (cuts == GeometryCollection())\n    expected_dangles = GeometryCollection([LineString([(1, 2), (100, 100)]), LineString([(5, 5), (6, 6)])])\n    assert (dangles == expected_dangles)\n    assert (invalid == GeometryCollection())", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_23", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == '???')\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_24", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == '???')\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((10 10, 0 0, 0 10, 10 10)))>", "expected"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_25", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == '???')\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_26", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == '???')\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((10 10, 0 0, 0 10, 10 10)))>", "expected"], "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_27", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == '???')\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["(2, 3)", "<GEOMETRYCOLLECTION (POLYGON ((10 10, 0 0, 0 10, 10 10)))>"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_28", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == '???')\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_29", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == '???')\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((10 10, 0 0, 0 10, 10 10)))>", "expected"], "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_30", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == '???')\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((10 10, 0 0, 0 10, 10 10)))>", "expected"], "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_31", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == '???')\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["(3, 2, 3)"], "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_32", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "masked_code": "def test_polygonize_full_array():\n    lines = [LineString([(0, 0), (10, 10)]), LineString([(0, 0), (0, 10)]), LineString([(0, 10), (10, 10)])]\n    expected = GeometryCollection([Polygon([(10, 10), (0, 0), (0, 10), (10, 10)])])\n    result = shapely.polygonize_full(np.array(lines))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, shapely.Geometry) for geom in result))\n    assert (result[0] == expected)\n    assert all(((geom == GeometryCollection()) for geom in result[1:]))\n    result = shapely.polygonize_full(np.array([lines]))\n    assert (len(result) == 4)\n    assert all((isinstance(geom, np.ndarray) for geom in result))\n    assert all(((geom.shape == (1,)) for geom in result))\n    assert (result[0][0] == expected)\n    assert all(((geom[0] == GeometryCollection()) for geom in result[1:]))\n    arr = np.array([lines, lines])\n    assert (arr.shape == (2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == 4)\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (2,)) for arr in result))\n    assert (result[0][0] == expected)\n    assert (result[0][1] == expected)\n    assert all(((g == GeometryCollection()) for geom in result[1:] for g in geom))\n    arr = np.array([[lines, lines], [lines, lines], [lines, lines]])\n    assert (arr.shape == (3, 2, 3))\n    result = shapely.polygonize_full(arr)\n    assert (len(result) == '???')\n    assert all((isinstance(arr, np.ndarray) for arr in result))\n    assert all(((arr.shape == (3, 2)) for arr in result))\n    for res in result[0].flatten():\n        assert (res == expected)\n    for arr in result[1:]:\n        for res in arr.flatten():\n            assert (res == GeometryCollection())", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_33", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array_axis():\n    lines = [LineString([(3, 3), (4, 4)]), LineString([(3, 3), (3, 4)]), LineString([(3, 4), (4, 4)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize_full(arr, axis=1)\n    assert (len(result) == 4)\n    assert all(((arr.shape == (2,)) for arr in result))\n    result = shapely.polygonize_full(arr, axis=0)\n    assert (len(result) == 4)\n    assert all(((arr.shape == (3,)) for arr in result))", "masked_code": "def test_polygonize_full_array_axis():\n    lines = [LineString([(3, 3), (4, 4)]), LineString([(3, 3), (3, 4)]), LineString([(3, 4), (4, 4)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize_full(arr, axis=1)\n    assert (len(result) == '???')\n    assert all(((arr.shape == (2,)) for arr in result))\n    result = shapely.polygonize_full(arr, axis=0)\n    assert (len(result) == 4)\n    assert all(((arr.shape == (3,)) for arr in result))", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_34", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_array_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_array_axis():\n    lines = [LineString([(3, 3), (4, 4)]), LineString([(3, 3), (3, 4)]), LineString([(3, 4), (4, 4)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize_full(arr, axis=1)\n    assert (len(result) == 4)\n    assert all(((arr.shape == (2,)) for arr in result))\n    result = shapely.polygonize_full(arr, axis=0)\n    assert (len(result) == 4)\n    assert all(((arr.shape == (3,)) for arr in result))", "masked_code": "def test_polygonize_full_array_axis():\n    lines = [LineString([(3, 3), (4, 4)]), LineString([(3, 3), (3, 4)]), LineString([(3, 4), (4, 4)])]\n    arr = np.array([lines, lines])\n    result = shapely.polygonize_full(arr, axis=1)\n    assert (len(result) == 4)\n    assert all(((arr.shape == (2,)) for arr in result))\n    result = shapely.polygonize_full(arr, axis=0)\n    assert (len(result) == '???')\n    assert all(((arr.shape == (3,)) for arr in result))", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_35", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_polygonize_full_missing", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_polygonize_full_missing():\n    result = shapely.polygonize_full([None, None])\n    assert (len(result) == 4)\n    assert all(((geom == GeometryCollection()) for geom in result))", "masked_code": "def test_polygonize_full_missing():\n    result = shapely.polygonize_full([None, None])\n    assert (len(result) == '???')\n    assert all(((geom == GeometryCollection()) for geom in result))", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_9", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_reverse_none", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "def test_reverse_none():\n    assert (shapely.reverse(None) is None)\n    assert (shapely.reverse([None]).tolist() == [None])\n    geometry = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    expected = Polygon([(10, 10), (10, 20), (20, 20), (20, 10), (10, 10)])\n    result = shapely.reverse([None, geometry])\n    assert (result[0] is None)\n    assert_geometries_equal(result[1], expected)", "masked_code": "def test_reverse_none():\n    assert (shapely.reverse(None) is None)\n    assert (shapely.reverse([None]).tolist() == '???')\n    geometry = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    expected = Polygon([(10, 10), (10, 20), (20, 20), (20, 10), (10, 10)])\n    result = shapely.reverse([None, geometry])\n    assert (result[0] is None)\n    assert_geometries_equal(result[1], expected)", "ground_truth": ["[None]"], "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_2", "reponame": "shapely", "testpath": "shapely/tests/test_constructive.py", "testname": "test_constructive.py", "funcname": "test_snap_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, GEOSException, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, geos_version", "from shapely.errors import UnsupportedGEOSVersionError", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import ArrayLike, all_types, empty, empty_line_string, empty_point, empty_polygon, ignore_invalid, line_string, multi_point, point, point_z"], "code": "@pytest.mark.parametrize('geometry', [MultiPoint([(0, 0), (1, 1)]), GeometryCollection([Point(10, 0), Point(0, 10)])])\n@pytest.mark.parametrize('reference', [MultiPoint([(0, 0), (10, 10)]), Point(5, 5)])\ndef test_snap_array(geometry, reference):\n    actual = shapely.snap([geometry, geometry], [reference, reference], tolerance=1.0)\n    assert (actual.shape == (2,))\n    assert isinstance(actual[0], Geometry)", "masked_code": "@pytest.mark.parametrize('geometry', [MultiPoint([(0, 0), (1, 1)]), GeometryCollection([Point(10, 0), Point(0, 10)])])\n@pytest.mark.parametrize('reference', [MultiPoint([(0, 0), (10, 10)]), Point(5, 5)])\ndef test_snap_array(geometry, reference):\n    actual = shapely.snap([geometry, geometry], [reference, reference], tolerance=1.0)\n    assert (actual.shape == '???')\n    assert isinstance(actual[0], Geometry)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_47", "reponame": "shapely", "testpath": "shapely/tests/test_coordinates.py", "testname": "test_coordinates.py", "funcname": "test_transform_correct_coordinate_dimension", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_equal", "import shapely", "from shapely import count_coordinates, get_coordinates, set_coordinates, transform", "from shapely.tests.common import empty, empty_line_string_z, empty_point, empty_point_m, empty_point_z, empty_point_zm, geometry_collection, geometry_collection_z, geometry_collection_zm, line_string, line_string_m, line_string_z, line_string_zm, linear_ring, multi_line_string, multi_point, multi_polygon, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_z"], "code": "def test_transform_correct_coordinate_dimension():\n    geom = polygon_z\n    assert (shapely.get_coordinate_dimension(geom) == 3)\n    new_geom = transform(geom, (lambda x: (x * 2)), include_z=False)\n    assert (shapely.get_coordinate_dimension(new_geom) == 2)", "masked_code": "def test_transform_correct_coordinate_dimension():\n    geom = polygon_z\n    assert (shapely.get_coordinate_dimension(geom) == '???')\n    new_geom = transform(geom, (lambda x: (x * 2)), include_z=False)\n    assert (shapely.get_coordinate_dimension(new_geom) == 2)", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_48", "reponame": "shapely", "testpath": "shapely/tests/test_coordinates.py", "testname": "test_coordinates.py", "funcname": "test_transform_empty_preserve_z", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_equal", "import shapely", "from shapely import count_coordinates, get_coordinates, set_coordinates, transform", "from shapely.tests.common import empty, empty_line_string_z, empty_point, empty_point_m, empty_point_z, empty_point_zm, geometry_collection, geometry_collection_z, geometry_collection_zm, line_string, line_string_m, line_string_z, line_string_zm, linear_ring, multi_line_string, multi_point, multi_polygon, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_z"], "code": "@pytest.mark.parametrize('geom', [empty_point_z, empty_line_string_z, empty_point_m, empty_point_zm])\ndef test_transform_empty_preserve_z(geom):\n    if (geom is empty_line_string_z):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    elif (geom is empty_point_z):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    elif (geom is empty_point_zm):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    else:\n        assert (shapely.get_coordinate_dimension(geom) == 2)\n    new_geom = transform(geom, (lambda x: (x - 100)), include_z=True)\n    if (geom is empty_line_string_z):\n        assert (shapely.get_coordinate_dimension(new_geom) == 3)\n    elif (geom is empty_point_z):\n        assert (shapely.get_coordinate_dimension(new_geom) == 3)\n    elif (geom is empty_point_zm):\n        assert (shapely.get_coordinate_dimension(new_geom) == 3)\n    else:\n        assert (shapely.get_coordinate_dimension(new_geom) == 2)", "masked_code": "@pytest.mark.parametrize('geom', [empty_point_z, empty_line_string_z, empty_point_m, empty_point_zm])\ndef test_transform_empty_preserve_z(geom):\n    if (geom is empty_line_string_z):\n        assert (shapely.get_coordinate_dimension(geom) == '???')\n    elif (geom is empty_point_z):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    elif (geom is empty_point_zm):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    else:\n        assert (shapely.get_coordinate_dimension(geom) == 2)\n    new_geom = transform(geom, (lambda x: (x - 100)), include_z=True)\n    if (geom is empty_line_string_z):\n        assert (shapely.get_coordinate_dimension(new_geom) == 3)\n    elif (geom is empty_point_z):\n        assert (shapely.get_coordinate_dimension(new_geom) == 3)\n    elif (geom is empty_point_zm):\n        assert (shapely.get_coordinate_dimension(new_geom) == 3)\n    else:\n        assert (shapely.get_coordinate_dimension(new_geom) == 2)", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_49", "reponame": "shapely", "testpath": "shapely/tests/test_coordinates.py", "testname": "test_coordinates.py", "funcname": "test_transform_empty_preserve_z", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_equal", "import shapely", "from shapely import count_coordinates, get_coordinates, set_coordinates, transform", "from shapely.tests.common import empty, empty_line_string_z, empty_point, empty_point_m, empty_point_z, empty_point_zm, geometry_collection, geometry_collection_z, geometry_collection_zm, line_string, line_string_m, line_string_z, line_string_zm, linear_ring, multi_line_string, multi_point, multi_polygon, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_z"], "code": "@pytest.mark.parametrize('geom', [empty_point_z, empty_line_string_z, empty_point_m, empty_point_zm])\ndef test_transform_empty_preserve_z(geom):\n    if (geom is empty_line_string_z):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    elif (geom is empty_point_z):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    elif (geom is empty_point_zm):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    else:\n        assert (shapely.get_coordinate_dimension(geom) == 2)\n    new_geom = transform(geom, (lambda x: (x - 100)), include_z=True)\n    if (geom is empty_line_string_z):\n        assert (shapely.get_coordinate_dimension(new_geom) == 3)\n    elif (geom is empty_point_z):\n        assert (shapely.get_coordinate_dimension(new_geom) == 3)\n    elif (geom is empty_point_zm):\n        assert (shapely.get_coordinate_dimension(new_geom) == 3)\n    else:\n        assert (shapely.get_coordinate_dimension(new_geom) == 2)", "masked_code": "@pytest.mark.parametrize('geom', [empty_point_z, empty_line_string_z, empty_point_m, empty_point_zm])\ndef test_transform_empty_preserve_z(geom):\n    if (geom is empty_line_string_z):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    elif (geom is empty_point_z):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    elif (geom is empty_point_zm):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    else:\n        assert (shapely.get_coordinate_dimension(geom) == 2)\n    new_geom = transform(geom, (lambda x: (x - 100)), include_z=True)\n    if (geom is empty_line_string_z):\n        assert (shapely.get_coordinate_dimension(new_geom) == '???')\n    elif (geom is empty_point_z):\n        assert (shapely.get_coordinate_dimension(new_geom) == 3)\n    elif (geom is empty_point_zm):\n        assert (shapely.get_coordinate_dimension(new_geom) == 3)\n    else:\n        assert (shapely.get_coordinate_dimension(new_geom) == 2)", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_46", "reponame": "shapely", "testpath": "shapely/tests/test_coordinates.py", "testname": "test_coordinates.py", "funcname": "test_transform_no_geoms", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_equal", "import shapely", "from shapely import count_coordinates, get_coordinates, set_coordinates, transform", "from shapely.tests.common import empty, empty_line_string_z, empty_point, empty_point_m, empty_point_z, empty_point_zm, geometry_collection, geometry_collection_z, geometry_collection_zm, line_string, line_string_m, line_string_z, line_string_zm, linear_ring, multi_line_string, multi_point, multi_polygon, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_z"], "code": "def test_transform_no_geoms():\n    actual = transform([None, empty], (lambda x: (x * 0)))\n    assert (actual.shape == (2,))", "masked_code": "def test_transform_no_geoms():\n    actual = transform([None, empty], (lambda x: (x * 0)))\n    assert (actual.shape == '???')", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_50", "reponame": "shapely", "testpath": "shapely/tests/test_coordinates.py", "testname": "test_coordinates.py", "funcname": "test_transform_remove_z", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_equal", "import shapely", "from shapely import count_coordinates, get_coordinates, set_coordinates, transform", "from shapely.tests.common import empty, empty_line_string_z, empty_point, empty_point_m, empty_point_z, empty_point_zm, geometry_collection, geometry_collection_z, geometry_collection_zm, line_string, line_string_m, line_string_z, line_string_zm, linear_ring, multi_line_string, multi_point, multi_polygon, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_z"], "code": "@pytest.mark.parametrize('geom', [empty_point_z, empty_line_string_z, empty_point_m, empty_point_zm])\ndef test_transform_remove_z(geom):\n    if (geom is empty_line_string_z):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    elif (geom is empty_point_z):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    elif (geom is empty_point_zm):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    else:\n        assert (shapely.get_coordinate_dimension(geom) == 2)\n    new_geom = transform(geom, (lambda x: (x - 100)), include_z=False)\n    assert (shapely.get_coordinate_dimension(new_geom) == 2)", "masked_code": "@pytest.mark.parametrize('geom', [empty_point_z, empty_line_string_z, empty_point_m, empty_point_zm])\ndef test_transform_remove_z(geom):\n    if (geom is empty_line_string_z):\n        assert (shapely.get_coordinate_dimension(geom) == '???')\n    elif (geom is empty_point_z):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    elif (geom is empty_point_zm):\n        assert (shapely.get_coordinate_dimension(geom) == 3)\n    else:\n        assert (shapely.get_coordinate_dimension(geom) == 2)\n    new_geom = transform(geom, (lambda x: (x - 100)), include_z=False)\n    assert (shapely.get_coordinate_dimension(new_geom) == 2)", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_259", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_arrays", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_arrays(self):\n    (x, y) = LineString([(1000000.0, (- 1000000.0)), (0.0, 0.0), ((- 1e-06), 1e-06)]).xy\n    assert (len(x) == 3)\n    assert (list(x) == [1000000.0, 0.0, (- 1e-06)])\n    assert (len(y) == 3)\n    assert (list(y) == [(- 1000000.0), 0.0, 1e-06])", "masked_code": "def test_arrays(self):\n    (x, y) = LineString([(1000000.0, (- 1000000.0)), (0.0, 0.0), ((- 1e-06), 1e-06)]).xy\n    assert (len(x) == '???')\n    assert (list(x) == [1000000.0, 0.0, (- 1e-06)])\n    assert (len(y) == 3)\n    assert (list(y) == [(- 1000000.0), 0.0, 1e-06])", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestXY"}
{"task_id": "shapely_260", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_arrays", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_arrays(self):\n    (x, y) = LineString([(1000000.0, (- 1000000.0)), (0.0, 0.0), ((- 1e-06), 1e-06)]).xy\n    assert (len(x) == 3)\n    assert (list(x) == [1000000.0, 0.0, (- 1e-06)])\n    assert (len(y) == 3)\n    assert (list(y) == [(- 1000000.0), 0.0, 1e-06])", "masked_code": "def test_arrays(self):\n    (x, y) = LineString([(1000000.0, (- 1000000.0)), (0.0, 0.0), ((- 1e-06), 1e-06)]).xy\n    assert (len(x) == 3)\n    assert (list(x) == '???')\n    assert (len(y) == 3)\n    assert (list(y) == [(- 1000000.0), 0.0, 1e-06])", "ground_truth": ["[1000000.0, 0.0, (- 1e-06)]", "[1000000.0, 0.0, -1e-06]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestXY"}
{"task_id": "shapely_244", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_data_destriding", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_data_destriding(self):\n    coords = np.array([[(- 10000.01), 34.56], [789.99, 0]], dtype=np.float32)\n    processed_coords = np.array(LineString(coords[::(- 1)]).coords)\n    assert (coords[::(- 1)].tolist() == processed_coords.tolist())", "masked_code": "def test_data_destriding(self):\n    coords = np.array([[(- 10000.01), 34.56], [789.99, 0]], dtype=np.float32)\n    processed_coords = np.array(LineString(coords[::(- 1)]).coords)\n    assert (coords[::(- 1)].tolist() == '???')", "ground_truth": ["[[789.989990234375, 0.0], [-10000.009765625, 34.560001373291016]]", "processed_coords.tolist()"], "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoords"}
{"task_id": "shapely_243", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_data_promotion", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_data_promotion(self):\n    coords = np.array([[0, (- 99999999)], [2.123456, 99999999]], dtype=np.float32)\n    processed_coords = np.array(LineString(coords).coords)\n    assert (coords.tolist() == processed_coords.tolist())", "masked_code": "def test_data_promotion(self):\n    coords = np.array([[0, (- 99999999)], [2.123456, 99999999]], dtype=np.float32)\n    processed_coords = np.array(LineString(coords).coords)\n    assert (coords.tolist() == '???')", "ground_truth": ["[[0.0, -100000000.0], [2.1234560012817383, 100000000.0]]", "processed_coords.tolist()"], "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoords"}
{"task_id": "shapely_245", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_index_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_index_coords(self):\n    c = [(1000000000.0, (- 1000000000.0)), ((- 100000.0), 100000.0), (0.0, 0.0), ((- 9999.99), 9999.99)]\n    g = LineString(c)\n    for i in range((- 4), 4):\n        assert (g.coords[i] == c[i])\n    with pytest.raises(IndexError):\n        g.coords[4]\n    with pytest.raises(IndexError):\n        g.coords[(- 5)]", "masked_code": "def test_index_coords(self):\n    c = [(1000000000.0, (- 1000000000.0)), ((- 100000.0), 100000.0), (0.0, 0.0), ((- 9999.99), 9999.99)]\n    g = LineString(c)\n    for i in range((- 4), 4):\n        assert (g.coords[i] == '???')\n    with pytest.raises(IndexError):\n        g.coords[4]\n    with pytest.raises(IndexError):\n        g.coords[(- 5)]", "ground_truth": ["(1000000000.0, -1000000000.0)", "c[i]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_246", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_index_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_index_coords_z(self):\n    c = [(1000000000.0, (- 1000000000.0), 0.123), ((- 100000.0), 100000.0, (- 0.456)), (0.0, 0.0, 9999999.9), ((- 9999.99), 9999.99, (- 999.99))]\n    g = LineString(c)\n    for i in range((- 4), 4):\n        assert (g.coords[i] == c[i])\n    with pytest.raises(IndexError):\n        g.coords[4]\n    with pytest.raises(IndexError):\n        g.coords[(- 5)]", "masked_code": "def test_index_coords_z(self):\n    c = [(1000000000.0, (- 1000000000.0), 0.123), ((- 100000.0), 100000.0, (- 0.456)), (0.0, 0.0, 9999999.9), ((- 9999.99), 9999.99, (- 999.99))]\n    g = LineString(c)\n    for i in range((- 4), 4):\n        assert (g.coords[i] == '???')\n    with pytest.raises(IndexError):\n        g.coords[4]\n    with pytest.raises(IndexError):\n        g.coords[(- 5)]", "ground_truth": ["c[i]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_247", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords(self):\n    c = [(3.1, 2.8), ((- 9999.99), 9999.99), (0.0, 0.0), (1e-12, (- 1e-12)), (1, 2)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "masked_code": "def test_slice_coords(self):\n    c = [(3.1, 2.8), ((- 9999.99), 9999.99), (0.0, 0.0), (1e-12, (- 1e-12)), (1, 2)]\n    g = LineString(c)\n    assert (g.coords[1:] == '???')\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "ground_truth": ["[[-9999.99, 9999.99], [0.0, 0.0], [1e-12, -1e-12], [1, 2]]", "c[1:]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_248", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords(self):\n    c = [(3.1, 2.8), ((- 9999.99), 9999.99), (0.0, 0.0), (1e-12, (- 1e-12)), (1, 2)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "masked_code": "def test_slice_coords(self):\n    c = [(3.1, 2.8), ((- 9999.99), 9999.99), (0.0, 0.0), (1e-12, (- 1e-12)), (1, 2)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == '???')\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "ground_truth": ["[[3.1, 2.8], [-9999.99, 9999.99], [0.0, 0.0], [1e-12, -1e-12]]", "c[:(- 1)]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_249", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords(self):\n    c = [(3.1, 2.8), ((- 9999.99), 9999.99), (0.0, 0.0), (1e-12, (- 1e-12)), (1, 2)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "masked_code": "def test_slice_coords(self):\n    c = [(3.1, 2.8), ((- 9999.99), 9999.99), (0.0, 0.0), (1e-12, (- 1e-12)), (1, 2)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == '???')\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "ground_truth": ["[[1, 2], [1e-12, -1e-12], [0.0, 0.0], [-9999.99, 9999.99], [3.1, 2.8]]", "c[::(- 1)]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_250", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords(self):\n    c = [(3.1, 2.8), ((- 9999.99), 9999.99), (0.0, 0.0), (1e-12, (- 1e-12)), (1, 2)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "masked_code": "def test_slice_coords(self):\n    c = [(3.1, 2.8), ((- 9999.99), 9999.99), (0.0, 0.0), (1e-12, (- 1e-12)), (1, 2)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == '???')\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "ground_truth": ["[[3.1, 2.8], [0.0, 0.0], [1, 2]]", "c[::2]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_251", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords(self):\n    c = [(3.1, 2.8), ((- 9999.99), 9999.99), (0.0, 0.0), (1e-12, (- 1e-12)), (1, 2)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "masked_code": "def test_slice_coords(self):\n    c = [(3.1, 2.8), ((- 9999.99), 9999.99), (0.0, 0.0), (1e-12, (- 1e-12)), (1, 2)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == '???')\n    assert (g.coords[5:] == c[5:] == [])", "ground_truth": ["[[3.1, 2.8], [-9999.99, 9999.99], [0.0, 0.0], [1e-12, -1e-12], [1, 2]]", "c[:5]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_252", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords(self):\n    c = [(3.1, 2.8), ((- 9999.99), 9999.99), (0.0, 0.0), (1e-12, (- 1e-12)), (1, 2)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "masked_code": "def test_slice_coords(self):\n    c = [(3.1, 2.8), ((- 9999.99), 9999.99), (0.0, 0.0), (1e-12, (- 1e-12)), (1, 2)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == '???' == [])", "ground_truth": ["c[5:]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_253", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords_z(self):\n    c = [(3.1, 2.8, 77.7), ((- 9999.99), 9999.99, (- 123.123)), (0.0, 0.0, 0.0), (1e-12, (- 1e-12), 0.0), (1, 2, 3)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "masked_code": "def test_slice_coords_z(self):\n    c = [(3.1, 2.8, 77.7), ((- 9999.99), 9999.99, (- 123.123)), (0.0, 0.0, 0.0), (1e-12, (- 1e-12), 0.0), (1, 2, 3)]\n    g = LineString(c)\n    assert (g.coords[1:] == '???')\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "ground_truth": ["[[-9999.99, 9999.99, -123.123], [0.0, 0.0, 0.0], [1e-12, -1e-12, 0.0], [1, 2, 3]]", "c[1:]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_254", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords_z(self):\n    c = [(3.1, 2.8, 77.7), ((- 9999.99), 9999.99, (- 123.123)), (0.0, 0.0, 0.0), (1e-12, (- 1e-12), 0.0), (1, 2, 3)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "masked_code": "def test_slice_coords_z(self):\n    c = [(3.1, 2.8, 77.7), ((- 9999.99), 9999.99, (- 123.123)), (0.0, 0.0, 0.0), (1e-12, (- 1e-12), 0.0), (1, 2, 3)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == '???')\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "ground_truth": ["[[3.1, 2.8, 77.7], [-9999.99, 9999.99, -123.123], [0.0, 0.0, 0.0], [1e-12, -1e-12, 0.0]]", "c[:(- 1)]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_255", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords_z(self):\n    c = [(3.1, 2.8, 77.7), ((- 9999.99), 9999.99, (- 123.123)), (0.0, 0.0, 0.0), (1e-12, (- 1e-12), 0.0), (1, 2, 3)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "masked_code": "def test_slice_coords_z(self):\n    c = [(3.1, 2.8, 77.7), ((- 9999.99), 9999.99, (- 123.123)), (0.0, 0.0, 0.0), (1e-12, (- 1e-12), 0.0), (1, 2, 3)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == '???')\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "ground_truth": ["[[1, 2, 3], [1e-12, -1e-12, 0.0], [0.0, 0.0, 0.0], [-9999.99, 9999.99, -123.123], [3.1, 2.8, 77.7]]", "c[::(- 1)]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_256", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords_z(self):\n    c = [(3.1, 2.8, 77.7), ((- 9999.99), 9999.99, (- 123.123)), (0.0, 0.0, 0.0), (1e-12, (- 1e-12), 0.0), (1, 2, 3)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "masked_code": "def test_slice_coords_z(self):\n    c = [(3.1, 2.8, 77.7), ((- 9999.99), 9999.99, (- 123.123)), (0.0, 0.0, 0.0), (1e-12, (- 1e-12), 0.0), (1, 2, 3)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == '???')\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "ground_truth": ["[[3.1, 2.8, 77.7], [0.0, 0.0, 0.0], [1, 2, 3]]", "c[::2]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_257", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords_z(self):\n    c = [(3.1, 2.8, 77.7), ((- 9999.99), 9999.99, (- 123.123)), (0.0, 0.0, 0.0), (1e-12, (- 1e-12), 0.0), (1, 2, 3)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "masked_code": "def test_slice_coords_z(self):\n    c = [(3.1, 2.8, 77.7), ((- 9999.99), 9999.99, (- 123.123)), (0.0, 0.0, 0.0), (1e-12, (- 1e-12), 0.0), (1, 2, 3)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == '???')\n    assert (g.coords[5:] == c[5:] == [])", "ground_truth": ["[[3.1, 2.8, 77.7], [-9999.99, 9999.99, -123.123], [0.0, 0.0, 0.0], [1e-12, -1e-12, 0.0], [1, 2, 3]]", "c[:5]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_258", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_coords.py", "testname": "test_coords.py", "funcname": "test_slice_coords_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, geos_version", "from shapely.tests.common import line_string, line_string_m, line_string_z, line_string_zm, point, point_m, point_z, point_zm"], "code": "def test_slice_coords_z(self):\n    c = [(3.1, 2.8, 77.7), ((- 9999.99), 9999.99, (- 123.123)), (0.0, 0.0, 0.0), (1e-12, (- 1e-12), 0.0), (1, 2, 3)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == c[5:] == [])", "masked_code": "def test_slice_coords_z(self):\n    c = [(3.1, 2.8, 77.7), ((- 9999.99), 9999.99, (- 123.123)), (0.0, 0.0, 0.0), (1e-12, (- 1e-12), 0.0), (1, 2, 3)]\n    g = LineString(c)\n    assert (g.coords[1:] == c[1:])\n    assert (g.coords[:(- 1)] == c[:(- 1)])\n    assert (g.coords[::(- 1)] == c[::(- 1)])\n    assert (g.coords[::2] == c[::2])\n    assert (g.coords[:5] == c[:5])\n    assert (g.coords[5:] == '???' == [])", "ground_truth": ["c[5:]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestCoordsGetItem"}
{"task_id": "shapely_479", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_create_inconsistent_dimensionality.py", "testname": "test_create_inconsistent_dimensionality.py", "funcname": "test_create_from_wkt", "imports": ["import pytest", "import shapely", "from shapely import wkt", "from shapely.errors import GEOSException", "from shapely.geometry import LineString, Polygon, shape"], "code": "@pytest.mark.parametrize('wkt_geom,expected', wkt_cases)\ndef test_create_from_wkt(wkt_geom, expected):\n    if (shapely.geos_version >= (3, 12, 0)):\n        with pytest.raises(GEOSException):\n            wkt.loads(wkt_geom)\n    else:\n        geom = wkt.loads(wkt_geom)\n        assert (geom.wkt == expected)", "masked_code": "@pytest.mark.parametrize('wkt_geom,expected', wkt_cases)\ndef test_create_from_wkt(wkt_geom, expected):\n    if (shapely.geos_version >= (3, 12, 0)):\n        with pytest.raises(GEOSException):\n            wkt.loads(wkt_geom)\n    else:\n        geom = wkt.loads(wkt_geom)\n        assert (geom.wkt == '???')", "ground_truth": ["'MULTIPOINT EMPTY'", "expected"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_62", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_2_polygons_with_2_same_holes", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_2_polygons_with_2_same_holes():\n    actual = shapely.polygons([box_tpl(0, 0, 20, 20), box_tpl((- 10), (- 10), 10, 10)], [box_tpl(5, 5, 6, 6), box_tpl(7, 7, 8, 8)])\n    assert (shapely.area(actual).tolist() == [398.0, 398.0])", "masked_code": "def test_2_polygons_with_2_same_holes():\n    actual = shapely.polygons([box_tpl(0, 0, 20, 20), box_tpl((- 10), (- 10), 10, 10)], [box_tpl(5, 5, 6, 6), box_tpl(7, 7, 8, 8)])\n    assert (shapely.area(actual).tolist() == '???')", "ground_truth": ["[398.0, 398.0]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_63", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_2_polygons_with_different_holes", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_2_polygons_with_different_holes():\n    actual = shapely.polygons([box_tpl(0, 0, 100, 100), box_tpl(0, 0, 20, 20)], [[box_tpl(10, 10, 20, 20)], [box_tpl(2, 2, 4, 4)]])\n    assert (shapely.area(actual).tolist() == [9900.0, 396.0])", "masked_code": "def test_2_polygons_with_different_holes():\n    actual = shapely.polygons([box_tpl(0, 0, 100, 100), box_tpl(0, 0, 20, 20)], [[box_tpl(10, 10, 20, 20)], [box_tpl(2, 2, 4, 4)]])\n    assert (shapely.area(actual).tolist() == '???')", "ground_truth": ["[9900.0, 396.0]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_61", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_2_polygons_with_same_hole", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_2_polygons_with_same_hole():\n    actual = shapely.polygons([box_tpl(0, 0, 50, 50), box_tpl((- 20), (- 20), 5, 5)], [box_tpl(1, 1, 2, 2)])\n    assert (shapely.area(actual).tolist() == [2499.0, 624.0])", "masked_code": "def test_2_polygons_with_same_hole():\n    actual = shapely.polygons([box_tpl(0, 0, 50, 50), box_tpl((- 20), (- 20), 5, 5)], [box_tpl(1, 1, 2, 2)])\n    assert (shapely.area(actual).tolist() == '???')", "ground_truth": ["[2499.0, 624.0]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_55", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_points_nan_3D_all_nan_becomes_empty_2D", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "@pytest.mark.skipif((shapely.geos_version[:2] not in ((3, 10), (3, 11))), reason='GEOS not in 3.10, 3.11')\ndef test_points_nan_3D_all_nan_becomes_empty_2D():\n    actual = shapely.points(np.nan, np.nan, np.inf)\n    assert (actual.wkt == 'POINT Z EMPTY')", "masked_code": "@pytest.mark.skipif((shapely.geos_version[:2] not in ((3, 10), (3, 11))), reason='GEOS not in 3.10, 3.11')\ndef test_points_nan_3D_all_nan_becomes_empty_2D():\n    actual = shapely.points(np.nan, np.nan, np.inf)\n    assert (actual.wkt == '???')", "ground_truth": ["'POINT Z EMPTY'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_54", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_points_nan_all_nan_becomes_empty", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "@pytest.mark.skipif((shapely.geos_version[:2] not in ((3, 10), (3, 11), (3, 12))), reason='GEOS not in 3.10, 3.11, 3.12')\ndef test_points_nan_all_nan_becomes_empty():\n    actual = shapely.points(np.nan, (- np.inf))\n    assert (actual.wkt == 'POINT (NaN -Infinity)')", "masked_code": "@pytest.mark.skipif((shapely.geos_version[:2] not in ((3, 10), (3, 11), (3, 12))), reason='GEOS not in 3.10, 3.11, 3.12')\ndef test_points_nan_all_nan_becomes_empty():\n    actual = shapely.points(np.nan, (- np.inf))\n    assert (actual.wkt == '???')", "ground_truth": ["'POINT (NaN -Infinity)'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_58", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_polygon_with_1_hole", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_polygon_with_1_hole():\n    actual = shapely.polygons(box_tpl(0, 0, 100, 100), [box_tpl(10, 10, 30, 30)])\n    assert (shapely.area(actual) == 9600.0)", "masked_code": "def test_polygon_with_1_hole():\n    actual = shapely.polygons(box_tpl(0, 0, 100, 100), [box_tpl(10, 10, 30, 30)])\n    assert (shapely.area(actual) == '???')", "ground_truth": ["9600.0"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_59", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_polygon_with_2_holes", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_polygon_with_2_holes():\n    actual = shapely.polygons(box_tpl(0, 0, 20, 20), [box_tpl(2, 2, 8, 8), box_tpl(10, 10, 12, 12)])\n    assert (shapely.area(actual) == 360.0)", "masked_code": "def test_polygon_with_2_holes():\n    actual = shapely.polygons(box_tpl(0, 0, 20, 20), [box_tpl(2, 2, 8, 8), box_tpl(10, 10, 12, 12)])\n    assert (shapely.area(actual) == '???')", "ground_truth": ["360.0"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_60", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_polygon_with_none_hole", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_polygon_with_none_hole():\n    actual = shapely.polygons(shapely.linearrings(box_tpl(0, 0, 100, 100)), [None, shapely.linearrings(box_tpl(1, 1, 10, 10)), None, shapely.linearrings(box_tpl(90, 90, 98, 98))])\n    assert (shapely.area(actual) == 9855.0)", "masked_code": "def test_polygon_with_none_hole():\n    actual = shapely.polygons(shapely.linearrings(box_tpl(0, 0, 100, 100)), [None, shapely.linearrings(box_tpl(1, 1, 10, 10)), None, shapely.linearrings(box_tpl(90, 90, 98, 98))])\n    assert (shapely.area(actual) == '???')", "ground_truth": ["9855.0"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_64", "reponame": "shapely", "testpath": "shapely/tests/test_creation.py", "testname": "test_creation.py", "funcname": "test_prepare", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import GeometryCollection, GeometryType, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty_polygon, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, multi_polygon, point, polygon"], "code": "def test_prepare():\n    arr = np.array([shapely.points((- 1000), 100000000.0), None, shapely.box((- 10), (- 10), 10, 10), shapely.points(0, 0, 9999)])\n    assert (arr[0]._geom_prepared == 0)\n    assert (arr[2]._geom_prepared == 0)\n    assert (arr[3]._geom_prepared == 0)\n    shapely.prepare(arr)\n    assert (arr[0]._geom_prepared != 0)\n    assert (arr[1] is None)\n    assert (arr[2]._geom_prepared != 0)\n    assert (arr[3]._geom_prepared != 0)\n    original = arr[0]._geom_prepared\n    shapely.prepare(arr)\n    assert (arr[0]._geom_prepared == original)", "masked_code": "def test_prepare():\n    arr = np.array([shapely.points((- 1000), 100000000.0), None, shapely.box((- 10), (- 10), 10, 10), shapely.points(0, 0, 9999)])\n    assert (arr[0]._geom_prepared == 0)\n    assert (arr[2]._geom_prepared == 0)\n    assert (arr[3]._geom_prepared == 0)\n    shapely.prepare(arr)\n    assert (arr[0]._geom_prepared != 0)\n    assert (arr[1] is None)\n    assert (arr[2]._geom_prepared != 0)\n    assert (arr[3]._geom_prepared != 0)\n    original = arr[0]._geom_prepared\n    shapely.prepare(arr)\n    assert (arr[0]._geom_prepared == '???')", "ground_truth": ["original"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_261", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_decimal.py", "testname": "test_decimal.py", "funcname": "test_decimal", "imports": ["from decimal import Decimal", "import pytest", "from shapely import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon"], "code": "@pytest.mark.parametrize('geoms', list(zip(*all_geoms)))\ndef test_decimal(geoms):\n    assert (geoms[0] == geoms[1] == geoms[2])\n    assert (geoms[3] == geoms[4] == geoms[5])", "masked_code": "@pytest.mark.parametrize('geoms', list(zip(*all_geoms)))\ndef test_decimal(geoms):\n    assert (geoms[0] == '???' == geoms[2])\n    assert (geoms[3] == geoms[4] == geoms[5])", "ground_truth": ["geoms[1]"], "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_262", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_decimal.py", "testname": "test_decimal.py", "funcname": "test_decimal", "imports": ["from decimal import Decimal", "import pytest", "from shapely import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon"], "code": "@pytest.mark.parametrize('geoms', list(zip(*all_geoms)))\ndef test_decimal(geoms):\n    assert (geoms[0] == geoms[1] == geoms[2])\n    assert (geoms[3] == geoms[4] == geoms[5])", "masked_code": "@pytest.mark.parametrize('geoms', list(zip(*all_geoms)))\ndef test_decimal(geoms):\n    assert (geoms[0] == geoms[1] == geoms[2])\n    assert (geoms[3] == '???' == geoms[5])", "ground_truth": ["geoms[4]"], "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_65", "reponame": "shapely", "testpath": "shapely/tests/test_decorators.py", "testname": "test_decorators.py", "funcname": "test_all_kwargs_no_warning", "imports": ["import pytest", "from pytest import WarningsRecorder", "from shapely.decorators import deprecate_positional"], "code": "def test_all_kwargs_no_warning(recwarn: WarningsRecorder) -> None:\n    assert (func_two(a=0, b=(- 10), c=1.5) == (0, (- 10), 1.5))\n    assert (not recwarn.list)", "masked_code": "def test_all_kwargs_no_warning(recwarn: WarningsRecorder) -> None:\n    assert (func_two(a=0, b=(- 10), c=1.5) == '???')\n    assert (not recwarn.list)", "ground_truth": ["(0, (- 10), 1.5)", "(0, -10, 1.5)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_66", "reponame": "shapely", "testpath": "shapely/tests/test_decorators.py", "testname": "test_decorators.py", "funcname": "test_only_required_arg_no_warning", "imports": ["import pytest", "from pytest import WarningsRecorder", "from shapely.decorators import deprecate_positional"], "code": "def test_only_required_arg_no_warning(recwarn: WarningsRecorder) -> None:\n    assert (func_two((- 99999)) == ((- 99999), 2, 3))\n    assert (not recwarn.list)", "masked_code": "def test_only_required_arg_no_warning(recwarn: WarningsRecorder) -> None:\n    assert (func_two((- 99999)) == '???')\n    assert (not recwarn.list)", "ground_truth": ["((- 99999), 2, 3)", "(-99999, 2, 3)"], "quality_analysis": {"complexity_score": 13, "left_complexity": 6, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_67", "reponame": "shapely", "testpath": "shapely/tests/test_decorators.py", "testname": "test_decorators.py", "funcname": "test_repeated_warnings", "imports": ["import pytest", "from pytest import WarningsRecorder", "from shapely.decorators import deprecate_positional"], "code": "def test_repeated_warnings() -> None:\n    with pytest.warns(DeprecationWarning) as record:\n        func_two(101.1, 0.0, (- 50000.5))\n        func_two(101.1, 0.0, (- 50000.5))\n        assert (len(record) == 2)\n        assert (str(record[0].message) == str(record[1].message))", "masked_code": "def test_repeated_warnings() -> None:\n    with pytest.warns(DeprecationWarning) as record:\n        func_two(101.1, 0.0, (- 50000.5))\n        func_two(101.1, 0.0, (- 50000.5))\n        assert (len(record) == 2)\n        assert (str(record[0].message) == '???')", "ground_truth": ["'positional arguments `b` and `c` for `func_two` are deprecated. Please use keyword arguments instead.'", "str(record[1].message)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_480", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_delaunay.py", "testname": "test_delaunay.py", "funcname": "test_lines", "imports": ["import unittest", "from shapely.geometry import LineString, Point, Polygon", "from shapely.ops import triangulate"], "code": "def test_lines(self):\n    hexagon = Polygon([(0, 0), (2, 0), (3, 1), (2, 2), (0, 2), ((- 1), 1)])\n    polys = triangulate(hexagon, edges=True)\n    assert (len(polys) == 9)\n    for p in polys:\n        assert isinstance(p, LineString)", "masked_code": "def test_lines(self):\n    hexagon = Polygon([(0, 0), (2, 0), (3, 1), (2, 2), (0, 2), ((- 1), 1)])\n    polys = triangulate(hexagon, edges=True)\n    assert (len(polys) == '???')\n    for p in polys:\n        assert isinstance(p, LineString)", "ground_truth": ["9"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "DelaunayTriangulation"}
{"task_id": "shapely_263", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_emptiness.py", "testname": "test_emptiness.py", "funcname": "test_empty_geometry_bounds", "imports": ["import math", "import numpy as np", "import pytest", "from shapely import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.geometry import mapping, shape", "from shapely.geometry.base import BaseGeometry, EmptyGeometry"], "code": "@pytest.mark.parametrize('geom', [Point(), LineString(), Polygon(), MultiPoint(), MultiLineString(), MultiPolygon(), GeometryCollection(), LinearRing(), LineString([]), Polygon([]), MultiPoint([]), MultiLineString([]), MultiPolygon([]), GeometryCollection([]), LinearRing([]), LineString(None), Polygon(None), LinearRing(None), LineString(empty_generator()), Polygon(empty_generator()), LinearRing(empty_generator())])\ndef test_empty_geometry_bounds(geom):\n    'The bounds of an empty geometry is a tuple of NaNs'\n    assert (len(geom.bounds) == 4)\n    assert all((math.isnan(v) for v in geom.bounds))", "masked_code": "@pytest.mark.parametrize('geom', [Point(), LineString(), Polygon(), MultiPoint(), MultiLineString(), MultiPolygon(), GeometryCollection(), LinearRing(), LineString([]), Polygon([]), MultiPoint([]), MultiLineString([]), MultiPolygon([]), GeometryCollection([]), LinearRing([]), LineString(None), Polygon(None), LinearRing(None), LineString(empty_generator()), Polygon(empty_generator()), LinearRing(empty_generator())])\ndef test_empty_geometry_bounds(geom):\n    'The bounds of an empty geometry is a tuple of NaNs'\n    assert (len(geom.bounds) == '???')\n    assert all((math.isnan(v) for v in geom.bounds))", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_483", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_empty_polygon", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_empty_polygon():\n    'Confirm fix for issue #450 - check polygon with 0-area single point shell'\n    g = Polygon([(0.0, 0.0), (0.0, 0.0), (0.0, 0.0)])\n    assert (g.__geo_interface__['type'] == 'Polygon')\n    assert (g.__geo_interface__['coordinates'] == (((0.0, 0.0), (0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),))", "masked_code": "def test_empty_polygon():\n    'Confirm fix for issue #450 - check polygon with 0-area single point shell'\n    g = Polygon([(0.0, 0.0), (0.0, 0.0), (0.0, 0.0)])\n    assert (g.__geo_interface__['type'] == '???')\n    assert (g.__geo_interface__['coordinates'] == (((0.0, 0.0), (0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),))", "ground_truth": ["'Polygon'"], "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_484", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_empty_polygon", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_empty_polygon():\n    'Confirm fix for issue #450 - check polygon with 0-area single point shell'\n    g = Polygon([(0.0, 0.0), (0.0, 0.0), (0.0, 0.0)])\n    assert (g.__geo_interface__['type'] == 'Polygon')\n    assert (g.__geo_interface__['coordinates'] == (((0.0, 0.0), (0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),))", "masked_code": "def test_empty_polygon():\n    'Confirm fix for issue #450 - check polygon with 0-area single point shell'\n    g = Polygon([(0.0, 0.0), (0.0, 0.0), (0.0, 0.0)])\n    assert (g.__geo_interface__['type'] == 'Polygon')\n    assert (g.__geo_interface__['coordinates'] == '???')", "ground_truth": ["(((0.0, 0.0), (0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),)", "([[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],)"], "quality_analysis": {"complexity_score": 26, "left_complexity": 6, "right_complexity": 20, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_481", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_empty_wkt_polygon", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_empty_wkt_polygon():\n    'Confirm fix for issue #450 - now test with explicit whitespace and lower case'\n    g = wkt.loads(' polygon empty   ')\n    assert (g.__geo_interface__['type'] == 'Polygon')\n    assert (g.__geo_interface__['coordinates'] == ())", "masked_code": "def test_empty_wkt_polygon():\n    'Confirm fix for issue #450 - now test with explicit whitespace and lower case'\n    g = wkt.loads(' polygon empty   ')\n    assert (g.__geo_interface__['type'] == '???')\n    assert (g.__geo_interface__['coordinates'] == ())", "ground_truth": ["'Polygon'"], "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_482", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_empty_wkt_polygon", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_empty_wkt_polygon():\n    'Confirm fix for issue #450 - now test with explicit whitespace and lower case'\n    g = wkt.loads(' polygon empty   ')\n    assert (g.__geo_interface__['type'] == 'Polygon')\n    assert (g.__geo_interface__['coordinates'] == ())", "masked_code": "def test_empty_wkt_polygon():\n    'Confirm fix for issue #450 - now test with explicit whitespace and lower case'\n    g = wkt.loads(' polygon empty   ')\n    assert (g.__geo_interface__['type'] == 'Polygon')\n    assert (g.__geo_interface__['coordinates'] == '???')", "ground_truth": ["()"], "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_485", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == (((- 9999999.0), 9999999.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((1.5, (- 2.5), 42.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 5), 0.1), (1.0, 3), (0, (- 10))))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)))\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == '???')\n    assert (tuple(geom.coords) == (((- 9999999.0), 9999999.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((1.5, (- 2.5), 42.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 5), 0.1), (1.0, 3), (0, (- 10))))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)))\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "ground_truth": ["'Point'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_486", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == (((- 9999999.0), 9999999.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((1.5, (- 2.5), 42.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 5), 0.1), (1.0, 3), (0, (- 10))))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)))\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == '???')\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((1.5, (- 2.5), 42.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 5), 0.1), (1.0, 3), (0, (- 10))))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)))\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "ground_truth": ["(((- 9999999.0), 9999999.0),)", "([-9999999.0, 9999999.0],)"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_487", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == (((- 9999999.0), 9999999.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((1.5, (- 2.5), 42.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 5), 0.1), (1.0, 3), (0, (- 10))))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)))\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == (((- 9999999.0), 9999999.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == '???')\n    assert (tuple(geom.coords) == ((1.5, (- 2.5), 42.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 5), 0.1), (1.0, 3), (0, (- 10))))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)))\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "ground_truth": ["'Point'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_488", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == (((- 9999999.0), 9999999.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((1.5, (- 2.5), 42.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 5), 0.1), (1.0, 3), (0, (- 10))))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)))\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == (((- 9999999.0), 9999999.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == '???')\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 5), 0.1), (1.0, 3), (0, (- 10))))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)))\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "ground_truth": ["((1.5, (- 2.5), 42.0),)", "([1.5, -2.5, 42.0],)"], "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_489", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == (((- 9999999.0), 9999999.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((1.5, (- 2.5), 42.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 5), 0.1), (1.0, 3), (0, (- 10))))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)))\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == (((- 9999999.0), 9999999.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((1.5, (- 2.5), 42.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == '???')\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)))\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "ground_truth": ["(((- 5), 0.1), (1.0, 3), (0, (- 10)))", "([-5, 0.1], [1.0, 3], [0, -10])"], "quality_analysis": {"complexity_score": 23, "left_complexity": 5, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_490", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == (((- 9999999.0), 9999999.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((1.5, (- 2.5), 42.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 5), 0.1), (1.0, 3), (0, (- 10))))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)))\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == (((- 9999999.0), 9999999.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((1.5, (- 2.5), 42.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 5), 0.1), (1.0, 3), (0, (- 10))))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == '???')\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)))\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "ground_truth": ["((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))", "([0.0, 0.0], [-1.0, 2.0], [2.0, -1.0], [-3.5, 0.0], [0.0, 0.0])"], "quality_analysis": {"complexity_score": 33, "left_complexity": 5, "right_complexity": 28, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_491", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_geointerface.py", "testname": "test_geointerface.py", "funcname": "test_geointerface", "imports": ["import unittest", "from shapely import wkt", "from shapely.geometry import shape", "from shapely.geometry.linestring import LineString", "from shapely.geometry.multilinestring import MultiLineString", "from shapely.geometry.multipoint import MultiPoint", "from shapely.geometry.multipolygon import MultiPolygon", "from shapely.geometry.polygon import LinearRing, Polygon"], "code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == (((- 9999999.0), 9999999.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((1.5, (- 2.5), 42.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 5), 0.1), (1.0, 3), (0, (- 10))))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == ((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)))\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "masked_code": "def test_geointerface(self):\n    d = {'type': 'Point', 'coordinates': ((- 9999999.0), 9999999.0)}\n    geom = shape(d)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == (((- 9999999.0), 9999999.0),))\n    geom = None\n    thing = GeoThing({'type': 'Point', 'coordinates': (1.5, (- 2.5), 42.0)})\n    geom = shape(thing)\n    assert (geom.geom_type == 'Point')\n    assert (tuple(geom.coords) == ((1.5, (- 2.5), 42.0),))\n    geom = shape({'type': 'LineString', 'coordinates': (((- 5), 0.1), (1.0, 3), (0, (- 10)))})\n    assert isinstance(geom, LineString)\n    assert (tuple(geom.coords) == (((- 5), 0.1), (1.0, 3), (0, (- 10))))\n    geom = shape({'type': 'LinearRing', 'coordinates': ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0))})\n    assert isinstance(geom, LinearRing)\n    assert (tuple(geom.coords) == ((0.0, 0.0), ((- 1.0), 2.0), (2.0, (- 1.0)), ((- 3.5), 0.0), (0.0, 0.0)))\n    geom = shape({'type': 'Polygon', 'coordinates': (((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0)), ((10000.1, 10000.1), (10000.1, 10000.2), (10000.2, 10000.2), (10000.2, 10000.1), (10000.1, 10000.1)), ((9999.1, 9999.1), (9999.1, 9999.2), (9999.2, 9999.2), (9999.2, 9999.1), (9999.1, 9999.1)))})\n    assert isinstance(geom, Polygon)\n    assert (tuple(geom.exterior.coords) == '???')\n    assert (len(geom.interiors) == 2)\n    geom = shape({'type': 'MultiPoint', 'coordinates': ((0, 0), ((- 1.2), 3.5), (6, (- 7)))})\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 3)\n    geom = shape({'type': 'MultiLineString', 'coordinates': (((0.0, 0.0), (1.0, 2.0)), (((- 5), 10), (0, (- 5)), (2, 2)))})\n    assert isinstance(geom, MultiLineString)\n    assert (len(geom.geoms) == 2)\n    geom = shape({'type': 'MultiPolygon', 'coordinates': [(((5.0, 5.0), (5.0, 6.0), (6.0, 6.0), (6.0, 5.0), (5.0, 5.0)), ((5.1, 5.1), (5.1, 5.2), (5.2, 5.2), (5.2, 5.1), (5.1, 5.1))), (((10.0, 10.0), (11.0, 10.0), (11.0, 11.0), (10.0, 11.0), (10.0, 10.0)), [])]})\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 2)", "ground_truth": ["((10000.0, 10000.0), (10000.0, 10001.0), (10001.0, 10001.0), (10002.0, 9999.0), (10000.0, 10000.0))", "([10000.0, 10000.0], [10000.0, 10001.0], [10001.0, 10001.0], [10002.0, 9999.0], [10000.0, 10000.0])"], "quality_analysis": {"complexity_score": 27, "left_complexity": 5, "right_complexity": 22, "is_quality": true, "reason": "High quality assertion"}, "classname": "GeoInterfaceTestCase"}
{"task_id": "shapely_83", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_force_3d", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "@pytest.mark.parametrize('geom,expected', [(point, point_z), (point_z, point_z), (empty_point, empty_point_z), (empty_point_z, empty_point_z), (line_string, line_string_z), (line_string_z, line_string_z), (empty_line_string, empty_line_string_z), (empty_line_string_z, empty_line_string_z), (polygon, polygon_z), (polygon_z, polygon_z), (polygon_with_hole, polygon_with_hole_z), (polygon_with_hole_z, polygon_with_hole_z), (multi_point, multi_point_z), (multi_point_z, multi_point_z), (multi_line_string, multi_line_string_z), (multi_line_string_z, multi_line_string_z), (multi_polygon, multi_polygon_z), (multi_polygon_z, multi_polygon_z), (geometry_collection_2, geometry_collection_z), (geometry_collection_z, geometry_collection_z)])\ndef test_force_3d(geom, expected):\n    actual = shapely.force_3d(geom, z=4)\n    assert (shapely.get_coordinate_dimension(actual) == 3)\n    assert_geometries_equal(actual, expected)", "masked_code": "@pytest.mark.parametrize('geom,expected', [(point, point_z), (point_z, point_z), (empty_point, empty_point_z), (empty_point_z, empty_point_z), (line_string, line_string_z), (line_string_z, line_string_z), (empty_line_string, empty_line_string_z), (empty_line_string_z, empty_line_string_z), (polygon, polygon_z), (polygon_z, polygon_z), (polygon_with_hole, polygon_with_hole_z), (polygon_with_hole_z, polygon_with_hole_z), (multi_point, multi_point_z), (multi_point_z, multi_point_z), (multi_line_string, multi_line_string_z), (multi_line_string_z, multi_line_string_z), (multi_polygon, multi_polygon_z), (multi_polygon_z, multi_polygon_z), (geometry_collection_2, geometry_collection_z), (geometry_collection_z, geometry_collection_z)])\ndef test_force_3d(geom, expected):\n    actual = shapely.force_3d(geom, z=4)\n    assert (shapely.get_coordinate_dimension(actual) == '???')\n    assert_geometries_equal(actual, expected)", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_73", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_parts", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "@pytest.mark.parametrize('geom', [point, multi_point, line_string, multi_line_string, polygon, multi_polygon, geometry_collection, empty_point, empty_line_string, empty_polygon, empty_geometry_collection, np.array([None]), np.empty_like(np.array([None]))])\ndef test_get_parts(geom):\n    expected_num_parts = shapely.get_num_geometries(geom)\n    if (expected_num_parts == 0):\n        expected_parts = []\n    else:\n        expected_parts = shapely.get_geometry(geom, range(expected_num_parts))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == expected_num_parts)\n    assert_geometries_equal(parts, expected_parts)", "masked_code": "@pytest.mark.parametrize('geom', [point, multi_point, line_string, multi_line_string, polygon, multi_polygon, geometry_collection, empty_point, empty_line_string, empty_polygon, empty_geometry_collection, np.array([None]), np.empty_like(np.array([None]))])\ndef test_get_parts(geom):\n    expected_num_parts = shapely.get_num_geometries(geom)\n    if (expected_num_parts == 0):\n        expected_parts = []\n    else:\n        expected_parts = shapely.get_geometry(geom, range(expected_num_parts))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == '???')\n    assert_geometries_equal(parts, expected_parts)", "ground_truth": ["expected_num_parts", "np.int32(1)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_74", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_parts_array", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "def test_get_parts_array():\n    geom = np.array([None, empty_point, multi_line_string, Point(5, 5), MultiPolygon([Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])])])\n    expected_parts = []\n    for g in geom:\n        for i in range(shapely.get_num_geometries(g)):\n            expected_parts.append(shapely.get_geometry(g, i))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == len(expected_parts))\n    assert_geometries_equal(parts, expected_parts)", "masked_code": "def test_get_parts_array():\n    geom = np.array([None, empty_point, multi_line_string, Point(5, 5), MultiPolygon([Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])])])\n    expected_parts = []\n    for g in geom:\n        for i in range(shapely.get_num_geometries(g)):\n            expected_parts.append(shapely.get_geometry(g, i))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == '???')\n    assert_geometries_equal(parts, expected_parts)", "ground_truth": ["4", "len(expected_parts)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_75", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_parts_geometry_collection_multi", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "def test_get_parts_geometry_collection_multi():\n    geom = shapely.geometrycollections([MultiPolygon([Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])]), MultiPoint([(0, 0), (1, 2)]), empty_geometry_collection])\n    expected_num_parts = shapely.get_num_geometries(geom)\n    expected_parts = shapely.get_geometry(geom, range(expected_num_parts))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == expected_num_parts)\n    assert_geometries_equal(parts, expected_parts)\n    expected_subparts = []\n    for g in np.asarray(expected_parts):\n        for i in range(shapely.get_num_geometries(g)):\n            expected_subparts.append(shapely.get_geometry(g, i))\n    subparts = shapely.get_parts(parts)\n    assert (len(subparts) == len(expected_subparts))\n    assert_geometries_equal(subparts, expected_subparts)", "masked_code": "def test_get_parts_geometry_collection_multi():\n    geom = shapely.geometrycollections([MultiPolygon([Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])]), MultiPoint([(0, 0), (1, 2)]), empty_geometry_collection])\n    expected_num_parts = shapely.get_num_geometries(geom)\n    expected_parts = shapely.get_geometry(geom, range(expected_num_parts))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == '???')\n    assert_geometries_equal(parts, expected_parts)\n    expected_subparts = []\n    for g in np.asarray(expected_parts):\n        for i in range(shapely.get_num_geometries(g)):\n            expected_subparts.append(shapely.get_geometry(g, i))\n    subparts = shapely.get_parts(parts)\n    assert (len(subparts) == len(expected_subparts))\n    assert_geometries_equal(subparts, expected_subparts)", "ground_truth": ["expected_num_parts", "np.int32(3)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_76", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_parts_geometry_collection_multi", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "def test_get_parts_geometry_collection_multi():\n    geom = shapely.geometrycollections([MultiPolygon([Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])]), MultiPoint([(0, 0), (1, 2)]), empty_geometry_collection])\n    expected_num_parts = shapely.get_num_geometries(geom)\n    expected_parts = shapely.get_geometry(geom, range(expected_num_parts))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == expected_num_parts)\n    assert_geometries_equal(parts, expected_parts)\n    expected_subparts = []\n    for g in np.asarray(expected_parts):\n        for i in range(shapely.get_num_geometries(g)):\n            expected_subparts.append(shapely.get_geometry(g, i))\n    subparts = shapely.get_parts(parts)\n    assert (len(subparts) == len(expected_subparts))\n    assert_geometries_equal(subparts, expected_subparts)", "masked_code": "def test_get_parts_geometry_collection_multi():\n    geom = shapely.geometrycollections([MultiPolygon([Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])]), MultiPoint([(0, 0), (1, 2)]), empty_geometry_collection])\n    expected_num_parts = shapely.get_num_geometries(geom)\n    expected_parts = shapely.get_geometry(geom, range(expected_num_parts))\n    parts = shapely.get_parts(geom)\n    assert (len(parts) == expected_num_parts)\n    assert_geometries_equal(parts, expected_parts)\n    expected_subparts = []\n    for g in np.asarray(expected_parts):\n        for i in range(shapely.get_num_geometries(g)):\n            expected_subparts.append(shapely.get_geometry(g, i))\n    subparts = shapely.get_parts(parts)\n    assert (len(subparts) == '???')\n    assert_geometries_equal(subparts, expected_subparts)", "ground_truth": ["3", "len(expected_subparts)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_77", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_parts_return_index", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "def test_get_parts_return_index():\n    geom = np.array([multi_line_string, Point(2, 2), empty_polygon])\n    expected_parts = []\n    expected_index = []\n    for (i, g) in enumerate(geom):\n        for j in range(shapely.get_num_geometries(g)):\n            expected_parts.append(shapely.get_geometry(g, j))\n            expected_index.append(i)\n    (parts, index) = shapely.get_parts(geom, return_index=True)\n    assert (len(parts) == len(expected_parts))\n    assert_geometries_equal(parts, expected_parts)\n    assert np.array_equal(index, expected_index)", "masked_code": "def test_get_parts_return_index():\n    geom = np.array([multi_line_string, Point(2, 2), empty_polygon])\n    expected_parts = []\n    expected_index = []\n    for (i, g) in enumerate(geom):\n        for j in range(shapely.get_num_geometries(g)):\n            expected_parts.append(shapely.get_geometry(g, j))\n            expected_index.append(i)\n    (parts, index) = shapely.get_parts(geom, return_index=True)\n    assert (len(parts) == '???')\n    assert_geometries_equal(parts, expected_parts)\n    assert np.array_equal(index, expected_index)", "ground_truth": ["3", "len(expected_parts)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_78", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_rings", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "@pytest.mark.parametrize('geom', [point, multi_point, line_string, multi_line_string, polygon, multi_polygon, geometry_collection, empty_point, empty_line_string, empty_polygon, empty_geometry_collection, None])\ndef test_get_rings(geom):\n    if ((shapely.get_type_id(geom) != shapely.GeometryType.POLYGON) or shapely.is_empty(geom)):\n        rings = shapely.get_rings(geom)\n        assert (len(rings) == 0)\n    else:\n        rings = shapely.get_rings(geom)\n        assert (len(rings) == 1)\n        assert (rings[0] == shapely.get_exterior_ring(geom))", "masked_code": "@pytest.mark.parametrize('geom', [point, multi_point, line_string, multi_line_string, polygon, multi_polygon, geometry_collection, empty_point, empty_line_string, empty_polygon, empty_geometry_collection, None])\ndef test_get_rings(geom):\n    if ((shapely.get_type_id(geom) != shapely.GeometryType.POLYGON) or shapely.is_empty(geom)):\n        rings = shapely.get_rings(geom)\n        assert (len(rings) == 0)\n    else:\n        rings = shapely.get_rings(geom)\n        assert (len(rings) == 1)\n        assert (rings[0] == '???')", "ground_truth": ["<LINEARRING (0 0, 2 0, 2 2, 0 2, 0 0)>", "shapely.get_exterior_ring(geom)"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_79", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_rings_holes", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "def test_get_rings_holes():\n    poly = Polygon([(0, 0), (4, 0), (4, 4), (0, 4), (0, 0)], holes=[[(1, 1), (2, 1), (2, 2), (1, 2), (1, 1)], [(3, 1), (3, 2), (2, 2), (2, 1), (3, 1)]])\n    rings = shapely.get_rings(poly)\n    assert (len(rings) == 3)\n    assert (rings[0] == shapely.get_exterior_ring(poly))\n    assert (rings[1] == shapely.get_interior_ring(poly, 0))\n    assert (rings[2] == shapely.get_interior_ring(poly, 1))", "masked_code": "def test_get_rings_holes():\n    poly = Polygon([(0, 0), (4, 0), (4, 4), (0, 4), (0, 0)], holes=[[(1, 1), (2, 1), (2, 2), (1, 2), (1, 1)], [(3, 1), (3, 2), (2, 2), (2, 1), (3, 1)]])\n    rings = shapely.get_rings(poly)\n    assert (len(rings) == '???')\n    assert (rings[0] == shapely.get_exterior_ring(poly))\n    assert (rings[1] == shapely.get_interior_ring(poly, 0))\n    assert (rings[2] == shapely.get_interior_ring(poly, 1))", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_80", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_rings_holes", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "def test_get_rings_holes():\n    poly = Polygon([(0, 0), (4, 0), (4, 4), (0, 4), (0, 0)], holes=[[(1, 1), (2, 1), (2, 2), (1, 2), (1, 1)], [(3, 1), (3, 2), (2, 2), (2, 1), (3, 1)]])\n    rings = shapely.get_rings(poly)\n    assert (len(rings) == 3)\n    assert (rings[0] == shapely.get_exterior_ring(poly))\n    assert (rings[1] == shapely.get_interior_ring(poly, 0))\n    assert (rings[2] == shapely.get_interior_ring(poly, 1))", "masked_code": "def test_get_rings_holes():\n    poly = Polygon([(0, 0), (4, 0), (4, 4), (0, 4), (0, 0)], holes=[[(1, 1), (2, 1), (2, 2), (1, 2), (1, 1)], [(3, 1), (3, 2), (2, 2), (2, 1), (3, 1)]])\n    rings = shapely.get_rings(poly)\n    assert (len(rings) == 3)\n    assert (rings[0] == '???')\n    assert (rings[1] == shapely.get_interior_ring(poly, 0))\n    assert (rings[2] == shapely.get_interior_ring(poly, 1))", "ground_truth": ["<LINEARRING (0 0, 4 0, 4 4, 0 4, 0 0)>", "shapely.get_exterior_ring(poly)"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_81", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_rings_return_index", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "def test_get_rings_return_index():\n    poly1 = Polygon([(0, 0), (2, 0), (2, 2), (0, 2), (0, 0)])\n    poly2 = Polygon([(1, 1), (3, 1), (3, 3), (1, 3), (1, 1)], holes=[[(1.5, 1.5), (2.5, 1.5), (2.5, 2.5), (1.5, 2.5), (1.5, 1.5)]])\n    geom = np.array([poly1, None, empty_polygon, poly2])\n    expected_parts = []\n    expected_index = []\n    for (i, g) in enumerate(geom):\n        if ((g is None) or shapely.is_empty(g)):\n            continue\n        expected_parts.append(shapely.get_exterior_ring(g))\n        expected_index.append(i)\n        for j in range(shapely.get_num_interior_rings(g)):\n            expected_parts.append(shapely.get_interior_ring(g, j))\n            expected_index.append(i)\n    (parts, index) = shapely.get_rings(geom, return_index=True)\n    assert (len(parts) == len(expected_parts))\n    assert_geometries_equal(parts, expected_parts)\n    assert np.array_equal(index, expected_index)", "masked_code": "def test_get_rings_return_index():\n    poly1 = Polygon([(0, 0), (2, 0), (2, 2), (0, 2), (0, 0)])\n    poly2 = Polygon([(1, 1), (3, 1), (3, 3), (1, 3), (1, 1)], holes=[[(1.5, 1.5), (2.5, 1.5), (2.5, 2.5), (1.5, 2.5), (1.5, 1.5)]])\n    geom = np.array([poly1, None, empty_polygon, poly2])\n    expected_parts = []\n    expected_index = []\n    for (i, g) in enumerate(geom):\n        if ((g is None) or shapely.is_empty(g)):\n            continue\n        expected_parts.append(shapely.get_exterior_ring(g))\n        expected_index.append(i)\n        for j in range(shapely.get_num_interior_rings(g)):\n            expected_parts.append(shapely.get_interior_ring(g, j))\n            expected_index.append(i)\n    (parts, index) = shapely.get_rings(geom, return_index=True)\n    assert (len(parts) == '???')\n    assert_geometries_equal(parts, expected_parts)\n    assert np.array_equal(index, expected_index)", "ground_truth": ["3", "len(expected_parts)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_68", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_set_srid", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "def test_get_set_srid():\n    geo = Point((- 999999), 999999)\n    out1 = shapely.set_srid(geo, (- 4326))\n    out2 = shapely.set_srid(geo, 2147483647)\n    assert (shapely.get_srid(geo) == 0)\n    assert (shapely.get_srid(out1) == (- 4326))\n    assert (shapely.get_srid(out2) == 2147483647)", "masked_code": "def test_get_set_srid():\n    geo = Point((- 999999), 999999)\n    out1 = shapely.set_srid(geo, (- 4326))\n    out2 = shapely.set_srid(geo, 2147483647)\n    assert (shapely.get_srid(geo) == 0)\n    assert (shapely.get_srid(out1) == '???')\n    assert (shapely.get_srid(out2) == 2147483647)", "ground_truth": ["(- 4326)", "-4326"], "quality_analysis": {"complexity_score": 7, "left_complexity": 4, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_69", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_x", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "def test_get_x():\n    pts = [Point((- 100.123), 50.5), Point(0.0, 0.0)]\n    assert (shapely.get_x(pts).tolist() == [(- 100.123), 0.0])", "masked_code": "def test_get_x():\n    pts = [Point((- 100.123), 50.5), Point(0.0, 0.0)]\n    assert (shapely.get_x(pts).tolist() == '???')", "ground_truth": ["[(- 100.123), 0.0]", "[-100.123, 0.0]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_70", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_y", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "def test_get_y():\n    pts = [Point(1.1, (- 200.5)), Point(2.2, 999999.9999)]\n    assert (shapely.get_y(pts).tolist() == [(- 200.5), 999999.9999])", "masked_code": "def test_get_y():\n    pts = [Point(1.1, (- 200.5)), Point(2.2, 999999.9999)]\n    assert (shapely.get_y(pts).tolist() == '???')", "ground_truth": ["[(- 200.5), 999999.9999]", "[-200.5, 999999.9999]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_71", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_get_z", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "def test_get_z():\n    pts = [Point(0, 0, 0), Point(1, 1, (- 2.5)), Point(2, 2, 10000000000.0)]\n    assert (shapely.get_z(pts).tolist() == [0.0, (- 2.5), 10000000000.0])", "masked_code": "def test_get_z():\n    pts = [Point(0, 0, 0), Point(1, 1, (- 2.5)), Point(2, 2, 10000000000.0)]\n    assert (shapely.get_z(pts).tolist() == '???')", "ground_truth": ["[0.0, (- 2.5), 10000000000.0]", "[0.0, -2.5, 10000000000.0]"], "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_82", "reponame": "shapely", "testpath": "shapely/tests/test_geometry.py", "testname": "test_geometry.py", "funcname": "test_set_precision_intersection", "imports": ["import warnings", "import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, MultiPolygon, Point, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty as empty_geometry_collection, empty_line_string, empty_line_string_z, empty_point, empty_point_z, empty_polygon, equal_geometries_abnormally_yield_unequal, geometry_collection, geometry_collection_z, ignore_invalid, line_string, line_string_nan, line_string_z, linear_ring, multi_line_string, multi_line_string_z, multi_point, multi_point_z, multi_polygon, multi_polygon_z, point, point_m, point_z, point_zm, polygon, polygon_with_hole, polygon_with_hole_z, polygon_z", "from shapely import MultiPoint"], "code": "def test_set_precision_intersection():\n    'Operations should use the most precise precision grid size of the inputs'\n    box1 = shapely.normalize(shapely.box((- 2), (- 2), 0.6, 2.8))\n    box2 = shapely.normalize(shapely.box(0.75, (- 3), 3, 0.75))\n    assert (shapely.get_precision(shapely.intersection(box1, box2)) == 0)\n    box1 = shapely.set_precision(box1, 0.75)\n    box2 = shapely.set_precision(box2, 2)\n    out = shapely.intersection(box1, box2)\n    assert (shapely.get_precision(out) == 0.75)\n    assert_geometries_equal(out, Polygon([(0.75, (- 2.25)), (0, (- 2.25)), (0, 0), (0.75, 0), (0.75, (- 2.25))]))", "masked_code": "def test_set_precision_intersection():\n    'Operations should use the most precise precision grid size of the inputs'\n    box1 = shapely.normalize(shapely.box((- 2), (- 2), 0.6, 2.8))\n    box2 = shapely.normalize(shapely.box(0.75, (- 3), 3, 0.75))\n    assert (shapely.get_precision(shapely.intersection(box1, box2)) == 0)\n    box1 = shapely.set_precision(box1, 0.75)\n    box2 = shapely.set_precision(box2, 2)\n    out = shapely.intersection(box1, box2)\n    assert (shapely.get_precision(out) == '???')\n    assert_geometries_equal(out, Polygon([(0.75, (- 2.25)), (0, (- 2.25)), (0, 0), (0.75, 0), (0.75, (- 2.25))]))", "ground_truth": ["0.75"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_275", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_geometry_base.py", "testname": "test_geometry_base.py", "funcname": "test_reverse", "imports": ["import platform", "import weakref", "import numpy as np", "import pytest", "import shapely", "from shapely import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.errors import ShapelyDeprecationWarning", "from shapely.testing import assert_geometries_equal"], "code": "def test_reverse():\n    coords = [(0, 0), (1.5, (- 2.75)), (0, 0), (3, 0), (10, 10), ((- 5), 0), (0.0, 0.0)]\n    line = LineString(coords)\n    result = line.reverse()\n    assert (result.coords[:] == coords[::(- 1)])", "masked_code": "def test_reverse():\n    coords = [(0, 0), (1.5, (- 2.75)), (0, 0), (3, 0), (10, 10), ((- 5), 0), (0.0, 0.0)]\n    line = LineString(coords)\n    result = line.reverse()\n    assert (result.coords[:] == '???')", "ground_truth": ["[[0.0, 0.0], [-5, 0], [10, 10], [3, 0], [0, 0], [1.5, -2.75], [0, 0]]", "coords[::(- 1)]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_495", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linear_referencing.py", "testname": "test_linear_referencing.py", "funcname": "test_multiline_project", "imports": ["import unittest", "import pytest", "import shapely", "from shapely.geometry import LineString, MultiLineString, Point"], "code": "def test_multiline_project(self):\n    point = Point(3, 5)\n    assert (self.multiline.project(point) == 7.0)\n    assert (self.multiline.project(point, normalized=True) == 0.875)", "masked_code": "def test_multiline_project(self):\n    point = Point(3, 5)\n    assert (self.multiline.project(point) == '???')\n    assert (self.multiline.project(point, normalized=True) == 0.875)", "ground_truth": ["7.0"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LinearReferencingTestCase"}
{"task_id": "shapely_496", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == '???')\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "ground_truth": ["6"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_497", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == '???')\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "ground_truth": ["((- 5.5), 0.0)", "(-5.5, 0.0)"], "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_498", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == '???')\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "ground_truth": ["(15.0, 20.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_499", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == '???')\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_500", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == '???')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "ground_truth": ["'MultiLineString'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_501", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == '???')\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "ground_truth": ["(3.0, 3.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_502", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == '???')\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "ground_truth": ["(0.0, 0.0)"], "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_503", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_linemerge.py", "testname": "test_linemerge.py", "funcname": "test_linemerge", "imports": ["import unittest", "from shapely.geometry import LineString, MultiLineString", "from shapely.ops import linemerge"], "code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == 4)\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "masked_code": "def test_linemerge(self):\n    lines = MultiLineString([[((- 5.5), 0.0), (0, 0), (1.2, 1.3)], [(1.2, 1.3), (2, 5.5), (10, 10)], [(10, 10), (15, 20)]])\n    result = linemerge(lines)\n    assert isinstance(result, LineString)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 6)\n    assert (result.coords[0] == ((- 5.5), 0.0))\n    assert (result.coords[5] == (15.0, 20.0))\n    lines2 = MultiLineString([((0, 0), (3, 4.5)), ((3, 4.5), (7, 1)), ((7, 1), (0.0, 0.2))])\n    result = linemerge(lines2)\n    assert (not result.is_ring)\n    assert (len(result.coords) == 4)\n    lines3 = [LineString([(0, 0), (1, 1), (2, 2)]), LineString([(3, 3), (4, 4), (5, 5)])]\n    result = linemerge(lines3)\n    assert (result.geom_type == 'MultiLineString')\n    assert (len(result.geoms) == 2)\n    assert all((isinstance(g, LineString) for g in result.geoms))\n    lines4 = [[(0, 0), (0, 0)], [(0, 0), (0, 0)]]\n    result = linemerge(lines4)\n    from shapely.geometry.base import BaseGeometry\n    assert result.is_empty\n    lines5 = [((2, 2), (1, 1), (0, 0)), ((3, 3), (2, 2))]\n    result = linemerge(lines5)\n    assert isinstance(result, LineString)\n    assert (result.coords[0] == (3.0, 3.0))\n    assert (result.coords[(- 1)] == (0.0, 0.0))\n    assert (len(result.coords) == '???')\n    lines6 = MultiLineString([])\n    result = linemerge(lines6)\n    assert hasattr(result, 'is_empty')\n    assert result.is_empty\n    pass", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LineMergeTestCase"}
{"task_id": "shapely_276", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_coordinate_sequence", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_coordinate_sequence():\n    line = LineString([((- 10.5), 0.0), (5.1, (- 4.5)), ((- 10.5), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == [((- 10.5), 0.0), (5.1, (- 4.5)), ((- 10.5), 0.0)])\n    line = LineString([(0.0, 0.0), (10000000000.0, (- 10000000000.0))])\n    assert (line.coords[:] == [(0.0, 0.0), (10000000000.0, (- 10000000000.0))])", "masked_code": "def test_from_coordinate_sequence():\n    line = LineString([((- 10.5), 0.0), (5.1, (- 4.5)), ((- 10.5), 0.0)])\n    assert (len(line.coords) == '???')\n    assert (line.coords[:] == [((- 10.5), 0.0), (5.1, (- 4.5)), ((- 10.5), 0.0)])\n    line = LineString([(0.0, 0.0), (10000000000.0, (- 10000000000.0))])\n    assert (line.coords[:] == [(0.0, 0.0), (10000000000.0, (- 10000000000.0))])", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_277", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_coordinate_sequence", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_coordinate_sequence():\n    line = LineString([((- 10.5), 0.0), (5.1, (- 4.5)), ((- 10.5), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == [((- 10.5), 0.0), (5.1, (- 4.5)), ((- 10.5), 0.0)])\n    line = LineString([(0.0, 0.0), (10000000000.0, (- 10000000000.0))])\n    assert (line.coords[:] == [(0.0, 0.0), (10000000000.0, (- 10000000000.0))])", "masked_code": "def test_from_coordinate_sequence():\n    line = LineString([((- 10.5), 0.0), (5.1, (- 4.5)), ((- 10.5), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == '???')\n    line = LineString([(0.0, 0.0), (10000000000.0, (- 10000000000.0))])\n    assert (line.coords[:] == [(0.0, 0.0), (10000000000.0, (- 10000000000.0))])", "ground_truth": ["[((- 10.5), 0.0), (5.1, (- 4.5)), ((- 10.5), 0.0)]", "[[-10.5, 0.0], [5.1, -4.5], [-10.5, 0.0]]"], "quality_analysis": {"complexity_score": 25, "left_complexity": 5, "right_complexity": 20, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_278", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_coordinate_sequence_z", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_coordinate_sequence_z():\n    line = LineString([((- 1000.0), 5000.0, 9999.99), (100000.0, 200000.0, (- 123456789))])\n    assert line.has_z\n    assert (line.coords[:] == [((- 1000.0), 5000.0, 9999.99), (100000.0, 200000.0, (- 123456789.0))])", "masked_code": "def test_from_coordinate_sequence_z():\n    line = LineString([((- 1000.0), 5000.0, 9999.99), (100000.0, 200000.0, (- 123456789))])\n    assert line.has_z\n    assert (line.coords[:] == '???')", "ground_truth": ["[((- 1000.0), 5000.0, 9999.99), (100000.0, 200000.0, (- 123456789.0))]", "[[-1000.0, 5000.0, 9999.99], [100000.0, 200000.0, -123456789.0]]"], "quality_analysis": {"complexity_score": 21, "left_complexity": 5, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_289", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_empty():\n    line = LineString()\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])\n    line = LineString([])\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])\n    line = LineString(np.empty((0, 2)))\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])", "masked_code": "def test_from_empty():\n    line = LineString()\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == '???')\n    line = LineString([])\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])\n    line = LineString(np.empty((0, 2)))\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])", "ground_truth": ["[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_290", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_empty():\n    line = LineString()\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])\n    line = LineString([])\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])\n    line = LineString(np.empty((0, 2)))\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])", "masked_code": "def test_from_empty():\n    line = LineString()\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])\n    line = LineString([])\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == '???')\n    line = LineString(np.empty((0, 2)))\n    assert line.is_empty\n    assert isinstance(line.coords, CoordinateSequence)\n    assert (line.coords[:] == [])", "ground_truth": ["[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_288", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_generator", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_generator():\n    gen = (coord for coord in [(9999999.1, (- 9999999.1)), (0.0, 0.0), (1e-10, 10000000000.0)])\n    line = LineString(gen)\n    assert (line.coords[:] == [(9999999.1, (- 9999999.1)), (0.0, 0.0), (1e-10, 10000000000.0)])", "masked_code": "def test_from_generator():\n    gen = (coord for coord in [(9999999.1, (- 9999999.1)), (0.0, 0.0), (1e-10, 10000000000.0)])\n    line = LineString(gen)\n    assert (line.coords[:] == '???')", "ground_truth": ["[(9999999.1, (- 9999999.1)), (0.0, 0.0), (1e-10, 10000000000.0)]", "[[9999999.1, -9999999.1], [0.0, 0.0], [1e-10, 10000000000.0]]"], "quality_analysis": {"complexity_score": 21, "left_complexity": 5, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_284", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_linearring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_linearring():\n    coords = [((- 2.0), (- 2.0)), (0.0, (- 2.0)), (0.0, 2.0), ((- 2.0), (- 2.0))]\n    ring = LinearRing(coords)\n    copy = LineString(ring)\n    assert (copy.coords[:] == coords)\n    assert (copy.geom_type == 'LineString')", "masked_code": "def test_from_linearring():\n    coords = [((- 2.0), (- 2.0)), (0.0, (- 2.0)), (0.0, 2.0), ((- 2.0), (- 2.0))]\n    ring = LinearRing(coords)\n    copy = LineString(ring)\n    assert (copy.coords[:] == '???')\n    assert (copy.geom_type == 'LineString')", "ground_truth": ["[[-2.0, -2.0], [0.0, -2.0], [0.0, 2.0], [-2.0, -2.0]]", "coords"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_285", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_linearring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_linearring():\n    coords = [((- 2.0), (- 2.0)), (0.0, (- 2.0)), (0.0, 2.0), ((- 2.0), (- 2.0))]\n    ring = LinearRing(coords)\n    copy = LineString(ring)\n    assert (copy.coords[:] == coords)\n    assert (copy.geom_type == 'LineString')", "masked_code": "def test_from_linearring():\n    coords = [((- 2.0), (- 2.0)), (0.0, (- 2.0)), (0.0, 2.0), ((- 2.0), (- 2.0))]\n    ring = LinearRing(coords)\n    copy = LineString(ring)\n    assert (copy.coords[:] == coords)\n    assert (copy.geom_type == '???')", "ground_truth": ["'LineString'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_282", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_linestring():\n    line = LineString([(3, 4), (5, 6.5), ((- 2.4), 0), (3, 4)])\n    copy = LineString(line)\n    assert (copy.coords[:] == [(3.0, 4.0), (5.0, 6.5), ((- 2.4), 0.0), (3.0, 4.0)])\n    assert (copy.geom_type == 'LineString')", "masked_code": "def test_from_linestring():\n    line = LineString([(3, 4), (5, 6.5), ((- 2.4), 0), (3, 4)])\n    copy = LineString(line)\n    assert (copy.coords[:] == '???')\n    assert (copy.geom_type == 'LineString')", "ground_truth": ["[(3.0, 4.0), (5.0, 6.5), ((- 2.4), 0.0), (3.0, 4.0)]", "[[3.0, 4.0], [5.0, 6.5], [-2.4, 0.0], [3.0, 4.0]]"], "quality_analysis": {"complexity_score": 25, "left_complexity": 5, "right_complexity": 20, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_283", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_linestring():\n    line = LineString([(3, 4), (5, 6.5), ((- 2.4), 0), (3, 4)])\n    copy = LineString(line)\n    assert (copy.coords[:] == [(3.0, 4.0), (5.0, 6.5), ((- 2.4), 0.0), (3.0, 4.0)])\n    assert (copy.geom_type == 'LineString')", "masked_code": "def test_from_linestring():\n    line = LineString([(3, 4), (5, 6.5), ((- 2.4), 0), (3, 4)])\n    copy = LineString(line)\n    assert (copy.coords[:] == [(3.0, 4.0), (5.0, 6.5), ((- 2.4), 0.0), (3.0, 4.0)])\n    assert (copy.geom_type == '???')", "ground_truth": ["'LineString'", "[[3.0, 4.0], [5.0, 6.5], [-2.4, 0.0], [3.0, 4.0]]"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_286", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_linestring_z", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_linestring_z():\n    coords = [((- 100.5), 0.0, 1.3), (3.3, 2.2, 4.4)]\n    line = LineString(coords)\n    copy = LineString(line)\n    assert (copy.coords[:] == [((- 100.5), 0.0, 1.3), (3.3, 2.2, 4.4)])\n    assert (copy.geom_type == 'LineString')", "masked_code": "def test_from_linestring_z():\n    coords = [((- 100.5), 0.0, 1.3), (3.3, 2.2, 4.4)]\n    line = LineString(coords)\n    copy = LineString(line)\n    assert (copy.coords[:] == '???')\n    assert (copy.geom_type == 'LineString')", "ground_truth": ["[((- 100.5), 0.0, 1.3), (3.3, 2.2, 4.4)]", "[[-100.5, 0.0, 1.3], [3.3, 2.2, 4.4]]"], "quality_analysis": {"complexity_score": 19, "left_complexity": 5, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_287", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_linestring_z", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_linestring_z():\n    coords = [((- 100.5), 0.0, 1.3), (3.3, 2.2, 4.4)]\n    line = LineString(coords)\n    copy = LineString(line)\n    assert (copy.coords[:] == [((- 100.5), 0.0, 1.3), (3.3, 2.2, 4.4)])\n    assert (copy.geom_type == 'LineString')", "masked_code": "def test_from_linestring_z():\n    coords = [((- 100.5), 0.0, 1.3), (3.3, 2.2, 4.4)]\n    line = LineString(coords)\n    copy = LineString(line)\n    assert (copy.coords[:] == [((- 100.5), 0.0, 1.3), (3.3, 2.2, 4.4)])\n    assert (copy.geom_type == '???')", "ground_truth": ["'LineString'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_281", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_mix", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_mix():\n    line = LineString([Point(42, 100), ((- 100.5), 0.5), Point(0, 0)])\n    assert (line.coords[:] == [(42.0, 100.0), ((- 100.5), 0.5), (0.0, 0.0)])", "masked_code": "def test_from_mix():\n    line = LineString([Point(42, 100), ((- 100.5), 0.5), Point(0, 0)])\n    assert (line.coords[:] == '???')", "ground_truth": ["[(42.0, 100.0), ((- 100.5), 0.5), (0.0, 0.0)]", "[[42.0, 100.0], [-100.5, 0.5], [0.0, 0.0]]"], "quality_analysis": {"complexity_score": 21, "left_complexity": 5, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_291", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_numpy", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_numpy():\n    arr = np.array([[(- 1000.5), 2000.5], [3.14, (- 44.0)], [0.0, 0.0]])\n    line = LineString(arr)\n    assert (line.coords[:] == [((- 1000.5), 2000.5), (3.14, (- 44.0)), (0.0, 0.0)])", "masked_code": "def test_from_numpy():\n    arr = np.array([[(- 1000.5), 2000.5], [3.14, (- 44.0)], [0.0, 0.0]])\n    line = LineString(arr)\n    assert (line.coords[:] == '???')", "ground_truth": ["[((- 1000.5), 2000.5), (3.14, (- 44.0)), (0.0, 0.0)]", "[[-1000.5, 2000.5], [3.14, -44.0], [0.0, 0.0]]"], "quality_analysis": {"complexity_score": 23, "left_complexity": 5, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_279", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_points", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_points():\n    line = LineString([Point((- 1.5), 0.0), Point(123456.789, (- 98765.4321))])\n    assert (line.coords[:] == [((- 1.5), 0.0), (123456.789, (- 98765.4321))])\n    line = LineString([Point(0, 0), Point((- 1), (- 1))])\n    assert (line.coords[:] == [(0.0, 0.0), ((- 1.0), (- 1.0))])", "masked_code": "def test_from_points():\n    line = LineString([Point((- 1.5), 0.0), Point(123456.789, (- 98765.4321))])\n    assert (line.coords[:] == '???')\n    line = LineString([Point(0, 0), Point((- 1), (- 1))])\n    assert (line.coords[:] == [(0.0, 0.0), ((- 1.0), (- 1.0))])", "ground_truth": ["[((- 1.5), 0.0), (123456.789, (- 98765.4321))]"], "quality_analysis": {"complexity_score": 19, "left_complexity": 5, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_280", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_from_points", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_from_points():\n    line = LineString([Point((- 1.5), 0.0), Point(123456.789, (- 98765.4321))])\n    assert (line.coords[:] == [((- 1.5), 0.0), (123456.789, (- 98765.4321))])\n    line = LineString([Point(0, 0), Point((- 1), (- 1))])\n    assert (line.coords[:] == [(0.0, 0.0), ((- 1.0), (- 1.0))])", "masked_code": "def test_from_points():\n    line = LineString([Point((- 1.5), 0.0), Point(123456.789, (- 98765.4321))])\n    assert (line.coords[:] == [((- 1.5), 0.0), (123456.789, (- 98765.4321))])\n    line = LineString([Point(0, 0), Point((- 1), (- 1))])\n    assert (line.coords[:] == '???')", "ground_truth": ["[(0.0, 0.0), ((- 1.0), (- 1.0))]", "[[0.0, 0.0], [-1.0, -1.0]]"], "quality_analysis": {"complexity_score": 19, "left_complexity": 5, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_296", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring(self):\n    line = LineString([(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == [(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (line.bounds == ((- 999.999), (- 8765.4321), 1234.5678, 0.0))\n    assert (tuple(line.coords) == ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)))\n    assert (line.coords[0] == (0.0, 0.0))\n    assert (line.coords[2] == ((- 999.999), 0.0))\n    with pytest.raises(IndexError):\n        line.coords[3]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0))})", "masked_code": "def test_linestring(self):\n    line = LineString([(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (len(line.coords) == '???')\n    assert (line.coords[:] == [(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (line.bounds == ((- 999.999), (- 8765.4321), 1234.5678, 0.0))\n    assert (tuple(line.coords) == ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)))\n    assert (line.coords[0] == (0.0, 0.0))\n    assert (line.coords[2] == ((- 999.999), 0.0))\n    with pytest.raises(IndexError):\n        line.coords[3]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0))})", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_297", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring(self):\n    line = LineString([(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == [(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (line.bounds == ((- 999.999), (- 8765.4321), 1234.5678, 0.0))\n    assert (tuple(line.coords) == ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)))\n    assert (line.coords[0] == (0.0, 0.0))\n    assert (line.coords[2] == ((- 999.999), 0.0))\n    with pytest.raises(IndexError):\n        line.coords[3]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0))})", "masked_code": "def test_linestring(self):\n    line = LineString([(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == '???')\n    assert (line.bounds == ((- 999.999), (- 8765.4321), 1234.5678, 0.0))\n    assert (tuple(line.coords) == ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)))\n    assert (line.coords[0] == (0.0, 0.0))\n    assert (line.coords[2] == ((- 999.999), 0.0))\n    with pytest.raises(IndexError):\n        line.coords[3]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0))})", "ground_truth": ["[(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)]", "[[0.0, 0.0], [1234.5678, -8765.4321], [-999.999, 0.0]]"], "quality_analysis": {"complexity_score": 23, "left_complexity": 5, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_298", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring(self):\n    line = LineString([(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == [(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (line.bounds == ((- 999.999), (- 8765.4321), 1234.5678, 0.0))\n    assert (tuple(line.coords) == ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)))\n    assert (line.coords[0] == (0.0, 0.0))\n    assert (line.coords[2] == ((- 999.999), 0.0))\n    with pytest.raises(IndexError):\n        line.coords[3]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0))})", "masked_code": "def test_linestring(self):\n    line = LineString([(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == [(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (line.bounds == '???')\n    assert (tuple(line.coords) == ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)))\n    assert (line.coords[0] == (0.0, 0.0))\n    assert (line.coords[2] == ((- 999.999), 0.0))\n    with pytest.raises(IndexError):\n        line.coords[3]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0))})", "ground_truth": ["((- 999.999), (- 8765.4321), 1234.5678, 0.0)", "(-999.999, -8765.4321, 1234.5678, 0.0)"], "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_299", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring(self):\n    line = LineString([(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == [(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (line.bounds == ((- 999.999), (- 8765.4321), 1234.5678, 0.0))\n    assert (tuple(line.coords) == ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)))\n    assert (line.coords[0] == (0.0, 0.0))\n    assert (line.coords[2] == ((- 999.999), 0.0))\n    with pytest.raises(IndexError):\n        line.coords[3]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0))})", "masked_code": "def test_linestring(self):\n    line = LineString([(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == [(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (line.bounds == ((- 999.999), (- 8765.4321), 1234.5678, 0.0))\n    assert (tuple(line.coords) == '???')\n    assert (line.coords[0] == (0.0, 0.0))\n    assert (line.coords[2] == ((- 999.999), 0.0))\n    with pytest.raises(IndexError):\n        line.coords[3]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0))})", "ground_truth": ["((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0))", "([0.0, 0.0], [1234.5678, -8765.4321], [-999.999, 0.0])"], "quality_analysis": {"complexity_score": 23, "left_complexity": 5, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_300", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring(self):\n    line = LineString([(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == [(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (line.bounds == ((- 999.999), (- 8765.4321), 1234.5678, 0.0))\n    assert (tuple(line.coords) == ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)))\n    assert (line.coords[0] == (0.0, 0.0))\n    assert (line.coords[2] == ((- 999.999), 0.0))\n    with pytest.raises(IndexError):\n        line.coords[3]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0))})", "masked_code": "def test_linestring(self):\n    line = LineString([(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == [(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (line.bounds == ((- 999.999), (- 8765.4321), 1234.5678, 0.0))\n    assert (tuple(line.coords) == ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)))\n    assert (line.coords[0] == '???')\n    assert (line.coords[2] == ((- 999.999), 0.0))\n    with pytest.raises(IndexError):\n        line.coords[3]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0))})", "ground_truth": ["(0.0, 0.0)"], "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_301", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring(self):\n    line = LineString([(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == [(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (line.bounds == ((- 999.999), (- 8765.4321), 1234.5678, 0.0))\n    assert (tuple(line.coords) == ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)))\n    assert (line.coords[0] == (0.0, 0.0))\n    assert (line.coords[2] == ((- 999.999), 0.0))\n    with pytest.raises(IndexError):\n        line.coords[3]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0))})", "masked_code": "def test_linestring(self):\n    line = LineString([(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (len(line.coords) == 3)\n    assert (line.coords[:] == [(0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)])\n    assert (line.bounds == ((- 999.999), (- 8765.4321), 1234.5678, 0.0))\n    assert (tuple(line.coords) == ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0)))\n    assert (line.coords[0] == (0.0, 0.0))\n    assert (line.coords[2] == '???')\n    with pytest.raises(IndexError):\n        line.coords[3]\n    assert (line.__geo_interface__ == {'type': 'LineString', 'coordinates': ((0.0, 0.0), (1234.5678, (- 8765.4321)), ((- 999.999), 0.0))})", "ground_truth": ["((- 999.999), 0.0)", "(-999.999, 0.0)"], "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_294", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring_array_coercion", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring_array_coercion():\n    line = LineString([(0.0, 0.0), (10.0, (- 10.0)), ((- 99.0), 99.0)])\n    arr = np.array(line)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == line)", "masked_code": "def test_linestring_array_coercion():\n    line = LineString([(0.0, 0.0), (10.0, (- 10.0)), ((- 99.0), 99.0)])\n    arr = np.array(line)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == '???')\n    assert (arr.item() == line)", "ground_truth": ["dtype('O')", "np.dtype('object')"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_295", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring_array_coercion", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring_array_coercion():\n    line = LineString([(0.0, 0.0), (10.0, (- 10.0)), ((- 99.0), 99.0)])\n    arr = np.array(line)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == line)", "masked_code": "def test_linestring_array_coercion():\n    line = LineString([(0.0, 0.0), (10.0, (- 10.0)), ((- 99.0), 99.0)])\n    arr = np.array(line)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == '???')", "ground_truth": ["<LINESTRING (0 0, 10 -10, -99 99)>", "line"], "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_302", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_linestring_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_linestring_empty(self):\n    l_null = LineString([])\n    assert (l_null.wkt == 'LINESTRING EMPTY')\n    assert (l_null.length == 0.0)", "masked_code": "def test_linestring_empty(self):\n    l_null = LineString([])\n    assert (l_null.wkt == '???')\n    assert (l_null.length == 0.0)", "ground_truth": ["'LINESTRING EMPTY'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestLineString"}
{"task_id": "shapely_292", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_numpy_empty_linestring_coords", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_numpy_empty_linestring_coords():\n    line = LineString([])\n    la = np.asarray(line.coords)\n    assert (la.shape == (0, 2))", "masked_code": "def test_numpy_empty_linestring_coords():\n    line = LineString([])\n    la = np.asarray(line.coords)\n    assert (la.shape == '???')", "ground_truth": ["(0, 2)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_293", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_linestring.py", "testname": "test_linestring.py", "funcname": "test_numpy_object_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import LinearRing, LineString, Point", "from shapely.coords import CoordinateSequence"], "code": "def test_numpy_object_array():\n    geom = LineString([(1.5, 30000000000.0), ((- 9e-09), 1e-07)])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == geom)", "masked_code": "def test_numpy_object_array():\n    geom = LineString([(1.5, 30000000000.0), ((- 9e-09), 1e-07)])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == '???')", "ground_truth": ["<LINESTRING (1.5 30000000000, 0 0)>", "geom"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_504", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_make_valid.py", "testname": "test_make_valid.py", "funcname": "test_make_valid_input", "imports": ["from shapely.geometry import Polygon", "from shapely.validation import make_valid"], "code": "def test_make_valid_input():\n    geom = Polygon([(0, 0), (4, 0), (8, 0), (8, 8), (4, 8), (0, 8), (0, 0)])\n    valid = make_valid(geom)\n    assert (id(valid) == id(geom))", "masked_code": "def test_make_valid_input():\n    geom = Polygon([(0, 0), (4, 0), (8, 0), (8, 8), (4, 8), (0, 8), (0, 0)])\n    valid = make_valid(geom)\n    assert (id(valid) == '???')", "ground_truth": ["140718532427712", "id(geom)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_505", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_mapping.py", "testname": "test_mapping.py", "funcname": "test_point", "imports": ["import unittest", "from shapely.geometry import Point, Polygon, mapping"], "code": "def test_point(self):\n    m = mapping(Point((- 123456789), 1.7e+308))\n    assert (m['type'] == 'Point')\n    assert (m['coordinates'] == ((- 123456789.0), 1.7e+308))", "masked_code": "def test_point(self):\n    m = mapping(Point((- 123456789), 1.7e+308))\n    assert (m['type'] == '???')\n    assert (m['coordinates'] == ((- 123456789.0), 1.7e+308))", "ground_truth": ["'Point'"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "MappingTestCase"}
{"task_id": "shapely_506", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_mapping.py", "testname": "test_mapping.py", "funcname": "test_point", "imports": ["import unittest", "from shapely.geometry import Point, Polygon, mapping"], "code": "def test_point(self):\n    m = mapping(Point((- 123456789), 1.7e+308))\n    assert (m['type'] == 'Point')\n    assert (m['coordinates'] == ((- 123456789.0), 1.7e+308))", "masked_code": "def test_point(self):\n    m = mapping(Point((- 123456789), 1.7e+308))\n    assert (m['type'] == 'Point')\n    assert (m['coordinates'] == '???')", "ground_truth": ["((- 123456789.0), 1.7e+308)", "(-123456789.0, 1.7e+308)"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "MappingTestCase"}
{"task_id": "shapely_164", "reponame": "shapely", "testpath": "shapely/tests/test_measurement.py", "testname": "test_measurement.py", "funcname": "test_area", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_array_equal", "import shapely", "from shapely import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.tests.common import empty, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, point, point_polygon_testdata, polygon, polygon_with_hole", "from shapely.tests.common import multi_polygon"], "code": "def test_area():\n    poly1 = Polygon([(0, 0), (10, 0), (5, 5), (0, 0)])\n    poly2 = Polygon([(100, 100), (110, 100), (110, 120), (100, 120), (100, 100)])\n    poly3 = Polygon([((- 2), (- 2)), ((- 2), (- 1.9)), ((- 1.9), (- 1.9)), ((- 1.9), (- 2)), ((- 2), (- 2))])\n    poly4 = Polygon([(0, 0), (1, 10), (2, 0), (0, 0)])\n    actual = shapely.area([poly1, poly2, poly3, poly4])\n    assert (actual.tolist() == [25.0, 200.0, 0.010000000000000018, 10.0])", "masked_code": "def test_area():\n    poly1 = Polygon([(0, 0), (10, 0), (5, 5), (0, 0)])\n    poly2 = Polygon([(100, 100), (110, 100), (110, 120), (100, 120), (100, 100)])\n    poly3 = Polygon([((- 2), (- 2)), ((- 2), (- 1.9)), ((- 1.9), (- 1.9)), ((- 1.9), (- 2)), ((- 2), (- 2))])\n    poly4 = Polygon([(0, 0), (1, 10), (2, 0), (0, 0)])\n    actual = shapely.area([poly1, poly2, poly3, poly4])\n    assert (actual.tolist() == '???')", "ground_truth": ["[25.0, 200.0, 0.010000000000000018, 10.0]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_165", "reponame": "shapely", "testpath": "shapely/tests/test_measurement.py", "testname": "test_measurement.py", "funcname": "test_bounds_dimensions", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_array_equal", "import shapely", "from shapely import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.tests.common import empty, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, point, point_polygon_testdata, polygon, polygon_with_hole", "from shapely.tests.common import multi_polygon"], "code": "@pytest.mark.parametrize('geom,shape', [(point, (4,)), (None, (4,)), ([point, multi_point], (2, 4)), ([[point, multi_point], [polygon, point]], (2, 2, 4)), ([[[point, multi_point]], [[polygon, point]]], (2, 1, 2, 4))])\ndef test_bounds_dimensions(geom, shape):\n    assert (shapely.bounds(geom).shape == shape)", "masked_code": "@pytest.mark.parametrize('geom,shape', [(point, (4,)), (None, (4,)), ([point, multi_point], (2, 4)), ([[point, multi_point], [polygon, point]], (2, 2, 4)), ([[[point, multi_point]], [[polygon, point]]], (2, 1, 2, 4))])\ndef test_bounds_dimensions(geom, shape):\n    assert (shapely.bounds(geom).shape == '???')", "ground_truth": ["(4,)", "shape"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_166", "reponame": "shapely", "testpath": "shapely/tests/test_measurement.py", "testname": "test_measurement.py", "funcname": "test_total_bounds_dimensions", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_allclose, assert_array_equal", "import shapely", "from shapely import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.tests.common import empty, geometry_collection, ignore_invalid, line_string, linear_ring, multi_line_string, multi_point, point, point_polygon_testdata, polygon, polygon_with_hole", "from shapely.tests.common import multi_polygon"], "code": "@pytest.mark.parametrize('geom', [point, None, [point, multi_point], [[point, multi_point], [polygon, point]], [[[point, multi_point]], [[polygon, point]]]])\ndef test_total_bounds_dimensions(geom):\n    assert (shapely.total_bounds(geom).shape == (4,))", "masked_code": "@pytest.mark.parametrize('geom', [point, None, [point, multi_point], [[point, multi_point], [polygon, point]], [[[point, multi_point]], [[polygon, point]]]])\ndef test_total_bounds_dimensions(geom):\n    assert (shapely.total_bounds(geom).shape == '???')", "ground_truth": ["(4,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_508", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_minimum_clearance.py", "testname": "test_minimum_clearance.py", "funcname": "test_linestring", "imports": ["import math", "from shapely.wkt import loads as load_wkt"], "code": "def test_linestring():\n    line = load_wkt('LINESTRING (0 0, -3.5 4.5, 7.2 -2.3, 10.7 8.8)')\n    assert (round(line.minimum_clearance, 6) == 1.92066)", "masked_code": "def test_linestring():\n    line = load_wkt('LINESTRING (0 0, -3.5 4.5, 7.2 -2.3, 10.7 8.8)')\n    assert (round(line.minimum_clearance, 6) == '???')", "ground_truth": ["1.92066"], "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_509", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_minimum_clearance.py", "testname": "test_minimum_clearance.py", "funcname": "test_more_complicated_polygon", "imports": ["import math", "from shapely.wkt import loads as load_wkt"], "code": "def test_more_complicated_polygon():\n    poly = load_wkt('POLYGON ((100 100, 250 400, 400 550, 600 540, 650 300, 500 200, 550 450, 300 350, 200 150, 100 100))')\n    assert (round(poly.minimum_clearance, 6) == 67.082039)", "masked_code": "def test_more_complicated_polygon():\n    poly = load_wkt('POLYGON ((100 100, 250 400, 400 550, 600 540, 650 300, 500 200, 550 450, 300 350, 200 150, 100 100))')\n    assert (round(poly.minimum_clearance, 6) == '???')", "ground_truth": ["67.082039"], "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_507", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_minimum_clearance.py", "testname": "test_minimum_clearance.py", "funcname": "test_point", "imports": ["import math", "from shapely.wkt import loads as load_wkt"], "code": "def test_point():\n    point = load_wkt('POINT (-1e10 1e10)')\n    assert (point.minimum_clearance == math.inf)", "masked_code": "def test_point():\n    point = load_wkt('POINT (-1e10 1e10)')\n    assert (point.minimum_clearance == '???')", "ground_truth": ["inf", "math.inf"], "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_172", "reponame": "shapely", "testpath": "shapely/tests/test_misc.py", "testname": "test_misc.py", "funcname": "test_multithreading_enabled_ok", "imports": ["import os", "import sys", "from inspect import cleandoc", "from itertools import chain", "from string import ascii_letters, digits", "from unittest import mock", "import numpy as np", "import pytest", "import shapely", "from shapely.decorators import multithreading_enabled, requires_geos"], "code": "@pytest.mark.parametrize('args,kwargs', [((np.empty((1,), dtype=np.int64),), {}), ((), {'a': np.empty((1,), dtype=np.int64)}), (([''],), {}), ((), {'a': ['', None]}), ((), {'out': np.empty((1,), dtype=float)}), ((), {'where': np.empty((1,), dtype=float)}), ((np.array([0], dtype=object),), {}), ((np.array([(- 999)], dtype=object),), {})])\ndef test_multithreading_enabled_ok(args, kwargs):\n    if ((len(args) == 1) and isinstance(args[0], np.ndarray) and (args[0].dtype == object) and ((args[0][0] == 0) or (args[0][0] == (- 999)))):\n        with pytest.raises(ValueError):\n            set_first_element((- 99999), *args, **kwargs)\n    else:\n        result = set_first_element((- 99999), *args, **kwargs)\n        assert (result[0] == (- 99999))", "masked_code": "@pytest.mark.parametrize('args,kwargs', [((np.empty((1,), dtype=np.int64),), {}), ((), {'a': np.empty((1,), dtype=np.int64)}), (([''],), {}), ((), {'a': ['', None]}), ((), {'out': np.empty((1,), dtype=float)}), ((), {'where': np.empty((1,), dtype=float)}), ((np.array([0], dtype=object),), {}), ((np.array([(- 999)], dtype=object),), {})])\ndef test_multithreading_enabled_ok(args, kwargs):\n    if ((len(args) == 1) and isinstance(args[0], np.ndarray) and (args[0].dtype == object) and ((args[0][0] == 0) or (args[0][0] == (- 999)))):\n        with pytest.raises(ValueError):\n            set_first_element((- 99999), *args, **kwargs)\n    else:\n        result = set_first_element((- 99999), *args, **kwargs)\n        assert (result[0] == '???')", "ground_truth": ["(- 99999)", "-99999"], "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_171", "reponame": "shapely", "testpath": "shapely/tests/test_misc.py", "testname": "test_misc.py", "funcname": "test_multithreading_enabled_raises_arg", "imports": ["import os", "import sys", "from inspect import cleandoc", "from itertools import chain", "from string import ascii_letters, digits", "from unittest import mock", "import numpy as np", "import pytest", "import shapely", "from shapely.decorators import multithreading_enabled, requires_geos"], "code": "def test_multithreading_enabled_raises_arg():\n    arr = np.empty((1,), dtype=float)\n    set_first_element((- 100000000000000.0), arr)\n    arr[0] = (- 100000000000000.0)\n    assert (arr[0] == (- 100000000000000.0))", "masked_code": "def test_multithreading_enabled_raises_arg():\n    arr = np.empty((1,), dtype=float)\n    set_first_element((- 100000000000000.0), arr)\n    arr[0] = (- 100000000000000.0)\n    assert (arr[0] == '???')", "ground_truth": ["(- 100000000000000.0)", "-100000000000000.0"], "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_169", "reponame": "shapely", "testpath": "shapely/tests/test_misc.py", "testname": "test_misc.py", "funcname": "test_requires_geos_doc_build", "imports": ["import os", "import sys", "from inspect import cleandoc", "from itertools import chain", "from string import ascii_letters, digits", "from unittest import mock", "import numpy as np", "import pytest", "import shapely", "from shapely.decorators import multithreading_enabled, requires_geos"], "code": "@pytest.mark.parametrize('version', ['0.0.0', '100.100.100', '2.8.7'])\ndef test_requires_geos_doc_build(version, mocked_geos_version, sphinx_doc_build):\n    'The requires_geos decorator always adapts the docstring.'\n    wrapped = requires_geos(version)(func)\n    assert (wrapped.__doc__ == expected_docstring(version=version, indent=(' ' * 4)))", "masked_code": "@pytest.mark.parametrize('version', ['0.0.0', '100.100.100', '2.8.7'])\ndef test_requires_geos_doc_build(version, mocked_geos_version, sphinx_doc_build):\n    'The requires_geos decorator always adapts the docstring.'\n    wrapped = requires_geos(version)(func)\n    assert (wrapped.__doc__ == '???')", "ground_truth": ["\"Docstring that will be mocked.\\n    A multiline.\\n\\n    .. note:: 'func' requires at least GEOS 0.0.0.\\n\\n    Some description.\\n    \"", "expected_docstring(version=version, indent=(' ' * 4))"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_170", "reponame": "shapely", "testpath": "shapely/tests/test_misc.py", "testname": "test_misc.py", "funcname": "test_requires_geos_method", "imports": ["import os", "import sys", "from inspect import cleandoc", "from itertools import chain", "from string import ascii_letters, digits", "from unittest import mock", "import numpy as np", "import pytest", "import shapely", "from shapely.decorators import multithreading_enabled, requires_geos"], "code": "@pytest.mark.parametrize('version', ['999.999.999', '0.0.1', '4.4.4'])\ndef test_requires_geos_method(version, mocked_geos_version, sphinx_doc_build):\n    'The requires_geos decorator adjusts methods docstrings correctly'\n    wrapped = requires_geos(version)(SomeClass.func)\n    assert (wrapped.__doc__ == expected_docstring(version=version, indent=(' ' * 8)))", "masked_code": "@pytest.mark.parametrize('version', ['999.999.999', '0.0.1', '4.4.4'])\ndef test_requires_geos_method(version, mocked_geos_version, sphinx_doc_build):\n    'The requires_geos decorator adjusts methods docstrings correctly'\n    wrapped = requires_geos(version)(SomeClass.func)\n    assert (wrapped.__doc__ == '???')", "ground_truth": ["\"Docstring that will be mocked.\\n        A multiline.\\n\\n        .. note:: 'func' requires at least GEOS 999.999.999.\\n\\n        Some description.\\n        \"", "expected_docstring(version=version, indent=(' ' * 8))"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_168", "reponame": "shapely", "testpath": "shapely/tests/test_misc.py", "testname": "test_misc.py", "funcname": "test_requires_geos_not_ok", "imports": ["import os", "import sys", "from inspect import cleandoc", "from itertools import chain", "from string import ascii_letters, digits", "from unittest import mock", "import numpy as np", "import pytest", "import shapely", "from shapely.decorators import multithreading_enabled, requires_geos"], "code": "@pytest.mark.parametrize('version', ['3.11.5', '4.0.0', '4.0.1', '999.0.0'])\ndef test_requires_geos_not_ok(version, mocked_geos_version):\n    wrapped = requires_geos(version)(func)\n    with pytest.raises(shapely.errors.UnsupportedGEOSVersionError):\n        wrapped()\n    assert (wrapped.__doc__ == expected_docstring(version=version, indent=(' ' * 4)))", "masked_code": "@pytest.mark.parametrize('version', ['3.11.5', '4.0.0', '4.0.1', '999.0.0'])\ndef test_requires_geos_not_ok(version, mocked_geos_version):\n    wrapped = requires_geos(version)(func)\n    with pytest.raises(shapely.errors.UnsupportedGEOSVersionError):\n        wrapped()\n    assert (wrapped.__doc__ == '???')", "ground_truth": ["\"Docstring that will be mocked.\\n    A multiline.\\n\\n    .. note:: 'func' requires at least GEOS 3.11.5.\\n\\n    Some description.\\n    \"", "expected_docstring(version=version, indent=(' ' * 4))"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_309", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_from_multilinestring_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_from_multilinestring_z(self):\n    coords1 = [((- 1000.0), (- 1.0), (- 2.0)), (3.33, 4.44, 0.0)]\n    coords2 = [(6.6, 7.7, 8.8), (0.0, 0.0, (- 99999.9))]\n    ml = MultiLineString([coords1, coords2])\n    copy = MultiLineString(ml)\n    assert isinstance(copy, MultiLineString)\n    assert (copy.geom_type == 'MultiLineString')\n    assert (len(copy.geoms) == 2)\n    assert (dump_coords(copy.geoms[0]) == coords1)\n    assert (dump_coords(copy.geoms[1]) == coords2)", "masked_code": "def test_from_multilinestring_z(self):\n    coords1 = [((- 1000.0), (- 1.0), (- 2.0)), (3.33, 4.44, 0.0)]\n    coords2 = [(6.6, 7.7, 8.8), (0.0, 0.0, (- 99999.9))]\n    ml = MultiLineString([coords1, coords2])\n    copy = MultiLineString(ml)\n    assert isinstance(copy, MultiLineString)\n    assert (copy.geom_type == '???')\n    assert (len(copy.geoms) == 2)\n    assert (dump_coords(copy.geoms[0]) == coords1)\n    assert (dump_coords(copy.geoms[1]) == coords2)", "ground_truth": ["'MultiLineString'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_310", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_from_multilinestring_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_from_multilinestring_z(self):\n    coords1 = [((- 1000.0), (- 1.0), (- 2.0)), (3.33, 4.44, 0.0)]\n    coords2 = [(6.6, 7.7, 8.8), (0.0, 0.0, (- 99999.9))]\n    ml = MultiLineString([coords1, coords2])\n    copy = MultiLineString(ml)\n    assert isinstance(copy, MultiLineString)\n    assert (copy.geom_type == 'MultiLineString')\n    assert (len(copy.geoms) == 2)\n    assert (dump_coords(copy.geoms[0]) == coords1)\n    assert (dump_coords(copy.geoms[1]) == coords2)", "masked_code": "def test_from_multilinestring_z(self):\n    coords1 = [((- 1000.0), (- 1.0), (- 2.0)), (3.33, 4.44, 0.0)]\n    coords2 = [(6.6, 7.7, 8.8), (0.0, 0.0, (- 99999.9))]\n    ml = MultiLineString([coords1, coords2])\n    copy = MultiLineString(ml)\n    assert isinstance(copy, MultiLineString)\n    assert (copy.geom_type == 'MultiLineString')\n    assert (len(copy.geoms) == 2)\n    assert (dump_coords(copy.geoms[0]) == '???')\n    assert (dump_coords(copy.geoms[1]) == coords2)", "ground_truth": ["[[-1000.0, -1.0, -2.0], [3.33, 4.44, 0.0]]", "coords1"], "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_311", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_from_multilinestring_z", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_from_multilinestring_z(self):\n    coords1 = [((- 1000.0), (- 1.0), (- 2.0)), (3.33, 4.44, 0.0)]\n    coords2 = [(6.6, 7.7, 8.8), (0.0, 0.0, (- 99999.9))]\n    ml = MultiLineString([coords1, coords2])\n    copy = MultiLineString(ml)\n    assert isinstance(copy, MultiLineString)\n    assert (copy.geom_type == 'MultiLineString')\n    assert (len(copy.geoms) == 2)\n    assert (dump_coords(copy.geoms[0]) == coords1)\n    assert (dump_coords(copy.geoms[1]) == coords2)", "masked_code": "def test_from_multilinestring_z(self):\n    coords1 = [((- 1000.0), (- 1.0), (- 2.0)), (3.33, 4.44, 0.0)]\n    coords2 = [(6.6, 7.7, 8.8), (0.0, 0.0, (- 99999.9))]\n    ml = MultiLineString([coords1, coords2])\n    copy = MultiLineString(ml)\n    assert isinstance(copy, MultiLineString)\n    assert (copy.geom_type == 'MultiLineString')\n    assert (len(copy.geoms) == 2)\n    assert (dump_coords(copy.geoms[0]) == coords1)\n    assert (dump_coords(copy.geoms[1]) == '???')", "ground_truth": ["[[6.6, 7.7, 8.8], [0.0, 0.0, -99999.9]]", "coords2"], "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_304", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_multilinestring", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multilinestring(self):\n    with pytest.raises(ValueError):\n        MultiLineString([[(1000000.5, (- 2000000.5)), (3.5, 4.5, 11111.3)]])\n    a = LineString([((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)]])\n    b = LineString([(10.1, 20.2), (30.3, 40.4)])\n    ml2 = MultiLineString([a, b])\n    ml2_copied = MultiLineString(ml2)\n    assert (len(ml2_copied.geoms) == 2)\n    assert (dump_coords(ml2_copied) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)], [(10.1, 20.2), (30.3, 40.4)]])\n    geom = MultiLineString([((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0)))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))),)})", "masked_code": "def test_multilinestring(self):\n    with pytest.raises(ValueError):\n        MultiLineString([[(1000000.5, (- 2000000.5)), (3.5, 4.5, 11111.3)]])\n    a = LineString([((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == '???')\n    b = LineString([(10.1, 20.2), (30.3, 40.4)])\n    ml2 = MultiLineString([a, b])\n    ml2_copied = MultiLineString(ml2)\n    assert (len(ml2_copied.geoms) == 2)\n    assert (dump_coords(ml2_copied) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)], [(10.1, 20.2), (30.3, 40.4)]])\n    geom = MultiLineString([((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0)))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))),)})", "ground_truth": ["[[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)]]", "[[[-5.5, -6.6, 0.0], [0.0, 0.0, 0.0]]]"], "quality_analysis": {"complexity_score": 22, "left_complexity": 4, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_305", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_multilinestring", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multilinestring(self):\n    with pytest.raises(ValueError):\n        MultiLineString([[(1000000.5, (- 2000000.5)), (3.5, 4.5, 11111.3)]])\n    a = LineString([((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)]])\n    b = LineString([(10.1, 20.2), (30.3, 40.4)])\n    ml2 = MultiLineString([a, b])\n    ml2_copied = MultiLineString(ml2)\n    assert (len(ml2_copied.geoms) == 2)\n    assert (dump_coords(ml2_copied) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)], [(10.1, 20.2), (30.3, 40.4)]])\n    geom = MultiLineString([((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0)))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))),)})", "masked_code": "def test_multilinestring(self):\n    with pytest.raises(ValueError):\n        MultiLineString([[(1000000.5, (- 2000000.5)), (3.5, 4.5, 11111.3)]])\n    a = LineString([((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)]])\n    b = LineString([(10.1, 20.2), (30.3, 40.4)])\n    ml2 = MultiLineString([a, b])\n    ml2_copied = MultiLineString(ml2)\n    assert (len(ml2_copied.geoms) == 2)\n    assert (dump_coords(ml2_copied) == '???')\n    geom = MultiLineString([((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0)))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))),)})", "ground_truth": ["[[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)], [(10.1, 20.2), (30.3, 40.4)]]", "[[[-5.5, -6.6, 0.0], [0.0, 0.0, 0.0]], [[10.1, 20.2], [30.3, 40.4]]]"], "quality_analysis": {"complexity_score": 32, "left_complexity": 4, "right_complexity": 28, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_306", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_multilinestring", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multilinestring(self):\n    with pytest.raises(ValueError):\n        MultiLineString([[(1000000.5, (- 2000000.5)), (3.5, 4.5, 11111.3)]])\n    a = LineString([((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)]])\n    b = LineString([(10.1, 20.2), (30.3, 40.4)])\n    ml2 = MultiLineString([a, b])\n    ml2_copied = MultiLineString(ml2)\n    assert (len(ml2_copied.geoms) == 2)\n    assert (dump_coords(ml2_copied) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)], [(10.1, 20.2), (30.3, 40.4)]])\n    geom = MultiLineString([((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0)))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))),)})", "masked_code": "def test_multilinestring(self):\n    with pytest.raises(ValueError):\n        MultiLineString([[(1000000.5, (- 2000000.5)), (3.5, 4.5, 11111.3)]])\n    a = LineString([((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)]])\n    b = LineString([(10.1, 20.2), (30.3, 40.4)])\n    ml2 = MultiLineString([a, b])\n    ml2_copied = MultiLineString(ml2)\n    assert (len(ml2_copied.geoms) == 2)\n    assert (dump_coords(ml2_copied) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)], [(10.1, 20.2), (30.3, 40.4)]])\n    geom = MultiLineString([((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0)))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == '???')\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))),)})", "ground_truth": ["[(0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))]", "[[0.0, 0.0, 0.0], [-1.0, -2.0, -3.0]]"], "quality_analysis": {"complexity_score": 27, "left_complexity": 9, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_307", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_multilinestring", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multilinestring(self):\n    with pytest.raises(ValueError):\n        MultiLineString([[(1000000.5, (- 2000000.5)), (3.5, 4.5, 11111.3)]])\n    a = LineString([((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)]])\n    b = LineString([(10.1, 20.2), (30.3, 40.4)])\n    ml2 = MultiLineString([a, b])\n    ml2_copied = MultiLineString(ml2)\n    assert (len(ml2_copied.geoms) == 2)\n    assert (dump_coords(ml2_copied) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)], [(10.1, 20.2), (30.3, 40.4)]])\n    geom = MultiLineString([((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0)))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiLineString', 'coordinates': (((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))),)})", "masked_code": "def test_multilinestring(self):\n    with pytest.raises(ValueError):\n        MultiLineString([[(1000000.5, (- 2000000.5)), (3.5, 4.5, 11111.3)]])\n    a = LineString([((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)])\n    ml = MultiLineString([a])\n    assert (len(ml.geoms) == 1)\n    assert (dump_coords(ml) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)]])\n    b = LineString([(10.1, 20.2), (30.3, 40.4)])\n    ml2 = MultiLineString([a, b])\n    ml2_copied = MultiLineString(ml2)\n    assert (len(ml2_copied.geoms) == 2)\n    assert (dump_coords(ml2_copied) == [[((- 5.5), (- 6.6), 0.0), (0.0, 0.0, 0.0)], [(10.1, 20.2), (30.3, 40.4)]])\n    geom = MultiLineString([((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0)))])\n    assert isinstance(geom.geoms[0], LineString)\n    assert (dump_coords(geom.geoms[0]) == [(0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == '???')", "ground_truth": ["{'type': 'MultiLineString', 'coordinates': (((0.0, 0.0, 0.0), ((- 1.0), (- 2.0), (- 3.0))),)}", "{'type': 'MultiLineString', 'coordinates': [[[0.0, 0.0, 0.0], [-1.0, -2.0, -3.0]]]}"], "quality_analysis": {"complexity_score": 28, "left_complexity": 2, "right_complexity": 26, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiLineString"}
{"task_id": "shapely_303", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multilinestring.py", "testname": "test_multilinestring.py", "funcname": "test_numpy_object_array", "imports": ["import numpy as np", "import pytest", "from shapely import LineString, MultiLineString", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_numpy_object_array():\n    geom = MultiLineString([[[(- 999999999), 0, 1000000000], [0, (- 888888888), 0]]])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == geom)", "masked_code": "def test_numpy_object_array():\n    geom = MultiLineString([[[(- 999999999), 0, 1000000000], [0, (- 888888888), 0]]])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == '???')", "ground_truth": ["<MULTILINESTRING Z ((-999999999 0 1000000000, 0 -888888888 0))>", "geom"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_316", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint(self):\n    geom = MultiPoint([((- 1000.0), 0.0), (9999999.0, (- 55555.0))])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[((- 1000.0), 0.0)], [(9999999.0, (- 55555.0))]])\n    geom = MultiPoint([Point(0.0, 0.0), Point((- 1500000.0), 2700000.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 0.0)\n    assert (geom.geoms[0].y == 0.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((0.0, 0.0), ((- 1500000.0), 2700000.0))})", "masked_code": "def test_multipoint(self):\n    geom = MultiPoint([((- 1000.0), 0.0), (9999999.0, (- 55555.0))])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == '???')\n    geom = MultiPoint([Point(0.0, 0.0), Point((- 1500000.0), 2700000.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 0.0)\n    assert (geom.geoms[0].y == 0.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((0.0, 0.0), ((- 1500000.0), 2700000.0))})", "ground_truth": ["[[((- 1000.0), 0.0)], [(9999999.0, (- 55555.0))]]", "[[[-1000.0, 0.0]], [[9999999.0, -55555.0]]]"], "quality_analysis": {"complexity_score": 22, "left_complexity": 4, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPoint"}
{"task_id": "shapely_317", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint(self):\n    geom = MultiPoint([((- 1000.0), 0.0), (9999999.0, (- 55555.0))])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[((- 1000.0), 0.0)], [(9999999.0, (- 55555.0))]])\n    geom = MultiPoint([Point(0.0, 0.0), Point((- 1500000.0), 2700000.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 0.0)\n    assert (geom.geoms[0].y == 0.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((0.0, 0.0), ((- 1500000.0), 2700000.0))})", "masked_code": "def test_multipoint(self):\n    geom = MultiPoint([((- 1000.0), 0.0), (9999999.0, (- 55555.0))])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[((- 1000.0), 0.0)], [(9999999.0, (- 55555.0))]])\n    geom = MultiPoint([Point(0.0, 0.0), Point((- 1500000.0), 2700000.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == '???')\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 0.0)\n    assert (geom.geoms[0].y == 0.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((0.0, 0.0), ((- 1500000.0), 2700000.0))})", "ground_truth": ["[[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]]", "[[[0.0, 0.0]], [[-1500000.0, 2700000.0]]]"], "quality_analysis": {"complexity_score": 20, "left_complexity": 4, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPoint"}
{"task_id": "shapely_318", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint(self):\n    geom = MultiPoint([((- 1000.0), 0.0), (9999999.0, (- 55555.0))])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[((- 1000.0), 0.0)], [(9999999.0, (- 55555.0))]])\n    geom = MultiPoint([Point(0.0, 0.0), Point((- 1500000.0), 2700000.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 0.0)\n    assert (geom.geoms[0].y == 0.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((0.0, 0.0), ((- 1500000.0), 2700000.0))})", "masked_code": "def test_multipoint(self):\n    geom = MultiPoint([((- 1000.0), 0.0), (9999999.0, (- 55555.0))])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[((- 1000.0), 0.0)], [(9999999.0, (- 55555.0))]])\n    geom = MultiPoint([Point(0.0, 0.0), Point((- 1500000.0), 2700000.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == '???')\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 0.0)\n    assert (geom.geoms[0].y == 0.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((0.0, 0.0), ((- 1500000.0), 2700000.0))})", "ground_truth": ["[[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]]", "[[[0.0, 0.0]], [[-1500000.0, 2700000.0]]]"], "quality_analysis": {"complexity_score": 20, "left_complexity": 4, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPoint"}
{"task_id": "shapely_319", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint(self):\n    geom = MultiPoint([((- 1000.0), 0.0), (9999999.0, (- 55555.0))])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[((- 1000.0), 0.0)], [(9999999.0, (- 55555.0))]])\n    geom = MultiPoint([Point(0.0, 0.0), Point((- 1500000.0), 2700000.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 0.0)\n    assert (geom.geoms[0].y == 0.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == {'type': 'MultiPoint', 'coordinates': ((0.0, 0.0), ((- 1500000.0), 2700000.0))})", "masked_code": "def test_multipoint(self):\n    geom = MultiPoint([((- 1000.0), 0.0), (9999999.0, (- 55555.0))])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[((- 1000.0), 0.0)], [(9999999.0, (- 55555.0))]])\n    geom = MultiPoint([Point(0.0, 0.0), Point((- 1500000.0), 2700000.0)])\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    geom2 = MultiPoint(geom)\n    assert (len(geom2.geoms) == 2)\n    assert (dump_coords(geom2) == [[(0.0, 0.0)], [((- 1500000.0), 2700000.0)]])\n    assert isinstance(geom.geoms[0], Point)\n    assert (geom.geoms[0].x == 0.0)\n    assert (geom.geoms[0].y == 0.0)\n    with pytest.raises(IndexError):\n        geom.geoms[2]\n    assert (geom.__geo_interface__ == '???')", "ground_truth": ["{'type': 'MultiPoint', 'coordinates': ((0.0, 0.0), ((- 1500000.0), 2700000.0))}", "{'type': 'MultiPoint', 'coordinates': [[0.0, 0.0], [-1500000.0, 2700000.0]]}"], "quality_analysis": {"complexity_score": 20, "left_complexity": 2, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPoint"}
{"task_id": "shapely_313", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint_array_coercion", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint_array_coercion():\n    geom = MultiPoint([(0.0, 0.0), (9000000000.0, (- 100000000.0)), ((- 123456789), 123456789)])\n    arr = np.array(geom)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == geom)", "masked_code": "def test_multipoint_array_coercion():\n    geom = MultiPoint([(0.0, 0.0), (9000000000.0, (- 100000000.0)), ((- 123456789), 123456789)])\n    arr = np.array(geom)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == '???')\n    assert (arr.item() == geom)", "ground_truth": ["dtype('O')", "np.dtype('object')"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_314", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint_array_coercion", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint_array_coercion():\n    geom = MultiPoint([(0.0, 0.0), (9000000000.0, (- 100000000.0)), ((- 123456789), 123456789)])\n    arr = np.array(geom)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == geom)", "masked_code": "def test_multipoint_array_coercion():\n    geom = MultiPoint([(0.0, 0.0), (9000000000.0, (- 100000000.0)), ((- 123456789), 123456789)])\n    arr = np.array(geom)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == '???')", "ground_truth": ["<MULTIPOINT (0 0, 9000000000 -100000000, -123456789 123456789)>", "geom"], "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_320", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_multipoint_from_numpy", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipoint_from_numpy(self):\n    geom = MultiPoint(np.array([[(- 10000000000.0), 1e-10], [5.5, (- 5.5)]]))\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == [[((- 10000000000.0), 1e-10)], [(5.5, (- 5.5))]])", "masked_code": "def test_multipoint_from_numpy(self):\n    geom = MultiPoint(np.array([[(- 10000000000.0), 1e-10], [5.5, (- 5.5)]]))\n    assert isinstance(geom, MultiPoint)\n    assert (len(geom.geoms) == 2)\n    assert (dump_coords(geom) == '???')", "ground_truth": ["[[((- 10000000000.0), 1e-10)], [(5.5, (- 5.5))]]", "[[[-10000000000.0, 1e-10]], [[5.5, -5.5]]]"], "quality_analysis": {"complexity_score": 22, "left_complexity": 4, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPoint"}
{"task_id": "shapely_315", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipoint.py", "testname": "test_multipoint.py", "funcname": "test_numpy_object_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import MultiPoint, Point", "from shapely.errors import EmptyPartError", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_numpy_object_array():\n    geom = MultiPoint([(0, 0), ((- 99999), 12345), (999999, (- 88888888))])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == geom)", "masked_code": "def test_numpy_object_array():\n    geom = MultiPoint([(0, 0), ((- 99999), 12345), (999999, (- 88888888))])\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == '???')", "ground_truth": ["<MULTIPOINT (0 0, -99999 12345, 999999 -88888888)>", "geom"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_322", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_multipolygon", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [((((- 1000000), (- 1000000)), (0.0, 5000000), (1000000, (- 1000000)), (5000000, 5000000), (0.0, 0.0)), [(((- 500000), (- 500000)), ((- 250000), (- 250000)), ((- 500000), 500000), (0.0, 0.0))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[((- 1000000.0), (- 1000000.0)), (0.0, 5000000.0), (1000000.0, (- 1000000.0)), (5000000.0, 5000000.0), (0.0, 0.0), ((- 1000000.0), (- 1000000.0)), [((- 500000.0), (- 500000.0)), ((- 250000.0), (- 250000.0)), ((- 500000.0), 500000.0), (0.0, 0.0), ((- 500000.0), (- 500000.0))]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3))),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3)), (0.0, 0.0)]])\n    p = Polygon(((10, 0), (20, 0), (20, 1), (10, 1)), [((15.0, 0.5), (15.0, 0.5), (15.0, 0.5))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    p2 = Polygon(((100, 100), (200, 100), (200, 200), (100, 200)), [((150, 150), (150, 175), (175, 175), (175, 150))])\n    geom_multiple_from_list = MultiPolygon([p, p2])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert ([dump_coords(g) for g in geom_multiple_from_list.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom_multiple_from_array = MultiPolygon(np.array([p, p2]))\n    assert ([dump_coords(g) for g in geom_multiple_from_array.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0)), ((15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)))]})", "masked_code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [((((- 1000000), (- 1000000)), (0.0, 5000000), (1000000, (- 1000000)), (5000000, 5000000), (0.0, 0.0)), [(((- 500000), (- 500000)), ((- 250000), (- 250000)), ((- 500000), 500000), (0.0, 0.0))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == '???')\n    coords2 = [(((0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3))),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3)), (0.0, 0.0)]])\n    p = Polygon(((10, 0), (20, 0), (20, 1), (10, 1)), [((15.0, 0.5), (15.0, 0.5), (15.0, 0.5))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    p2 = Polygon(((100, 100), (200, 100), (200, 200), (100, 200)), [((150, 150), (150, 175), (175, 175), (175, 150))])\n    geom_multiple_from_list = MultiPolygon([p, p2])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert ([dump_coords(g) for g in geom_multiple_from_list.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom_multiple_from_array = MultiPolygon(np.array([p, p2]))\n    assert ([dump_coords(g) for g in geom_multiple_from_array.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0)), ((15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)))]})", "ground_truth": ["[[((- 1000000.0), (- 1000000.0)), (0.0, 5000000.0), (1000000.0, (- 1000000.0)), (5000000.0, 5000000.0), (0.0, 0.0), ((- 1000000.0), (- 1000000.0)), [((- 500000.0), (- 500000.0)), ((- 250000.0), (- 250000.0)), ((- 500000.0), 500000.0), (0.0, 0.0), ((- 500000.0), (- 500000.0))]]]", "[[[-1000000.0, -1000000.0], [0.0, 5000000.0], [1000000.0, -1000000.0], [5000000.0, 5000000.0], [0.0, 0.0], [-1000000.0, -1000000.0], [[-500000.0, -500000.0], [-250000.0, -250000.0], [-500000.0, 500000.0], [0.0, 0.0], [-500000.0, -500000.0]]]]"], "quality_analysis": {"complexity_score": 78, "left_complexity": 4, "right_complexity": 74, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPolygon"}
{"task_id": "shapely_323", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_multipolygon", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [((((- 1000000), (- 1000000)), (0.0, 5000000), (1000000, (- 1000000)), (5000000, 5000000), (0.0, 0.0)), [(((- 500000), (- 500000)), ((- 250000), (- 250000)), ((- 500000), 500000), (0.0, 0.0))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[((- 1000000.0), (- 1000000.0)), (0.0, 5000000.0), (1000000.0, (- 1000000.0)), (5000000.0, 5000000.0), (0.0, 0.0), ((- 1000000.0), (- 1000000.0)), [((- 500000.0), (- 500000.0)), ((- 250000.0), (- 250000.0)), ((- 500000.0), 500000.0), (0.0, 0.0), ((- 500000.0), (- 500000.0))]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3))),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3)), (0.0, 0.0)]])\n    p = Polygon(((10, 0), (20, 0), (20, 1), (10, 1)), [((15.0, 0.5), (15.0, 0.5), (15.0, 0.5))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    p2 = Polygon(((100, 100), (200, 100), (200, 200), (100, 200)), [((150, 150), (150, 175), (175, 175), (175, 150))])\n    geom_multiple_from_list = MultiPolygon([p, p2])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert ([dump_coords(g) for g in geom_multiple_from_list.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom_multiple_from_array = MultiPolygon(np.array([p, p2]))\n    assert ([dump_coords(g) for g in geom_multiple_from_array.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0)), ((15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)))]})", "masked_code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [((((- 1000000), (- 1000000)), (0.0, 5000000), (1000000, (- 1000000)), (5000000, 5000000), (0.0, 0.0)), [(((- 500000), (- 500000)), ((- 250000), (- 250000)), ((- 500000), 500000), (0.0, 0.0))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[((- 1000000.0), (- 1000000.0)), (0.0, 5000000.0), (1000000.0, (- 1000000.0)), (5000000.0, 5000000.0), (0.0, 0.0), ((- 1000000.0), (- 1000000.0)), [((- 500000.0), (- 500000.0)), ((- 250000.0), (- 250000.0)), ((- 500000.0), 500000.0), (0.0, 0.0), ((- 500000.0), (- 500000.0))]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3))),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == '???')\n    p = Polygon(((10, 0), (20, 0), (20, 1), (10, 1)), [((15.0, 0.5), (15.0, 0.5), (15.0, 0.5))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    p2 = Polygon(((100, 100), (200, 100), (200, 200), (100, 200)), [((150, 150), (150, 175), (175, 175), (175, 150))])\n    geom_multiple_from_list = MultiPolygon([p, p2])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert ([dump_coords(g) for g in geom_multiple_from_list.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom_multiple_from_array = MultiPolygon(np.array([p, p2]))\n    assert ([dump_coords(g) for g in geom_multiple_from_array.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0)), ((15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)))]})", "ground_truth": ["[[(0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3)), (0.0, 0.0)]]", "[[[0.0, 0.0], [0.0, 1.5], [2.7, 1.0], [1.0, 0.0], [0.0, -2.3], [0.0, 0.0]]]"], "quality_analysis": {"complexity_score": 34, "left_complexity": 4, "right_complexity": 30, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPolygon"}
{"task_id": "shapely_324", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_multipolygon", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [((((- 1000000), (- 1000000)), (0.0, 5000000), (1000000, (- 1000000)), (5000000, 5000000), (0.0, 0.0)), [(((- 500000), (- 500000)), ((- 250000), (- 250000)), ((- 500000), 500000), (0.0, 0.0))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[((- 1000000.0), (- 1000000.0)), (0.0, 5000000.0), (1000000.0, (- 1000000.0)), (5000000.0, 5000000.0), (0.0, 0.0), ((- 1000000.0), (- 1000000.0)), [((- 500000.0), (- 500000.0)), ((- 250000.0), (- 250000.0)), ((- 500000.0), 500000.0), (0.0, 0.0), ((- 500000.0), (- 500000.0))]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3))),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3)), (0.0, 0.0)]])\n    p = Polygon(((10, 0), (20, 0), (20, 1), (10, 1)), [((15.0, 0.5), (15.0, 0.5), (15.0, 0.5))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    p2 = Polygon(((100, 100), (200, 100), (200, 200), (100, 200)), [((150, 150), (150, 175), (175, 175), (175, 150))])\n    geom_multiple_from_list = MultiPolygon([p, p2])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert ([dump_coords(g) for g in geom_multiple_from_list.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom_multiple_from_array = MultiPolygon(np.array([p, p2]))\n    assert ([dump_coords(g) for g in geom_multiple_from_array.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0)), ((15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)))]})", "masked_code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [((((- 1000000), (- 1000000)), (0.0, 5000000), (1000000, (- 1000000)), (5000000, 5000000), (0.0, 0.0)), [(((- 500000), (- 500000)), ((- 250000), (- 250000)), ((- 500000), 500000), (0.0, 0.0))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[((- 1000000.0), (- 1000000.0)), (0.0, 5000000.0), (1000000.0, (- 1000000.0)), (5000000.0, 5000000.0), (0.0, 0.0), ((- 1000000.0), (- 1000000.0)), [((- 500000.0), (- 500000.0)), ((- 250000.0), (- 250000.0)), ((- 500000.0), 500000.0), (0.0, 0.0), ((- 500000.0), (- 500000.0))]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3))),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3)), (0.0, 0.0)]])\n    p = Polygon(((10, 0), (20, 0), (20, 1), (10, 1)), [((15.0, 0.5), (15.0, 0.5), (15.0, 0.5))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == '???')\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    p2 = Polygon(((100, 100), (200, 100), (200, 200), (100, 200)), [((150, 150), (150, 175), (175, 175), (175, 150))])\n    geom_multiple_from_list = MultiPolygon([p, p2])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert ([dump_coords(g) for g in geom_multiple_from_list.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom_multiple_from_array = MultiPolygon(np.array([p, p2]))\n    assert ([dump_coords(g) for g in geom_multiple_from_array.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0)), ((15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)))]})", "ground_truth": ["[[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]]", "[[[10.0, 0.0], [20.0, 0.0], [20.0, 1.0], [10.0, 1.0], [10.0, 0.0], [[15.0, 0.5], [15.0, 0.5], [15.0, 0.5], [15.0, 0.5]]]]"], "quality_analysis": {"complexity_score": 46, "left_complexity": 4, "right_complexity": 42, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPolygon"}
{"task_id": "shapely_325", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_multipolygon", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [((((- 1000000), (- 1000000)), (0.0, 5000000), (1000000, (- 1000000)), (5000000, 5000000), (0.0, 0.0)), [(((- 500000), (- 500000)), ((- 250000), (- 250000)), ((- 500000), 500000), (0.0, 0.0))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[((- 1000000.0), (- 1000000.0)), (0.0, 5000000.0), (1000000.0, (- 1000000.0)), (5000000.0, 5000000.0), (0.0, 0.0), ((- 1000000.0), (- 1000000.0)), [((- 500000.0), (- 500000.0)), ((- 250000.0), (- 250000.0)), ((- 500000.0), 500000.0), (0.0, 0.0), ((- 500000.0), (- 500000.0))]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3))),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3)), (0.0, 0.0)]])\n    p = Polygon(((10, 0), (20, 0), (20, 1), (10, 1)), [((15.0, 0.5), (15.0, 0.5), (15.0, 0.5))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    p2 = Polygon(((100, 100), (200, 100), (200, 200), (100, 200)), [((150, 150), (150, 175), (175, 175), (175, 150))])\n    geom_multiple_from_list = MultiPolygon([p, p2])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert ([dump_coords(g) for g in geom_multiple_from_list.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom_multiple_from_array = MultiPolygon(np.array([p, p2]))\n    assert ([dump_coords(g) for g in geom_multiple_from_array.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0)), ((15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)))]})", "masked_code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [((((- 1000000), (- 1000000)), (0.0, 5000000), (1000000, (- 1000000)), (5000000, 5000000), (0.0, 0.0)), [(((- 500000), (- 500000)), ((- 250000), (- 250000)), ((- 500000), 500000), (0.0, 0.0))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[((- 1000000.0), (- 1000000.0)), (0.0, 5000000.0), (1000000.0, (- 1000000.0)), (5000000.0, 5000000.0), (0.0, 0.0), ((- 1000000.0), (- 1000000.0)), [((- 500000.0), (- 500000.0)), ((- 250000.0), (- 250000.0)), ((- 500000.0), 500000.0), (0.0, 0.0), ((- 500000.0), (- 500000.0))]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3))),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3)), (0.0, 0.0)]])\n    p = Polygon(((10, 0), (20, 0), (20, 1), (10, 1)), [((15.0, 0.5), (15.0, 0.5), (15.0, 0.5))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    p2 = Polygon(((100, 100), (200, 100), (200, 200), (100, 200)), [((150, 150), (150, 175), (175, 175), (175, 150))])\n    geom_multiple_from_list = MultiPolygon([p, p2])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert ([dump_coords(g) for g in geom_multiple_from_list.geoms] == '???')\n    geom_multiple_from_array = MultiPolygon(np.array([p, p2]))\n    assert ([dump_coords(g) for g in geom_multiple_from_array.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0)), ((15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)))]})", "ground_truth": ["[[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]]", "[[[10.0, 0.0], [20.0, 0.0], [20.0, 1.0], [10.0, 1.0], [10.0, 0.0], [[15.0, 0.5], [15.0, 0.5], [15.0, 0.5], [15.0, 0.5]]], [[100.0, 100.0], [200.0, 100.0], [200.0, 200.0], [100.0, 200.0], [100.0, 100.0], [[150.0, 150.0], [150.0, 175.0], [175.0, 175.0], [175.0, 150.0], [150.0, 150.0]]]]"], "quality_analysis": {"complexity_score": 86, "left_complexity": 0, "right_complexity": 86, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPolygon"}
{"task_id": "shapely_326", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_multipolygon", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [((((- 1000000), (- 1000000)), (0.0, 5000000), (1000000, (- 1000000)), (5000000, 5000000), (0.0, 0.0)), [(((- 500000), (- 500000)), ((- 250000), (- 250000)), ((- 500000), 500000), (0.0, 0.0))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[((- 1000000.0), (- 1000000.0)), (0.0, 5000000.0), (1000000.0, (- 1000000.0)), (5000000.0, 5000000.0), (0.0, 0.0), ((- 1000000.0), (- 1000000.0)), [((- 500000.0), (- 500000.0)), ((- 250000.0), (- 250000.0)), ((- 500000.0), 500000.0), (0.0, 0.0), ((- 500000.0), (- 500000.0))]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3))),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3)), (0.0, 0.0)]])\n    p = Polygon(((10, 0), (20, 0), (20, 1), (10, 1)), [((15.0, 0.5), (15.0, 0.5), (15.0, 0.5))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    p2 = Polygon(((100, 100), (200, 100), (200, 200), (100, 200)), [((150, 150), (150, 175), (175, 175), (175, 150))])\n    geom_multiple_from_list = MultiPolygon([p, p2])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert ([dump_coords(g) for g in geom_multiple_from_list.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom_multiple_from_array = MultiPolygon(np.array([p, p2]))\n    assert ([dump_coords(g) for g in geom_multiple_from_array.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0)), ((15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)))]})", "masked_code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [((((- 1000000), (- 1000000)), (0.0, 5000000), (1000000, (- 1000000)), (5000000, 5000000), (0.0, 0.0)), [(((- 500000), (- 500000)), ((- 250000), (- 250000)), ((- 500000), 500000), (0.0, 0.0))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[((- 1000000.0), (- 1000000.0)), (0.0, 5000000.0), (1000000.0, (- 1000000.0)), (5000000.0, 5000000.0), (0.0, 0.0), ((- 1000000.0), (- 1000000.0)), [((- 500000.0), (- 500000.0)), ((- 250000.0), (- 250000.0)), ((- 500000.0), 500000.0), (0.0, 0.0), ((- 500000.0), (- 500000.0))]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3))),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3)), (0.0, 0.0)]])\n    p = Polygon(((10, 0), (20, 0), (20, 1), (10, 1)), [((15.0, 0.5), (15.0, 0.5), (15.0, 0.5))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    p2 = Polygon(((100, 100), (200, 100), (200, 200), (100, 200)), [((150, 150), (150, 175), (175, 175), (175, 150))])\n    geom_multiple_from_list = MultiPolygon([p, p2])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert ([dump_coords(g) for g in geom_multiple_from_list.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom_multiple_from_array = MultiPolygon(np.array([p, p2]))\n    assert ([dump_coords(g) for g in geom_multiple_from_array.geoms] == '???')\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0)), ((15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)))]})", "ground_truth": ["[[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]]", "[[[10.0, 0.0], [20.0, 0.0], [20.0, 1.0], [10.0, 1.0], [10.0, 0.0], [[15.0, 0.5], [15.0, 0.5], [15.0, 0.5], [15.0, 0.5]]], [[100.0, 100.0], [200.0, 100.0], [200.0, 200.0], [100.0, 200.0], [100.0, 100.0], [[150.0, 150.0], [150.0, 175.0], [175.0, 175.0], [175.0, 150.0], [150.0, 150.0]]]]"], "quality_analysis": {"complexity_score": 86, "left_complexity": 0, "right_complexity": 86, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPolygon"}
{"task_id": "shapely_327", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_multipolygon", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [((((- 1000000), (- 1000000)), (0.0, 5000000), (1000000, (- 1000000)), (5000000, 5000000), (0.0, 0.0)), [(((- 500000), (- 500000)), ((- 250000), (- 250000)), ((- 500000), 500000), (0.0, 0.0))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[((- 1000000.0), (- 1000000.0)), (0.0, 5000000.0), (1000000.0, (- 1000000.0)), (5000000.0, 5000000.0), (0.0, 0.0), ((- 1000000.0), (- 1000000.0)), [((- 500000.0), (- 500000.0)), ((- 250000.0), (- 250000.0)), ((- 500000.0), 500000.0), (0.0, 0.0), ((- 500000.0), (- 500000.0))]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3))),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3)), (0.0, 0.0)]])\n    p = Polygon(((10, 0), (20, 0), (20, 1), (10, 1)), [((15.0, 0.5), (15.0, 0.5), (15.0, 0.5))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    p2 = Polygon(((100, 100), (200, 100), (200, 200), (100, 200)), [((150, 150), (150, 175), (175, 175), (175, 150))])\n    geom_multiple_from_list = MultiPolygon([p, p2])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert ([dump_coords(g) for g in geom_multiple_from_list.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom_multiple_from_array = MultiPolygon(np.array([p, p2]))\n    assert ([dump_coords(g) for g in geom_multiple_from_array.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0)), ((15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)))]})", "masked_code": "def test_multipolygon(self):\n    geom = MultiPolygon([])\n    assert geom.is_empty\n    assert (len(geom.geoms) == 0)\n    coords = [((((- 1000000), (- 1000000)), (0.0, 5000000), (1000000, (- 1000000)), (5000000, 5000000), (0.0, 0.0)), [(((- 500000), (- 500000)), ((- 250000), (- 250000)), ((- 500000), 500000), (0.0, 0.0))])]\n    geom = MultiPolygon(coords)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[((- 1000000.0), (- 1000000.0)), (0.0, 5000000.0), (1000000.0, (- 1000000.0)), (5000000.0, 5000000.0), (0.0, 0.0), ((- 1000000.0), (- 1000000.0)), [((- 500000.0), (- 500000.0)), ((- 250000.0), (- 250000.0)), ((- 500000.0), 500000.0), (0.0, 0.0), ((- 500000.0), (- 500000.0))]]])\n    coords2 = [(((0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3))),)]\n    geom = MultiPolygon(coords2)\n    assert isinstance(geom, MultiPolygon)\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(0.0, 0.0), (0.0, 1.5), (2.7, 1.0), (1.0, 0.0), (0.0, (- 2.3)), (0.0, 0.0)]])\n    p = Polygon(((10, 0), (20, 0), (20, 1), (10, 1)), [((15.0, 0.5), (15.0, 0.5), (15.0, 0.5))])\n    geom = MultiPolygon([p])\n    assert (len(geom.geoms) == 1)\n    assert (dump_coords(geom) == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]])\n    geom_from_list_with_empty = MultiPolygon([p, None, Polygon()])\n    assert (geom_from_list_with_empty == geom)\n    p2 = Polygon(((100, 100), (200, 100), (200, 200), (100, 200)), [((150, 150), (150, 175), (175, 175), (175, 150))])\n    geom_multiple_from_list = MultiPolygon([p, p2])\n    assert (len(geom_multiple_from_list.geoms) == 2)\n    assert ([dump_coords(g) for g in geom_multiple_from_list.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom_multiple_from_array = MultiPolygon(np.array([p, p2]))\n    assert ([dump_coords(g) for g in geom_multiple_from_array.geoms] == [[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]], [(100.0, 100.0), (200.0, 100.0), (200.0, 200.0), (100.0, 200.0), (100.0, 100.0), [(150.0, 150.0), (150.0, 175.0), (175.0, 175.0), (175.0, 150.0), (150.0, 150.0)]]])\n    geom2 = MultiPolygon(geom)\n    assert (len(geom2.geoms) == 1)\n    assert (dump_coords(geom2) == '???')\n    assert isinstance(geom.geoms[0], Polygon)\n    assert (dump_coords(geom.geoms[0]) == [(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]])\n    with pytest.raises(IndexError):\n        geom.geoms[1]\n    assert (geom.__geo_interface__ == {'type': 'MultiPolygon', 'coordinates': [(((10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0)), ((15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)))]})", "ground_truth": ["[[(10.0, 0.0), (20.0, 0.0), (20.0, 1.0), (10.0, 1.0), (10.0, 0.0), [(15.0, 0.5), (15.0, 0.5), (15.0, 0.5), (15.0, 0.5)]]]", "[[[10.0, 0.0], [20.0, 0.0], [20.0, 1.0], [10.0, 1.0], [10.0, 0.0], [[15.0, 0.5], [15.0, 0.5], [15.0, 0.5], [15.0, 0.5]]]]"], "quality_analysis": {"complexity_score": 46, "left_complexity": 4, "right_complexity": 42, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMultiPolygon"}
{"task_id": "shapely_321", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_multipolygon.py", "testname": "test_multipolygon.py", "funcname": "test_numpy_object_array", "imports": ["import numpy as np", "import pytest", "from shapely import MultiPolygon, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.tests.geometry.test_multi import MultiGeometryTestCase"], "code": "def test_numpy_object_array():\n    geom = MultiPolygon([((((- 100.5), (- 100.5)), (0.0, 1000.1), (100.5, (- 100.5)), (1000.1, 1000.1), (0.0, 0.0)), [((0.25, 10000.0), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])])\n    ar = np.empty(2, object)\n    ar[:] = [geom, geom]\n    assert (ar[0] == geom)\n    assert (ar[1] == geom)", "masked_code": "def test_numpy_object_array():\n    geom = MultiPolygon([((((- 100.5), (- 100.5)), (0.0, 1000.1), (100.5, (- 100.5)), (1000.1, 1000.1), (0.0, 0.0)), [((0.25, 10000.0), (0.25, 0.5), (0.5, 0.5), (0.5, 0.25))])])\n    ar = np.empty(2, object)\n    ar[:] = [geom, geom]\n    assert (ar[0] == '???')\n    assert (ar[1] == geom)", "ground_truth": ["<MULTIPOLYGON (((-100.5 -100.5, 0 1000.1, 100.5 -100.5, 1000.1 1000.1, 0 0, ...>", "geom"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_510", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_ndarrays.py", "testname": "test_ndarrays.py", "funcname": "test_linestring", "imports": ["import unittest", "from functools import reduce", "import numpy as np", "from shapely import geometry"], "code": "def test_linestring(self):\n    a = np.array([[(- 10.0), 0.0, 10.0, 50.0, 100.0], [0.0, (- 10.0), 20.0, 40.0, 0.0]])\n    t = a.T\n    s = geometry.LineString(t)\n    assert (list(s.coords) == [((- 10.0), 0.0), (0.0, (- 10.0)), (10.0, 20.0), (50.0, 40.0), (100.0, 0.0)])", "masked_code": "def test_linestring(self):\n    a = np.array([[(- 10.0), 0.0, 10.0, 50.0, 100.0], [0.0, (- 10.0), 20.0, 40.0, 0.0]])\n    t = a.T\n    s = geometry.LineString(t)\n    assert (list(s.coords) == '???')", "ground_truth": ["[((- 10.0), 0.0), (0.0, (- 10.0)), (10.0, 20.0), (50.0, 40.0), (100.0, 0.0)]", "[[-10.0, 0.0], [0.0, -10.0], [10.0, 20.0], [50.0, 40.0], [100.0, 0.0]]"], "quality_analysis": {"complexity_score": 31, "left_complexity": 5, "right_complexity": 26, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransposeTestCase"}
{"task_id": "shapely_511", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_ndarrays.py", "testname": "test_ndarrays.py", "funcname": "test_polygon", "imports": ["import unittest", "from functools import reduce", "import numpy as np", "from shapely import geometry"], "code": "def test_polygon(self):\n    a = np.array([[0.5, 1.5, (- 2.5), 4.5, 0.5], [3.8, (- 1.2), 3.8, 2.1, 3.8]])\n    t = a.T\n    s = geometry.Polygon(t)\n    assert (list(s.exterior.coords) == [(0.5, 3.8), (1.5, (- 1.2)), ((- 2.5), 3.8), (4.5, 2.1), (0.5, 3.8)])", "masked_code": "def test_polygon(self):\n    a = np.array([[0.5, 1.5, (- 2.5), 4.5, 0.5], [3.8, (- 1.2), 3.8, 2.1, 3.8]])\n    t = a.T\n    s = geometry.Polygon(t)\n    assert (list(s.exterior.coords) == '???')", "ground_truth": ["[(0.5, 3.8), (1.5, (- 1.2)), ((- 2.5), 3.8), (4.5, 2.1), (0.5, 3.8)]", "[[0.5, 3.8], [1.5, -1.2], [-2.5, 3.8], [4.5, 2.1], [0.5, 3.8]]"], "quality_analysis": {"complexity_score": 31, "left_complexity": 5, "right_complexity": 26, "is_quality": true, "reason": "High quality assertion"}, "classname": "TransposeTestCase"}
{"task_id": "shapely_516", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_operations.py", "testname": "test_operations.py", "funcname": "test_operations", "imports": ["import unittest", "import pytest", "import shapely", "from shapely import geos_version", "from shapely.errors import TopologicalError", "from shapely.geometry import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.wkt import loads"], "code": "def test_operations(self):\n    point = Point(1e+20, (- 1e+20))\n    assert (point.area == 0.0)\n    assert (point.length == 0.0)\n    assert (point.distance(Point((- 1e+20), 1e+20)) == pytest.approx(2.8284271247461905e+20))\n    assert isinstance(point.envelope, Point)\n    assert point.intersection(Point(10000000000.0, 10000000000.0)).is_empty\n    assert isinstance(point.buffer(10000000000.0), Polygon)\n    assert isinstance(point.buffer(10000000000.0, quad_segs=1), Polygon)\n    p = loads('POLYGON ((-300 -300, 500 800, 600 900, -800 -900, 1000 1200, -300 -295, -305 -299, -300 -300))')\n    expected = loads('POLYGON ((-300 -300, 600 900, -800 -900, 1000 1200, -300 -300))')\n    s = p.simplify(100.5, preserve_topology=False)\n    assert s.equals_exact(expected, 0.001)\n    p = loads('POLYGON ((50 500, 250 500, 250 60, 50 60, 50 500),(-100 120, 280 120, 180 799, 160 900, 140 799, -100 120))')\n    expected = p.simplify(100.5, preserve_topology=True)\n    s = p.simplify(100.5, preserve_topology=True)\n    assert s.equals_exact(expected, 0.001)\n    assert isinstance(point.convex_hull, Point)\n    assert isinstance(point.difference(Point(1e+20, 1e+20)), Point)\n    assert isinstance(point.symmetric_difference(Point(1e+20, 1e+20)), MultiPoint)\n    assert isinstance(point.boundary, GeometryCollection)\n    assert isinstance(point.union(Point(1e+20, 1e+20)), MultiPoint)\n    assert isinstance(point.representative_point(), Point)\n    assert isinstance(point.point_on_surface(), Point)\n    assert (point.representative_point() == point.point_on_surface())\n    assert isinstance(point.centroid, Point)", "masked_code": "def test_operations(self):\n    point = Point(1e+20, (- 1e+20))\n    assert (point.area == 0.0)\n    assert (point.length == 0.0)\n    assert (point.distance(Point((- 1e+20), 1e+20)) == '???')\n    assert isinstance(point.envelope, Point)\n    assert point.intersection(Point(10000000000.0, 10000000000.0)).is_empty\n    assert isinstance(point.buffer(10000000000.0), Polygon)\n    assert isinstance(point.buffer(10000000000.0, quad_segs=1), Polygon)\n    p = loads('POLYGON ((-300 -300, 500 800, 600 900, -800 -900, 1000 1200, -300 -295, -305 -299, -300 -300))')\n    expected = loads('POLYGON ((-300 -300, 600 900, -800 -900, 1000 1200, -300 -300))')\n    s = p.simplify(100.5, preserve_topology=False)\n    assert s.equals_exact(expected, 0.001)\n    p = loads('POLYGON ((50 500, 250 500, 250 60, 50 60, 50 500),(-100 120, 280 120, 180 799, 160 900, 140 799, -100 120))')\n    expected = p.simplify(100.5, preserve_topology=True)\n    s = p.simplify(100.5, preserve_topology=True)\n    assert s.equals_exact(expected, 0.001)\n    assert isinstance(point.convex_hull, Point)\n    assert isinstance(point.difference(Point(1e+20, 1e+20)), Point)\n    assert isinstance(point.symmetric_difference(Point(1e+20, 1e+20)), MultiPoint)\n    assert isinstance(point.boundary, GeometryCollection)\n    assert isinstance(point.union(Point(1e+20, 1e+20)), MultiPoint)\n    assert isinstance(point.representative_point(), Point)\n    assert isinstance(point.point_on_surface(), Point)\n    assert (point.representative_point() == point.point_on_surface())\n    assert isinstance(point.centroid, Point)", "ground_truth": ["2.8284271247461905e+20", "282842712474619052032", "pytest.approx(2.8284271247461905e+20)"], "quality_analysis": {"complexity_score": 14, "left_complexity": 10, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "OperationsTestCase"}
{"task_id": "shapely_517", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_operations.py", "testname": "test_operations.py", "funcname": "test_operations", "imports": ["import unittest", "import pytest", "import shapely", "from shapely import geos_version", "from shapely.errors import TopologicalError", "from shapely.geometry import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.wkt import loads"], "code": "def test_operations(self):\n    point = Point(1e+20, (- 1e+20))\n    assert (point.area == 0.0)\n    assert (point.length == 0.0)\n    assert (point.distance(Point((- 1e+20), 1e+20)) == pytest.approx(2.8284271247461905e+20))\n    assert isinstance(point.envelope, Point)\n    assert point.intersection(Point(10000000000.0, 10000000000.0)).is_empty\n    assert isinstance(point.buffer(10000000000.0), Polygon)\n    assert isinstance(point.buffer(10000000000.0, quad_segs=1), Polygon)\n    p = loads('POLYGON ((-300 -300, 500 800, 600 900, -800 -900, 1000 1200, -300 -295, -305 -299, -300 -300))')\n    expected = loads('POLYGON ((-300 -300, 600 900, -800 -900, 1000 1200, -300 -300))')\n    s = p.simplify(100.5, preserve_topology=False)\n    assert s.equals_exact(expected, 0.001)\n    p = loads('POLYGON ((50 500, 250 500, 250 60, 50 60, 50 500),(-100 120, 280 120, 180 799, 160 900, 140 799, -100 120))')\n    expected = p.simplify(100.5, preserve_topology=True)\n    s = p.simplify(100.5, preserve_topology=True)\n    assert s.equals_exact(expected, 0.001)\n    assert isinstance(point.convex_hull, Point)\n    assert isinstance(point.difference(Point(1e+20, 1e+20)), Point)\n    assert isinstance(point.symmetric_difference(Point(1e+20, 1e+20)), MultiPoint)\n    assert isinstance(point.boundary, GeometryCollection)\n    assert isinstance(point.union(Point(1e+20, 1e+20)), MultiPoint)\n    assert isinstance(point.representative_point(), Point)\n    assert isinstance(point.point_on_surface(), Point)\n    assert (point.representative_point() == point.point_on_surface())\n    assert isinstance(point.centroid, Point)", "masked_code": "def test_operations(self):\n    point = Point(1e+20, (- 1e+20))\n    assert (point.area == 0.0)\n    assert (point.length == 0.0)\n    assert (point.distance(Point((- 1e+20), 1e+20)) == pytest.approx(2.8284271247461905e+20))\n    assert isinstance(point.envelope, Point)\n    assert point.intersection(Point(10000000000.0, 10000000000.0)).is_empty\n    assert isinstance(point.buffer(10000000000.0), Polygon)\n    assert isinstance(point.buffer(10000000000.0, quad_segs=1), Polygon)\n    p = loads('POLYGON ((-300 -300, 500 800, 600 900, -800 -900, 1000 1200, -300 -295, -305 -299, -300 -300))')\n    expected = loads('POLYGON ((-300 -300, 600 900, -800 -900, 1000 1200, -300 -300))')\n    s = p.simplify(100.5, preserve_topology=False)\n    assert s.equals_exact(expected, 0.001)\n    p = loads('POLYGON ((50 500, 250 500, 250 60, 50 60, 50 500),(-100 120, 280 120, 180 799, 160 900, 140 799, -100 120))')\n    expected = p.simplify(100.5, preserve_topology=True)\n    s = p.simplify(100.5, preserve_topology=True)\n    assert s.equals_exact(expected, 0.001)\n    assert isinstance(point.convex_hull, Point)\n    assert isinstance(point.difference(Point(1e+20, 1e+20)), Point)\n    assert isinstance(point.symmetric_difference(Point(1e+20, 1e+20)), MultiPoint)\n    assert isinstance(point.boundary, GeometryCollection)\n    assert isinstance(point.union(Point(1e+20, 1e+20)), MultiPoint)\n    assert isinstance(point.representative_point(), Point)\n    assert isinstance(point.point_on_surface(), Point)\n    assert (point.representative_point() == '???')\n    assert isinstance(point.centroid, Point)", "ground_truth": ["<POINT (100000000000000000000 -100000000000000000000)>", "point.point_on_surface()"], "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "OperationsTestCase"}
{"task_id": "shapely_518", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_operations.py", "testname": "test_operations.py", "funcname": "test_relate", "imports": ["import unittest", "import pytest", "import shapely", "from shapely import geos_version", "from shapely.errors import TopologicalError", "from shapely.geometry import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.wkt import loads"], "code": "def test_relate(self):\n    assert (Point((- 1000000000000.0), 2.5).relate(Point(1000000000000.0, (- 2.5))) == 'FF0FFF0F2')\n    invalid_polygon = loads('POLYGON ((440 100, 880 100, 880 60, 440 60, 440 100), (640 60, 880 60, 880 40, 640 40, 640 60))')\n    assert (not invalid_polygon.is_valid)\n    if (geos_version < (3, 13, 0)):\n        with pytest.raises((TopologicalError, shapely.GEOSException)):\n            invalid_polygon.relate(invalid_polygon)\n    else:\n        assert (invalid_polygon.relate(invalid_polygon) == '2FFF1FFF2')", "masked_code": "def test_relate(self):\n    assert (Point((- 1000000000000.0), 2.5).relate(Point(1000000000000.0, (- 2.5))) == '???')\n    invalid_polygon = loads('POLYGON ((440 100, 880 100, 880 60, 440 60, 440 100), (640 60, 880 60, 880 40, 640 40, 640 60))')\n    assert (not invalid_polygon.is_valid)\n    if (geos_version < (3, 13, 0)):\n        with pytest.raises((TopologicalError, shapely.GEOSException)):\n            invalid_polygon.relate(invalid_polygon)\n    else:\n        assert (invalid_polygon.relate(invalid_polygon) == '2FFF1FFF2')", "ground_truth": ["'FF0FFF0F2'"], "quality_analysis": {"complexity_score": 11, "left_complexity": 10, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OperationsTestCase"}
{"task_id": "shapely_519", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_operations.py", "testname": "test_operations.py", "funcname": "test_relate", "imports": ["import unittest", "import pytest", "import shapely", "from shapely import geos_version", "from shapely.errors import TopologicalError", "from shapely.geometry import GeometryCollection, LineString, MultiPoint, Point, Polygon", "from shapely.wkt import loads"], "code": "def test_relate(self):\n    assert (Point((- 1000000000000.0), 2.5).relate(Point(1000000000000.0, (- 2.5))) == 'FF0FFF0F2')\n    invalid_polygon = loads('POLYGON ((440 100, 880 100, 880 60, 440 60, 440 100), (640 60, 880 60, 880 40, 640 40, 640 60))')\n    assert (not invalid_polygon.is_valid)\n    if (geos_version < (3, 13, 0)):\n        with pytest.raises((TopologicalError, shapely.GEOSException)):\n            invalid_polygon.relate(invalid_polygon)\n    else:\n        assert (invalid_polygon.relate(invalid_polygon) == '2FFF1FFF2')", "masked_code": "def test_relate(self):\n    assert (Point((- 1000000000000.0), 2.5).relate(Point(1000000000000.0, (- 2.5))) == 'FF0FFF0F2')\n    invalid_polygon = loads('POLYGON ((440 100, 880 100, 880 60, 440 60, 440 100), (640 60, 880 60, 880 40, 640 40, 640 60))')\n    assert (not invalid_polygon.is_valid)\n    if (geos_version < (3, 13, 0)):\n        with pytest.raises((TopologicalError, shapely.GEOSException)):\n            invalid_polygon.relate(invalid_polygon)\n    else:\n        assert (invalid_polygon.relate(invalid_polygon) == '???')", "ground_truth": ["'2FFF1FFF2'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OperationsTestCase"}
{"task_id": "shapely_530", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_empty_polygon", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_empty_polygon(self):\n    polygon = Polygon()\n    assert (orient(polygon) == polygon)", "masked_code": "def test_empty_polygon(self):\n    polygon = Polygon()\n    assert (orient(polygon) == '???')", "ground_truth": ["<POLYGON EMPTY>", "polygon"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_535", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_geometrycollection", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_geometrycollection(self):\n    polygon = Polygon([(0, 0), (0, 2), (2, 2), (2, 0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    point = Point(10, 20)\n    linestring = LineString([((- 1), (- 1)), (0, 0), (1.2, 3.4)])\n    collection = GeometryCollection([polygon, point, linestring])\n    assert (orient(collection, 1) == GeometryCollection([polygon_reversed, point, linestring]))\n    assert (orient(collection, (- 1)) == GeometryCollection([polygon, point, linestring]))", "masked_code": "def test_geometrycollection(self):\n    polygon = Polygon([(0, 0), (0, 2), (2, 2), (2, 0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    point = Point(10, 20)\n    linestring = LineString([((- 1), (- 1)), (0, 0), (1.2, 3.4)])\n    collection = GeometryCollection([polygon, point, linestring])\n    assert (orient(collection, 1) == '???')\n    assert (orient(collection, (- 1)) == GeometryCollection([polygon, point, linestring]))", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((0 0, 2 0, 2 2, 0 2, 0 0)), POINT (10 20), LIN...>", "GeometryCollection([polygon_reversed, point, linestring])"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_536", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_geometrycollection", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_geometrycollection(self):\n    polygon = Polygon([(0, 0), (0, 2), (2, 2), (2, 0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    point = Point(10, 20)\n    linestring = LineString([((- 1), (- 1)), (0, 0), (1.2, 3.4)])\n    collection = GeometryCollection([polygon, point, linestring])\n    assert (orient(collection, 1) == GeometryCollection([polygon_reversed, point, linestring]))\n    assert (orient(collection, (- 1)) == GeometryCollection([polygon, point, linestring]))", "masked_code": "def test_geometrycollection(self):\n    polygon = Polygon([(0, 0), (0, 2), (2, 2), (2, 0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    point = Point(10, 20)\n    linestring = LineString([((- 1), (- 1)), (0, 0), (1.2, 3.4)])\n    collection = GeometryCollection([polygon, point, linestring])\n    assert (orient(collection, 1) == GeometryCollection([polygon_reversed, point, linestring]))\n    assert (orient(collection, (- 1)) == '???')", "ground_truth": ["<GEOMETRYCOLLECTION (POLYGON ((0 0, 0 2, 2 2, 2 0, 0 0)), POINT (10 20), LIN...>", "GeometryCollection([polygon, point, linestring])"], "quality_analysis": {"complexity_score": 15, "left_complexity": 7, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_528", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_linearring", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_linearring(self):\n    linearring = LinearRing([(0, 0), (1, 2), (3, (- 1)), (0, 0)])\n    assert (orient(linearring, 1) == linearring)\n    assert (orient(linearring, (- 1)) == linearring)", "masked_code": "def test_linearring(self):\n    linearring = LinearRing([(0, 0), (1, 2), (3, (- 1)), (0, 0)])\n    assert (orient(linearring, 1) == '???')\n    assert (orient(linearring, (- 1)) == linearring)", "ground_truth": ["<LINEARRING (0 0, 1 2, 3 -1, 0 0)>", "linearring"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_529", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_linearring", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_linearring(self):\n    linearring = LinearRing([(0, 0), (1, 2), (3, (- 1)), (0, 0)])\n    assert (orient(linearring, 1) == linearring)\n    assert (orient(linearring, (- 1)) == linearring)", "masked_code": "def test_linearring(self):\n    linearring = LinearRing([(0, 0), (1, 2), (3, (- 1)), (0, 0)])\n    assert (orient(linearring, 1) == linearring)\n    assert (orient(linearring, (- 1)) == '???')", "ground_truth": ["<LINEARRING (0 0, 1 2, 3 -1, 0 0)>", "linearring"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_524", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_linestring", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_linestring(self):\n    linestring = LineString([(0, 0), (1, 1), (2.5, (- 1000.0)), (5, 6)])\n    assert (orient(linestring, 1) == linestring)\n    assert (orient(linestring, (- 1)) == linestring)", "masked_code": "def test_linestring(self):\n    linestring = LineString([(0, 0), (1, 1), (2.5, (- 1000.0)), (5, 6)])\n    assert (orient(linestring, 1) == '???')\n    assert (orient(linestring, (- 1)) == linestring)", "ground_truth": ["linestring"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_525", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_linestring", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_linestring(self):\n    linestring = LineString([(0, 0), (1, 1), (2.5, (- 1000.0)), (5, 6)])\n    assert (orient(linestring, 1) == linestring)\n    assert (orient(linestring, (- 1)) == linestring)", "masked_code": "def test_linestring(self):\n    linestring = LineString([(0, 0), (1, 1), (2.5, (- 1000.0)), (5, 6)])\n    assert (orient(linestring, 1) == linestring)\n    assert (orient(linestring, (- 1)) == '???')", "ground_truth": ["<LINESTRING (0 0, 1 1, 2.5 -1000, 5 6)>", "linestring"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_526", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_multilinestring", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_multilinestring(self):\n    multilinestring = MultiLineString([[(0, 0), (1, 1), (2, 3)], [(5, 0), (5, (- 5))], [((- 100.0), 100.0), (0, 0)]])\n    assert (orient(multilinestring, 1) == multilinestring)\n    assert (orient(multilinestring, (- 1)) == multilinestring)", "masked_code": "def test_multilinestring(self):\n    multilinestring = MultiLineString([[(0, 0), (1, 1), (2, 3)], [(5, 0), (5, (- 5))], [((- 100.0), 100.0), (0, 0)]])\n    assert (orient(multilinestring, 1) == '???')\n    assert (orient(multilinestring, (- 1)) == multilinestring)", "ground_truth": ["<MULTILINESTRING ((0 0, 1 1, 2 3), (5 0, 5 -5), (-100 100, 0 0))>", "multilinestring"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_527", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_multilinestring", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_multilinestring(self):\n    multilinestring = MultiLineString([[(0, 0), (1, 1), (2, 3)], [(5, 0), (5, (- 5))], [((- 100.0), 100.0), (0, 0)]])\n    assert (orient(multilinestring, 1) == multilinestring)\n    assert (orient(multilinestring, (- 1)) == multilinestring)", "masked_code": "def test_multilinestring(self):\n    multilinestring = MultiLineString([[(0, 0), (1, 1), (2, 3)], [(5, 0), (5, (- 5))], [((- 100.0), 100.0), (0, 0)]])\n    assert (orient(multilinestring, 1) == multilinestring)\n    assert (orient(multilinestring, (- 1)) == '???')", "ground_truth": ["<MULTILINESTRING ((0 0, 1 1, 2 3), (5 0, 5 -5), (-100 100, 0 0))>", "multilinestring"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_522", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_multipoint", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_multipoint(self):\n    multipoint = MultiPoint([(0, 0), ((- 5.5), 2.2), (1000000.0, (- 1e-05)), (0, 0)])\n    assert (orient(multipoint, 1) == multipoint)\n    assert (orient(multipoint, (- 1)) == multipoint)", "masked_code": "def test_multipoint(self):\n    multipoint = MultiPoint([(0, 0), ((- 5.5), 2.2), (1000000.0, (- 1e-05)), (0, 0)])\n    assert (orient(multipoint, 1) == '???')\n    assert (orient(multipoint, (- 1)) == multipoint)", "ground_truth": ["<MULTIPOINT (0 0, -5.5 2.2, 1000000 0, 0 0)>", "multipoint"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_523", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_multipoint", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_multipoint(self):\n    multipoint = MultiPoint([(0, 0), ((- 5.5), 2.2), (1000000.0, (- 1e-05)), (0, 0)])\n    assert (orient(multipoint, 1) == multipoint)\n    assert (orient(multipoint, (- 1)) == multipoint)", "masked_code": "def test_multipoint(self):\n    multipoint = MultiPoint([(0, 0), ((- 5.5), 2.2), (1000000.0, (- 1e-05)), (0, 0)])\n    assert (orient(multipoint, 1) == multipoint)\n    assert (orient(multipoint, (- 1)) == '???')", "ground_truth": ["<MULTIPOINT (0 0, -5.5 2.2, 1000000 0, 0 0)>", "multipoint"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_533", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_multipolygon", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_multipolygon(self):\n    polygon1 = Polygon([(0, 0), (0, 2), (2, 2), (2, 0)])\n    polygon2 = Polygon([(3, 3), (4, 3), (4, 4), (3, 4)])\n    polygon3 = Polygon([((- 5), (- 5)), ((- 5), (- 1)), ((- 2), (- 1)), ((- 2), (- 5))])\n    polygon1_reversed = Polygon(polygon1.exterior.coords[::(- 1)])\n    polygon2_reversed = Polygon(polygon2.exterior.coords[::(- 1)])\n    polygon3_reversed = Polygon(polygon3.exterior.coords[::(- 1)])\n    multipolygon = MultiPolygon([polygon1, polygon2, polygon3])\n    assert (not polygon1.exterior.is_ccw)\n    assert polygon2.exterior.is_ccw\n    assert (not polygon3.exterior.is_ccw)\n    assert (orient(multipolygon, 1) == MultiPolygon([polygon1_reversed, polygon2, polygon3_reversed]))\n    assert (orient(multipolygon, (- 1)) == MultiPolygon([polygon1, polygon2_reversed, polygon3]))", "masked_code": "def test_multipolygon(self):\n    polygon1 = Polygon([(0, 0), (0, 2), (2, 2), (2, 0)])\n    polygon2 = Polygon([(3, 3), (4, 3), (4, 4), (3, 4)])\n    polygon3 = Polygon([((- 5), (- 5)), ((- 5), (- 1)), ((- 2), (- 1)), ((- 2), (- 5))])\n    polygon1_reversed = Polygon(polygon1.exterior.coords[::(- 1)])\n    polygon2_reversed = Polygon(polygon2.exterior.coords[::(- 1)])\n    polygon3_reversed = Polygon(polygon3.exterior.coords[::(- 1)])\n    multipolygon = MultiPolygon([polygon1, polygon2, polygon3])\n    assert (not polygon1.exterior.is_ccw)\n    assert polygon2.exterior.is_ccw\n    assert (not polygon3.exterior.is_ccw)\n    assert (orient(multipolygon, 1) == '???')\n    assert (orient(multipolygon, (- 1)) == MultiPolygon([polygon1, polygon2_reversed, polygon3]))", "ground_truth": ["<MULTIPOLYGON (((0 0, 2 0, 2 2, 0 2, 0 0)), ((3 3, 4 3, 4 4, 3 4, 3 3)), ((-...>", "MultiPolygon([polygon1_reversed, polygon2, polygon3_reversed])"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_534", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_multipolygon", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_multipolygon(self):\n    polygon1 = Polygon([(0, 0), (0, 2), (2, 2), (2, 0)])\n    polygon2 = Polygon([(3, 3), (4, 3), (4, 4), (3, 4)])\n    polygon3 = Polygon([((- 5), (- 5)), ((- 5), (- 1)), ((- 2), (- 1)), ((- 2), (- 5))])\n    polygon1_reversed = Polygon(polygon1.exterior.coords[::(- 1)])\n    polygon2_reversed = Polygon(polygon2.exterior.coords[::(- 1)])\n    polygon3_reversed = Polygon(polygon3.exterior.coords[::(- 1)])\n    multipolygon = MultiPolygon([polygon1, polygon2, polygon3])\n    assert (not polygon1.exterior.is_ccw)\n    assert polygon2.exterior.is_ccw\n    assert (not polygon3.exterior.is_ccw)\n    assert (orient(multipolygon, 1) == MultiPolygon([polygon1_reversed, polygon2, polygon3_reversed]))\n    assert (orient(multipolygon, (- 1)) == MultiPolygon([polygon1, polygon2_reversed, polygon3]))", "masked_code": "def test_multipolygon(self):\n    polygon1 = Polygon([(0, 0), (0, 2), (2, 2), (2, 0)])\n    polygon2 = Polygon([(3, 3), (4, 3), (4, 4), (3, 4)])\n    polygon3 = Polygon([((- 5), (- 5)), ((- 5), (- 1)), ((- 2), (- 1)), ((- 2), (- 5))])\n    polygon1_reversed = Polygon(polygon1.exterior.coords[::(- 1)])\n    polygon2_reversed = Polygon(polygon2.exterior.coords[::(- 1)])\n    polygon3_reversed = Polygon(polygon3.exterior.coords[::(- 1)])\n    multipolygon = MultiPolygon([polygon1, polygon2, polygon3])\n    assert (not polygon1.exterior.is_ccw)\n    assert polygon2.exterior.is_ccw\n    assert (not polygon3.exterior.is_ccw)\n    assert (orient(multipolygon, 1) == MultiPolygon([polygon1_reversed, polygon2, polygon3_reversed]))\n    assert (orient(multipolygon, (- 1)) == '???')", "ground_truth": ["<MULTIPOLYGON (((0 0, 0 2, 2 2, 2 0, 0 0)), ((3 3, 3 4, 4 4, 4 3, 3 3)), ((-...>", "MultiPolygon([polygon1, polygon2_reversed, polygon3])"], "quality_analysis": {"complexity_score": 15, "left_complexity": 7, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_520", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_point", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_point(self):\n    point = Point(1000000.0, (- 1000000.0))\n    assert (orient(point, 1) == point)\n    assert (orient(point, (- 1)) == point)", "masked_code": "def test_point(self):\n    point = Point(1000000.0, (- 1000000.0))\n    assert (orient(point, 1) == '???')\n    assert (orient(point, (- 1)) == point)", "ground_truth": ["<POINT (1000000 -1000000)>", "point"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_521", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_point", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_point(self):\n    point = Point(1000000.0, (- 1000000.0))\n    assert (orient(point, 1) == point)\n    assert (orient(point, (- 1)) == point)", "masked_code": "def test_point(self):\n    point = Point(1000000.0, (- 1000000.0))\n    assert (orient(point, 1) == point)\n    assert (orient(point, (- 1)) == '???')", "ground_truth": ["<POINT (1000000 -1000000)>", "point"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_531", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_polygon", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_polygon(self):\n    polygon = Polygon([(0.0, 0.0), (0.0, 2.5), (3.3, 2.5), ((- 1.1), 0.0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    assert (orient(polygon, 1) == polygon_reversed)\n    assert (orient(polygon, (- 1)) == polygon)", "masked_code": "def test_polygon(self):\n    polygon = Polygon([(0.0, 0.0), (0.0, 2.5), (3.3, 2.5), ((- 1.1), 0.0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    assert (orient(polygon, 1) == '???')\n    assert (orient(polygon, (- 1)) == polygon)", "ground_truth": ["<POLYGON ((0 0, -1.1 0, 3.3 2.5, 0 2.5, 0 0))>", "polygon_reversed"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_532", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_orient.py", "testname": "test_orient.py", "funcname": "test_polygon", "imports": ["import unittest", "from numpy.testing import assert_array_equal", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from shapely.ops import orient"], "code": "def test_polygon(self):\n    polygon = Polygon([(0.0, 0.0), (0.0, 2.5), (3.3, 2.5), ((- 1.1), 0.0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    assert (orient(polygon, 1) == polygon_reversed)\n    assert (orient(polygon, (- 1)) == polygon)", "masked_code": "def test_polygon(self):\n    polygon = Polygon([(0.0, 0.0), (0.0, 2.5), (3.3, 2.5), ((- 1.1), 0.0)])\n    polygon_reversed = Polygon(polygon.exterior.coords[::(- 1)])\n    assert (orient(polygon, 1) == polygon_reversed)\n    assert (orient(polygon, (- 1)) == '???')", "ground_truth": ["<POLYGON ((0 0, 0 2.5, 3.3 2.5, -1.1 0, 0 0))>", "polygon"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "OrientTestCase"}
{"task_id": "shapely_537", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_persist.py", "testname": "test_persist.py", "funcname": "test_wkb_dumps_endianness", "imports": ["import pickle", "import struct", "import unittest", "from shapely import wkb, wkt", "from shapely.geometry import Point"], "code": "def test_wkb_dumps_endianness(self):\n    p = Point((- 10000000000.0), 1e-10)\n    wkb_big_endian = wkb.dumps(p, big_endian=True)\n    wkb_little_endian = wkb.dumps(p, big_endian=False)\n    assert (wkb_big_endian != wkb_little_endian)\n    assert (wkb_big_endian[0] == 0)\n    assert (wkb_little_endian[0] == 1)\n    double_size = struct.calcsize('d')\n    assert (wkb_big_endian[((- 2) * double_size):] == struct.pack('>2d', p.x, p.y))\n    assert (wkb_little_endian[((- 2) * double_size):] == struct.pack('<2d', p.x, p.y))", "masked_code": "def test_wkb_dumps_endianness(self):\n    p = Point((- 10000000000.0), 1e-10)\n    wkb_big_endian = wkb.dumps(p, big_endian=True)\n    wkb_little_endian = wkb.dumps(p, big_endian=False)\n    assert (wkb_big_endian != wkb_little_endian)\n    assert (wkb_big_endian[0] == 0)\n    assert (wkb_little_endian[0] == 1)\n    double_size = struct.calcsize('d')\n    assert (wkb_big_endian[((- 2) * double_size):] == '???')\n    assert (wkb_little_endian[((- 2) * double_size):] == struct.pack('<2d', p.x, p.y))", "ground_truth": ["b'\\xc2\\x02\\xa0_ \\x00\\x00\\x00=\\xdb|\\xdf\\xd9\\xd7\\xbd\\xbb'", "struct.pack('>2d', p.x, p.y)"], "quality_analysis": {"complexity_score": 12, "left_complexity": 4, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "PersistTestCase"}
{"task_id": "shapely_538", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_persist.py", "testname": "test_persist.py", "funcname": "test_wkb_dumps_endianness", "imports": ["import pickle", "import struct", "import unittest", "from shapely import wkb, wkt", "from shapely.geometry import Point"], "code": "def test_wkb_dumps_endianness(self):\n    p = Point((- 10000000000.0), 1e-10)\n    wkb_big_endian = wkb.dumps(p, big_endian=True)\n    wkb_little_endian = wkb.dumps(p, big_endian=False)\n    assert (wkb_big_endian != wkb_little_endian)\n    assert (wkb_big_endian[0] == 0)\n    assert (wkb_little_endian[0] == 1)\n    double_size = struct.calcsize('d')\n    assert (wkb_big_endian[((- 2) * double_size):] == struct.pack('>2d', p.x, p.y))\n    assert (wkb_little_endian[((- 2) * double_size):] == struct.pack('<2d', p.x, p.y))", "masked_code": "def test_wkb_dumps_endianness(self):\n    p = Point((- 10000000000.0), 1e-10)\n    wkb_big_endian = wkb.dumps(p, big_endian=True)\n    wkb_little_endian = wkb.dumps(p, big_endian=False)\n    assert (wkb_big_endian != wkb_little_endian)\n    assert (wkb_big_endian[0] == 0)\n    assert (wkb_little_endian[0] == 1)\n    double_size = struct.calcsize('d')\n    assert (wkb_big_endian[((- 2) * double_size):] == struct.pack('>2d', p.x, p.y))\n    assert (wkb_little_endian[((- 2) * double_size):] == '???')", "ground_truth": ["b'\\x00\\x00\\x00 _\\xa0\\x02\\xc2\\xbb\\xbd\\xd7\\xd9\\xdf|\\xdb='", "struct.pack('<2d', p.x, p.y)"], "quality_analysis": {"complexity_score": 12, "left_complexity": 4, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "PersistTestCase"}
{"task_id": "shapely_539", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_pickle.py", "testname": "test_pickle.py", "funcname": "test_pickle_round_trip", "imports": ["import pathlib", "import pickle", "import warnings", "from pickle import HIGHEST_PROTOCOL, dumps, loads", "import pytest", "import shapely", "from shapely import wkt", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, box"], "code": "@pytest.mark.parametrize('geom1', AUGMENTED_TEST_GEOMS, ids=AUGMENTED_TEST_NAMES)\ndef test_pickle_round_trip(geom1):\n    data = dumps(geom1, HIGHEST_PROTOCOL)\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        geom2 = loads(data)\n    assert (geom2.has_z == geom1.has_z)\n    assert (type(geom2) is type(geom1))\n    assert (geom2.geom_type == geom1.geom_type)\n    assert (geom2.wkt == geom1.wkt)", "masked_code": "@pytest.mark.parametrize('geom1', AUGMENTED_TEST_GEOMS, ids=AUGMENTED_TEST_NAMES)\ndef test_pickle_round_trip(geom1):\n    data = dumps(geom1, HIGHEST_PROTOCOL)\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        geom2 = loads(data)\n    assert (geom2.has_z == '???')\n    assert (type(geom2) is type(geom1))\n    assert (geom2.geom_type == geom1.geom_type)\n    assert (geom2.wkt == geom1.wkt)", "ground_truth": ["False", "geom1.has_z"], "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_540", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_pickle.py", "testname": "test_pickle.py", "funcname": "test_pickle_round_trip", "imports": ["import pathlib", "import pickle", "import warnings", "from pickle import HIGHEST_PROTOCOL, dumps, loads", "import pytest", "import shapely", "from shapely import wkt", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, box"], "code": "@pytest.mark.parametrize('geom1', AUGMENTED_TEST_GEOMS, ids=AUGMENTED_TEST_NAMES)\ndef test_pickle_round_trip(geom1):\n    data = dumps(geom1, HIGHEST_PROTOCOL)\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        geom2 = loads(data)\n    assert (geom2.has_z == geom1.has_z)\n    assert (type(geom2) is type(geom1))\n    assert (geom2.geom_type == geom1.geom_type)\n    assert (geom2.wkt == geom1.wkt)", "masked_code": "@pytest.mark.parametrize('geom1', AUGMENTED_TEST_GEOMS, ids=AUGMENTED_TEST_NAMES)\ndef test_pickle_round_trip(geom1):\n    data = dumps(geom1, HIGHEST_PROTOCOL)\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        geom2 = loads(data)\n    assert (geom2.has_z == geom1.has_z)\n    assert (type(geom2) is type(geom1))\n    assert (geom2.geom_type == '???')\n    assert (geom2.wkt == geom1.wkt)", "ground_truth": ["'Point'", "geom1.geom_type"], "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_541", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_pickle.py", "testname": "test_pickle.py", "funcname": "test_pickle_round_trip", "imports": ["import pathlib", "import pickle", "import warnings", "from pickle import HIGHEST_PROTOCOL, dumps, loads", "import pytest", "import shapely", "from shapely import wkt", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon, box"], "code": "@pytest.mark.parametrize('geom1', AUGMENTED_TEST_GEOMS, ids=AUGMENTED_TEST_NAMES)\ndef test_pickle_round_trip(geom1):\n    data = dumps(geom1, HIGHEST_PROTOCOL)\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        geom2 = loads(data)\n    assert (geom2.has_z == geom1.has_z)\n    assert (type(geom2) is type(geom1))\n    assert (geom2.geom_type == geom1.geom_type)\n    assert (geom2.wkt == geom1.wkt)", "masked_code": "@pytest.mark.parametrize('geom1', AUGMENTED_TEST_GEOMS, ids=AUGMENTED_TEST_NAMES)\ndef test_pickle_round_trip(geom1):\n    data = dumps(geom1, HIGHEST_PROTOCOL)\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        geom2 = loads(data)\n    assert (geom2.has_z == geom1.has_z)\n    assert (type(geom2) is type(geom1))\n    assert (geom2.geom_type == geom1.geom_type)\n    assert (geom2.wkt == '???')", "ground_truth": ["'POINT (0 0)'", "geom1.wkt"], "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_363", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_coords", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_coords(self):\n    p = Point(0.0, 0.0, (- 1.0))\n    coords = p.coords[0]\n    assert (coords == (0.0, 0.0, (- 1.0)))\n    a = np.asarray(coords)\n    assert (a.ndim == 1)\n    assert (a.size == 3)\n    assert (a.shape == (3,))", "masked_code": "def test_coords(self):\n    p = Point(0.0, 0.0, (- 1.0))\n    coords = p.coords[0]\n    assert (coords == (0.0, 0.0, (- 1.0)))\n    a = np.asarray(coords)\n    assert (a.ndim == 1)\n    assert (a.size == '???')\n    assert (a.shape == (3,))", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_364", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_coords", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_coords(self):\n    p = Point(0.0, 0.0, (- 1.0))\n    coords = p.coords[0]\n    assert (coords == (0.0, 0.0, (- 1.0)))\n    a = np.asarray(coords)\n    assert (a.ndim == 1)\n    assert (a.size == 3)\n    assert (a.shape == (3,))", "masked_code": "def test_coords(self):\n    p = Point(0.0, 0.0, (- 1.0))\n    coords = p.coords[0]\n    assert (coords == (0.0, 0.0, (- 1.0)))\n    a = np.asarray(coords)\n    assert (a.ndim == 1)\n    assert (a.size == 3)\n    assert (a.shape == '???')", "ground_truth": ["(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_328", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_coordinates", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_coordinates():\n    p = Point(1000000, (- 500000))\n    assert (p.coords[:] == [(1000000.0, (- 500000.0))])\n    assert (p.has_z is False)\n    p = Point(0.0, 0.0, (- 123456.789))\n    assert (p.coords[:] == [(0.0, 0.0, (- 123456.789))])\n    assert p.has_z\n    p = Point()\n    assert p.is_empty\n    assert isinstance(p.coords, CoordinateSequence)\n    assert (p.coords[:] == [])", "masked_code": "def test_from_coordinates():\n    p = Point(1000000, (- 500000))\n    assert (p.coords[:] == '???')\n    assert (p.has_z is False)\n    p = Point(0.0, 0.0, (- 123456.789))\n    assert (p.coords[:] == [(0.0, 0.0, (- 123456.789))])\n    assert p.has_z\n    p = Point()\n    assert p.is_empty\n    assert isinstance(p.coords, CoordinateSequence)\n    assert (p.coords[:] == [])", "ground_truth": ["[(1000000.0, (- 500000.0))]", "[[1000000.0, -500000.0]]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_329", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_coordinates", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_coordinates():\n    p = Point(1000000, (- 500000))\n    assert (p.coords[:] == [(1000000.0, (- 500000.0))])\n    assert (p.has_z is False)\n    p = Point(0.0, 0.0, (- 123456.789))\n    assert (p.coords[:] == [(0.0, 0.0, (- 123456.789))])\n    assert p.has_z\n    p = Point()\n    assert p.is_empty\n    assert isinstance(p.coords, CoordinateSequence)\n    assert (p.coords[:] == [])", "masked_code": "def test_from_coordinates():\n    p = Point(1000000, (- 500000))\n    assert (p.coords[:] == [(1000000.0, (- 500000.0))])\n    assert (p.has_z is False)\n    p = Point(0.0, 0.0, (- 123456.789))\n    assert (p.coords[:] == '???')\n    assert p.has_z\n    p = Point()\n    assert p.is_empty\n    assert isinstance(p.coords, CoordinateSequence)\n    assert (p.coords[:] == [])", "ground_truth": ["[(0.0, 0.0, (- 123456.789))]", "[[0.0, 0.0, -123456.789]]"], "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_330", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_coordinates", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_coordinates():\n    p = Point(1000000, (- 500000))\n    assert (p.coords[:] == [(1000000.0, (- 500000.0))])\n    assert (p.has_z is False)\n    p = Point(0.0, 0.0, (- 123456.789))\n    assert (p.coords[:] == [(0.0, 0.0, (- 123456.789))])\n    assert p.has_z\n    p = Point()\n    assert p.is_empty\n    assert isinstance(p.coords, CoordinateSequence)\n    assert (p.coords[:] == [])", "masked_code": "def test_from_coordinates():\n    p = Point(1000000, (- 500000))\n    assert (p.coords[:] == [(1000000.0, (- 500000.0))])\n    assert (p.has_z is False)\n    p = Point(0.0, 0.0, (- 123456.789))\n    assert (p.coords[:] == [(0.0, 0.0, (- 123456.789))])\n    assert p.has_z\n    p = Point()\n    assert p.is_empty\n    assert isinstance(p.coords, CoordinateSequence)\n    assert (p.coords[:] == '???')", "ground_truth": ["[[0.0, 0.0, -123456.789]]", "[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_344", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_generator", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_generator():\n    gen = (coord for coord in [(123456.0, (- 98765.0))])\n    p = Point(gen)\n    assert (p.coords[:] == [(123456.0, (- 98765.0))])", "masked_code": "def test_from_generator():\n    gen = (coord for coord in [(123456.0, (- 98765.0))])\n    p = Point(gen)\n    assert (p.coords[:] == '???')", "ground_truth": ["[(123456.0, (- 98765.0))]", "[[123456.0, -98765.0]]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_338", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_numpy", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_numpy():\n    p = Point(np.array([0.0, 0.0]))\n    assert (p.coords[:] == [(0.0, 0.0)])\n    p = Point(np.array([(- 100000.0), 1e-05, 2]))\n    assert (p.coords[:] == [((- 100000.0), 1e-05, 2.0)])", "masked_code": "def test_from_numpy():\n    p = Point(np.array([0.0, 0.0]))\n    assert (p.coords[:] == '???')\n    p = Point(np.array([(- 100000.0), 1e-05, 2]))\n    assert (p.coords[:] == [((- 100000.0), 1e-05, 2.0)])", "ground_truth": ["[(0.0, 0.0)]", "[[0.0, 0.0]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_339", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_numpy", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_numpy():\n    p = Point(np.array([0.0, 0.0]))\n    assert (p.coords[:] == [(0.0, 0.0)])\n    p = Point(np.array([(- 100000.0), 1e-05, 2]))\n    assert (p.coords[:] == [((- 100000.0), 1e-05, 2.0)])", "masked_code": "def test_from_numpy():\n    p = Point(np.array([0.0, 0.0]))\n    assert (p.coords[:] == [(0.0, 0.0)])\n    p = Point(np.array([(- 100000.0), 1e-05, 2]))\n    assert (p.coords[:] == '???')", "ground_truth": ["[((- 100000.0), 1e-05, 2.0)]", "[[-100000.0, 1e-05, 2.0]]"], "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_340", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_numpy_xy", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_numpy_xy():\n    p = Point(np.array([(- 2.5)]), np.array([105.1]))\n    assert (p.coords[:] == [((- 2.5), 105.1)])\n    p = Point(np.array([0.0]), np.array([0.0]), np.array([(- 300.5)]))\n    assert (p.coords[:] == [(0.0, 0.0, (- 300.5))])", "masked_code": "def test_from_numpy_xy():\n    p = Point(np.array([(- 2.5)]), np.array([105.1]))\n    assert (p.coords[:] == '???')\n    p = Point(np.array([0.0]), np.array([0.0]), np.array([(- 300.5)]))\n    assert (p.coords[:] == [(0.0, 0.0, (- 300.5))])", "ground_truth": ["[((- 2.5), 105.1)]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_341", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_numpy_xy", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_numpy_xy():\n    p = Point(np.array([(- 2.5)]), np.array([105.1]))\n    assert (p.coords[:] == [((- 2.5), 105.1)])\n    p = Point(np.array([0.0]), np.array([0.0]), np.array([(- 300.5)]))\n    assert (p.coords[:] == [(0.0, 0.0, (- 300.5))])", "masked_code": "def test_from_numpy_xy():\n    p = Point(np.array([(- 2.5)]), np.array([105.1]))\n    assert (p.coords[:] == [((- 2.5), 105.1)])\n    p = Point(np.array([0.0]), np.array([0.0]), np.array([(- 300.5)]))\n    assert (p.coords[:] == '???')", "ground_truth": ["[(0.0, 0.0, (- 300.5))]", "[[0.0, 0.0, -300.5]]"], "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_342", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_point():\n    p = Point((- 11.0), (- 22.0))\n    q = Point(p)\n    assert (q.coords[:] == [((- 11.0), (- 22.0))])\n    p = Point(0.0, (- 3.14), 2.718)\n    q = Point(p)\n    assert (q.coords[:] == [(0.0, (- 3.14), 2.718)])", "masked_code": "def test_from_point():\n    p = Point((- 11.0), (- 22.0))\n    q = Point(p)\n    assert (q.coords[:] == '???')\n    p = Point(0.0, (- 3.14), 2.718)\n    q = Point(p)\n    assert (q.coords[:] == [(0.0, (- 3.14), 2.718)])", "ground_truth": ["[((- 11.0), (- 22.0))]", "[[-11.0, -22.0]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_343", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_point():\n    p = Point((- 11.0), (- 22.0))\n    q = Point(p)\n    assert (q.coords[:] == [((- 11.0), (- 22.0))])\n    p = Point(0.0, (- 3.14), 2.718)\n    q = Point(p)\n    assert (q.coords[:] == [(0.0, (- 3.14), 2.718)])", "masked_code": "def test_from_point():\n    p = Point((- 11.0), (- 22.0))\n    q = Point(p)\n    assert (q.coords[:] == [((- 11.0), (- 22.0))])\n    p = Point(0.0, (- 3.14), 2.718)\n    q = Point(p)\n    assert (q.coords[:] == '???')", "ground_truth": ["[(0.0, (- 3.14), 2.718)]", "[[0.0, -3.14, 2.718]]"], "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_331", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == [((- 9999.999), 12345.6789)])\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == [(0.0, (- 10000000000.0))])\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == [(7000000.0, 4.0)])\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == [(0.0, (- 314.159))])\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == [(0.0, 3.14, (- 999.0))])\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == [((- 1000000000.0), 0.0, 987654321.0)])\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == [(2.718, (- 22.0), 0.0)])", "masked_code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == '???')\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == [(0.0, (- 10000000000.0))])\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == [(7000000.0, 4.0)])\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == [(0.0, (- 314.159))])\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == [(0.0, 3.14, (- 999.0))])\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == [((- 1000000000.0), 0.0, 987654321.0)])\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == [(2.718, (- 22.0), 0.0)])", "ground_truth": ["[((- 9999.999), 12345.6789)]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_332", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == [((- 9999.999), 12345.6789)])\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == [(0.0, (- 10000000000.0))])\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == [(7000000.0, 4.0)])\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == [(0.0, (- 314.159))])\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == [(0.0, 3.14, (- 999.0))])\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == [((- 1000000000.0), 0.0, 987654321.0)])\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == [(2.718, (- 22.0), 0.0)])", "masked_code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == [((- 9999.999), 12345.6789)])\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == '???')\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == [(7000000.0, 4.0)])\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == [(0.0, (- 314.159))])\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == [(0.0, 3.14, (- 999.0))])\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == [((- 1000000000.0), 0.0, 987654321.0)])\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == [(2.718, (- 22.0), 0.0)])", "ground_truth": ["[(0.0, (- 10000000000.0))]", "[[0.0, -10000000000.0]]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_333", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == [((- 9999.999), 12345.6789)])\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == [(0.0, (- 10000000000.0))])\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == [(7000000.0, 4.0)])\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == [(0.0, (- 314.159))])\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == [(0.0, 3.14, (- 999.0))])\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == [((- 1000000000.0), 0.0, 987654321.0)])\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == [(2.718, (- 22.0), 0.0)])", "masked_code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == [((- 9999.999), 12345.6789)])\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == [(0.0, (- 10000000000.0))])\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == '???')\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == [(0.0, (- 314.159))])\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == [(0.0, 3.14, (- 999.0))])\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == [((- 1000000000.0), 0.0, 987654321.0)])\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == [(2.718, (- 22.0), 0.0)])", "ground_truth": ["[(7000000.0, 4.0)]", "[[7000000.0, 4.0]]"], "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_334", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == [((- 9999.999), 12345.6789)])\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == [(0.0, (- 10000000000.0))])\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == [(7000000.0, 4.0)])\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == [(0.0, (- 314.159))])\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == [(0.0, 3.14, (- 999.0))])\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == [((- 1000000000.0), 0.0, 987654321.0)])\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == [(2.718, (- 22.0), 0.0)])", "masked_code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == [((- 9999.999), 12345.6789)])\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == [(0.0, (- 10000000000.0))])\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == [(7000000.0, 4.0)])\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == '???')\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == [(0.0, 3.14, (- 999.0))])\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == [((- 1000000000.0), 0.0, 987654321.0)])\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == [(2.718, (- 22.0), 0.0)])", "ground_truth": ["[(0.0, (- 314.159))]", "[[0.0, -314.159]]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_335", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == [((- 9999.999), 12345.6789)])\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == [(0.0, (- 10000000000.0))])\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == [(7000000.0, 4.0)])\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == [(0.0, (- 314.159))])\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == [(0.0, 3.14, (- 999.0))])\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == [((- 1000000000.0), 0.0, 987654321.0)])\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == [(2.718, (- 22.0), 0.0)])", "masked_code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == [((- 9999.999), 12345.6789)])\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == [(0.0, (- 10000000000.0))])\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == [(7000000.0, 4.0)])\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == [(0.0, (- 314.159))])\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == '???')\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == [((- 1000000000.0), 0.0, 987654321.0)])\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == [(2.718, (- 22.0), 0.0)])", "ground_truth": ["[(0.0, 3.14, (- 999.0))]", "[[0.0, -314.159]]"], "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_336", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == [((- 9999.999), 12345.6789)])\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == [(0.0, (- 10000000000.0))])\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == [(7000000.0, 4.0)])\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == [(0.0, (- 314.159))])\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == [(0.0, 3.14, (- 999.0))])\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == [((- 1000000000.0), 0.0, 987654321.0)])\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == [(2.718, (- 22.0), 0.0)])", "masked_code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == [((- 9999.999), 12345.6789)])\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == [(0.0, (- 10000000000.0))])\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == [(7000000.0, 4.0)])\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == [(0.0, (- 314.159))])\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == [(0.0, 3.14, (- 999.0))])\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == '???')\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == [(2.718, (- 22.0), 0.0)])", "ground_truth": ["[((- 1000000000.0), 0.0, 987654321.0)]", "[[-1000000000.0, 0.0, 987654321.0]]"], "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_337", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_from_sequence", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == [((- 9999.999), 12345.6789)])\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == [(0.0, (- 10000000000.0))])\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == [(7000000.0, 4.0)])\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == [(0.0, (- 314.159))])\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == [(0.0, 3.14, (- 999.0))])\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == [((- 1000000000.0), 0.0, 987654321.0)])\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == [(2.718, (- 22.0), 0.0)])", "masked_code": "def test_from_sequence():\n    p = Point(((- 9999.999), 12345.6789))\n    assert (p.coords[:] == [((- 9999.999), 12345.6789)])\n    p = Point([0, (- 10000000000.0)])\n    assert (p.coords[:] == [(0.0, (- 10000000000.0))])\n    p = Point([(7000000.0, 4.0)])\n    assert (p.coords[:] == [(7000000.0, 4.0)])\n    p = Point([[0.0, (- 314.159)]])\n    assert (p.coords[:] == [(0.0, (- 314.159))])\n    p = Point((0.0, 3.14, (- 999)))\n    assert (p.coords[:] == [(0.0, 3.14, (- 999.0))])\n    p = Point([(- 1000000000.0), 0, 987654321])\n    assert (p.coords[:] == [((- 1000000000.0), 0.0, 987654321.0)])\n    p = Point([(2.718, (- 22.0), 0)])\n    assert (p.coords[:] == '???')", "ground_truth": ["[(2.718, (- 22.0), 0.0)]", "[[2.718, -22.0, 0.0]]"], "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_347", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_numpy_empty_point_coords", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_numpy_empty_point_coords():\n    pe = Point()\n    a = np.asarray(pe.coords)\n    assert (a.shape == (0, 2))", "masked_code": "def test_numpy_empty_point_coords():\n    pe = Point()\n    a = np.asarray(pe.coords)\n    assert (a.shape == '???')", "ground_truth": ["(0, 2)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_348", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_numpy_object_array", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_numpy_object_array():\n    geom = Point(0.0, 0.0)\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == geom)", "masked_code": "def test_numpy_object_array():\n    geom = Point(0.0, 0.0)\n    ar = np.empty(1, object)\n    ar[:] = [geom]\n    assert (ar[0] == '???')", "ground_truth": ["<POINT (0 0)>", "geom"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_349", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "masked_code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == '???')\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "ground_truth": ["(- 123.456)", "-123.456"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_350", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "masked_code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == '???')\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "ground_truth": ["789.012"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_351", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "masked_code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == '???')\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "ground_truth": ["[((- 123.456), 789.012)]", "[[-123.456, 789.012]]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_352", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "masked_code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == '???')\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "ground_truth": ["'POINT (-123.456 789.012)'", "p.wkt"], "quality_analysis": {"complexity_score": 6, "left_complexity": 4, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_353", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "masked_code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == '???')\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "ground_truth": ["[(0.0, 0.0, 0.0)]", "[[0.0, 0.0, 0.0]]"], "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_354", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "masked_code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == '???')\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "ground_truth": ["'POINT (-123.456 789.012)'", "p.wkt"], "quality_analysis": {"complexity_score": 6, "left_complexity": 4, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_355", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "masked_code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == '???')\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "ground_truth": ["(- 4.0)", "-4.0"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_356", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "masked_code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == '???')\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "ground_truth": ["(- 3.0)", "-4.0"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_357", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "masked_code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == '???')\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "ground_truth": ["(((- 4.0), (- 3.0)),)", "([-4.0, -3.0],)"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_358", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "masked_code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == '???')\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "ground_truth": ["((- 4.0), (- 3.0))", "(-4.0, -3.0)"], "quality_analysis": {"complexity_score": 14, "left_complexity": 6, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_359", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == ((- 4.0), (- 3.0), (- 4.0), (- 3.0)))\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "masked_code": "def test_point(self):\n    p = Point((- 123.456), 789.012)\n    assert (p.x == (- 123.456))\n    assert (type(p.x) is float)\n    assert (p.y == 789.012)\n    assert (type(p.y) is float)\n    assert (p.coords[:] == [((- 123.456), 789.012)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is False)\n    with pytest.raises(DimensionError):\n        p.z\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    else:\n        with pytest.raises(UnsupportedGEOSVersionError):\n            p.m\n    p = Point(0.0, 0.0, 0.0)\n    assert (p.coords[:] == [(0.0, 0.0, 0.0)])\n    assert (str(p) == p.wkt)\n    assert (p.has_z is True)\n    assert (p.z == 0.0)\n    assert (type(p.z) is float)\n    if (geos_version >= (3, 12, 0)):\n        assert (p.has_m is False)\n        with pytest.raises(DimensionError):\n            p.m\n    p = Point(((- 4.0), (- 3.0)))\n    assert (p.x == (- 4.0))\n    assert (p.y == (- 3.0))\n    assert (tuple(p.coords) == (((- 4.0), (- 3.0)),))\n    assert (p.coords[0] == ((- 4.0), (- 3.0)))\n    with pytest.raises(IndexError):\n        p.coords[1]\n    assert (p.bounds == '???')\n    assert (p.__geo_interface__ == {'type': 'Point', 'coordinates': ((- 4.0), (- 3.0))})", "ground_truth": ["((- 4.0), (- 3.0), (- 4.0), (- 3.0))", "(-4.0, -3.0, -4.0, -3.0)"], "quality_analysis": {"complexity_score": 16, "left_complexity": 2, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_345", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point_array_coercion", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point_array_coercion():\n    p = Point((- 3.0), (- 4.0))\n    arr = np.array(p)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == p)\n    p_empty = Point()\n    arr_empty = np.array(p_empty)\n    assert (arr_empty.ndim == 0)\n    assert (arr_empty.size == 1)\n    assert (arr_empty.dtype == np.dtype('object'))\n    assert (arr_empty.item() == p_empty)", "masked_code": "def test_point_array_coercion():\n    p = Point((- 3.0), (- 4.0))\n    arr = np.array(p)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == '???')\n    assert (arr.item() == p)\n    p_empty = Point()\n    arr_empty = np.array(p_empty)\n    assert (arr_empty.ndim == 0)\n    assert (arr_empty.size == 1)\n    assert (arr_empty.dtype == np.dtype('object'))\n    assert (arr_empty.item() == p_empty)", "ground_truth": ["dtype('O')", "np.dtype('object')"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_346", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point_array_coercion", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point_array_coercion():\n    p = Point((- 3.0), (- 4.0))\n    arr = np.array(p)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == p)\n    p_empty = Point()\n    arr_empty = np.array(p_empty)\n    assert (arr_empty.ndim == 0)\n    assert (arr_empty.size == 1)\n    assert (arr_empty.dtype == np.dtype('object'))\n    assert (arr_empty.item() == p_empty)", "masked_code": "def test_point_array_coercion():\n    p = Point((- 3.0), (- 4.0))\n    arr = np.array(p)\n    assert (arr.ndim == 0)\n    assert (arr.size == 1)\n    assert (arr.dtype == np.dtype('object'))\n    assert (arr.item() == '???')\n    p_empty = Point()\n    arr_empty = np.array(p_empty)\n    assert (arr_empty.ndim == 0)\n    assert (arr_empty.size == 1)\n    assert (arr_empty.dtype == np.dtype('object'))\n    assert (arr_empty.item() == p_empty)", "ground_truth": ["<POINT (-3 -4)>", "p"], "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_360", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point_empty", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point_empty(self):\n    p_null = Point()\n    assert (p_null.wkt == 'POINT EMPTY')\n    assert (p_null.coords[:] == [])\n    assert (p_null.area == 0.0)\n    assert (p_null.__geo_interface__ == {'type': 'Point', 'coordinates': ()})", "masked_code": "def test_point_empty(self):\n    p_null = Point()\n    assert (p_null.wkt == '???')\n    assert (p_null.coords[:] == [])\n    assert (p_null.area == 0.0)\n    assert (p_null.__geo_interface__ == {'type': 'Point', 'coordinates': ()})", "ground_truth": ["'POINT EMPTY'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_361", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point_empty", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point_empty(self):\n    p_null = Point()\n    assert (p_null.wkt == 'POINT EMPTY')\n    assert (p_null.coords[:] == [])\n    assert (p_null.area == 0.0)\n    assert (p_null.__geo_interface__ == {'type': 'Point', 'coordinates': ()})", "masked_code": "def test_point_empty(self):\n    p_null = Point()\n    assert (p_null.wkt == 'POINT EMPTY')\n    assert (p_null.coords[:] == '???')\n    assert (p_null.area == 0.0)\n    assert (p_null.__geo_interface__ == {'type': 'Point', 'coordinates': ()})", "ground_truth": ["[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_362", "reponame": "shapely", "testpath": "shapely/tests/geometry/test_point.py", "testname": "test_point.py", "funcname": "test_point_empty", "imports": ["import numpy as np", "import pytest", "from shapely import Point, geos_version", "from shapely.coords import CoordinateSequence", "from shapely.errors import DimensionError, UnsupportedGEOSVersionError"], "code": "def test_point_empty(self):\n    p_null = Point()\n    assert (p_null.wkt == 'POINT EMPTY')\n    assert (p_null.coords[:] == [])\n    assert (p_null.area == 0.0)\n    assert (p_null.__geo_interface__ == {'type': 'Point', 'coordinates': ()})", "masked_code": "def test_point_empty(self):\n    p_null = Point()\n    assert (p_null.wkt == 'POINT EMPTY')\n    assert (p_null.coords[:] == [])\n    assert (p_null.area == 0.0)\n    assert (p_null.__geo_interface__ == '???')", "ground_truth": ["{'type': 'Point', 'coordinates': ()}", "{'type': 'Point', 'coordinates': []}"], "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestPoint"}
{"task_id": "shapely_542", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polygonize.py", "testname": "test_polygonize.py", "funcname": "test_polygonize_full", "imports": ["import unittest", "from shapely.geometry import LineString, Point, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.ops import polygonize, polygonize_full"], "code": "def test_polygonize_full(self):\n    lines2 = [[((- 1.5), (- 1)), (1.5, 1)], [(0, 0), (0, 10)], [(0, 10), (10, 10)], [(10, 10), (10, 0)], [(10, 0), (0, 0)], [(20, 20), (30, 30)], [(10, 10), (1000000.0, 1000000.0)], [(3, 3), (3, 3)], [((- 1.5), (- 1)), (5, 5)]]\n    (result2, cuts, dangles, invalids) = polygonize_full(lines2)\n    assert (len(result2.geoms) == 1)\n    assert all((isinstance(x, Polygon) for x in result2.geoms))\n    assert (list(cuts.geoms) == [])\n    assert all((isinstance(x, LineString) for x in dangles.geoms))\n    assert (dump_coords(dangles) == [[(10.0, 10.0), (1000000.0, 1000000.0)], [(20.0, 20.0), (30.0, 30.0)], [((- 1.5), (- 1.0)), (5.0, 5.0)], [((- 1.5), (- 1.0)), (1.5, 1.0)]])\n    assert (list(invalids.geoms) == [])", "masked_code": "def test_polygonize_full(self):\n    lines2 = [[((- 1.5), (- 1)), (1.5, 1)], [(0, 0), (0, 10)], [(0, 10), (10, 10)], [(10, 10), (10, 0)], [(10, 0), (0, 0)], [(20, 20), (30, 30)], [(10, 10), (1000000.0, 1000000.0)], [(3, 3), (3, 3)], [((- 1.5), (- 1)), (5, 5)]]\n    (result2, cuts, dangles, invalids) = polygonize_full(lines2)\n    assert (len(result2.geoms) == 1)\n    assert all((isinstance(x, Polygon) for x in result2.geoms))\n    assert (list(cuts.geoms) == '???')\n    assert all((isinstance(x, LineString) for x in dangles.geoms))\n    assert (dump_coords(dangles) == [[(10.0, 10.0), (1000000.0, 1000000.0)], [(20.0, 20.0), (30.0, 30.0)], [((- 1.5), (- 1.0)), (5.0, 5.0)], [((- 1.5), (- 1.0)), (1.5, 1.0)]])\n    assert (list(invalids.geoms) == [])", "ground_truth": ["[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolygonizeTestCase"}
{"task_id": "shapely_543", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polygonize.py", "testname": "test_polygonize.py", "funcname": "test_polygonize_full", "imports": ["import unittest", "from shapely.geometry import LineString, Point, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.ops import polygonize, polygonize_full"], "code": "def test_polygonize_full(self):\n    lines2 = [[((- 1.5), (- 1)), (1.5, 1)], [(0, 0), (0, 10)], [(0, 10), (10, 10)], [(10, 10), (10, 0)], [(10, 0), (0, 0)], [(20, 20), (30, 30)], [(10, 10), (1000000.0, 1000000.0)], [(3, 3), (3, 3)], [((- 1.5), (- 1)), (5, 5)]]\n    (result2, cuts, dangles, invalids) = polygonize_full(lines2)\n    assert (len(result2.geoms) == 1)\n    assert all((isinstance(x, Polygon) for x in result2.geoms))\n    assert (list(cuts.geoms) == [])\n    assert all((isinstance(x, LineString) for x in dangles.geoms))\n    assert (dump_coords(dangles) == [[(10.0, 10.0), (1000000.0, 1000000.0)], [(20.0, 20.0), (30.0, 30.0)], [((- 1.5), (- 1.0)), (5.0, 5.0)], [((- 1.5), (- 1.0)), (1.5, 1.0)]])\n    assert (list(invalids.geoms) == [])", "masked_code": "def test_polygonize_full(self):\n    lines2 = [[((- 1.5), (- 1)), (1.5, 1)], [(0, 0), (0, 10)], [(0, 10), (10, 10)], [(10, 10), (10, 0)], [(10, 0), (0, 0)], [(20, 20), (30, 30)], [(10, 10), (1000000.0, 1000000.0)], [(3, 3), (3, 3)], [((- 1.5), (- 1)), (5, 5)]]\n    (result2, cuts, dangles, invalids) = polygonize_full(lines2)\n    assert (len(result2.geoms) == 1)\n    assert all((isinstance(x, Polygon) for x in result2.geoms))\n    assert (list(cuts.geoms) == [])\n    assert all((isinstance(x, LineString) for x in dangles.geoms))\n    assert (dump_coords(dangles) == '???')\n    assert (list(invalids.geoms) == [])", "ground_truth": ["[[(10.0, 10.0), (1000000.0, 1000000.0)], [(20.0, 20.0), (30.0, 30.0)], [((- 1.5), (- 1.0)), (5.0, 5.0)], [((- 1.5), (- 1.0)), (1.5, 1.0)]]", "[[[10.0, 10.0], [1000000.0, 1000000.0]], [[20.0, 20.0], [30.0, 30.0]], [[-1.5, -1.0], [5.0, 5.0]], [[-1.5, -1.0], [1.5, 1.0]]]"], "quality_analysis": {"complexity_score": 54, "left_complexity": 4, "right_complexity": 50, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolygonizeTestCase"}
{"task_id": "shapely_544", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polygonize.py", "testname": "test_polygonize.py", "funcname": "test_polygonize_full", "imports": ["import unittest", "from shapely.geometry import LineString, Point, Polygon", "from shapely.geometry.base import dump_coords", "from shapely.ops import polygonize, polygonize_full"], "code": "def test_polygonize_full(self):\n    lines2 = [[((- 1.5), (- 1)), (1.5, 1)], [(0, 0), (0, 10)], [(0, 10), (10, 10)], [(10, 10), (10, 0)], [(10, 0), (0, 0)], [(20, 20), (30, 30)], [(10, 10), (1000000.0, 1000000.0)], [(3, 3), (3, 3)], [((- 1.5), (- 1)), (5, 5)]]\n    (result2, cuts, dangles, invalids) = polygonize_full(lines2)\n    assert (len(result2.geoms) == 1)\n    assert all((isinstance(x, Polygon) for x in result2.geoms))\n    assert (list(cuts.geoms) == [])\n    assert all((isinstance(x, LineString) for x in dangles.geoms))\n    assert (dump_coords(dangles) == [[(10.0, 10.0), (1000000.0, 1000000.0)], [(20.0, 20.0), (30.0, 30.0)], [((- 1.5), (- 1.0)), (5.0, 5.0)], [((- 1.5), (- 1.0)), (1.5, 1.0)]])\n    assert (list(invalids.geoms) == [])", "masked_code": "def test_polygonize_full(self):\n    lines2 = [[((- 1.5), (- 1)), (1.5, 1)], [(0, 0), (0, 10)], [(0, 10), (10, 10)], [(10, 10), (10, 0)], [(10, 0), (0, 0)], [(20, 20), (30, 30)], [(10, 10), (1000000.0, 1000000.0)], [(3, 3), (3, 3)], [((- 1.5), (- 1)), (5, 5)]]\n    (result2, cuts, dangles, invalids) = polygonize_full(lines2)\n    assert (len(result2.geoms) == 1)\n    assert all((isinstance(x, Polygon) for x in result2.geoms))\n    assert (list(cuts.geoms) == [])\n    assert all((isinstance(x, LineString) for x in dangles.geoms))\n    assert (dump_coords(dangles) == [[(10.0, 10.0), (1000000.0, 1000000.0)], [(20.0, 20.0), (30.0, 30.0)], [((- 1.5), (- 1.0)), (5.0, 5.0)], [((- 1.5), (- 1.0)), (1.5, 1.0)]])\n    assert (list(invalids.geoms) == '???')", "ground_truth": ["[]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolygonizeTestCase"}
{"task_id": "shapely_548", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polylabel.py", "testname": "test_polylabel.py", "funcname": "test_polygon_with_hole", "imports": ["import unittest", "import pytest", "import shapely", "from shapely.algorithms.polylabel import polylabel", "from shapely.geometry import LineString, Point, Polygon"], "code": "def test_polygon_with_hole(self):\n    '\\n        Finds pole of inaccessibility for a polygon with a hole\\n        https://github.com/shapely/shapely/issues/817\\n        '\n    polygon = Polygon(shell=[(100, 100), (300, 100), (300, 300), (100, 300), (100, 100)], holes=[[(150, 150), (250, 150), (250, 200), (150, 200), (150, 150)]])\n    label = polylabel(polygon, 0.05)\n    assert (label.x == pytest.approx(150.0))\n    assert (label.y == pytest.approx(250.0))", "masked_code": "def test_polygon_with_hole(self):\n    '\\n        Finds pole of inaccessibility for a polygon with a hole\\n        https://github.com/shapely/shapely/issues/817\\n        '\n    polygon = Polygon(shell=[(100, 100), (300, 100), (300, 300), (100, 300), (100, 100)], holes=[[(150, 150), (250, 150), (250, 200), (150, 200), (150, 150)]])\n    label = polylabel(polygon, 0.05)\n    assert (label.x == '???')\n    assert (label.y == pytest.approx(250.0))", "ground_truth": ["150", "150.0", "pytest.approx(150.0)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolylabelTestCase"}
{"task_id": "shapely_549", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polylabel.py", "testname": "test_polylabel.py", "funcname": "test_polygon_with_hole", "imports": ["import unittest", "import pytest", "import shapely", "from shapely.algorithms.polylabel import polylabel", "from shapely.geometry import LineString, Point, Polygon"], "code": "def test_polygon_with_hole(self):\n    '\\n        Finds pole of inaccessibility for a polygon with a hole\\n        https://github.com/shapely/shapely/issues/817\\n        '\n    polygon = Polygon(shell=[(100, 100), (300, 100), (300, 300), (100, 300), (100, 100)], holes=[[(150, 150), (250, 150), (250, 200), (150, 200), (150, 150)]])\n    label = polylabel(polygon, 0.05)\n    assert (label.x == pytest.approx(150.0))\n    assert (label.y == pytest.approx(250.0))", "masked_code": "def test_polygon_with_hole(self):\n    '\\n        Finds pole of inaccessibility for a polygon with a hole\\n        https://github.com/shapely/shapely/issues/817\\n        '\n    polygon = Polygon(shell=[(100, 100), (300, 100), (300, 300), (100, 300), (100, 100)], holes=[[(150, 150), (250, 150), (250, 200), (150, 200), (150, 150)]])\n    label = polylabel(polygon, 0.05)\n    assert (label.x == pytest.approx(150.0))\n    assert (label.y == '???')", "ground_truth": ["250", "250.0", "pytest.approx(250.0)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolylabelTestCase"}
{"task_id": "shapely_545", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polylabel.py", "testname": "test_polylabel.py", "funcname": "test_rectangle_special_case", "imports": ["import unittest", "import pytest", "import shapely", "from shapely.algorithms.polylabel import polylabel", "from shapely.geometry import LineString, Point, Polygon"], "code": "def test_rectangle_special_case(self):\n    '\\n        The centroid algorithm used is vulnerable to floating point errors\\n        and can give unexpected results for rectangular polygons. Test\\n        that this special case is handled correctly.\\n        https://github.com/mapbox/polylabel/issues/3\\n        '\n    polygon = Polygon([((- 2000.0), (- 3000.0)), ((- 2000.0), 2000.0), (3000.0, 2000.0), (3000.0, (- 3000.0))])\n    label = polylabel(polygon)\n    if (shapely.geos_version >= (3, 14, 0)):\n        assert (label.coords[:] == [(500.0, (- 500.0))])\n    elif (shapely.geos_version >= (3, 12, 0)):\n        assert (label.coords[:] == [(500.0, (- 500.0))])\n    else:\n        assert (label.coords[:] == [(500.0, (- 500.0))])", "masked_code": "def test_rectangle_special_case(self):\n    '\\n        The centroid algorithm used is vulnerable to floating point errors\\n        and can give unexpected results for rectangular polygons. Test\\n        that this special case is handled correctly.\\n        https://github.com/mapbox/polylabel/issues/3\\n        '\n    polygon = Polygon([((- 2000.0), (- 3000.0)), ((- 2000.0), 2000.0), (3000.0, 2000.0), (3000.0, (- 3000.0))])\n    label = polylabel(polygon)\n    if (shapely.geos_version >= (3, 14, 0)):\n        assert (label.coords[:] == '???')\n    elif (shapely.geos_version >= (3, 12, 0)):\n        assert (label.coords[:] == [(500.0, (- 500.0))])\n    else:\n        assert (label.coords[:] == [(500.0, (- 500.0))])", "ground_truth": ["[(500.0, (- 500.0))]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolylabelTestCase"}
{"task_id": "shapely_546", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polylabel.py", "testname": "test_polylabel.py", "funcname": "test_rectangle_special_case", "imports": ["import unittest", "import pytest", "import shapely", "from shapely.algorithms.polylabel import polylabel", "from shapely.geometry import LineString, Point, Polygon"], "code": "def test_rectangle_special_case(self):\n    '\\n        The centroid algorithm used is vulnerable to floating point errors\\n        and can give unexpected results for rectangular polygons. Test\\n        that this special case is handled correctly.\\n        https://github.com/mapbox/polylabel/issues/3\\n        '\n    polygon = Polygon([((- 2000.0), (- 3000.0)), ((- 2000.0), 2000.0), (3000.0, 2000.0), (3000.0, (- 3000.0))])\n    label = polylabel(polygon)\n    if (shapely.geos_version >= (3, 14, 0)):\n        assert (label.coords[:] == [(500.0, (- 500.0))])\n    elif (shapely.geos_version >= (3, 12, 0)):\n        assert (label.coords[:] == [(500.0, (- 500.0))])\n    else:\n        assert (label.coords[:] == [(500.0, (- 500.0))])", "masked_code": "def test_rectangle_special_case(self):\n    '\\n        The centroid algorithm used is vulnerable to floating point errors\\n        and can give unexpected results for rectangular polygons. Test\\n        that this special case is handled correctly.\\n        https://github.com/mapbox/polylabel/issues/3\\n        '\n    polygon = Polygon([((- 2000.0), (- 3000.0)), ((- 2000.0), 2000.0), (3000.0, 2000.0), (3000.0, (- 3000.0))])\n    label = polylabel(polygon)\n    if (shapely.geos_version >= (3, 14, 0)):\n        assert (label.coords[:] == [(500.0, (- 500.0))])\n    elif (shapely.geos_version >= (3, 12, 0)):\n        assert (label.coords[:] == '???')\n    else:\n        assert (label.coords[:] == [(500.0, (- 500.0))])", "ground_truth": ["[(500.0, (- 500.0))]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolylabelTestCase"}
{"task_id": "shapely_547", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_polylabel.py", "testname": "test_polylabel.py", "funcname": "test_rectangle_special_case", "imports": ["import unittest", "import pytest", "import shapely", "from shapely.algorithms.polylabel import polylabel", "from shapely.geometry import LineString, Point, Polygon"], "code": "def test_rectangle_special_case(self):\n    '\\n        The centroid algorithm used is vulnerable to floating point errors\\n        and can give unexpected results for rectangular polygons. Test\\n        that this special case is handled correctly.\\n        https://github.com/mapbox/polylabel/issues/3\\n        '\n    polygon = Polygon([((- 2000.0), (- 3000.0)), ((- 2000.0), 2000.0), (3000.0, 2000.0), (3000.0, (- 3000.0))])\n    label = polylabel(polygon)\n    if (shapely.geos_version >= (3, 14, 0)):\n        assert (label.coords[:] == [(500.0, (- 500.0))])\n    elif (shapely.geos_version >= (3, 12, 0)):\n        assert (label.coords[:] == [(500.0, (- 500.0))])\n    else:\n        assert (label.coords[:] == [(500.0, (- 500.0))])", "masked_code": "def test_rectangle_special_case(self):\n    '\\n        The centroid algorithm used is vulnerable to floating point errors\\n        and can give unexpected results for rectangular polygons. Test\\n        that this special case is handled correctly.\\n        https://github.com/mapbox/polylabel/issues/3\\n        '\n    polygon = Polygon([((- 2000.0), (- 3000.0)), ((- 2000.0), 2000.0), (3000.0, 2000.0), (3000.0, (- 3000.0))])\n    label = polylabel(polygon)\n    if (shapely.geos_version >= (3, 14, 0)):\n        assert (label.coords[:] == [(500.0, (- 500.0))])\n    elif (shapely.geos_version >= (3, 12, 0)):\n        assert (label.coords[:] == [(500.0, (- 500.0))])\n    else:\n        assert (label.coords[:] == '???')", "ground_truth": ["[(500.0, (- 500.0))]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolylabelTestCase"}
{"task_id": "shapely_553", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == '???')\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["True", "prepared_polygon1.disjoint(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_554", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == '???')\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["False", "prepared_polygon1.touches(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_555", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == '???')\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["False", "prepared_polygon1.intersects(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_556", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == '???')\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["False", "prepared_polygon1.crosses(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_557", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == '???')\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["False", "prepared_polygon1.within(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_558", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == '???')\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["False", "prepared_polygon1.contains(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_559", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == '???')\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "ground_truth": ["False", "prepared_polygon1.contains_properly(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_560", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_prepared.py", "testname": "test_prepared.py", "funcname": "test_prepared_predicates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import Point, Polygon", "from shapely.prepared import PreparedGeometry, prep"], "code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == prepared_polygon1.overlaps(geom2))", "masked_code": "def test_prepared_predicates():\n    polygon1 = Polygon([(2, 2), (5, 2), (5, 5), (2, 5), (2, 2)])\n    polygon2 = Polygon([(10, 10), (20, 10), (20, 20), (10, 20), (10, 10)])\n    point2 = Point(0, 0)\n    polygon_empty = Polygon()\n    prepared_polygon1 = PreparedGeometry(polygon1)\n    for geom2 in (polygon2, point2, polygon_empty):\n        with np.errstate(invalid='ignore'):\n            assert (polygon1.disjoint(geom2) == prepared_polygon1.disjoint(geom2))\n            assert (polygon1.touches(geom2) == prepared_polygon1.touches(geom2))\n            assert (polygon1.intersects(geom2) == prepared_polygon1.intersects(geom2))\n            assert (polygon1.crosses(geom2) == prepared_polygon1.crosses(geom2))\n            assert (polygon1.within(geom2) == prepared_polygon1.within(geom2))\n            assert (polygon1.contains(geom2) == prepared_polygon1.contains(geom2))\n            assert (polygon1.contains_properly(geom2) == prepared_polygon1.contains_properly(geom2))\n            assert (polygon1.overlaps(geom2) == '???')", "ground_truth": ["False", "prepared_polygon1.overlaps(geom2)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_561", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_products_z.py", "testname": "test_products_z.py", "funcname": "test_line_intersection", "imports": ["import unittest", "from shapely.geometry import LineString"], "code": "def test_line_intersection(self):\n    line1 = LineString([((- 10), (- 10), (- 5.5)), (10, 10, 25.5)])\n    line2 = LineString([((- 10), 10, 12.25), (10, (- 10), (- 1.25))])\n    interxn = line1.intersection(line2)\n    assert interxn.has_z\n    assert (interxn._ndim == 3)\n    assert ((- 5.5) <= interxn.z <= 25.5)", "masked_code": "def test_line_intersection(self):\n    line1 = LineString([((- 10), (- 10), (- 5.5)), (10, 10, 25.5)])\n    line2 = LineString([((- 10), 10, 12.25), (10, (- 10), (- 1.25))])\n    interxn = line1.intersection(line2)\n    assert interxn.has_z\n    assert (interxn._ndim == '???')\n    assert ((- 5.5) <= interxn.z <= 25.5)", "ground_truth": ["3"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "ProductZTestCase"}
{"task_id": "shapely_226", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_coverage_union_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('n', range(2, 5))\ndef test_coverage_union_reduce_axis(n):\n    data = [[shapely.box((i * n), (j * n), ((i + 1) * n), ((j + 1) * n)) for i in range(2)] for j in range(3)]\n    actual = shapely.coverage_union_all(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual0 = shapely.coverage_union_all(data, axis=0)\n    assert (actual0.shape == (2,))\n    actual1 = shapely.coverage_union_all(data, axis=1)\n    assert (actual1.shape == (3,))\n    actualm1 = shapely.coverage_union_all(data, axis=(- 1))\n    assert (actualm1.shape == (3,))", "masked_code": "@pytest.mark.parametrize('n', range(2, 5))\ndef test_coverage_union_reduce_axis(n):\n    data = [[shapely.box((i * n), (j * n), ((i + 1) * n), ((j + 1) * n)) for i in range(2)] for j in range(3)]\n    actual = shapely.coverage_union_all(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual0 = shapely.coverage_union_all(data, axis=0)\n    assert (actual0.shape == '???')\n    actual1 = shapely.coverage_union_all(data, axis=1)\n    assert (actual1.shape == (3,))\n    actualm1 = shapely.coverage_union_all(data, axis=(- 1))\n    assert (actualm1.shape == (3,))", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_227", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_coverage_union_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('n', range(2, 5))\ndef test_coverage_union_reduce_axis(n):\n    data = [[shapely.box((i * n), (j * n), ((i + 1) * n), ((j + 1) * n)) for i in range(2)] for j in range(3)]\n    actual = shapely.coverage_union_all(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual0 = shapely.coverage_union_all(data, axis=0)\n    assert (actual0.shape == (2,))\n    actual1 = shapely.coverage_union_all(data, axis=1)\n    assert (actual1.shape == (3,))\n    actualm1 = shapely.coverage_union_all(data, axis=(- 1))\n    assert (actualm1.shape == (3,))", "masked_code": "@pytest.mark.parametrize('n', range(2, 5))\ndef test_coverage_union_reduce_axis(n):\n    data = [[shapely.box((i * n), (j * n), ((i + 1) * n), ((j + 1) * n)) for i in range(2)] for j in range(3)]\n    actual = shapely.coverage_union_all(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual0 = shapely.coverage_union_all(data, axis=0)\n    assert (actual0.shape == (2,))\n    actual1 = shapely.coverage_union_all(data, axis=1)\n    assert (actual1.shape == '???')\n    actualm1 = shapely.coverage_union_all(data, axis=(- 1))\n    assert (actualm1.shape == (3,))", "ground_truth": ["(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_228", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_coverage_union_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('n', range(2, 5))\ndef test_coverage_union_reduce_axis(n):\n    data = [[shapely.box((i * n), (j * n), ((i + 1) * n), ((j + 1) * n)) for i in range(2)] for j in range(3)]\n    actual = shapely.coverage_union_all(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual0 = shapely.coverage_union_all(data, axis=0)\n    assert (actual0.shape == (2,))\n    actual1 = shapely.coverage_union_all(data, axis=1)\n    assert (actual1.shape == (3,))\n    actualm1 = shapely.coverage_union_all(data, axis=(- 1))\n    assert (actualm1.shape == (3,))", "masked_code": "@pytest.mark.parametrize('n', range(2, 5))\ndef test_coverage_union_reduce_axis(n):\n    data = [[shapely.box((i * n), (j * n), ((i + 1) * n), ((j + 1) * n)) for i in range(2)] for j in range(3)]\n    actual = shapely.coverage_union_all(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual0 = shapely.coverage_union_all(data, axis=0)\n    assert (actual0.shape == (2,))\n    actual1 = shapely.coverage_union_all(data, axis=1)\n    assert (actual1.shape == (3,))\n    actualm1 = shapely.coverage_union_all(data, axis=(- 1))\n    assert (actualm1.shape == '???')", "ground_truth": ["(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_211", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('a', all_types)\n@pytest.mark.parametrize('func', SET_OPERATIONS)\ndef test_set_operation_array(a, func):\n    actual = func(empty, a)\n    assert isinstance(actual, Geometry)\n    arr_input = np.array([a, empty])\n    actual = func(arr_input, point)\n    assert (actual.shape == (2,))\n    assert isinstance(actual[0], Geometry)", "masked_code": "@pytest.mark.parametrize('a', all_types)\n@pytest.mark.parametrize('func', SET_OPERATIONS)\ndef test_set_operation_array(a, func):\n    actual = func(empty, a)\n    assert isinstance(actual, Geometry)\n    arr_input = np.array([a, empty])\n    actual = func(arr_input, point)\n    assert (actual.shape == '???')\n    assert isinstance(actual[0], Geometry)", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_212", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_prec_array", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('a', all_single_types)\n@pytest.mark.parametrize('func', SET_OPERATIONS)\n@pytest.mark.parametrize('grid_size', [0, (- 1), 100])\ndef test_set_operation_prec_array(a, func, grid_size):\n    if (func is shapely.disjoint_subset_union):\n        pytest.skip('disjoint_subset_union does not support grid_size')\n    actual = func([point, a], a, grid_size=grid_size)\n    assert (actual.shape == (2,))\n    assert isinstance(actual[0], Geometry)\n    b = shapely.set_precision(point, grid_size=grid_size)\n    a2 = shapely.set_precision(a, grid_size=grid_size)\n    expected = func([b, a2], a2, grid_size=grid_size)\n    assert shapely.equals(shapely.normalize(actual), shapely.normalize(expected)).all()", "masked_code": "@pytest.mark.parametrize('a', all_single_types)\n@pytest.mark.parametrize('func', SET_OPERATIONS)\n@pytest.mark.parametrize('grid_size', [0, (- 1), 100])\ndef test_set_operation_prec_array(a, func, grid_size):\n    if (func is shapely.disjoint_subset_union):\n        pytest.skip('disjoint_subset_union does not support grid_size')\n    actual = func([point, a], a, grid_size=grid_size)\n    assert (actual.shape == '???')\n    assert isinstance(actual[0], Geometry)\n    b = shapely.set_precision(point, grid_size=grid_size)\n    a2 = shapely.set_precision(a, grid_size=grid_size)\n    expected = func([b, a2], a2, grid_size=grid_size)\n    assert shapely.equals(shapely.normalize(actual), shapely.normalize(expected)).all()", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_223", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_prec_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS_PREC)\ndef test_set_operation_prec_reduce_axis(func, related_func):\n    data = [[point, empty], [shapely.Point(10, 10), shapely.Point((- 10), (- 10))], [shapely.Point(5, 5), point]]\n    actual = func(data, grid_size=10, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, grid_size=10, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, grid_size=10, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, grid_size=10, axis=(- 1))\n    assert (actual.shape == (3,))", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS_PREC)\ndef test_set_operation_prec_reduce_axis(func, related_func):\n    data = [[point, empty], [shapely.Point(10, 10), shapely.Point((- 10), (- 10))], [shapely.Point(5, 5), point]]\n    actual = func(data, grid_size=10, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, grid_size=10, axis=0)\n    assert (actual.shape == '???')\n    actual = func(data, grid_size=10, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, grid_size=10, axis=(- 1))\n    assert (actual.shape == (3,))", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_224", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_prec_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS_PREC)\ndef test_set_operation_prec_reduce_axis(func, related_func):\n    data = [[point, empty], [shapely.Point(10, 10), shapely.Point((- 10), (- 10))], [shapely.Point(5, 5), point]]\n    actual = func(data, grid_size=10, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, grid_size=10, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, grid_size=10, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, grid_size=10, axis=(- 1))\n    assert (actual.shape == (3,))", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS_PREC)\ndef test_set_operation_prec_reduce_axis(func, related_func):\n    data = [[point, empty], [shapely.Point(10, 10), shapely.Point((- 10), (- 10))], [shapely.Point(5, 5), point]]\n    actual = func(data, grid_size=10, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, grid_size=10, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, grid_size=10, axis=1)\n    assert (actual.shape == '???')\n    actual = func(data, grid_size=10, axis=(- 1))\n    assert (actual.shape == (3,))", "ground_truth": ["(2,)", "(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_225", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_prec_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS_PREC)\ndef test_set_operation_prec_reduce_axis(func, related_func):\n    data = [[point, empty], [shapely.Point(10, 10), shapely.Point((- 10), (- 10))], [shapely.Point(5, 5), point]]\n    actual = func(data, grid_size=10, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, grid_size=10, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, grid_size=10, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, grid_size=10, axis=(- 1))\n    assert (actual.shape == (3,))", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS_PREC)\ndef test_set_operation_prec_reduce_axis(func, related_func):\n    data = [[point, empty], [shapely.Point(10, 10), shapely.Point((- 10), (- 10))], [shapely.Point(5, 5), point]]\n    actual = func(data, grid_size=10, axis=None)\n    assert isinstance(actual, Geometry)\n    actual = func(data, grid_size=10, axis=0)\n    assert (actual.shape == (2,))\n    actual = func(data, grid_size=10, axis=1)\n    assert (actual.shape == (3,))\n    actual = func(data, grid_size=10, axis=(- 1))\n    assert (actual.shape == '???')", "ground_truth": ["(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_221", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_all_none_arr", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('n', [3, 4])\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_all_none_arr(n, func, related_func):\n    assert (func(([([None] * n)] * 2), axis=1).tolist() == [empty, empty])\n    assert (func(([([None] * 2)] * n), axis=0).tolist() == [empty, empty])", "masked_code": "@pytest.mark.parametrize('n', [3, 4])\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_all_none_arr(n, func, related_func):\n    assert (func(([([None] * n)] * 2), axis=1).tolist() == '???')\n    assert (func(([([None] * 2)] * n), axis=0).tolist() == [empty, empty])", "ground_truth": ["[<GEOMETRYCOLLECTION EMPTY>, <GEOMETRYCOLLECTION EMPTY>]", "[empty, empty]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_222", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_all_none_arr", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('n', [3, 4])\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_all_none_arr(n, func, related_func):\n    assert (func(([([None] * n)] * 2), axis=1).tolist() == [empty, empty])\n    assert (func(([([None] * 2)] * n), axis=0).tolist() == [empty, empty])", "masked_code": "@pytest.mark.parametrize('n', [3, 4])\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_all_none_arr(n, func, related_func):\n    assert (func(([([None] * n)] * 2), axis=1).tolist() == [empty, empty])\n    assert (func(([([None] * 2)] * n), axis=0).tolist() == '???')", "ground_truth": ["[<GEOMETRYCOLLECTION EMPTY>, <GEOMETRYCOLLECTION EMPTY>]", "[empty, empty]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_213", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('n', range(2, 5))\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_axis(func, related_func, n):\n    data = np.array([[reduce_test_data[0], reduce_test_data[1]], [reduce_test_data[2], empty], [reduce_test_data[3], reduce_test_data[1]]], dtype=object)\n    actual = func(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual0 = func(data, axis=0)\n    assert (actual0.shape == (2,))\n    actual1 = func(data, axis=1)\n    assert (actual1.shape == (3,))\n    actualm1 = func(data, axis=(- 1))\n    assert (actualm1.shape == (3,))", "masked_code": "@pytest.mark.parametrize('n', range(2, 5))\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_axis(func, related_func, n):\n    data = np.array([[reduce_test_data[0], reduce_test_data[1]], [reduce_test_data[2], empty], [reduce_test_data[3], reduce_test_data[1]]], dtype=object)\n    actual = func(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual0 = func(data, axis=0)\n    assert (actual0.shape == '???')\n    actual1 = func(data, axis=1)\n    assert (actual1.shape == (3,))\n    actualm1 = func(data, axis=(- 1))\n    assert (actualm1.shape == (3,))", "ground_truth": ["(2,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_214", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('n', range(2, 5))\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_axis(func, related_func, n):\n    data = np.array([[reduce_test_data[0], reduce_test_data[1]], [reduce_test_data[2], empty], [reduce_test_data[3], reduce_test_data[1]]], dtype=object)\n    actual = func(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual0 = func(data, axis=0)\n    assert (actual0.shape == (2,))\n    actual1 = func(data, axis=1)\n    assert (actual1.shape == (3,))\n    actualm1 = func(data, axis=(- 1))\n    assert (actualm1.shape == (3,))", "masked_code": "@pytest.mark.parametrize('n', range(2, 5))\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_axis(func, related_func, n):\n    data = np.array([[reduce_test_data[0], reduce_test_data[1]], [reduce_test_data[2], empty], [reduce_test_data[3], reduce_test_data[1]]], dtype=object)\n    actual = func(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual0 = func(data, axis=0)\n    assert (actual0.shape == (2,))\n    actual1 = func(data, axis=1)\n    assert (actual1.shape == '???')\n    actualm1 = func(data, axis=(- 1))\n    assert (actualm1.shape == (3,))", "ground_truth": ["(2,)", "(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_215", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_axis", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('n', range(2, 5))\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_axis(func, related_func, n):\n    data = np.array([[reduce_test_data[0], reduce_test_data[1]], [reduce_test_data[2], empty], [reduce_test_data[3], reduce_test_data[1]]], dtype=object)\n    actual = func(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual0 = func(data, axis=0)\n    assert (actual0.shape == (2,))\n    actual1 = func(data, axis=1)\n    assert (actual1.shape == (3,))\n    actualm1 = func(data, axis=(- 1))\n    assert (actualm1.shape == (3,))", "masked_code": "@pytest.mark.parametrize('n', range(2, 5))\n@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_axis(func, related_func, n):\n    data = np.array([[reduce_test_data[0], reduce_test_data[1]], [reduce_test_data[2], empty], [reduce_test_data[3], reduce_test_data[1]]], dtype=object)\n    actual = func(data, axis=None)\n    assert isinstance(actual, Geometry)\n    actual0 = func(data, axis=0)\n    assert (actual0.shape == (2,))\n    actual1 = func(data, axis=1)\n    assert (actual1.shape == (3,))\n    actualm1 = func(data, axis=(- 1))\n    assert (actualm1.shape == '???')", "ground_truth": ["(3,)"], "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_216", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    arr_empty_1D = np.empty((0,), dtype=object)\n    arr_empty_2D = np.empty((0, 3), dtype=object)\n    arr_empty_3D = np.empty((2, 0, 3), dtype=object)\n    assert (func(arr_empty_1D) == empty)\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_3D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 3))\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    arr_empty_1D = np.empty((0,), dtype=object)\n    arr_empty_2D = np.empty((0, 3), dtype=object)\n    arr_empty_3D = np.empty((2, 0, 3), dtype=object)\n    assert (func(arr_empty_1D) == '???')\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_3D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 3))\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "ground_truth": ["<GEOMETRYCOLLECTION EMPTY>", "empty"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_217", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    arr_empty_1D = np.empty((0,), dtype=object)\n    arr_empty_2D = np.empty((0, 3), dtype=object)\n    arr_empty_3D = np.empty((2, 0, 3), dtype=object)\n    assert (func(arr_empty_1D) == empty)\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_3D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 3))\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    arr_empty_1D = np.empty((0,), dtype=object)\n    arr_empty_2D = np.empty((0, 3), dtype=object)\n    arr_empty_3D = np.empty((2, 0, 3), dtype=object)\n    assert (func(arr_empty_1D) == empty)\n    assert (func(arr_empty_2D) == '???')\n    assert (func(arr_empty_3D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 3))\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "ground_truth": ["<GEOMETRYCOLLECTION EMPTY>", "empty"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_218", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    arr_empty_1D = np.empty((0,), dtype=object)\n    arr_empty_2D = np.empty((0, 3), dtype=object)\n    arr_empty_3D = np.empty((2, 0, 3), dtype=object)\n    assert (func(arr_empty_1D) == empty)\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_3D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 3))\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    arr_empty_1D = np.empty((0,), dtype=object)\n    arr_empty_2D = np.empty((0, 3), dtype=object)\n    arr_empty_3D = np.empty((2, 0, 3), dtype=object)\n    assert (func(arr_empty_1D) == empty)\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_3D) == '???')\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 3))\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "ground_truth": ["<GEOMETRYCOLLECTION EMPTY>", "empty"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_219", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_empty", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    arr_empty_1D = np.empty((0,), dtype=object)\n    arr_empty_2D = np.empty((0, 3), dtype=object)\n    arr_empty_3D = np.empty((2, 0, 3), dtype=object)\n    assert (func(arr_empty_1D) == empty)\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_3D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == ([empty] * 3))\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_empty(func, related_func):\n    arr_empty_1D = np.empty((0,), dtype=object)\n    arr_empty_2D = np.empty((0, 3), dtype=object)\n    arr_empty_3D = np.empty((2, 0, 3), dtype=object)\n    assert (func(arr_empty_1D) == empty)\n    assert (func(arr_empty_2D) == empty)\n    assert (func(arr_empty_3D) == empty)\n    assert (func(arr_empty_2D, axis=0).tolist() == '???')\n    assert (func(arr_empty_2D, axis=1).tolist() == [])", "ground_truth": ["([empty] * 3)", "[<GEOMETRYCOLLECTION EMPTY>, <GEOMETRYCOLLECTION EMPTY>, <GEOMETRYCOLLECTION EMPTY>]"], "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_220", "reponame": "shapely", "testpath": "shapely/tests/test_set_operations.py", "testname": "test_set_operations.py", "funcname": "test_set_operation_reduce_some_none_len2", "imports": ["import numpy as np", "import pytest", "import shapely", "from shapely import Geometry, GeometryCollection, Polygon", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import all_types, empty, ignore_invalid, point, polygon"], "code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_some_none_len2(func, related_func):\n    assert (func([None, empty]) == empty)\n    assert (func([empty, None]) == empty)", "masked_code": "@pytest.mark.parametrize('func, related_func', REDUCE_SET_OPERATIONS)\ndef test_set_operation_reduce_some_none_len2(func, related_func):\n    assert (func([None, empty]) == '???')\n    assert (func([empty, None]) == empty)", "ground_truth": ["<GEOMETRYCOLLECTION EMPTY>", "empty"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_564", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_shape.py", "testname": "test_shape.py", "funcname": "test_multilinestring_empty", "imports": ["import pytest", "from shapely.geometry import MultiLineString, Point, Polygon, shape", "from shapely.geometry.geo import _is_coordinates_empty"], "code": "@pytest.mark.parametrize('geom', [{'type': 'MultiLineString', 'coordinates': [[]]}, {'type': 'MultiLineString', 'coordinates': [[], [[], []]]}])\ndef test_multilinestring_empty(geom):\n    coords = geom['coordinates']\n    if (coords == [[[0.0, 0.0], [1.5, 2.5]], [[3, 4], [5, 6]]]):\n        expected = MultiLineString([[(0.0, 0.0), (1.5, 2.5)], [(3, 4), (5, 6)]])\n    else:\n        expected = MultiLineString()\n    assert (shape(geom) == expected)", "masked_code": "@pytest.mark.parametrize('geom', [{'type': 'MultiLineString', 'coordinates': [[]]}, {'type': 'MultiLineString', 'coordinates': [[], [[], []]]}])\ndef test_multilinestring_empty(geom):\n    coords = geom['coordinates']\n    if (coords == [[[0.0, 0.0], [1.5, 2.5]], [[3, 4], [5, 6]]]):\n        expected = MultiLineString([[(0.0, 0.0), (1.5, 2.5)], [(3, 4), (5, 6)]])\n    else:\n        expected = MultiLineString()\n    assert (shape(geom) == '???')", "ground_truth": ["<MULTILINESTRING EMPTY>", "expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_563", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_shape.py", "testname": "test_shape.py", "funcname": "test_polygon_empty_np_array", "imports": ["import pytest", "from shapely.geometry import MultiLineString, Point, Polygon, shape", "from shapely.geometry.geo import _is_coordinates_empty"], "code": "def test_polygon_empty_np_array():\n    np = pytest.importorskip('numpy')\n    geom = {'type': 'Polygon', 'coordinates': np.array([[]])}\n    assert (shape(geom) == Polygon())", "masked_code": "def test_polygon_empty_np_array():\n    np = pytest.importorskip('numpy')\n    geom = {'type': 'Polygon', 'coordinates': np.array([[]])}\n    assert (shape(geom) == '???')", "ground_truth": ["<POLYGON EMPTY>", "Polygon()"], "quality_analysis": {"complexity_score": 7, "left_complexity": 4, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_562", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_shape.py", "testname": "test_shape.py", "funcname": "test_polygon_no_coords", "imports": ["import pytest", "from shapely.geometry import MultiLineString, Point, Polygon, shape", "from shapely.geometry.geo import _is_coordinates_empty"], "code": "@pytest.mark.parametrize('geom', [{'type': 'Polygon', 'coordinates': ''}, {'type': 'Polygon', 'coordinates': [[[0, 0], [0, 1000000], [1000000, 1000000], [1000000, 0]]]}])\ndef test_polygon_no_coords(geom):\n    if (geom['coordinates'] == ''):\n        with pytest.raises(IndexError):\n            shape(geom)\n    else:\n        expected = Polygon([(0, 0), (0, 1000000), (1000000, 1000000), (1000000, 0)])\n        assert (shape(geom) == expected)", "masked_code": "@pytest.mark.parametrize('geom', [{'type': 'Polygon', 'coordinates': ''}, {'type': 'Polygon', 'coordinates': [[[0, 0], [0, 1000000], [1000000, 1000000], [1000000, 0]]]}])\ndef test_polygon_no_coords(geom):\n    if (geom['coordinates'] == ''):\n        with pytest.raises(IndexError):\n            shape(geom)\n    else:\n        expected = Polygon([(0, 0), (0, 1000000), (1000000, 1000000), (1000000, 0)])\n        assert (shape(geom) == '???')", "ground_truth": ["<POLYGON ((0 0, 0 1000000, 1000000 1000000, 1000000 0, 0 0))>", "expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_565", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_shared_paths.py", "testname": "test_shared_paths.py", "funcname": "test_shared_paths_forward", "imports": ["import unittest", "import pytest", "from shapely.errors import GeometryTypeError", "from shapely.geometry import GeometryCollection, LineString, MultiLineString, Point", "from shapely.ops import shared_paths"], "code": "def test_shared_paths_forward(self):\n    g1 = LineString([((- 1000), (- 1000.5)), (0, 0), (1000, 0), (1000, 500.5)])\n    g2 = LineString([(0, 0), (1000, 0), (1500, 0)])\n    result = shared_paths(g1, g2)\n    assert isinstance(result, GeometryCollection)\n    assert (len(result.geoms) == 2)\n    (a, b) = result.geoms\n    assert isinstance(a, MultiLineString)\n    assert (len(a.geoms) == 1)\n    assert (a.geoms[0].coords[:] == [(0, 0), (1000, 0)])\n    assert b.is_empty", "masked_code": "def test_shared_paths_forward(self):\n    g1 = LineString([((- 1000), (- 1000.5)), (0, 0), (1000, 0), (1000, 500.5)])\n    g2 = LineString([(0, 0), (1000, 0), (1500, 0)])\n    result = shared_paths(g1, g2)\n    assert isinstance(result, GeometryCollection)\n    assert (len(result.geoms) == 2)\n    (a, b) = result.geoms\n    assert isinstance(a, MultiLineString)\n    assert (len(a.geoms) == 1)\n    assert (a.geoms[0].coords[:] == '???')\n    assert b.is_empty", "ground_truth": ["[(0, 0), (1000, 0)]", "[[0, 0], [1000, 0]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "SharedPaths"}
{"task_id": "shapely_566", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_shared_paths.py", "testname": "test_shared_paths.py", "funcname": "test_shared_paths_forward2", "imports": ["import unittest", "import pytest", "from shapely.errors import GeometryTypeError", "from shapely.geometry import GeometryCollection, LineString, MultiLineString, Point", "from shapely.ops import shared_paths"], "code": "def test_shared_paths_forward2(self):\n    g1 = LineString([(2.5, (- 100.8)), (0, 0), (10.75, 0), (10.75, 5.5)])\n    g2 = LineString([(10.75, 0), (0, 0), ((- 50), 0)])\n    result = shared_paths(g1, g2)\n    assert isinstance(result, GeometryCollection)\n    assert (len(result.geoms) == 2)\n    (a, b) = result.geoms\n    assert isinstance(b, MultiLineString)\n    assert (len(b.geoms) == 1)\n    assert (b.geoms[0].coords[:] == [(0.0, 0.0), (10.75, 0.0)])\n    assert a.is_empty", "masked_code": "def test_shared_paths_forward2(self):\n    g1 = LineString([(2.5, (- 100.8)), (0, 0), (10.75, 0), (10.75, 5.5)])\n    g2 = LineString([(10.75, 0), (0, 0), ((- 50), 0)])\n    result = shared_paths(g1, g2)\n    assert isinstance(result, GeometryCollection)\n    assert (len(result.geoms) == 2)\n    (a, b) = result.geoms\n    assert isinstance(b, MultiLineString)\n    assert (len(b.geoms) == 1)\n    assert (b.geoms[0].coords[:] == '???')\n    assert a.is_empty", "ground_truth": ["[(0.0, 0.0), (10.75, 0.0)]", "[[0.0, 0.0], [10.75, 0.0]]"], "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "SharedPaths"}
{"task_id": "shapely_567", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_singularity.py", "testname": "test_singularity.py", "funcname": "test_polygon_3", "imports": ["import unittest", "from shapely.geometry import Polygon"], "code": "def test_polygon_3(self):\n    p = (0.0, 0.0)\n    poly = Polygon([p, p, p])\n    assert (poly.bounds == (0.0, 0.0, 0.0, 0.0))", "masked_code": "def test_polygon_3(self):\n    p = (0.0, 0.0)\n    poly = Polygon([p, p, p])\n    assert (poly.bounds == '???')", "ground_truth": ["(0.0, 0.0, 0.0, 0.0)"], "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolygonTestCase"}
{"task_id": "shapely_568", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_singularity.py", "testname": "test_singularity.py", "funcname": "test_polygon_5", "imports": ["import unittest", "from shapely.geometry import Polygon"], "code": "def test_polygon_5(self):\n    p = (10000000000.0, (- 10000000000.0))\n    poly = Polygon([p, p, p, p, p])\n    assert (poly.bounds == (10000000000.0, (- 10000000000.0), 10000000000.0, (- 10000000000.0)))", "masked_code": "def test_polygon_5(self):\n    p = (10000000000.0, (- 10000000000.0))\n    poly = Polygon([p, p, p, p, p])\n    assert (poly.bounds == '???')", "ground_truth": ["(10000000000.0, (- 10000000000.0), 10000000000.0, (- 10000000000.0))"], "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "PolygonTestCase"}
{"task_id": "shapely_569", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_snap.py", "testname": "test_snap.py", "funcname": "test_snap", "imports": ["import unittest", "from shapely.geometry import LineString, Polygon", "from shapely.ops import snap"], "code": "def test_snap(self):\n    square = Polygon([((- 1000), (- 1000)), (1000, (- 1000)), (1000, 1000), ((- 1000), 1000), ((- 1000), (- 1000))])\n    line = LineString([(0.0, 0.0), ((- 999.5), (- 999.5)), (999.3, (- 999.8)), (1500.0, 0.0)])\n    square_coords = square.exterior.coords[:]\n    line_coords = line.coords[:]\n    result = snap(line, square, 1.0)\n    assert isinstance(result, LineString)\n    assert (result.coords[:] == [(0.0, 0.0), ((- 1000.0), (- 1000.0)), (1000.0, (- 1000.0)), (1500.0, 0.0)])\n    assert (square.exterior.coords[:] == square_coords)\n    assert (line.coords[:] == line_coords)", "masked_code": "def test_snap(self):\n    square = Polygon([((- 1000), (- 1000)), (1000, (- 1000)), (1000, 1000), ((- 1000), 1000), ((- 1000), (- 1000))])\n    line = LineString([(0.0, 0.0), ((- 999.5), (- 999.5)), (999.3, (- 999.8)), (1500.0, 0.0)])\n    square_coords = square.exterior.coords[:]\n    line_coords = line.coords[:]\n    result = snap(line, square, 1.0)\n    assert isinstance(result, LineString)\n    assert (result.coords[:] == '???')\n    assert (square.exterior.coords[:] == square_coords)\n    assert (line.coords[:] == line_coords)", "ground_truth": ["[(0.0, 0.0), ((- 1000.0), (- 1000.0)), (1000.0, (- 1000.0)), (1500.0, 0.0)]", "[[0.0, 0.0], [-1000.0, -1000.0], [1000.0, -1000.0], [1500.0, 0.0]]"], "quality_analysis": {"complexity_score": 29, "left_complexity": 5, "right_complexity": 24, "is_quality": true, "reason": "High quality assertion"}, "classname": "Snap"}
{"task_id": "shapely_570", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_snap.py", "testname": "test_snap.py", "funcname": "test_snap", "imports": ["import unittest", "from shapely.geometry import LineString, Polygon", "from shapely.ops import snap"], "code": "def test_snap(self):\n    square = Polygon([((- 1000), (- 1000)), (1000, (- 1000)), (1000, 1000), ((- 1000), 1000), ((- 1000), (- 1000))])\n    line = LineString([(0.0, 0.0), ((- 999.5), (- 999.5)), (999.3, (- 999.8)), (1500.0, 0.0)])\n    square_coords = square.exterior.coords[:]\n    line_coords = line.coords[:]\n    result = snap(line, square, 1.0)\n    assert isinstance(result, LineString)\n    assert (result.coords[:] == [(0.0, 0.0), ((- 1000.0), (- 1000.0)), (1000.0, (- 1000.0)), (1500.0, 0.0)])\n    assert (square.exterior.coords[:] == square_coords)\n    assert (line.coords[:] == line_coords)", "masked_code": "def test_snap(self):\n    square = Polygon([((- 1000), (- 1000)), (1000, (- 1000)), (1000, 1000), ((- 1000), 1000), ((- 1000), (- 1000))])\n    line = LineString([(0.0, 0.0), ((- 999.5), (- 999.5)), (999.3, (- 999.8)), (1500.0, 0.0)])\n    square_coords = square.exterior.coords[:]\n    line_coords = line.coords[:]\n    result = snap(line, square, 1.0)\n    assert isinstance(result, LineString)\n    assert (result.coords[:] == [(0.0, 0.0), ((- 1000.0), (- 1000.0)), (1000.0, (- 1000.0)), (1500.0, 0.0)])\n    assert (square.exterior.coords[:] == '???')\n    assert (line.coords[:] == line_coords)", "ground_truth": ["[[-1000.0, -1000.0], [1000.0, -1000.0], [1000.0, 1000.0], [-1000.0, 1000.0], [-1000.0, -1000.0]]", "square_coords"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Snap"}
{"task_id": "shapely_571", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_snap.py", "testname": "test_snap.py", "funcname": "test_snap", "imports": ["import unittest", "from shapely.geometry import LineString, Polygon", "from shapely.ops import snap"], "code": "def test_snap(self):\n    square = Polygon([((- 1000), (- 1000)), (1000, (- 1000)), (1000, 1000), ((- 1000), 1000), ((- 1000), (- 1000))])\n    line = LineString([(0.0, 0.0), ((- 999.5), (- 999.5)), (999.3, (- 999.8)), (1500.0, 0.0)])\n    square_coords = square.exterior.coords[:]\n    line_coords = line.coords[:]\n    result = snap(line, square, 1.0)\n    assert isinstance(result, LineString)\n    assert (result.coords[:] == [(0.0, 0.0), ((- 1000.0), (- 1000.0)), (1000.0, (- 1000.0)), (1500.0, 0.0)])\n    assert (square.exterior.coords[:] == square_coords)\n    assert (line.coords[:] == line_coords)", "masked_code": "def test_snap(self):\n    square = Polygon([((- 1000), (- 1000)), (1000, (- 1000)), (1000, 1000), ((- 1000), 1000), ((- 1000), (- 1000))])\n    line = LineString([(0.0, 0.0), ((- 999.5), (- 999.5)), (999.3, (- 999.8)), (1500.0, 0.0)])\n    square_coords = square.exterior.coords[:]\n    line_coords = line.coords[:]\n    result = snap(line, square, 1.0)\n    assert isinstance(result, LineString)\n    assert (result.coords[:] == [(0.0, 0.0), ((- 1000.0), (- 1000.0)), (1000.0, (- 1000.0)), (1500.0, 0.0)])\n    assert (square.exterior.coords[:] == square_coords)\n    assert (line.coords[:] == '???')", "ground_truth": ["[[0.0, 0.0], [-999.5, -999.5], [999.3, -999.8], [1500.0, 0.0]]", "line_coords"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Snap"}
{"task_id": "shapely_229", "reponame": "shapely", "testpath": "shapely/tests/test_strtree.py", "testname": "test_strtree.py", "funcname": "test_init", "imports": ["import itertools", "import math", "import pickle", "import subprocess", "import sys", "from concurrent.futures import ThreadPoolExecutor", "import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import LineString, MultiPoint, Point, STRtree, box, geos_version", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty, empty_line_string, empty_point, ignore_invalid, point"], "code": "@pytest.mark.parametrize('geometry,count, hits', [([], 0, 0), ([Point(1000, (- 1000))], 1, 1), ([None], 0, 0), ([Point((- 500), 500), None], 1, 1), ([empty, Point(1000000.0, (- 1000000.0)), empty_point, empty_line_string], 1, 1), ([empty, Point(0.0, 0.0), empty_point, empty_line_string], 1, 1), ([LineString()], 0, 0)])\ndef test_init(geometry, count, hits):\n    tree = STRtree(geometry)\n    assert (len(tree) == count)\n    assert (tree.query(box((- 10000000.0), (- 10000000.0), 10000000.0, 10000000.0)).size == hits)", "masked_code": "@pytest.mark.parametrize('geometry,count, hits', [([], 0, 0), ([Point(1000, (- 1000))], 1, 1), ([None], 0, 0), ([Point((- 500), 500), None], 1, 1), ([empty, Point(1000000.0, (- 1000000.0)), empty_point, empty_line_string], 1, 1), ([empty, Point(0.0, 0.0), empty_point, empty_line_string], 1, 1), ([LineString()], 0, 0)])\ndef test_init(geometry, count, hits):\n    tree = STRtree(geometry)\n    assert (len(tree) == '???')\n    assert (tree.query(box((- 10000000.0), (- 10000000.0), 10000000.0, 10000000.0)).size == hits)", "ground_truth": ["0", "count"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_230", "reponame": "shapely", "testpath": "shapely/tests/test_strtree.py", "testname": "test_strtree.py", "funcname": "test_init", "imports": ["import itertools", "import math", "import pickle", "import subprocess", "import sys", "from concurrent.futures import ThreadPoolExecutor", "import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import LineString, MultiPoint, Point, STRtree, box, geos_version", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty, empty_line_string, empty_point, ignore_invalid, point"], "code": "@pytest.mark.parametrize('geometry,count, hits', [([], 0, 0), ([Point(1000, (- 1000))], 1, 1), ([None], 0, 0), ([Point((- 500), 500), None], 1, 1), ([empty, Point(1000000.0, (- 1000000.0)), empty_point, empty_line_string], 1, 1), ([empty, Point(0.0, 0.0), empty_point, empty_line_string], 1, 1), ([LineString()], 0, 0)])\ndef test_init(geometry, count, hits):\n    tree = STRtree(geometry)\n    assert (len(tree) == count)\n    assert (tree.query(box((- 10000000.0), (- 10000000.0), 10000000.0, 10000000.0)).size == hits)", "masked_code": "@pytest.mark.parametrize('geometry,count, hits', [([], 0, 0), ([Point(1000, (- 1000))], 1, 1), ([None], 0, 0), ([Point((- 500), 500), None], 1, 1), ([empty, Point(1000000.0, (- 1000000.0)), empty_point, empty_line_string], 1, 1), ([empty, Point(0.0, 0.0), empty_point, empty_line_string], 1, 1), ([LineString()], 0, 0)])\ndef test_init(geometry, count, hits):\n    tree = STRtree(geometry)\n    assert (len(tree) == count)\n    assert (tree.query(box((- 10000000.0), (- 10000000.0), 10000000.0, 10000000.0)).size == '???')", "ground_truth": ["0", "hits"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_231", "reponame": "shapely", "testpath": "shapely/tests/test_strtree.py", "testname": "test_strtree.py", "funcname": "test_references", "imports": ["import itertools", "import math", "import pickle", "import subprocess", "import sys", "from concurrent.futures import ThreadPoolExecutor", "import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "import shapely", "from shapely import LineString, MultiPoint, Point, STRtree, box, geos_version", "from shapely.testing import assert_geometries_equal", "from shapely.tests.common import empty, empty_line_string, empty_point, ignore_invalid, point"], "code": "def test_references():\n    point1 = Point(10000000000.0, (- 10000000000.0))\n    point2 = Point((- 1e-09), 1e-09)\n    geoms = [point1, point2]\n    tree = STRtree(geoms)\n    point1 = None\n    point2 = None\n    import gc\n    gc.collect()\n    assert (tree.query(box((- 20000000000.0), (- 20000000000.0), 20000000000.0, 20000000000.0)).tolist() == [0, 1])", "masked_code": "def test_references():\n    point1 = Point(10000000000.0, (- 10000000000.0))\n    point2 = Point((- 1e-09), 1e-09)\n    geoms = [point1, point2]\n    tree = STRtree(geoms)\n    point1 = None\n    point2 = None\n    import gc\n    gc.collect()\n    assert (tree.query(box((- 20000000000.0), (- 20000000000.0), 20000000000.0, 20000000000.0)).tolist() == '???')", "ground_truth": ["[0, 1]"], "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_618", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_line", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_line(self):\n    g = geometry.LineString([((- 5000.0), 0), (123456.789, (- 99999.1))])\n    h = transform(self.func, g)\n    assert (h.geom_type == 'LineString')\n    assert (list(h.coords) == [((- 5000.0), 0), (123456.789, (- 99999.1))])", "masked_code": "def test_line(self):\n    g = geometry.LineString([((- 5000.0), 0), (123456.789, (- 99999.1))])\n    h = transform(self.func, g)\n    assert (h.geom_type == '???')\n    assert (list(h.coords) == [((- 5000.0), 0), (123456.789, (- 99999.1))])", "ground_truth": ["'LineString'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_619", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_line", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_line(self):\n    g = geometry.LineString([((- 5000.0), 0), (123456.789, (- 99999.1))])\n    h = transform(self.func, g)\n    assert (h.geom_type == 'LineString')\n    assert (list(h.coords) == [((- 5000.0), 0), (123456.789, (- 99999.1))])", "masked_code": "def test_line(self):\n    g = geometry.LineString([((- 5000.0), 0), (123456.789, (- 99999.1))])\n    h = transform(self.func, g)\n    assert (h.geom_type == 'LineString')\n    assert (list(h.coords) == '???')", "ground_truth": ["[((- 5000.0), 0), (123456.789, (- 99999.1))]", "[[-5000.0, 0], [123456.789, -99999.1]]"], "quality_analysis": {"complexity_score": 19, "left_complexity": 5, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_628", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_line", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_line(self):\n    g = geometry.LineString([(10.0, 20.0), ((- 5.0), (- 15.0))])\n    h = transform((lambda x, y, z=None: ((x - 100.5), (y + 2000.0))), g)\n    assert (h.geom_type == 'LineString')\n    assert (list(h.coords) == [((- 90.5), 2020.0), ((- 105.5), 1985.0)])", "masked_code": "def test_line(self):\n    g = geometry.LineString([(10.0, 20.0), ((- 5.0), (- 15.0))])\n    h = transform((lambda x, y, z=None: ((x - 100.5), (y + 2000.0))), g)\n    assert (h.geom_type == '???')\n    assert (list(h.coords) == [((- 90.5), 2020.0), ((- 105.5), 1985.0)])", "ground_truth": ["'LineString'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_629", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_line", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_line(self):\n    g = geometry.LineString([(10.0, 20.0), ((- 5.0), (- 15.0))])\n    h = transform((lambda x, y, z=None: ((x - 100.5), (y + 2000.0))), g)\n    assert (h.geom_type == 'LineString')\n    assert (list(h.coords) == [((- 90.5), 2020.0), ((- 105.5), 1985.0)])", "masked_code": "def test_line(self):\n    g = geometry.LineString([(10.0, 20.0), ((- 5.0), (- 15.0))])\n    h = transform((lambda x, y, z=None: ((x - 100.5), (y + 2000.0))), g)\n    assert (h.geom_type == 'LineString')\n    assert (list(h.coords) == '???')", "ground_truth": ["[((- 90.5), 2020.0), ((- 105.5), 1985.0)]", "[[-90.5, 2020.0], [-105.5, 1985.0]]"], "quality_analysis": {"complexity_score": 19, "left_complexity": 5, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_620", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_linearring", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_linearring(self):\n    g = geometry.LinearRing([(0, 0), ((- 1.5), 2.5), ((- 3.5), (- 1.5)), (0, 0)])\n    h = transform(self.func, g)\n    assert (h.geom_type == 'LinearRing')\n    assert (list(h.coords) == [(0, 0), ((- 1.5), 2.5), ((- 3.5), (- 1.5)), (0, 0)])", "masked_code": "def test_linearring(self):\n    g = geometry.LinearRing([(0, 0), ((- 1.5), 2.5), ((- 3.5), (- 1.5)), (0, 0)])\n    h = transform(self.func, g)\n    assert (h.geom_type == '???')\n    assert (list(h.coords) == [(0, 0), ((- 1.5), 2.5), ((- 3.5), (- 1.5)), (0, 0)])", "ground_truth": ["'LinearRing'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_621", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_linearring", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_linearring(self):\n    g = geometry.LinearRing([(0, 0), ((- 1.5), 2.5), ((- 3.5), (- 1.5)), (0, 0)])\n    h = transform(self.func, g)\n    assert (h.geom_type == 'LinearRing')\n    assert (list(h.coords) == [(0, 0), ((- 1.5), 2.5), ((- 3.5), (- 1.5)), (0, 0)])", "masked_code": "def test_linearring(self):\n    g = geometry.LinearRing([(0, 0), ((- 1.5), 2.5), ((- 3.5), (- 1.5)), (0, 0)])\n    h = transform(self.func, g)\n    assert (h.geom_type == 'LinearRing')\n    assert (list(h.coords) == '???')", "ground_truth": ["[(0, 0), ((- 1.5), 2.5), ((- 3.5), (- 1.5)), (0, 0)]", "[[0, 0], [-1.5, 2.5], [-3.5, -1.5], [0, 0]]"], "quality_analysis": {"complexity_score": 29, "left_complexity": 5, "right_complexity": 24, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_624", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_multipolygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([((- 1000000.0), 2000000.0), (1000000.0, (- 2000000.0))]).buffer(50000.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(h.area))", "masked_code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([((- 1000000.0), 2000000.0), (1000000.0, (- 2000000.0))]).buffer(50000.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == '???')\n    assert (g.area == pytest.approx(h.area))", "ground_truth": ["'MultiPolygon'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_625", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_multipolygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([((- 1000000.0), 2000000.0), (1000000.0, (- 2000000.0))]).buffer(50000.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(h.area))", "masked_code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([((- 1000000.0), 2000000.0), (1000000.0, (- 2000000.0))]).buffer(50000.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == '???')", "ground_truth": ["15682742452.729694", "pytest.approx(h.area)"], "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_634", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_multipolygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([((- 1000), 1000), (2000, (- 2000))]).buffer(100.0)\n    h = transform((lambda x, y, z=None: ((x * (- 2)), (abs(y) + 100))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(62730.9698109188))\n    assert (h.centroid.x == pytest.approx((- 1000.0)))\n    assert (h.centroid.y == pytest.approx(1600.0))", "masked_code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([((- 1000), 1000), (2000, (- 2000))]).buffer(100.0)\n    h = transform((lambda x, y, z=None: ((x * (- 2)), (abs(y) + 100))), g)\n    assert (h.geom_type == '???')\n    assert (g.area == pytest.approx(62730.9698109188))\n    assert (h.centroid.x == pytest.approx((- 1000.0)))\n    assert (h.centroid.y == pytest.approx(1600.0))", "ground_truth": ["'MultiPolygon'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_635", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_multipolygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([((- 1000), 1000), (2000, (- 2000))]).buffer(100.0)\n    h = transform((lambda x, y, z=None: ((x * (- 2)), (abs(y) + 100))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(62730.9698109188))\n    assert (h.centroid.x == pytest.approx((- 1000.0)))\n    assert (h.centroid.y == pytest.approx(1600.0))", "masked_code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([((- 1000), 1000), (2000, (- 2000))]).buffer(100.0)\n    h = transform((lambda x, y, z=None: ((x * (- 2)), (abs(y) + 100))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == '???')\n    assert (h.centroid.x == pytest.approx((- 1000.0)))\n    assert (h.centroid.y == pytest.approx(1600.0))", "ground_truth": ["62730.9698109188", "pytest.approx(62730.9698109188)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_636", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_multipolygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([((- 1000), 1000), (2000, (- 2000))]).buffer(100.0)\n    h = transform((lambda x, y, z=None: ((x * (- 2)), (abs(y) + 100))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(62730.9698109188))\n    assert (h.centroid.x == pytest.approx((- 1000.0)))\n    assert (h.centroid.y == pytest.approx(1600.0))", "masked_code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([((- 1000), 1000), (2000, (- 2000))]).buffer(100.0)\n    h = transform((lambda x, y, z=None: ((x * (- 2)), (abs(y) + 100))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(62730.9698109188))\n    assert (h.centroid.x == '???')\n    assert (h.centroid.y == pytest.approx(1600.0))", "ground_truth": ["-1000.0", "pytest.approx((- 1000.0))"], "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_637", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_multipolygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([((- 1000), 1000), (2000, (- 2000))]).buffer(100.0)\n    h = transform((lambda x, y, z=None: ((x * (- 2)), (abs(y) + 100))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(62730.9698109188))\n    assert (h.centroid.x == pytest.approx((- 1000.0)))\n    assert (h.centroid.y == pytest.approx(1600.0))", "masked_code": "def test_multipolygon(self):\n    g = geometry.MultiPoint([((- 1000), 1000), (2000, (- 2000))]).buffer(100.0)\n    h = transform((lambda x, y, z=None: ((x * (- 2)), (abs(y) + 100))), g)\n    assert (h.geom_type == 'MultiPolygon')\n    assert (g.area == pytest.approx(62730.9698109188))\n    assert (h.centroid.x == pytest.approx((- 1000.0)))\n    assert (h.centroid.y == '???')", "ground_truth": ["1600", "1600.0", "pytest.approx(1600.0)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_616", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_point", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_point(self):\n    g = geometry.Point((- 1000.5), 0.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'Point')\n    assert (list(h.coords) == [((- 1000.5), 0.0)])", "masked_code": "def test_point(self):\n    g = geometry.Point((- 1000.5), 0.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == '???')\n    assert (list(h.coords) == [((- 1000.5), 0.0)])", "ground_truth": ["'Point'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_617", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_point", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_point(self):\n    g = geometry.Point((- 1000.5), 0.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'Point')\n    assert (list(h.coords) == [((- 1000.5), 0.0)])", "masked_code": "def test_point(self):\n    g = geometry.Point((- 1000.5), 0.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'Point')\n    assert (list(h.coords) == '???')", "ground_truth": ["[((- 1000.5), 0.0)]", "[[-1000.5, 0.0]]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_626", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_point", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_point(self):\n    g = geometry.Point((- 200.5), 1000.0)\n    h = transform((lambda x, y, z=None: ((x + 10.0), (y - 25.5))), g)\n    assert (h.geom_type == 'Point')\n    assert (list(h.coords) == [((- 190.5), 974.5)])", "masked_code": "def test_point(self):\n    g = geometry.Point((- 200.5), 1000.0)\n    h = transform((lambda x, y, z=None: ((x + 10.0), (y - 25.5))), g)\n    assert (h.geom_type == '???')\n    assert (list(h.coords) == [((- 190.5), 974.5)])", "ground_truth": ["'Point'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_627", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_point", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_point(self):\n    g = geometry.Point((- 200.5), 1000.0)\n    h = transform((lambda x, y, z=None: ((x + 10.0), (y - 25.5))), g)\n    assert (h.geom_type == 'Point')\n    assert (list(h.coords) == [((- 190.5), 974.5)])", "masked_code": "def test_point(self):\n    g = geometry.Point((- 200.5), 1000.0)\n    h = transform((lambda x, y, z=None: ((x + 10.0), (y - 25.5))), g)\n    assert (h.geom_type == 'Point')\n    assert (list(h.coords) == '???')", "ground_truth": ["[((- 190.5), 974.5)]", "[[-190.5, 974.5]]"], "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_622", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_polygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_polygon(self):\n    g = geometry.Point(10000, (- 10000)).buffer(1000.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(h.area))", "masked_code": "def test_polygon(self):\n    g = geometry.Point(10000, (- 10000)).buffer(1000.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == '???')\n    assert (g.area == pytest.approx(h.area))", "ground_truth": ["'Polygon'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_623", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_polygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_polygon(self):\n    g = geometry.Point(10000, (- 10000)).buffer(1000.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(h.area))", "masked_code": "def test_polygon(self):\n    g = geometry.Point(10000, (- 10000)).buffer(1000.0)\n    h = transform(self.func, g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == '???')", "ground_truth": ["3136548.4905459364", "pytest.approx(h.area)"], "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "IdentityTestCase"}
{"task_id": "shapely_630", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_polygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_polygon(self):\n    g = geometry.Point(100.0, (- 100.0)).buffer(25.0)\n    h = transform((lambda x, y, z=None: ((x * 2), (y + 100))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(1960.3428065912124))\n    assert (h.centroid.x == pytest.approx(200.0))\n    assert (h.centroid.y == pytest.approx(0.0))", "masked_code": "def test_polygon(self):\n    g = geometry.Point(100.0, (- 100.0)).buffer(25.0)\n    h = transform((lambda x, y, z=None: ((x * 2), (y + 100))), g)\n    assert (h.geom_type == '???')\n    assert (g.area == pytest.approx(1960.3428065912124))\n    assert (h.centroid.x == pytest.approx(200.0))\n    assert (h.centroid.y == pytest.approx(0.0))", "ground_truth": ["'Polygon'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_631", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_polygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_polygon(self):\n    g = geometry.Point(100.0, (- 100.0)).buffer(25.0)\n    h = transform((lambda x, y, z=None: ((x * 2), (y + 100))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(1960.3428065912124))\n    assert (h.centroid.x == pytest.approx(200.0))\n    assert (h.centroid.y == pytest.approx(0.0))", "masked_code": "def test_polygon(self):\n    g = geometry.Point(100.0, (- 100.0)).buffer(25.0)\n    h = transform((lambda x, y, z=None: ((x * 2), (y + 100))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == '???')\n    assert (h.centroid.x == pytest.approx(200.0))\n    assert (h.centroid.y == pytest.approx(0.0))", "ground_truth": ["1960.3428065912124", "pytest.approx(1960.3428065912124)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_632", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_polygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_polygon(self):\n    g = geometry.Point(100.0, (- 100.0)).buffer(25.0)\n    h = transform((lambda x, y, z=None: ((x * 2), (y + 100))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(1960.3428065912124))\n    assert (h.centroid.x == pytest.approx(200.0))\n    assert (h.centroid.y == pytest.approx(0.0))", "masked_code": "def test_polygon(self):\n    g = geometry.Point(100.0, (- 100.0)).buffer(25.0)\n    h = transform((lambda x, y, z=None: ((x * 2), (y + 100))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(1960.3428065912124))\n    assert (h.centroid.x == '???')\n    assert (h.centroid.y == pytest.approx(0.0))", "ground_truth": ["200", "200.0", "pytest.approx(200.0)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_633", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_transform.py", "testname": "test_transform.py", "funcname": "test_polygon", "imports": ["import unittest", "import pytest", "from shapely import geometry", "from shapely.ops import transform"], "code": "def test_polygon(self):\n    g = geometry.Point(100.0, (- 100.0)).buffer(25.0)\n    h = transform((lambda x, y, z=None: ((x * 2), (y + 100))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(1960.3428065912124))\n    assert (h.centroid.x == pytest.approx(200.0))\n    assert (h.centroid.y == pytest.approx(0.0))", "masked_code": "def test_polygon(self):\n    g = geometry.Point(100.0, (- 100.0)).buffer(25.0)\n    h = transform((lambda x, y, z=None: ((x * 2), (y + 100))), g)\n    assert (h.geom_type == 'Polygon')\n    assert (g.area == pytest.approx(1960.3428065912124))\n    assert (h.centroid.x == pytest.approx(200.0))\n    assert (h.centroid.y == '???')", "ground_truth": ["0", "0.0", "pytest.approx(0.0)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "LambdaTestCase"}
{"task_id": "shapely_638", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_union.py", "testname": "test_union.py", "funcname": "test_unary_union", "imports": ["import random", "import unittest", "from functools import partial", "from itertools import islice", "import pytest", "from shapely.geometry import MultiPolygon, Point", "from shapely.ops import unary_union"], "code": "def test_unary_union(self):\n    coords_aug = zip(list(islice(halton(5), 0, 200, 5)), list(islice(halton(7), 0, 200, 5)))\n    patches = [Point(xy).buffer(0.025) for xy in coords_aug]\n    u = unary_union(patches)\n    assert (u.geom_type == 'MultiPolygon')\n    assert (u.area == pytest.approx(0.07699193789689952))", "masked_code": "def test_unary_union(self):\n    coords_aug = zip(list(islice(halton(5), 0, 200, 5)), list(islice(halton(7), 0, 200, 5)))\n    patches = [Point(xy).buffer(0.025) for xy in coords_aug]\n    u = unary_union(patches)\n    assert (u.geom_type == '???')\n    assert (u.area == pytest.approx(0.07699193789689952))", "ground_truth": ["'MultiPolygon'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "UnionTestCase"}
{"task_id": "shapely_639", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_union.py", "testname": "test_union.py", "funcname": "test_unary_union", "imports": ["import random", "import unittest", "from functools import partial", "from itertools import islice", "import pytest", "from shapely.geometry import MultiPolygon, Point", "from shapely.ops import unary_union"], "code": "def test_unary_union(self):\n    coords_aug = zip(list(islice(halton(5), 0, 200, 5)), list(islice(halton(7), 0, 200, 5)))\n    patches = [Point(xy).buffer(0.025) for xy in coords_aug]\n    u = unary_union(patches)\n    assert (u.geom_type == 'MultiPolygon')\n    assert (u.area == pytest.approx(0.07699193789689952))", "masked_code": "def test_unary_union(self):\n    coords_aug = zip(list(islice(halton(5), 0, 200, 5)), list(islice(halton(7), 0, 200, 5)))\n    patches = [Point(xy).buffer(0.025) for xy in coords_aug]\n    u = unary_union(patches)\n    assert (u.geom_type == 'MultiPolygon')\n    assert (u.area == '???')", "ground_truth": ["0.07699193789689952", "pytest.approx(0.07699193789689952)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "UnionTestCase"}
{"task_id": "shapely_640", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_union.py", "testname": "test_union.py", "funcname": "test_unary_union_multi", "imports": ["import random", "import unittest", "from functools import partial", "from itertools import islice", "import pytest", "from shapely.geometry import MultiPolygon, Point", "from shapely.ops import unary_union"], "code": "def test_unary_union_multi(self):\n    empty_mp = MultiPolygon([])\n    assert (unary_union(empty_mp).area == pytest.approx(0.0))\n    neg_coords = [((- 10), (- 10)), (0, 0), ((- 20), (- 20)), ((- 5), (- 3)), ((- 1000000.0), (- 1000000.0)), (1000000.0, 1000000.0)]\n    patches = MultiPolygon([Point(xy).buffer(0.03) for xy in neg_coords])\n    actual_union = unary_union(patches)\n    assert (actual_union.area == pytest.approx(0.016937361850205494))\n    assert (unary_union([patches, patches]).area == pytest.approx(0.0169373618502055))", "masked_code": "def test_unary_union_multi(self):\n    empty_mp = MultiPolygon([])\n    assert (unary_union(empty_mp).area == '???')\n    neg_coords = [((- 10), (- 10)), (0, 0), ((- 20), (- 20)), ((- 5), (- 3)), ((- 1000000.0), (- 1000000.0)), (1000000.0, 1000000.0)]\n    patches = MultiPolygon([Point(xy).buffer(0.03) for xy in neg_coords])\n    actual_union = unary_union(patches)\n    assert (actual_union.area == pytest.approx(0.016937361850205494))\n    assert (unary_union([patches, patches]).area == pytest.approx(0.0169373618502055))", "ground_truth": ["0", "0.0", "pytest.approx(0.0)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "UnionTestCase"}
{"task_id": "shapely_641", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_union.py", "testname": "test_union.py", "funcname": "test_unary_union_multi", "imports": ["import random", "import unittest", "from functools import partial", "from itertools import islice", "import pytest", "from shapely.geometry import MultiPolygon, Point", "from shapely.ops import unary_union"], "code": "def test_unary_union_multi(self):\n    empty_mp = MultiPolygon([])\n    assert (unary_union(empty_mp).area == pytest.approx(0.0))\n    neg_coords = [((- 10), (- 10)), (0, 0), ((- 20), (- 20)), ((- 5), (- 3)), ((- 1000000.0), (- 1000000.0)), (1000000.0, 1000000.0)]\n    patches = MultiPolygon([Point(xy).buffer(0.03) for xy in neg_coords])\n    actual_union = unary_union(patches)\n    assert (actual_union.area == pytest.approx(0.016937361850205494))\n    assert (unary_union([patches, patches]).area == pytest.approx(0.0169373618502055))", "masked_code": "def test_unary_union_multi(self):\n    empty_mp = MultiPolygon([])\n    assert (unary_union(empty_mp).area == pytest.approx(0.0))\n    neg_coords = [((- 10), (- 10)), (0, 0), ((- 20), (- 20)), ((- 5), (- 3)), ((- 1000000.0), (- 1000000.0)), (1000000.0, 1000000.0)]\n    patches = MultiPolygon([Point(xy).buffer(0.03) for xy in neg_coords])\n    actual_union = unary_union(patches)\n    assert (actual_union.area == '???')\n    assert (unary_union([patches, patches]).area == pytest.approx(0.0169373618502055))", "ground_truth": ["0.016937361850205494", "pytest.approx(0.016937361850205494)"], "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "UnionTestCase"}
{"task_id": "shapely_642", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_validation.py", "testname": "test_validation.py", "funcname": "test_valid", "imports": ["import unittest", "from shapely.geometry import Point", "from shapely.validation import explain_validity"], "code": "def test_valid(self):\n    assert (explain_validity(Point((- 1000000000.0), 1000000000.0)) == 'Valid Geometry')", "masked_code": "def test_valid(self):\n    assert (explain_validity(Point((- 1000000000.0), 1000000000.0)) == '???')", "ground_truth": ["'Valid Geometry'"], "quality_analysis": {"complexity_score": 11, "left_complexity": 10, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "ValidationTestCase"}
{"task_id": "shapely_643", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_vectorized.py", "testname": "test_vectorized.py", "funcname": "test_array_2d", "imports": ["import unittest", "import numpy as np", "import pytest", "from shapely.geometry import MultiPolygon, Point, box"], "code": "def test_array_2d(self):\n    (y, x) = np.mgrid[((- 20):20:11j, (- 10):35:10j)]\n    x = (x.astype(np.float64) * 1.5)\n    y = (y.astype(np.float64) * 2.0)\n    result = self.assertContainsResults(self.construct_torus(), x, y)\n    assert (result.shape == x.shape)", "masked_code": "def test_array_2d(self):\n    (y, x) = np.mgrid[((- 20):20:11j, (- 10):35:10j)]\n    x = (x.astype(np.float64) * 1.5)\n    y = (y.astype(np.float64) * 2.0)\n    result = self.assertContainsResults(self.construct_torus(), x, y)\n    assert (result.shape == '???')", "ground_truth": ["x.shape"], "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": "VectorizedContainsTestCase"}
{"task_id": "shapely_646", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_voronoi_diagram.py", "testname": "test_voronoi_diagram.py", "funcname": "test_from_multipoint_without_tolerace_without_floating_point_coordinates", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import MultiPoint", "from shapely.ops import voronoi_diagram", "from shapely.wkt import loads as load_wkt"], "code": "def test_from_multipoint_without_tolerace_without_floating_point_coordinates():\n    \"But it's fine without it.\"\n    mp = load_wkt('MULTIPOINT (-1 -2, 2 0, 1 3, 0 5, 5 5)')\n    regions = voronoi_diagram(mp)\n    assert (len(regions.geoms) == 5)", "masked_code": "def test_from_multipoint_without_tolerace_without_floating_point_coordinates():\n    \"But it's fine without it.\"\n    mp = load_wkt('MULTIPOINT (-1 -2, 2 0, 1 3, 0 5, 5 5)')\n    regions = voronoi_diagram(mp)\n    assert (len(regions.geoms) == '???')", "ground_truth": ["5"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_645", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_voronoi_diagram.py", "testname": "test_voronoi_diagram.py", "funcname": "test_from_polygon", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import MultiPoint", "from shapely.ops import voronoi_diagram", "from shapely.wkt import loads as load_wkt"], "code": "def test_from_polygon():\n    poly = load_wkt('POLYGON ((-10 -10, 10 -10, 10 10, -10 10, -10 -10, 0 0, -10 -10))')\n    regions = voronoi_diagram(poly)\n    assert (len(regions.geoms) == 5)", "masked_code": "def test_from_polygon():\n    poly = load_wkt('POLYGON ((-10 -10, 10 -10, 10 10, -10 10, -10 -10, 0 0, -10 -10))')\n    regions = voronoi_diagram(poly)\n    assert (len(regions.geoms) == '???')", "ground_truth": ["5"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_644", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_voronoi_diagram.py", "testname": "test_voronoi_diagram.py", "funcname": "test_larger_envelope", "imports": ["import numpy as np", "import pytest", "from shapely.geometry import MultiPoint", "from shapely.ops import voronoi_diagram", "from shapely.wkt import loads as load_wkt"], "code": "def test_larger_envelope():\n    'When the envelope we specify is larger than the\\n    area of the input feature, the created regions should\\n    expand to fill that area.'\n    mp = MultiPoint(points=[(0, 0), (1, 1), (0.2, 1.8), (1.8, 0.3)])\n    poly = load_wkt('POLYGON ((-2 -2, 4 -2, 4 4, -2 4, -2 -2))')\n    regions = voronoi_diagram(mp, envelope=poly)\n    assert (len(regions.geoms) == 4)\n    assert (sum((r.area for r in regions.geoms)) == poly.area)", "masked_code": "def test_larger_envelope():\n    'When the envelope we specify is larger than the\\n    area of the input feature, the created regions should\\n    expand to fill that area.'\n    mp = MultiPoint(points=[(0, 0), (1, 1), (0.2, 1.8), (1.8, 0.3)])\n    poly = load_wkt('POLYGON ((-2 -2, 4 -2, 4 4, -2 4, -2 -2))')\n    regions = voronoi_diagram(mp, envelope=poly)\n    assert (len(regions.geoms) == '???')\n    assert (sum((r.area for r in regions.geoms)) == poly.area)", "ground_truth": ["4"], "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_649", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_dumps_endianness", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "def test_dumps_endianness(some_point):\n    result = dumps(some_point)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)\n    result = dumps(some_point, big_endian=False)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)\n    result = dumps(some_point, big_endian=True)\n    expected = '0080000001C0C81CD6E631F8A1000000000000000041CD6F3458800000'\n    assert (bin2hex(result) == expected)", "masked_code": "def test_dumps_endianness(some_point):\n    result = dumps(some_point)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == '???')\n    result = dumps(some_point, big_endian=False)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)\n    result = dumps(some_point, big_endian=True)\n    expected = '0080000001C0C81CD6E631F8A1000000000000000041CD6F3458800000'\n    assert (bin2hex(result) == expected)", "ground_truth": ["'0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'", "expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_650", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_dumps_endianness", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "def test_dumps_endianness(some_point):\n    result = dumps(some_point)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)\n    result = dumps(some_point, big_endian=False)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)\n    result = dumps(some_point, big_endian=True)\n    expected = '0080000001C0C81CD6E631F8A1000000000000000041CD6F3458800000'\n    assert (bin2hex(result) == expected)", "masked_code": "def test_dumps_endianness(some_point):\n    result = dumps(some_point)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)\n    result = dumps(some_point, big_endian=False)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == '???')\n    result = dumps(some_point, big_endian=True)\n    expected = '0080000001C0C81CD6E631F8A1000000000000000041CD6F3458800000'\n    assert (bin2hex(result) == expected)", "ground_truth": ["'0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'", "expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_651", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_dumps_endianness", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "def test_dumps_endianness(some_point):\n    result = dumps(some_point)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)\n    result = dumps(some_point, big_endian=False)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)\n    result = dumps(some_point, big_endian=True)\n    expected = '0080000001C0C81CD6E631F8A1000000000000000041CD6F3458800000'\n    assert (bin2hex(result) == expected)", "masked_code": "def test_dumps_endianness(some_point):\n    result = dumps(some_point)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)\n    result = dumps(some_point, big_endian=False)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)\n    result = dumps(some_point, big_endian=True)\n    expected = '0080000001C0C81CD6E631F8A1000000000000000041CD6F3458800000'\n    assert (bin2hex(result) == '???')", "ground_truth": ["'0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'", "expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_647", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_dumps_srid", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_dumps_srid(some_point):\n    result = dumps(some_point)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)\n    result = dumps(some_point, srid=3857)\n    expected = '01010000A0110F0000A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_dumps_srid(some_point):\n    result = dumps(some_point)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == '???')\n    result = dumps(some_point, srid=3857)\n    expected = '01010000A0110F0000A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)", "ground_truth": ["expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_648", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_dumps_srid", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_dumps_srid(some_point):\n    result = dumps(some_point)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)\n    result = dumps(some_point, srid=3857)\n    expected = '01010000A0110F0000A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_dumps_srid(some_point):\n    result = dumps(some_point)\n    expected = '0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == expected)\n    result = dumps(some_point, srid=3857)\n    expected = '01010000A0110F0000A1F831E6D61CC8C0000000000000000000008058346FCD41'\n    assert (bin2hex(result) == '???')", "ground_truth": ["'0101000080A1F831E6D61CC8C0000000000000000000008058346FCD41'", "expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_656", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_loads_hex", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "def test_loads_hex(some_point):\n    wkb_hex = dumps(some_point, hex=True)\n    assert (loads(wkb_hex, hex=True) == some_point)", "masked_code": "def test_loads_hex(some_point):\n    wkb_hex = dumps(some_point, hex=True)\n    assert (loads(wkb_hex, hex=True) == '???')", "ground_truth": ["<POINT Z (-12345.679 0 987654321)>", "some_point"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_652", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_loads_srid", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [((- 1825.279885108856), 0.0, 10280556.327917175)])\n    result = dumps(geom)\n    expected = hostorder('BIddd', '0101000080B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, include_srid=True)\n    expected = hostorder('BIIddd', '01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, srid=999999999)\n    expected = hostorder('BIIddd', '01010000A0FFC99A3BB2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == '???')\n    result = dumps(geom)\n    expected = hostorder('BIddd', '0101000080B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, include_srid=True)\n    expected = hostorder('BIIddd', '01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, srid=999999999)\n    expected = hostorder('BIIddd', '01010000A0FFC99A3BB2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)", "ground_truth": ["[((- 1825.279885108856), 0.0, 10280556.327917175)]", "[[-1825.279885108856, 0.0, 10280556.327917175]]"], "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_653", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_loads_srid", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [((- 1825.279885108856), 0.0, 10280556.327917175)])\n    result = dumps(geom)\n    expected = hostorder('BIddd', '0101000080B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, include_srid=True)\n    expected = hostorder('BIIddd', '01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, srid=999999999)\n    expected = hostorder('BIIddd', '01010000A0FFC99A3BB2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [((- 1825.279885108856), 0.0, 10280556.327917175)])\n    result = dumps(geom)\n    expected = hostorder('BIddd', '0101000080B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == '???')\n    result = dumps(geom, include_srid=True)\n    expected = hostorder('BIIddd', '01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, srid=999999999)\n    expected = hostorder('BIIddd', '01010000A0FFC99A3BB2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)", "ground_truth": ["'0101000080B2B4339A1E859CC00000000000000000294C7E8ACD9B6341'", "expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_654", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_loads_srid", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [((- 1825.279885108856), 0.0, 10280556.327917175)])\n    result = dumps(geom)\n    expected = hostorder('BIddd', '0101000080B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, include_srid=True)\n    expected = hostorder('BIIddd', '01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, srid=999999999)\n    expected = hostorder('BIIddd', '01010000A0FFC99A3BB2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [((- 1825.279885108856), 0.0, 10280556.327917175)])\n    result = dumps(geom)\n    expected = hostorder('BIddd', '0101000080B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, include_srid=True)\n    expected = hostorder('BIIddd', '01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == '???')\n    result = dumps(geom, srid=999999999)\n    expected = hostorder('BIIddd', '01010000A0FFC99A3BB2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)", "ground_truth": ["'0101000080B2B4339A1E859CC00000000000000000294C7E8ACD9B6341'", "expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_655", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_loads_srid", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [((- 1825.279885108856), 0.0, 10280556.327917175)])\n    result = dumps(geom)\n    expected = hostorder('BIddd', '0101000080B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, include_srid=True)\n    expected = hostorder('BIIddd', '01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, srid=999999999)\n    expected = hostorder('BIIddd', '01010000A0FFC99A3BB2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_loads_srid():\n    geom = loads(hex2bin('01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341'))\n    assert isinstance(geom, Point)\n    assert (geom.coords[:] == [((- 1825.279885108856), 0.0, 10280556.327917175)])\n    result = dumps(geom)\n    expected = hostorder('BIddd', '0101000080B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, include_srid=True)\n    expected = hostorder('BIIddd', '01010000A0E6100000B2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == expected)\n    result = dumps(geom, srid=999999999)\n    expected = hostorder('BIIddd', '01010000A0FFC99A3BB2B4339A1E859CC00000000000000000294C7E8ACD9B6341')\n    assert (bin2hex(result) == '???')", "ground_truth": ["'0101000080B2B4339A1E859CC00000000000000000294C7E8ACD9B6341'", "expected"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_657", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_point_empty", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "def test_point_empty():\n    g = wkt.loads('POINT EMPTY')\n    result = dumps(g, big_endian=False)\n    assert (result[:((- 2) * 8)] == b'\\x01\\x01\\x00\\x00\\x00')\n    coords = struct.unpack('<2d', result[((- 2) * 8):])\n    assert (len(coords) == 2)\n    assert all((math.isnan(val) for val in coords))", "masked_code": "def test_point_empty():\n    g = wkt.loads('POINT EMPTY')\n    result = dumps(g, big_endian=False)\n    assert (result[:((- 2) * 8)] == '???')\n    coords = struct.unpack('<2d', result[((- 2) * 8):])\n    assert (len(coords) == 2)\n    assert all((math.isnan(val) for val in coords))", "ground_truth": ["b'\\x01\\x01\\x00\\x00\\x00'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_658", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkb.py", "testname": "test_wkb.py", "funcname": "test_point_z_empty", "imports": ["import binascii", "import math", "import struct", "import sys", "import pytest", "from shapely import geos_version, wkt", "from shapely.geometry import Point", "from shapely.tests.legacy.conftest import shapely20_todo", "from shapely.wkb import dump, dumps, load, loads"], "code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_point_z_empty():\n    g = wkt.loads('POINT Z EMPTY')\n    assert (g.wkb_hex == hostorder('BIddd', '0101000080000000000000F87F000000000000F87F000000000000F87F'))", "masked_code": "@pytest.mark.skipif((geos_version < (3, 10, 1)), reason='GEOS < 3.10.1')\ndef test_point_z_empty():\n    g = wkt.loads('POINT Z EMPTY')\n    assert (g.wkb_hex == '???')", "ground_truth": ["'0101000080000000000000F87F000000000000F87F000000000000F87F'", "hostorder('BIddd', '0101000080000000000000F87F000000000000F87F000000000000F87F')"], "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_661", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkt.py", "testname": "test_wkt.py", "funcname": "test_dumps_loads", "imports": ["from math import pi", "import pytest", "from shapely.geometry import Point", "from shapely.wkt import dump, dumps, load, loads"], "code": "def test_dumps_loads(some_point):\n    assert (dumps(some_point) == 'POINT (-10000000000.0000000000000000 2.3456789012345678)')\n    assert (loads(dumps(some_point)) == some_point)", "masked_code": "def test_dumps_loads(some_point):\n    assert (dumps(some_point) == '???')\n    assert (loads(dumps(some_point)) == some_point)", "ground_truth": ["'POINT (-10000000000.0000000000000000 2.3456789012345678)'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_662", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkt.py", "testname": "test_wkt.py", "funcname": "test_dumps_loads", "imports": ["from math import pi", "import pytest", "from shapely.geometry import Point", "from shapely.wkt import dump, dumps, load, loads"], "code": "def test_dumps_loads(some_point):\n    assert (dumps(some_point) == 'POINT (-10000000000.0000000000000000 2.3456789012345678)')\n    assert (loads(dumps(some_point)) == some_point)", "masked_code": "def test_dumps_loads(some_point):\n    assert (dumps(some_point) == 'POINT (-10000000000.0000000000000000 2.3456789012345678)')\n    assert (loads(dumps(some_point)) == '???')", "ground_truth": ["<POINT (-10000000000 2.346)>", "some_point"], "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_663", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkt.py", "testname": "test_wkt.py", "funcname": "test_dumps_loads_null_geometry", "imports": ["from math import pi", "import pytest", "from shapely.geometry import Point", "from shapely.wkt import dump, dumps, load, loads"], "code": "def test_dumps_loads_null_geometry(empty_geometry):\n    assert (dumps(empty_geometry) == 'POINT EMPTY')\n    assert loads(dumps(empty_geometry)).equals(empty_geometry)", "masked_code": "def test_dumps_loads_null_geometry(empty_geometry):\n    assert (dumps(empty_geometry) == '???')\n    assert loads(dumps(empty_geometry)).equals(empty_geometry)", "ground_truth": ["'POINT EMPTY'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_664", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkt.py", "testname": "test_wkt.py", "funcname": "test_dumps_precision", "imports": ["from math import pi", "import pytest", "from shapely.geometry import Point", "from shapely.wkt import dump, dumps, load, loads"], "code": "def test_dumps_precision(some_point):\n    assert (dumps(some_point, rounding_precision=2) == 'POINT (-10000000000.00 2.35)')", "masked_code": "def test_dumps_precision(some_point):\n    assert (dumps(some_point, rounding_precision=2) == '???')", "ground_truth": ["'POINT (-10000000000.00 2.35)'"], "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_659", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkt.py", "testname": "test_wkt.py", "funcname": "test_wkt", "imports": ["from math import pi", "import pytest", "from shapely.geometry import Point", "from shapely.wkt import dump, dumps, load, loads"], "code": "def test_wkt(some_point):\n    '.wkt and wkt.dumps() both do not trim by default.'\n    assert (some_point.wkt == 'POINT (-10000000000 2.345678901234568)')", "masked_code": "def test_wkt(some_point):\n    '.wkt and wkt.dumps() both do not trim by default.'\n    assert (some_point.wkt == '???')", "ground_truth": ["'POINT (-10000000000 2.345678901234568)'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "shapely_660", "reponame": "shapely", "testpath": "shapely/tests/legacy/test_wkt.py", "testname": "test_wkt.py", "funcname": "test_wkt_null", "imports": ["from math import pi", "import pytest", "from shapely.geometry import Point", "from shapely.wkt import dump, dumps, load, loads"], "code": "def test_wkt_null(empty_geometry):\n    assert (empty_geometry.wkt == 'POINT EMPTY')", "masked_code": "def test_wkt_null(empty_geometry):\n    assert (empty_geometry.wkt == '???')", "ground_truth": ["'POINT EMPTY'"], "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
