[
  {
    "command": "pytest --maxfail=10 --disable-warnings",
    "success": false,
    "stdout": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.4.1, pluggy-1.6.0\nrootdir: /app/repo_to_process\nconfigfile: pyproject.toml\ncollected 3672 items\n\npythran/tests/test_advanced.py FFFFFFFFFF\n\n=================================== FAILURES ===================================\n_________________________ TestAdvanced.test_add_arrays _________________________\n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com... [<pythran.dist.PythranExtension('test_add_arrays') at 0x7f288b296d40>], 'headers': [], 'name': 'test_add_arrays', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288b296320>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n>               dist.run_commands()\n\n/usr/lib/python3.10/distutils/core.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/distutils/dist.py:966: in run_commands\n    self.run_command(cmd)\n/usr/lib/python3.10/distutils/dist.py:985: in run_command\n    cmd_obj.run()\n/usr/lib/python3.10/distutils/command/build_ext.py:340: in run\n    self.build_extensions()\n/usr/lib/python3.10/distutils/command/build_ext.py:449: in build_extensions\n    self._build_extensions_serial()\n/usr/lib/python3.10/distutils/command/build_ext.py:474: in _build_extensions_serial\n    self.build_extension(ext)\npythran/dist.py:121: in build_extension\n    return super(PythranBuildExtMixIn, self).build_extension(ext)\n/usr/lib/python3.10/distutils/command/build_ext.py:529: in build_extension\n    objects = self.compiler.compile(sources,\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:369: in CCompiler_compile\n    single_compile(o)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:328: in single_compile\n    self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <distutils.unixccompiler.UnixCCompiler object at 0x7f288b2975e0>\nobj = '/tmp/tmpyhwfbxpf/tmp/tmp0mgmr8wk.o', src = '/tmp/tmp0mgmr8wk.cpp'\next = '.cpp'\ncc_args = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10', '-c']\nextra_postargs = ['-O2', '-std=c++11', '-fno-math-errno', '-fvisibility=hidden', '-fno-wrapv', '-Wno-unused-function', ...]\npp_opts = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10']\n\n    def UnixCCompiler__compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compile a single source files with a Unix-style compiler.\"\"\"\n        # HP ad-hoc fix, see ticket 1383\n        ccomp = self.compiler_so\n        if ccomp[0] == 'aCC':\n            # remove flags that will trigger ANSI-C mode for aCC\n            if '-Ae' in ccomp:\n                ccomp.remove('-Ae')\n            if '-Aa' in ccomp:\n                ccomp.remove('-Aa')\n            # add flags for (almost) sane C++ handling\n            ccomp += ['-AA']\n            self.compiler_so = ccomp\n        # ensure OPT environment variable is read\n        if 'OPT' in os.environ:\n            # XXX who uses this?\n            from sysconfig import get_config_vars\n            opt = shlex.join(shlex.split(os.environ['OPT']))\n            gcv_opt = shlex.join(shlex.split(get_config_vars('OPT')[0]))\n            ccomp_s = shlex.join(self.compiler_so)\n            if opt not in ccomp_s:\n                ccomp_s = ccomp_s.replace(gcv_opt, opt)\n                self.compiler_so = shlex.split(ccomp_s)\n            llink_s = shlex.join(self.linker_so)\n            if opt not in llink_s:\n                self.linker_so = self.linker_so + shlex.split(opt)\n    \n        display = '%s: %s' % (os.path.basename(self.compiler_so[0]), src)\n    \n        # gcc style automatic dependencies, outputs a makefile (-MF) that lists\n        # all headers needed by a c file as a side effect of compilation (-MMD)\n        if getattr(self, '_auto_depends', False):\n            deps = ['-MMD', '-MF', obj + '.d']\n        else:\n            deps = []\n    \n        try:\n            self.spawn(self.compiler_so + cc_args + [src, '-o', obj] + deps +\n                       extra_postargs, display = display)\n        except DistutilsExecError as e:\n            msg = str(e)\n>           raise CompileError(msg) from None\nE           distutils.errors.CompileError: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp0mgmr8wk.cpp -o /tmp/tmpyhwfbxpf/tmp/tmp0mgmr8wk.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/unixccompiler.py:58: CompileError\n\nDuring handling of the above exception, another exception occurred:\n\nmodule_name = 'test_add_arrays', cxxfile = '/tmp/tmp0mgmr8wk.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmplhel0ra2'\nbuildtmp = '/tmp/tmpyhwfbxpf'\nextension = <pythran.dist.PythranExtension('test_add_arrays') at 0x7f288b296d40>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n>           setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n\npythran/toolchain.py:348: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/dist-packages/numpy/distutils/core.py:169: in setup\n    return old_setup(**new_attr)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com... [<pythran.dist.PythranExtension('test_add_arrays') at 0x7f288b296d40>], 'headers': [], 'name': 'test_add_arrays', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288b296320>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n                dist.run_commands()\n            except KeyboardInterrupt:\n                raise SystemExit(\"interrupted\")\n            except OSError as exc:\n                if DEBUG:\n                    sys.stderr.write(\"error: %s\\n\" % (exc,))\n                    raise\n                else:\n                    raise SystemExit(\"error: %s\" % (exc,))\n    \n            except (DistutilsError,\n                    CCompilerError) as msg:\n                if DEBUG:\n                    raise\n                else:\n>                   raise SystemExit(\"error: \" + str(msg))\nE                   SystemExit: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp0mgmr8wk.cpp -o /tmp/tmpyhwfbxpf/tmp/tmp0mgmr8wk.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/lib/python3.10/distutils/core.py:163: SystemExit\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pythran.tests.test_advanced.TestAdvanced testMethod=test_add_arrays>\n\n    def test_add_arrays(self):\n>       self.run_test('def add_arrays(s): return (s,s) + (s,)', 1, add_arrays=[int])\n\npythran/tests/test_advanced.py:219: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npythran/tests/__init__.py:313: in run_test\n    cxx_compiled = compile_pythrancode(\npythran/toolchain.py:466: in compile_pythrancode\n    output_file = compile_cxxcode(module_name,\npythran/toolchain.py:403: in compile_cxxcode\n    output_binary = compile_cxxfile(module_name, fdpath,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodule_name = 'test_add_arrays', cxxfile = '/tmp/tmp0mgmr8wk.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmplhel0ra2'\nbuildtmp = '/tmp/tmpyhwfbxpf'\nextension = <pythran.dist.PythranExtension('test_add_arrays') at 0x7f288b296d40>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n            setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n        except SystemExit as e:\n>           raise PythranCompileError(str(e))\nE           pythran.errors.PythranCompileError: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp0mgmr8wk.cpp -o /tmp/tmpyhwfbxpf/tmp/tmp0mgmr8wk.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\npythran/toolchain.py:361: PythranCompileError\n----------------------------- Captured stdout call -----------------------------\nrunning build_ext\nDEBUG: new_compiler returns <class 'distutils.unixccompiler.UnixCCompiler'>\nbuilding 'test_add_arrays' extension\nINFO: C compiler: x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC\n\ncreating /tmp/tmpyhwfbxpf/tmp\nINFO: compile options: '-DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c'\nextra options: '-O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE'\nINFO: x86_64-linux-gnu-gcc: /tmp/tmp0mgmr8wk.cpp\n----------------------------- Captured stderr call -----------------------------\nIn file included from /tmp/tmp0mgmr8wk.cpp:1:\n/app/repo_to_process/pythran/pythonic/core.hpp:33:10: fatal error: pyconfig.h: No such file or directory\n   33 | #include \"pyconfig.h\"\n      |          ^~~~~~~~~~~~\ncompilation terminated.\nWARNING: Compilation error, trying hard to find its origin...\nWARNING: Nope, I'm going to flood you with C++ errors!\n------------------------------ Captured log call -------------------------------\nWARNING  pythran:toolchain.py:471 Compilation error, trying hard to find its origin...\nWARNING  pythran:toolchain.py:474 Nope, I'm going to flood you with C++ errors!\n________________________ TestAdvanced.test_annotations _________________________\n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...<pythran.dist.PythranExtension('test_annotations') at 0x7f288a10c4f0>], 'headers': [], 'name': 'test_annotations', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288a10c490>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n>               dist.run_commands()\n\n/usr/lib/python3.10/distutils/core.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/distutils/dist.py:966: in run_commands\n    self.run_command(cmd)\n/usr/lib/python3.10/distutils/dist.py:985: in run_command\n    cmd_obj.run()\n/usr/lib/python3.10/distutils/command/build_ext.py:340: in run\n    self.build_extensions()\n/usr/lib/python3.10/distutils/command/build_ext.py:449: in build_extensions\n    self._build_extensions_serial()\n/usr/lib/python3.10/distutils/command/build_ext.py:474: in _build_extensions_serial\n    self.build_extension(ext)\npythran/dist.py:121: in build_extension\n    return super(PythranBuildExtMixIn, self).build_extension(ext)\n/usr/lib/python3.10/distutils/command/build_ext.py:529: in build_extension\n    objects = self.compiler.compile(sources,\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:369: in CCompiler_compile\n    single_compile(o)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:328: in single_compile\n    self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <distutils.unixccompiler.UnixCCompiler object at 0x7f288a10c970>\nobj = '/tmp/tmpp7svih3p/tmp/tmpt75e_vmk.o', src = '/tmp/tmpt75e_vmk.cpp'\next = '.cpp'\ncc_args = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10', '-c']\nextra_postargs = ['-O2', '-std=c++11', '-fno-math-errno', '-fvisibility=hidden', '-fno-wrapv', '-Wno-unused-function', ...]\npp_opts = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10']\n\n    def UnixCCompiler__compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compile a single source files with a Unix-style compiler.\"\"\"\n        # HP ad-hoc fix, see ticket 1383\n        ccomp = self.compiler_so\n        if ccomp[0] == 'aCC':\n            # remove flags that will trigger ANSI-C mode for aCC\n            if '-Ae' in ccomp:\n                ccomp.remove('-Ae')\n            if '-Aa' in ccomp:\n                ccomp.remove('-Aa')\n            # add flags for (almost) sane C++ handling\n            ccomp += ['-AA']\n            self.compiler_so = ccomp\n        # ensure OPT environment variable is read\n        if 'OPT' in os.environ:\n            # XXX who uses this?\n            from sysconfig import get_config_vars\n            opt = shlex.join(shlex.split(os.environ['OPT']))\n            gcv_opt = shlex.join(shlex.split(get_config_vars('OPT')[0]))\n            ccomp_s = shlex.join(self.compiler_so)\n            if opt not in ccomp_s:\n                ccomp_s = ccomp_s.replace(gcv_opt, opt)\n                self.compiler_so = shlex.split(ccomp_s)\n            llink_s = shlex.join(self.linker_so)\n            if opt not in llink_s:\n                self.linker_so = self.linker_so + shlex.split(opt)\n    \n        display = '%s: %s' % (os.path.basename(self.compiler_so[0]), src)\n    \n        # gcc style automatic dependencies, outputs a makefile (-MF) that lists\n        # all headers needed by a c file as a side effect of compilation (-MMD)\n        if getattr(self, '_auto_depends', False):\n            deps = ['-MMD', '-MF', obj + '.d']\n        else:\n            deps = []\n    \n        try:\n            self.spawn(self.compiler_so + cc_args + [src, '-o', obj] + deps +\n                       extra_postargs, display = display)\n        except DistutilsExecError as e:\n            msg = str(e)\n>           raise CompileError(msg) from None\nE           distutils.errors.CompileError: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmpt75e_vmk.cpp -o /tmp/tmpp7svih3p/tmp/tmpt75e_vmk.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/unixccompiler.py:58: CompileError\n\nDuring handling of the above exception, another exception occurred:\n\nmodule_name = 'test_annotations', cxxfile = '/tmp/tmpt75e_vmk.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpl4gjyel_'\nbuildtmp = '/tmp/tmpp7svih3p'\nextension = <pythran.dist.PythranExtension('test_annotations') at 0x7f288a10c4f0>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n>           setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n\npythran/toolchain.py:348: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/dist-packages/numpy/distutils/core.py:169: in setup\n    return old_setup(**new_attr)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...<pythran.dist.PythranExtension('test_annotations') at 0x7f288a10c4f0>], 'headers': [], 'name': 'test_annotations', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288a10c490>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n                dist.run_commands()\n            except KeyboardInterrupt:\n                raise SystemExit(\"interrupted\")\n            except OSError as exc:\n                if DEBUG:\n                    sys.stderr.write(\"error: %s\\n\" % (exc,))\n                    raise\n                else:\n                    raise SystemExit(\"error: %s\" % (exc,))\n    \n            except (DistutilsError,\n                    CCompilerError) as msg:\n                if DEBUG:\n                    raise\n                else:\n>                   raise SystemExit(\"error: \" + str(msg))\nE                   SystemExit: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmpt75e_vmk.cpp -o /tmp/tmpp7svih3p/tmp/tmpt75e_vmk.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/lib/python3.10/distutils/core.py:163: SystemExit\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pythran.tests.test_advanced.TestAdvanced testMethod=test_annotations>\n\n    def test_annotations(self):\n        code  = '''\n        import numpy as np\n        def annotations(x: np.ndarray) -> np.ndarray:\n            return x'''\n>       self.run_test(code, numpy.ones(1), annotations=[NDArray[float, :]])\n\npythran/tests/test_advanced.py:479: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npythran/tests/__init__.py:313: in run_test\n    cxx_compiled = compile_pythrancode(\npythran/toolchain.py:466: in compile_pythrancode\n    output_file = compile_cxxcode(module_name,\npythran/toolchain.py:403: in compile_cxxcode\n    output_binary = compile_cxxfile(module_name, fdpath,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodule_name = 'test_annotations', cxxfile = '/tmp/tmpt75e_vmk.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpl4gjyel_'\nbuildtmp = '/tmp/tmpp7svih3p'\nextension = <pythran.dist.PythranExtension('test_annotations') at 0x7f288a10c4f0>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n            setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n        except SystemExit as e:\n>           raise PythranCompileError(str(e))\nE           pythran.errors.PythranCompileError: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmpt75e_vmk.cpp -o /tmp/tmpp7svih3p/tmp/tmpt75e_vmk.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\npythran/toolchain.py:361: PythranCompileError\n----------------------------- Captured stdout call -----------------------------\nrunning build_ext\nDEBUG: new_compiler returns <class 'distutils.unixccompiler.UnixCCompiler'>\nbuilding 'test_annotations' extension\nINFO: C compiler: x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC\n\ncreating /tmp/tmpp7svih3p/tmp\nINFO: compile options: '-DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c'\nextra options: '-O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE'\nINFO: x86_64-linux-gnu-gcc: /tmp/tmpt75e_vmk.cpp\n----------------------------- Captured stderr call -----------------------------\nIn file included from /tmp/tmpt75e_vmk.cpp:1:\n/app/repo_to_process/pythran/pythonic/core.hpp:33:10: fatal error: pyconfig.h: No such file or directory\n   33 | #include \"pyconfig.h\"\n      |          ^~~~~~~~~~~~\ncompilation terminated.\nWARNING: Compilation error, trying hard to find its origin...\nWARNING: Nope, I'm going to flood you with C++ errors!\n------------------------------ Captured log call -------------------------------\nWARNING  pythran:toolchain.py:471 Compilation error, trying hard to find its origin...\nWARNING  pythran:toolchain.py:474 Nope, I'm going to flood you with C++ errors!\n_______________________ TestAdvanced.test_array_to_tuple _______________________\n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...an.dist.PythranExtension('test_array_to_tuple') at 0x7f288a4a0190>], 'headers': [], 'name': 'test_array_to_tuple', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288a4a0580>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n>               dist.run_commands()\n\n/usr/lib/python3.10/distutils/core.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/distutils/dist.py:966: in run_commands\n    self.run_command(cmd)\n/usr/lib/python3.10/distutils/dist.py:985: in run_command\n    cmd_obj.run()\n/usr/lib/python3.10/distutils/command/build_ext.py:340: in run\n    self.build_extensions()\n/usr/lib/python3.10/distutils/command/build_ext.py:449: in build_extensions\n    self._build_extensions_serial()\n/usr/lib/python3.10/distutils/command/build_ext.py:474: in _build_extensions_serial\n    self.build_extension(ext)\npythran/dist.py:121: in build_extension\n    return super(PythranBuildExtMixIn, self).build_extension(ext)\n/usr/lib/python3.10/distutils/command/build_ext.py:529: in build_extension\n    objects = self.compiler.compile(sources,\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:369: in CCompiler_compile\n    single_compile(o)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:328: in single_compile\n    self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <distutils.unixccompiler.UnixCCompiler object at 0x7f288a4a0850>\nobj = '/tmp/tmp5d2qeueb/tmp/tmp1__sk9ke.o', src = '/tmp/tmp1__sk9ke.cpp'\next = '.cpp'\ncc_args = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10', '-c']\nextra_postargs = ['-O2', '-std=c++11', '-fno-math-errno', '-fvisibility=hidden', '-fno-wrapv', '-Wno-unused-function', ...]\npp_opts = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10']\n\n    def UnixCCompiler__compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compile a single source files with a Unix-style compiler.\"\"\"\n        # HP ad-hoc fix, see ticket 1383\n        ccomp = self.compiler_so\n        if ccomp[0] == 'aCC':\n            # remove flags that will trigger ANSI-C mode for aCC\n            if '-Ae' in ccomp:\n                ccomp.remove('-Ae')\n            if '-Aa' in ccomp:\n                ccomp.remove('-Aa')\n            # add flags for (almost) sane C++ handling\n            ccomp += ['-AA']\n            self.compiler_so = ccomp\n        # ensure OPT environment variable is read\n        if 'OPT' in os.environ:\n            # XXX who uses this?\n            from sysconfig import get_config_vars\n            opt = shlex.join(shlex.split(os.environ['OPT']))\n            gcv_opt = shlex.join(shlex.split(get_config_vars('OPT')[0]))\n            ccomp_s = shlex.join(self.compiler_so)\n            if opt not in ccomp_s:\n                ccomp_s = ccomp_s.replace(gcv_opt, opt)\n                self.compiler_so = shlex.split(ccomp_s)\n            llink_s = shlex.join(self.linker_so)\n            if opt not in llink_s:\n                self.linker_so = self.linker_so + shlex.split(opt)\n    \n        display = '%s: %s' % (os.path.basename(self.compiler_so[0]), src)\n    \n        # gcc style automatic dependencies, outputs a makefile (-MF) that lists\n        # all headers needed by a c file as a side effect of compilation (-MMD)\n        if getattr(self, '_auto_depends', False):\n            deps = ['-MMD', '-MF', obj + '.d']\n        else:\n            deps = []\n    \n        try:\n            self.spawn(self.compiler_so + cc_args + [src, '-o', obj] + deps +\n                       extra_postargs, display = display)\n        except DistutilsExecError as e:\n            msg = str(e)\n>           raise CompileError(msg) from None\nE           distutils.errors.CompileError: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp1__sk9ke.cpp -o /tmp/tmp5d2qeueb/tmp/tmp1__sk9ke.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/unixccompiler.py:58: CompileError\n\nDuring handling of the above exception, another exception occurred:\n\nmodule_name = 'test_array_to_tuple', cxxfile = '/tmp/tmp1__sk9ke.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmp7gqqihwz'\nbuildtmp = '/tmp/tmp5d2qeueb'\nextension = <pythran.dist.PythranExtension('test_array_to_tuple') at 0x7f288a4a0190>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n>           setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n\npythran/toolchain.py:348: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/dist-packages/numpy/distutils/core.py:169: in setup\n    return old_setup(**new_attr)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...an.dist.PythranExtension('test_array_to_tuple') at 0x7f288a4a0190>], 'headers': [], 'name': 'test_array_to_tuple', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288a4a0580>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n                dist.run_commands()\n            except KeyboardInterrupt:\n                raise SystemExit(\"interrupted\")\n            except OSError as exc:\n                if DEBUG:\n                    sys.stderr.write(\"error: %s\\n\" % (exc,))\n                    raise\n                else:\n                    raise SystemExit(\"error: %s\" % (exc,))\n    \n            except (DistutilsError,\n                    CCompilerError) as msg:\n                if DEBUG:\n                    raise\n                else:\n>                   raise SystemExit(\"error: \" + str(msg))\nE                   SystemExit: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp1__sk9ke.cpp -o /tmp/tmp5d2qeueb/tmp/tmp1__sk9ke.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/lib/python3.10/distutils/core.py:163: SystemExit\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pythran.tests.test_advanced.TestAdvanced testMethod=test_array_to_tuple>\n\n    def test_array_to_tuple(self):\n>       self.run_test('def array_to_tuple(t): return tuple((1, t))',\n                      2,\n                      array_to_tuple=[int])\n\npythran/tests/test_advanced.py:227: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npythran/tests/__init__.py:313: in run_test\n    cxx_compiled = compile_pythrancode(\npythran/toolchain.py:466: in compile_pythrancode\n    output_file = compile_cxxcode(module_name,\npythran/toolchain.py:403: in compile_cxxcode\n    output_binary = compile_cxxfile(module_name, fdpath,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodule_name = 'test_array_to_tuple', cxxfile = '/tmp/tmp1__sk9ke.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmp7gqqihwz'\nbuildtmp = '/tmp/tmp5d2qeueb'\nextension = <pythran.dist.PythranExtension('test_array_to_tuple') at 0x7f288a4a0190>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n            setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n        except SystemExit as e:\n>           raise PythranCompileError(str(e))\nE           pythran.errors.PythranCompileError: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp1__sk9ke.cpp -o /tmp/tmp5d2qeueb/tmp/tmp1__sk9ke.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\npythran/toolchain.py:361: PythranCompileError\n----------------------------- Captured stdout call -----------------------------\nrunning build_ext\nDEBUG: new_compiler returns <class 'distutils.unixccompiler.UnixCCompiler'>\nbuilding 'test_array_to_tuple' extension\nINFO: C compiler: x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC\n\ncreating /tmp/tmp5d2qeueb/tmp\nINFO: compile options: '-DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c'\nextra options: '-O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE'\nINFO: x86_64-linux-gnu-gcc: /tmp/tmp1__sk9ke.cpp\n----------------------------- Captured stderr call -----------------------------\nIn file included from /tmp/tmp1__sk9ke.cpp:1:\n/app/repo_to_process/pythran/pythonic/core.hpp:33:10: fatal error: pyconfig.h: No such file or directory\n   33 | #include \"pyconfig.h\"\n      |          ^~~~~~~~~~~~\ncompilation terminated.\nWARNING: Compilation error, trying hard to find its origin...\nWARNING: Nope, I'm going to flood you with C++ errors!\n------------------------------ Captured log call -------------------------------\nWARNING  pythran:toolchain.py:471 Compilation error, trying hard to find its origin...\nWARNING  pythran:toolchain.py:474 Nope, I'm going to flood you with C++ errors!\n______________________ TestAdvanced.test_assign_in_except ______________________\n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...ist.PythranExtension('test_assign_in_except') at 0x7f288ac2ef80>], 'headers': [], 'name': 'test_assign_in_except', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288ac2dae0>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n>               dist.run_commands()\n\n/usr/lib/python3.10/distutils/core.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/distutils/dist.py:966: in run_commands\n    self.run_command(cmd)\n/usr/lib/python3.10/distutils/dist.py:985: in run_command\n    cmd_obj.run()\n/usr/lib/python3.10/distutils/command/build_ext.py:340: in run\n    self.build_extensions()\n/usr/lib/python3.10/distutils/command/build_ext.py:449: in build_extensions\n    self._build_extensions_serial()\n/usr/lib/python3.10/distutils/command/build_ext.py:474: in _build_extensions_serial\n    self.build_extension(ext)\npythran/dist.py:121: in build_extension\n    return super(PythranBuildExtMixIn, self).build_extension(ext)\n/usr/lib/python3.10/distutils/command/build_ext.py:529: in build_extension\n    objects = self.compiler.compile(sources,\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:369: in CCompiler_compile\n    single_compile(o)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:328: in single_compile\n    self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <distutils.unixccompiler.UnixCCompiler object at 0x7f288ac2d270>\nobj = '/tmp/tmpdz0wpmis/tmp/tmpcjijj4cn.o', src = '/tmp/tmpcjijj4cn.cpp'\next = '.cpp'\ncc_args = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10', '-c']\nextra_postargs = ['-O2', '-std=c++11', '-fno-math-errno', '-fvisibility=hidden', '-fno-wrapv', '-Wno-unused-function', ...]\npp_opts = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10']\n\n    def UnixCCompiler__compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compile a single source files with a Unix-style compiler.\"\"\"\n        # HP ad-hoc fix, see ticket 1383\n        ccomp = self.compiler_so\n        if ccomp[0] == 'aCC':\n            # remove flags that will trigger ANSI-C mode for aCC\n            if '-Ae' in ccomp:\n                ccomp.remove('-Ae')\n            if '-Aa' in ccomp:\n                ccomp.remove('-Aa')\n            # add flags for (almost) sane C++ handling\n            ccomp += ['-AA']\n            self.compiler_so = ccomp\n        # ensure OPT environment variable is read\n        if 'OPT' in os.environ:\n            # XXX who uses this?\n            from sysconfig import get_config_vars\n            opt = shlex.join(shlex.split(os.environ['OPT']))\n            gcv_opt = shlex.join(shlex.split(get_config_vars('OPT')[0]))\n            ccomp_s = shlex.join(self.compiler_so)\n            if opt not in ccomp_s:\n                ccomp_s = ccomp_s.replace(gcv_opt, opt)\n                self.compiler_so = shlex.split(ccomp_s)\n            llink_s = shlex.join(self.linker_so)\n            if opt not in llink_s:\n                self.linker_so = self.linker_so + shlex.split(opt)\n    \n        display = '%s: %s' % (os.path.basename(self.compiler_so[0]), src)\n    \n        # gcc style automatic dependencies, outputs a makefile (-MF) that lists\n        # all headers needed by a c file as a side effect of compilation (-MMD)\n        if getattr(self, '_auto_depends', False):\n            deps = ['-MMD', '-MF', obj + '.d']\n        else:\n            deps = []\n    \n        try:\n            self.spawn(self.compiler_so + cc_args + [src, '-o', obj] + deps +\n                       extra_postargs, display = display)\n        except DistutilsExecError as e:\n            msg = str(e)\n>           raise CompileError(msg) from None\nE           distutils.errors.CompileError: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmpcjijj4cn.cpp -o /tmp/tmpdz0wpmis/tmp/tmpcjijj4cn.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/unixccompiler.py:58: CompileError\n\nDuring handling of the above exception, another exception occurred:\n\nmodule_name = 'test_assign_in_except', cxxfile = '/tmp/tmpcjijj4cn.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmph6s71dxj'\nbuildtmp = '/tmp/tmpdz0wpmis'\nextension = <pythran.dist.PythranExtension('test_assign_in_except') at 0x7f288ac2ef80>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n>           setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n\npythran/toolchain.py:348: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/dist-packages/numpy/distutils/core.py:169: in setup\n    return old_setup(**new_attr)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...ist.PythranExtension('test_assign_in_except') at 0x7f288ac2ef80>], 'headers': [], 'name': 'test_assign_in_except', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288ac2dae0>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n                dist.run_commands()\n            except KeyboardInterrupt:\n                raise SystemExit(\"interrupted\")\n            except OSError as exc:\n                if DEBUG:\n                    sys.stderr.write(\"error: %s\\n\" % (exc,))\n                    raise\n                else:\n                    raise SystemExit(\"error: %s\" % (exc,))\n    \n            except (DistutilsError,\n                    CCompilerError) as msg:\n                if DEBUG:\n                    raise\n                else:\n>                   raise SystemExit(\"error: \" + str(msg))\nE                   SystemExit: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmpcjijj4cn.cpp -o /tmp/tmpdz0wpmis/tmp/tmpcjijj4cn.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/lib/python3.10/distutils/core.py:163: SystemExit\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pythran.tests.test_advanced.TestAdvanced testMethod=test_assign_in_except>\n\n        def test_assign_in_except(self):\n            code = '''\n    def assign_in_except():\n        try:\n            a=1\n        except:\n            a+=a\n        return a'''\n>           self.run_test(code, assign_in_except=[])\n\npythran/tests/test_advanced.py:130: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npythran/tests/__init__.py:313: in run_test\n    cxx_compiled = compile_pythrancode(\npythran/toolchain.py:466: in compile_pythrancode\n    output_file = compile_cxxcode(module_name,\npythran/toolchain.py:403: in compile_cxxcode\n    output_binary = compile_cxxfile(module_name, fdpath,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodule_name = 'test_assign_in_except', cxxfile = '/tmp/tmpcjijj4cn.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmph6s71dxj'\nbuildtmp = '/tmp/tmpdz0wpmis'\nextension = <pythran.dist.PythranExtension('test_assign_in_except') at 0x7f288ac2ef80>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n            setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n        except SystemExit as e:\n>           raise PythranCompileError(str(e))\nE           pythran.errors.PythranCompileError: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmpcjijj4cn.cpp -o /tmp/tmpdz0wpmis/tmp/tmpcjijj4cn.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\npythran/toolchain.py:361: PythranCompileError\n----------------------------- Captured stdout call -----------------------------\nrunning build_ext\nDEBUG: new_compiler returns <class 'distutils.unixccompiler.UnixCCompiler'>\nbuilding 'test_assign_in_except' extension\nINFO: C compiler: x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC\n\ncreating /tmp/tmpdz0wpmis/tmp\nINFO: compile options: '-DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c'\nextra options: '-O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE'\nINFO: x86_64-linux-gnu-gcc: /tmp/tmpcjijj4cn.cpp\n----------------------------- Captured stderr call -----------------------------\nIn file included from /tmp/tmpcjijj4cn.cpp:1:\n/app/repo_to_process/pythran/pythonic/core.hpp:33:10: fatal error: pyconfig.h: No such file or directory\n   33 | #include \"pyconfig.h\"\n      |          ^~~~~~~~~~~~\ncompilation terminated.\nWARNING: Compilation error, trying hard to find its origin...\nWARNING: Nope, I'm going to flood you with C++ errors!\n------------------------------ Captured log call -------------------------------\nWARNING  pythran:toolchain.py:471 Compilation error, trying hard to find its origin...\nWARNING  pythran:toolchain.py:474 Nope, I'm going to flood you with C++ errors!\n_____________________ TestAdvanced.test_augassign_floordiv _____________________\n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...PythranExtension('test_augassign_floordiv') at 0x7f288a224b20>], 'headers': [], 'name': 'test_augassign_floordiv', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288a224700>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n>               dist.run_commands()\n\n/usr/lib/python3.10/distutils/core.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/distutils/dist.py:966: in run_commands\n    self.run_command(cmd)\n/usr/lib/python3.10/distutils/dist.py:985: in run_command\n    cmd_obj.run()\n/usr/lib/python3.10/distutils/command/build_ext.py:340: in run\n    self.build_extensions()\n/usr/lib/python3.10/distutils/command/build_ext.py:449: in build_extensions\n    self._build_extensions_serial()\n/usr/lib/python3.10/distutils/command/build_ext.py:474: in _build_extensions_serial\n    self.build_extension(ext)\npythran/dist.py:121: in build_extension\n    return super(PythranBuildExtMixIn, self).build_extension(ext)\n/usr/lib/python3.10/distutils/command/build_ext.py:529: in build_extension\n    objects = self.compiler.compile(sources,\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:369: in CCompiler_compile\n    single_compile(o)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:328: in single_compile\n    self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <distutils.unixccompiler.UnixCCompiler object at 0x7f288a2242e0>\nobj = '/tmp/tmpy8pky7oi/tmp/tmp8z_d96a7.o', src = '/tmp/tmp8z_d96a7.cpp'\next = '.cpp'\ncc_args = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10', '-c']\nextra_postargs = ['-O2', '-std=c++11', '-fno-math-errno', '-fvisibility=hidden', '-fno-wrapv', '-Wno-unused-function', ...]\npp_opts = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10']\n\n    def UnixCCompiler__compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compile a single source files with a Unix-style compiler.\"\"\"\n        # HP ad-hoc fix, see ticket 1383\n        ccomp = self.compiler_so\n        if ccomp[0] == 'aCC':\n            # remove flags that will trigger ANSI-C mode for aCC\n            if '-Ae' in ccomp:\n                ccomp.remove('-Ae')\n            if '-Aa' in ccomp:\n                ccomp.remove('-Aa')\n            # add flags for (almost) sane C++ handling\n            ccomp += ['-AA']\n            self.compiler_so = ccomp\n        # ensure OPT environment variable is read\n        if 'OPT' in os.environ:\n            # XXX who uses this?\n            from sysconfig import get_config_vars\n            opt = shlex.join(shlex.split(os.environ['OPT']))\n            gcv_opt = shlex.join(shlex.split(get_config_vars('OPT')[0]))\n            ccomp_s = shlex.join(self.compiler_so)\n            if opt not in ccomp_s:\n                ccomp_s = ccomp_s.replace(gcv_opt, opt)\n                self.compiler_so = shlex.split(ccomp_s)\n            llink_s = shlex.join(self.linker_so)\n            if opt not in llink_s:\n                self.linker_so = self.linker_so + shlex.split(opt)\n    \n        display = '%s: %s' % (os.path.basename(self.compiler_so[0]), src)\n    \n        # gcc style automatic dependencies, outputs a makefile (-MF) that lists\n        # all headers needed by a c file as a side effect of compilation (-MMD)\n        if getattr(self, '_auto_depends', False):\n            deps = ['-MMD', '-MF', obj + '.d']\n        else:\n            deps = []\n    \n        try:\n            self.spawn(self.compiler_so + cc_args + [src, '-o', obj] + deps +\n                       extra_postargs, display = display)\n        except DistutilsExecError as e:\n            msg = str(e)\n>           raise CompileError(msg) from None\nE           distutils.errors.CompileError: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp8z_d96a7.cpp -o /tmp/tmpy8pky7oi/tmp/tmp8z_d96a7.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/unixccompiler.py:58: CompileError\n\nDuring handling of the above exception, another exception occurred:\n\nmodule_name = 'test_augassign_floordiv', cxxfile = '/tmp/tmp8z_d96a7.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpojh81dae'\nbuildtmp = '/tmp/tmpy8pky7oi'\nextension = <pythran.dist.PythranExtension('test_augassign_floordiv') at 0x7f288a224b20>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n>           setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n\npythran/toolchain.py:348: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/dist-packages/numpy/distutils/core.py:169: in setup\n    return old_setup(**new_attr)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...PythranExtension('test_augassign_floordiv') at 0x7f288a224b20>], 'headers': [], 'name': 'test_augassign_floordiv', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288a224700>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n                dist.run_commands()\n            except KeyboardInterrupt:\n                raise SystemExit(\"interrupted\")\n            except OSError as exc:\n                if DEBUG:\n                    sys.stderr.write(\"error: %s\\n\" % (exc,))\n                    raise\n                else:\n                    raise SystemExit(\"error: %s\" % (exc,))\n    \n            except (DistutilsError,\n                    CCompilerError) as msg:\n                if DEBUG:\n                    raise\n                else:\n>                   raise SystemExit(\"error: \" + str(msg))\nE                   SystemExit: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp8z_d96a7.cpp -o /tmp/tmpy8pky7oi/tmp/tmp8z_d96a7.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/lib/python3.10/distutils/core.py:163: SystemExit\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pythran.tests.test_advanced.TestAdvanced testMethod=test_augassign_floordiv>\n\n    def test_augassign_floordiv(self):\n>       self.run_test(\"def augassign_floordiv(i,j): k=i ; k//=j; return k\",\n                2, 5, augassign_floordiv=[int, int])\n\npythran/tests/test_advanced.py:29: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npythran/tests/__init__.py:313: in run_test\n    cxx_compiled = compile_pythrancode(\npythran/toolchain.py:466: in compile_pythrancode\n    output_file = compile_cxxcode(module_name,\npythran/toolchain.py:403: in compile_cxxcode\n    output_binary = compile_cxxfile(module_name, fdpath,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodule_name = 'test_augassign_floordiv', cxxfile = '/tmp/tmp8z_d96a7.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpojh81dae'\nbuildtmp = '/tmp/tmpy8pky7oi'\nextension = <pythran.dist.PythranExtension('test_augassign_floordiv') at 0x7f288a224b20>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n            setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n        except SystemExit as e:\n>           raise PythranCompileError(str(e))\nE           pythran.errors.PythranCompileError: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp8z_d96a7.cpp -o /tmp/tmpy8pky7oi/tmp/tmp8z_d96a7.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\npythran/toolchain.py:361: PythranCompileError\n----------------------------- Captured stdout call -----------------------------\nrunning build_ext\nDEBUG: new_compiler returns <class 'distutils.unixccompiler.UnixCCompiler'>\nbuilding 'test_augassign_floordiv' extension\nINFO: C compiler: x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC\n\ncreating /tmp/tmpy8pky7oi/tmp\nINFO: compile options: '-DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c'\nextra options: '-O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE'\nINFO: x86_64-linux-gnu-gcc: /tmp/tmp8z_d96a7.cpp\n----------------------------- Captured stderr call -----------------------------\nIn file included from /tmp/tmp8z_d96a7.cpp:1:\n/app/repo_to_process/pythran/pythonic/core.hpp:33:10: fatal error: pyconfig.h: No such file or directory\n   33 | #include \"pyconfig.h\"\n      |          ^~~~~~~~~~~~\ncompilation terminated.\nWARNING: Compilation error, trying hard to find its origin...\nWARNING: Nope, I'm going to flood you with C++ errors!\n------------------------------ Captured log call -------------------------------\nWARNING  pythran:toolchain.py:471 Compilation error, trying hard to find its origin...\nWARNING  pythran:toolchain.py:474 Nope, I'm going to flood you with C++ errors!\n______________________ TestAdvanced.test_bool_op_casting _______________________\n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com....dist.PythranExtension('test_bool_op_casting') at 0x7f288ab85720>], 'headers': [], 'name': 'test_bool_op_casting', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288ab85300>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n>               dist.run_commands()\n\n/usr/lib/python3.10/distutils/core.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/distutils/dist.py:966: in run_commands\n    self.run_command(cmd)\n/usr/lib/python3.10/distutils/dist.py:985: in run_command\n    cmd_obj.run()\n/usr/lib/python3.10/distutils/command/build_ext.py:340: in run\n    self.build_extensions()\n/usr/lib/python3.10/distutils/command/build_ext.py:449: in build_extensions\n    self._build_extensions_serial()\n/usr/lib/python3.10/distutils/command/build_ext.py:474: in _build_extensions_serial\n    self.build_extension(ext)\npythran/dist.py:121: in build_extension\n    return super(PythranBuildExtMixIn, self).build_extension(ext)\n/usr/lib/python3.10/distutils/command/build_ext.py:529: in build_extension\n    objects = self.compiler.compile(sources,\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:369: in CCompiler_compile\n    single_compile(o)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:328: in single_compile\n    self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <distutils.unixccompiler.UnixCCompiler object at 0x7f288ab846d0>\nobj = '/tmp/tmpad_pexzn/tmp/tmpjxy1eook.o', src = '/tmp/tmpjxy1eook.cpp'\next = '.cpp'\ncc_args = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10', '-c']\nextra_postargs = ['-O2', '-std=c++11', '-fno-math-errno', '-fvisibility=hidden', '-fno-wrapv', '-Wno-unused-function', ...]\npp_opts = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10']\n\n    def UnixCCompiler__compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compile a single source files with a Unix-style compiler.\"\"\"\n        # HP ad-hoc fix, see ticket 1383\n        ccomp = self.compiler_so\n        if ccomp[0] == 'aCC':\n            # remove flags that will trigger ANSI-C mode for aCC\n            if '-Ae' in ccomp:\n                ccomp.remove('-Ae')\n            if '-Aa' in ccomp:\n                ccomp.remove('-Aa')\n            # add flags for (almost) sane C++ handling\n            ccomp += ['-AA']\n            self.compiler_so = ccomp\n        # ensure OPT environment variable is read\n        if 'OPT' in os.environ:\n            # XXX who uses this?\n            from sysconfig import get_config_vars\n            opt = shlex.join(shlex.split(os.environ['OPT']))\n            gcv_opt = shlex.join(shlex.split(get_config_vars('OPT')[0]))\n            ccomp_s = shlex.join(self.compiler_so)\n            if opt not in ccomp_s:\n                ccomp_s = ccomp_s.replace(gcv_opt, opt)\n                self.compiler_so = shlex.split(ccomp_s)\n            llink_s = shlex.join(self.linker_so)\n            if opt not in llink_s:\n                self.linker_so = self.linker_so + shlex.split(opt)\n    \n        display = '%s: %s' % (os.path.basename(self.compiler_so[0]), src)\n    \n        # gcc style automatic dependencies, outputs a makefile (-MF) that lists\n        # all headers needed by a c file as a side effect of compilation (-MMD)\n        if getattr(self, '_auto_depends', False):\n            deps = ['-MMD', '-MF', obj + '.d']\n        else:\n            deps = []\n    \n        try:\n            self.spawn(self.compiler_so + cc_args + [src, '-o', obj] + deps +\n                       extra_postargs, display = display)\n        except DistutilsExecError as e:\n            msg = str(e)\n>           raise CompileError(msg) from None\nE           distutils.errors.CompileError: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmpjxy1eook.cpp -o /tmp/tmpad_pexzn/tmp/tmpjxy1eook.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/unixccompiler.py:58: CompileError\n\nDuring handling of the above exception, another exception occurred:\n\nmodule_name = 'test_bool_op_casting', cxxfile = '/tmp/tmpjxy1eook.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpwi3z9anb'\nbuildtmp = '/tmp/tmpad_pexzn'\nextension = <pythran.dist.PythranExtension('test_bool_op_casting') at 0x7f288ab85720>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n>           setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n\npythran/toolchain.py:348: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/dist-packages/numpy/distutils/core.py:169: in setup\n    return old_setup(**new_attr)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com....dist.PythranExtension('test_bool_op_casting') at 0x7f288ab85720>], 'headers': [], 'name': 'test_bool_op_casting', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288ab85300>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n                dist.run_commands()\n            except KeyboardInterrupt:\n                raise SystemExit(\"interrupted\")\n            except OSError as exc:\n                if DEBUG:\n                    sys.stderr.write(\"error: %s\\n\" % (exc,))\n                    raise\n                else:\n                    raise SystemExit(\"error: %s\" % (exc,))\n    \n            except (DistutilsError,\n                    CCompilerError) as msg:\n                if DEBUG:\n                    raise\n                else:\n>                   raise SystemExit(\"error: \" + str(msg))\nE                   SystemExit: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmpjxy1eook.cpp -o /tmp/tmpad_pexzn/tmp/tmpjxy1eook.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/lib/python3.10/distutils/core.py:163: SystemExit\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pythran.tests.test_advanced.TestAdvanced testMethod=test_bool_op_casting>\n\n    def test_bool_op_casting(self):\n>       self.run_test('''\n            def bool_op_casting():\n                l=[]\n                L=[1]\n                M=[2]\n                if (l and L) or M:\n                    return (l and L) or M\n                else:\n                    return M''', bool_op_casting=[])\n\npythran/tests/test_advanced.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npythran/tests/__init__.py:313: in run_test\n    cxx_compiled = compile_pythrancode(\npythran/toolchain.py:466: in compile_pythrancode\n    output_file = compile_cxxcode(module_name,\npythran/toolchain.py:403: in compile_cxxcode\n    output_binary = compile_cxxfile(module_name, fdpath,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodule_name = 'test_bool_op_casting', cxxfile = '/tmp/tmpjxy1eook.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpwi3z9anb'\nbuildtmp = '/tmp/tmpad_pexzn'\nextension = <pythran.dist.PythranExtension('test_bool_op_casting') at 0x7f288ab85720>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n            setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n        except SystemExit as e:\n>           raise PythranCompileError(str(e))\nE           pythran.errors.PythranCompileError: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmpjxy1eook.cpp -o /tmp/tmpad_pexzn/tmp/tmpjxy1eook.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\npythran/toolchain.py:361: PythranCompileError\n----------------------------- Captured stdout call -----------------------------\nrunning build_ext\nDEBUG: new_compiler returns <class 'distutils.unixccompiler.UnixCCompiler'>\nbuilding 'test_bool_op_casting' extension\nINFO: C compiler: x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC\n\ncreating /tmp/tmpad_pexzn/tmp\nINFO: compile options: '-DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c'\nextra options: '-O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE'\nINFO: x86_64-linux-gnu-gcc: /tmp/tmpjxy1eook.cpp\n----------------------------- Captured stderr call -----------------------------\nIn file included from /tmp/tmpjxy1eook.cpp:1:\n/app/repo_to_process/pythran/pythonic/core.hpp:33:10: fatal error: pyconfig.h: No such file or directory\n   33 | #include \"pyconfig.h\"\n      |          ^~~~~~~~~~~~\ncompilation terminated.\nWARNING: Compilation error, trying hard to find its origin...\nWARNING: Nope, I'm going to flood you with C++ errors!\n------------------------------ Captured log call -------------------------------\nWARNING  pythran:toolchain.py:471 Compilation error, trying hard to find its origin...\nWARNING  pythran:toolchain.py:474 Nope, I'm going to flood you with C++ errors!\n____________________ TestAdvanced.test_builtin_constructors ____________________\n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...ranExtension('test_builtin_constructors') at 0x7f288b9ba260>], 'headers': [], 'name': 'test_builtin_constructors', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288b9b91b0>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n>               dist.run_commands()\n\n/usr/lib/python3.10/distutils/core.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/distutils/dist.py:966: in run_commands\n    self.run_command(cmd)\n/usr/lib/python3.10/distutils/dist.py:985: in run_command\n    cmd_obj.run()\n/usr/lib/python3.10/distutils/command/build_ext.py:340: in run\n    self.build_extensions()\n/usr/lib/python3.10/distutils/command/build_ext.py:449: in build_extensions\n    self._build_extensions_serial()\n/usr/lib/python3.10/distutils/command/build_ext.py:474: in _build_extensions_serial\n    self.build_extension(ext)\npythran/dist.py:121: in build_extension\n    return super(PythranBuildExtMixIn, self).build_extension(ext)\n/usr/lib/python3.10/distutils/command/build_ext.py:529: in build_extension\n    objects = self.compiler.compile(sources,\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:369: in CCompiler_compile\n    single_compile(o)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:328: in single_compile\n    self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <distutils.unixccompiler.UnixCCompiler object at 0x7f288b9b8e80>\nobj = '/tmp/tmp9d64ql_q/tmp/tmp4xagokw0.o', src = '/tmp/tmp4xagokw0.cpp'\next = '.cpp'\ncc_args = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10', '-c']\nextra_postargs = ['-O2', '-std=c++11', '-fno-math-errno', '-fvisibility=hidden', '-fno-wrapv', '-Wno-unused-function', ...]\npp_opts = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10']\n\n    def UnixCCompiler__compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compile a single source files with a Unix-style compiler.\"\"\"\n        # HP ad-hoc fix, see ticket 1383\n        ccomp = self.compiler_so\n        if ccomp[0] == 'aCC':\n            # remove flags that will trigger ANSI-C mode for aCC\n            if '-Ae' in ccomp:\n                ccomp.remove('-Ae')\n            if '-Aa' in ccomp:\n                ccomp.remove('-Aa')\n            # add flags for (almost) sane C++ handling\n            ccomp += ['-AA']\n            self.compiler_so = ccomp\n        # ensure OPT environment variable is read\n        if 'OPT' in os.environ:\n            # XXX who uses this?\n            from sysconfig import get_config_vars\n            opt = shlex.join(shlex.split(os.environ['OPT']))\n            gcv_opt = shlex.join(shlex.split(get_config_vars('OPT')[0]))\n            ccomp_s = shlex.join(self.compiler_so)\n            if opt not in ccomp_s:\n                ccomp_s = ccomp_s.replace(gcv_opt, opt)\n                self.compiler_so = shlex.split(ccomp_s)\n            llink_s = shlex.join(self.linker_so)\n            if opt not in llink_s:\n                self.linker_so = self.linker_so + shlex.split(opt)\n    \n        display = '%s: %s' % (os.path.basename(self.compiler_so[0]), src)\n    \n        # gcc style automatic dependencies, outputs a makefile (-MF) that lists\n        # all headers needed by a c file as a side effect of compilation (-MMD)\n        if getattr(self, '_auto_depends', False):\n            deps = ['-MMD', '-MF', obj + '.d']\n        else:\n            deps = []\n    \n        try:\n            self.spawn(self.compiler_so + cc_args + [src, '-o', obj] + deps +\n                       extra_postargs, display = display)\n        except DistutilsExecError as e:\n            msg = str(e)\n>           raise CompileError(msg) from None\nE           distutils.errors.CompileError: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp4xagokw0.cpp -o /tmp/tmp9d64ql_q/tmp/tmp4xagokw0.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/unixccompiler.py:58: CompileError\n\nDuring handling of the above exception, another exception occurred:\n\nmodule_name = 'test_builtin_constructors', cxxfile = '/tmp/tmp4xagokw0.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpg45ndiir'\nbuildtmp = '/tmp/tmp9d64ql_q'\nextension = <pythran.dist.PythranExtension('test_builtin_constructors') at 0x7f288b9ba260>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n>           setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n\npythran/toolchain.py:348: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/dist-packages/numpy/distutils/core.py:169: in setup\n    return old_setup(**new_attr)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...ranExtension('test_builtin_constructors') at 0x7f288b9ba260>], 'headers': [], 'name': 'test_builtin_constructors', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288b9b91b0>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n                dist.run_commands()\n            except KeyboardInterrupt:\n                raise SystemExit(\"interrupted\")\n            except OSError as exc:\n                if DEBUG:\n                    sys.stderr.write(\"error: %s\\n\" % (exc,))\n                    raise\n                else:\n                    raise SystemExit(\"error: %s\" % (exc,))\n    \n            except (DistutilsError,\n                    CCompilerError) as msg:\n                if DEBUG:\n                    raise\n                else:\n>                   raise SystemExit(\"error: \" + str(msg))\nE                   SystemExit: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp4xagokw0.cpp -o /tmp/tmp9d64ql_q/tmp/tmp4xagokw0.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/lib/python3.10/distutils/core.py:163: SystemExit\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pythran.tests.test_advanced.TestAdvanced testMethod=test_builtin_constructors>\n\n    def test_builtin_constructors(self):\n>       self.run_test(\"def builtin_constructors(l): return list(map(int,l))\",\n                [1.5, 2.5], builtin_constructors=[List[float]])\n\npythran/tests/test_advanced.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npythran/tests/__init__.py:313: in run_test\n    cxx_compiled = compile_pythrancode(\npythran/toolchain.py:466: in compile_pythrancode\n    output_file = compile_cxxcode(module_name,\npythran/toolchain.py:403: in compile_cxxcode\n    output_binary = compile_cxxfile(module_name, fdpath,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodule_name = 'test_builtin_constructors', cxxfile = '/tmp/tmp4xagokw0.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpg45ndiir'\nbuildtmp = '/tmp/tmp9d64ql_q'\nextension = <pythran.dist.PythranExtension('test_builtin_constructors') at 0x7f288b9ba260>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n            setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n        except SystemExit as e:\n>           raise PythranCompileError(str(e))\nE           pythran.errors.PythranCompileError: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp4xagokw0.cpp -o /tmp/tmp9d64ql_q/tmp/tmp4xagokw0.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\npythran/toolchain.py:361: PythranCompileError\n----------------------------- Captured stdout call -----------------------------\nrunning build_ext\nDEBUG: new_compiler returns <class 'distutils.unixccompiler.UnixCCompiler'>\nbuilding 'test_builtin_constructors' extension\nINFO: C compiler: x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC\n\ncreating /tmp/tmp9d64ql_q/tmp\nINFO: compile options: '-DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c'\nextra options: '-O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE'\nINFO: x86_64-linux-gnu-gcc: /tmp/tmp4xagokw0.cpp\n----------------------------- Captured stderr call -----------------------------\nIn file included from /tmp/tmp4xagokw0.cpp:1:\n/app/repo_to_process/pythran/pythonic/core.hpp:33:10: fatal error: pyconfig.h: No such file or directory\n   33 | #include \"pyconfig.h\"\n      |          ^~~~~~~~~~~~\ncompilation terminated.\nWARNING: Compilation error, trying hard to find its origin...\nWARNING: Nope, I'm going to flood you with C++ errors!\n------------------------------ Captured log call -------------------------------\nWARNING  pythran:toolchain.py:471 Compilation error, trying hard to find its origin...\nWARNING  pythran:toolchain.py:474 Nope, I'm going to flood you with C++ errors!\n_______________________ TestAdvanced.test_builtin_slices _______________________\n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...an.dist.PythranExtension('test_builtin_slices') at 0x7f288b043cd0>], 'headers': [], 'name': 'test_builtin_slices', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288b041720>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n>               dist.run_commands()\n\n/usr/lib/python3.10/distutils/core.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/distutils/dist.py:966: in run_commands\n    self.run_command(cmd)\n/usr/lib/python3.10/distutils/dist.py:985: in run_command\n    cmd_obj.run()\n/usr/lib/python3.10/distutils/command/build_ext.py:340: in run\n    self.build_extensions()\n/usr/lib/python3.10/distutils/command/build_ext.py:449: in build_extensions\n    self._build_extensions_serial()\n/usr/lib/python3.10/distutils/command/build_ext.py:474: in _build_extensions_serial\n    self.build_extension(ext)\npythran/dist.py:121: in build_extension\n    return super(PythranBuildExtMixIn, self).build_extension(ext)\n/usr/lib/python3.10/distutils/command/build_ext.py:529: in build_extension\n    objects = self.compiler.compile(sources,\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:369: in CCompiler_compile\n    single_compile(o)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:328: in single_compile\n    self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <distutils.unixccompiler.UnixCCompiler object at 0x7f288af911b0>\nobj = '/tmp/tmp70uiolmp/tmp/tmp4jpzhx_0.o', src = '/tmp/tmp4jpzhx_0.cpp'\next = '.cpp'\ncc_args = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10', '-c']\nextra_postargs = ['-O2', '-std=c++11', '-fno-math-errno', '-fvisibility=hidden', '-fno-wrapv', '-Wno-unused-function', ...]\npp_opts = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10']\n\n    def UnixCCompiler__compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compile a single source files with a Unix-style compiler.\"\"\"\n        # HP ad-hoc fix, see ticket 1383\n        ccomp = self.compiler_so\n        if ccomp[0] == 'aCC':\n            # remove flags that will trigger ANSI-C mode for aCC\n            if '-Ae' in ccomp:\n                ccomp.remove('-Ae')\n            if '-Aa' in ccomp:\n                ccomp.remove('-Aa')\n            # add flags for (almost) sane C++ handling\n            ccomp += ['-AA']\n            self.compiler_so = ccomp\n        # ensure OPT environment variable is read\n        if 'OPT' in os.environ:\n            # XXX who uses this?\n            from sysconfig import get_config_vars\n            opt = shlex.join(shlex.split(os.environ['OPT']))\n            gcv_opt = shlex.join(shlex.split(get_config_vars('OPT')[0]))\n            ccomp_s = shlex.join(self.compiler_so)\n            if opt not in ccomp_s:\n                ccomp_s = ccomp_s.replace(gcv_opt, opt)\n                self.compiler_so = shlex.split(ccomp_s)\n            llink_s = shlex.join(self.linker_so)\n            if opt not in llink_s:\n                self.linker_so = self.linker_so + shlex.split(opt)\n    \n        display = '%s: %s' % (os.path.basename(self.compiler_so[0]), src)\n    \n        # gcc style automatic dependencies, outputs a makefile (-MF) that lists\n        # all headers needed by a c file as a side effect of compilation (-MMD)\n        if getattr(self, '_auto_depends', False):\n            deps = ['-MMD', '-MF', obj + '.d']\n        else:\n            deps = []\n    \n        try:\n            self.spawn(self.compiler_so + cc_args + [src, '-o', obj] + deps +\n                       extra_postargs, display = display)\n        except DistutilsExecError as e:\n            msg = str(e)\n>           raise CompileError(msg) from None\nE           distutils.errors.CompileError: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp4jpzhx_0.cpp -o /tmp/tmp70uiolmp/tmp/tmp4jpzhx_0.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/unixccompiler.py:58: CompileError\n\nDuring handling of the above exception, another exception occurred:\n\nmodule_name = 'test_builtin_slices', cxxfile = '/tmp/tmp4jpzhx_0.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpn_47roej'\nbuildtmp = '/tmp/tmp70uiolmp'\nextension = <pythran.dist.PythranExtension('test_builtin_slices') at 0x7f288b043cd0>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n>           setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n\npythran/toolchain.py:348: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/dist-packages/numpy/distutils/core.py:169: in setup\n    return old_setup(**new_attr)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...an.dist.PythranExtension('test_builtin_slices') at 0x7f288b043cd0>], 'headers': [], 'name': 'test_builtin_slices', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288b041720>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n                dist.run_commands()\n            except KeyboardInterrupt:\n                raise SystemExit(\"interrupted\")\n            except OSError as exc:\n                if DEBUG:\n                    sys.stderr.write(\"error: %s\\n\" % (exc,))\n                    raise\n                else:\n                    raise SystemExit(\"error: %s\" % (exc,))\n    \n            except (DistutilsError,\n                    CCompilerError) as msg:\n                if DEBUG:\n                    raise\n                else:\n>                   raise SystemExit(\"error: \" + str(msg))\nE                   SystemExit: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp4jpzhx_0.cpp -o /tmp/tmp70uiolmp/tmp/tmp4jpzhx_0.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/lib/python3.10/distutils/core.py:163: SystemExit\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pythran.tests.test_advanced.TestAdvanced testMethod=test_builtin_slices>\n\n    def test_builtin_slices(self):\n        code = '''\n            def builtin_slices(x):\n                s = slice(2, None, None)\n                return (s.start, s.stop, s.step, s,\n                        x[s],\n                        x[slice(3)],\n                        x[slice(1,2)],\n                        x[slice(1,10,2)],\n                        x[slice(3, None)],\n                        x[slice(None,4)],\n                        x[slice(None,4, None)])'''\n>       self.run_test(code,\n                      numpy.arange(15),\n                      builtin_slices=[NDArray[int,:]])\n\npythran/tests/test_advanced.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npythran/tests/__init__.py:313: in run_test\n    cxx_compiled = compile_pythrancode(\npythran/toolchain.py:466: in compile_pythrancode\n    output_file = compile_cxxcode(module_name,\npythran/toolchain.py:403: in compile_cxxcode\n    output_binary = compile_cxxfile(module_name, fdpath,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodule_name = 'test_builtin_slices', cxxfile = '/tmp/tmp4jpzhx_0.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpn_47roej'\nbuildtmp = '/tmp/tmp70uiolmp'\nextension = <pythran.dist.PythranExtension('test_builtin_slices') at 0x7f288b043cd0>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n            setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n        except SystemExit as e:\n>           raise PythranCompileError(str(e))\nE           pythran.errors.PythranCompileError: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp4jpzhx_0.cpp -o /tmp/tmp70uiolmp/tmp/tmp4jpzhx_0.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\npythran/toolchain.py:361: PythranCompileError\n----------------------------- Captured stdout call -----------------------------\nrunning build_ext\nDEBUG: new_compiler returns <class 'distutils.unixccompiler.UnixCCompiler'>\nbuilding 'test_builtin_slices' extension\nINFO: C compiler: x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC\n\ncreating /tmp/tmp70uiolmp/tmp\nINFO: compile options: '-DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c'\nextra options: '-O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE'\nINFO: x86_64-linux-gnu-gcc: /tmp/tmp4jpzhx_0.cpp\n----------------------------- Captured stderr call -----------------------------\nIn file included from /tmp/tmp4jpzhx_0.cpp:1:\n/app/repo_to_process/pythran/pythonic/core.hpp:33:10: fatal error: pyconfig.h: No such file or directory\n   33 | #include \"pyconfig.h\"\n      |          ^~~~~~~~~~~~\ncompilation terminated.\nWARNING: Compilation error, trying hard to find its origin...\nWARNING: Nope, I'm going to flood you with C++ errors!\n------------------------------ Captured log call -------------------------------\nWARNING  pythran:toolchain.py:471 Compilation error, trying hard to find its origin...\nWARNING  pythran:toolchain.py:474 Nope, I'm going to flood you with C++ errors!\n___________________ TestAdvanced.test_combiner_on_empty_list ___________________\n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...xtension('test_combiner_on_empty_list') at 0x7f288a290c10>], 'headers': [], 'name': 'test_combiner_on_empty_list', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288a290fd0>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n>               dist.run_commands()\n\n/usr/lib/python3.10/distutils/core.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/distutils/dist.py:966: in run_commands\n    self.run_command(cmd)\n/usr/lib/python3.10/distutils/dist.py:985: in run_command\n    cmd_obj.run()\n/usr/lib/python3.10/distutils/command/build_ext.py:340: in run\n    self.build_extensions()\n/usr/lib/python3.10/distutils/command/build_ext.py:449: in build_extensions\n    self._build_extensions_serial()\n/usr/lib/python3.10/distutils/command/build_ext.py:474: in _build_extensions_serial\n    self.build_extension(ext)\npythran/dist.py:121: in build_extension\n    return super(PythranBuildExtMixIn, self).build_extension(ext)\n/usr/lib/python3.10/distutils/command/build_ext.py:529: in build_extension\n    objects = self.compiler.compile(sources,\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:369: in CCompiler_compile\n    single_compile(o)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:328: in single_compile\n    self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <distutils.unixccompiler.UnixCCompiler object at 0x7f288a291180>\nobj = '/tmp/tmpte1v6fp3/tmp/tmp6_18da03.o', src = '/tmp/tmp6_18da03.cpp'\next = '.cpp'\ncc_args = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10', '-c']\nextra_postargs = ['-O2', '-std=c++11', '-fno-math-errno', '-fvisibility=hidden', '-fno-wrapv', '-Wno-unused-function', ...]\npp_opts = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10']\n\n    def UnixCCompiler__compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compile a single source files with a Unix-style compiler.\"\"\"\n        # HP ad-hoc fix, see ticket 1383\n        ccomp = self.compiler_so\n        if ccomp[0] == 'aCC':\n            # remove flags that will trigger ANSI-C mode for aCC\n            if '-Ae' in ccomp:\n                ccomp.remove('-Ae')\n            if '-Aa' in ccomp:\n                ccomp.remove('-Aa')\n            # add flags for (almost) sane C++ handling\n            ccomp += ['-AA']\n            self.compiler_so = ccomp\n        # ensure OPT environment variable is read\n        if 'OPT' in os.environ:\n            # XXX who uses this?\n            from sysconfig import get_config_vars\n            opt = shlex.join(shlex.split(os.environ['OPT']))\n            gcv_opt = shlex.join(shlex.split(get_config_vars('OPT')[0]))\n            ccomp_s = shlex.join(self.compiler_so)\n            if opt not in ccomp_s:\n                ccomp_s = ccomp_s.replace(gcv_opt, opt)\n                self.compiler_so = shlex.split(ccomp_s)\n            llink_s = shlex.join(self.linker_so)\n            if opt not in llink_s:\n                self.linker_so = self.linker_so + shlex.split(opt)\n    \n        display = '%s: %s' % (os.path.basename(self.compiler_so[0]), src)\n    \n        # gcc style automatic dependencies, outputs a makefile (-MF) that lists\n        # all headers needed by a c file as a side effect of compilation (-MMD)\n        if getattr(self, '_auto_depends', False):\n            deps = ['-MMD', '-MF', obj + '.d']\n        else:\n            deps = []\n    \n        try:\n            self.spawn(self.compiler_so + cc_args + [src, '-o', obj] + deps +\n                       extra_postargs, display = display)\n        except DistutilsExecError as e:\n            msg = str(e)\n>           raise CompileError(msg) from None\nE           distutils.errors.CompileError: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp6_18da03.cpp -o /tmp/tmpte1v6fp3/tmp/tmp6_18da03.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/unixccompiler.py:58: CompileError\n\nDuring handling of the above exception, another exception occurred:\n\nmodule_name = 'test_combiner_on_empty_list', cxxfile = '/tmp/tmp6_18da03.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpa9vbnydm'\nbuildtmp = '/tmp/tmpte1v6fp3'\nextension = <pythran.dist.PythranExtension('test_combiner_on_empty_list') at 0x7f288a290c10>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n>           setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n\npythran/toolchain.py:348: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/dist-packages/numpy/distutils/core.py:169: in setup\n    return old_setup(**new_attr)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...xtension('test_combiner_on_empty_list') at 0x7f288a290c10>], 'headers': [], 'name': 'test_combiner_on_empty_list', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f288a290fd0>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n                dist.run_commands()\n            except KeyboardInterrupt:\n                raise SystemExit(\"interrupted\")\n            except OSError as exc:\n                if DEBUG:\n                    sys.stderr.write(\"error: %s\\n\" % (exc,))\n                    raise\n                else:\n                    raise SystemExit(\"error: %s\" % (exc,))\n    \n            except (DistutilsError,\n                    CCompilerError) as msg:\n                if DEBUG:\n                    raise\n                else:\n>                   raise SystemExit(\"error: \" + str(msg))\nE                   SystemExit: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp6_18da03.cpp -o /tmp/tmpte1v6fp3/tmp/tmp6_18da03.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/lib/python3.10/distutils/core.py:163: SystemExit\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pythran.tests.test_advanced.TestAdvanced testMethod=test_combiner_on_empty_list>\n\n        def test_combiner_on_empty_list(self):\n            code = '''\n    def b(l):\n        l+=[1]\n        return l\n    def combiner_on_empty_list():\n        return b(list()) + b([])'''\n>           self.run_test(code, combiner_on_empty_list=[])\n\npythran/tests/test_advanced.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npythran/tests/__init__.py:313: in run_test\n    cxx_compiled = compile_pythrancode(\npythran/toolchain.py:466: in compile_pythrancode\n    output_file = compile_cxxcode(module_name,\npythran/toolchain.py:403: in compile_cxxcode\n    output_binary = compile_cxxfile(module_name, fdpath,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodule_name = 'test_combiner_on_empty_list', cxxfile = '/tmp/tmp6_18da03.cpp'\noutput_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpa9vbnydm'\nbuildtmp = '/tmp/tmpte1v6fp3'\nextension = <pythran.dist.PythranExtension('test_combiner_on_empty_list') at 0x7f288a290c10>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n            setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n        except SystemExit as e:\n>           raise PythranCompileError(str(e))\nE           pythran.errors.PythranCompileError: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmp6_18da03.cpp -o /tmp/tmpte1v6fp3/tmp/tmp6_18da03.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\npythran/toolchain.py:361: PythranCompileError\n----------------------------- Captured stdout call -----------------------------\nrunning build_ext\nDEBUG: new_compiler returns <class 'distutils.unixccompiler.UnixCCompiler'>\nbuilding 'test_combiner_on_empty_list' extension\nINFO: C compiler: x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC\n\ncreating /tmp/tmpte1v6fp3/tmp\nINFO: compile options: '-DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c'\nextra options: '-O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE'\nINFO: x86_64-linux-gnu-gcc: /tmp/tmp6_18da03.cpp\n----------------------------- Captured stderr call -----------------------------\nIn file included from /tmp/tmp6_18da03.cpp:1:\n/app/repo_to_process/pythran/pythonic/core.hpp:33:10: fatal error: pyconfig.h: No such file or directory\n   33 | #include \"pyconfig.h\"\n      |          ^~~~~~~~~~~~\ncompilation terminated.\nWARNING: Compilation error, trying hard to find its origin...\nWARNING: Nope, I'm going to flood you with C++ errors!\n------------------------------ Captured log call -------------------------------\nWARNING  pythran:toolchain.py:471 Compilation error, trying hard to find its origin...\nWARNING  pythran:toolchain.py:474 Nope, I'm going to flood you with C++ errors!\n_____________________ TestAdvanced.test_conflicting_names ______________________\n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...'ext_modules': [<pythran.dist.PythranExtension('test_map') at 0x7f2889f311b0>], 'headers': [], 'name': 'test_map', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f2889f31150>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n>               dist.run_commands()\n\n/usr/lib/python3.10/distutils/core.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/distutils/dist.py:966: in run_commands\n    self.run_command(cmd)\n/usr/lib/python3.10/distutils/dist.py:985: in run_command\n    cmd_obj.run()\n/usr/lib/python3.10/distutils/command/build_ext.py:340: in run\n    self.build_extensions()\n/usr/lib/python3.10/distutils/command/build_ext.py:449: in build_extensions\n    self._build_extensions_serial()\n/usr/lib/python3.10/distutils/command/build_ext.py:474: in _build_extensions_serial\n    self.build_extension(ext)\npythran/dist.py:121: in build_extension\n    return super(PythranBuildExtMixIn, self).build_extension(ext)\n/usr/lib/python3.10/distutils/command/build_ext.py:529: in build_extension\n    objects = self.compiler.compile(sources,\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:369: in CCompiler_compile\n    single_compile(o)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:328: in single_compile\n    self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/ccompiler.py:91: in <lambda>\n    m = lambda self, *args, **kw: func(self, *args, **kw)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <distutils.unixccompiler.UnixCCompiler object at 0x7f2889f31630>\nobj = '/tmp/tmp9d9ywg_g/tmp/tmpofwvgpuo.o', src = '/tmp/tmpofwvgpuo.cpp'\next = '.cpp'\ncc_args = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10', '-c']\nextra_postargs = ['-O2', '-std=c++11', '-fno-math-errno', '-fvisibility=hidden', '-fno-wrapv', '-Wno-unused-function', ...]\npp_opts = ['-DENABLE_PYTHON_MODULE', '-DPYTHRAN_BLAS_NONE', '-I/app/repo_to_process/pythran', '-I/usr/local/lib/python3.10/dist-packages/numpy/_core/include', '-I/usr/include/python3.10']\n\n    def UnixCCompiler__compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compile a single source files with a Unix-style compiler.\"\"\"\n        # HP ad-hoc fix, see ticket 1383\n        ccomp = self.compiler_so\n        if ccomp[0] == 'aCC':\n            # remove flags that will trigger ANSI-C mode for aCC\n            if '-Ae' in ccomp:\n                ccomp.remove('-Ae')\n            if '-Aa' in ccomp:\n                ccomp.remove('-Aa')\n            # add flags for (almost) sane C++ handling\n            ccomp += ['-AA']\n            self.compiler_so = ccomp\n        # ensure OPT environment variable is read\n        if 'OPT' in os.environ:\n            # XXX who uses this?\n            from sysconfig import get_config_vars\n            opt = shlex.join(shlex.split(os.environ['OPT']))\n            gcv_opt = shlex.join(shlex.split(get_config_vars('OPT')[0]))\n            ccomp_s = shlex.join(self.compiler_so)\n            if opt not in ccomp_s:\n                ccomp_s = ccomp_s.replace(gcv_opt, opt)\n                self.compiler_so = shlex.split(ccomp_s)\n            llink_s = shlex.join(self.linker_so)\n            if opt not in llink_s:\n                self.linker_so = self.linker_so + shlex.split(opt)\n    \n        display = '%s: %s' % (os.path.basename(self.compiler_so[0]), src)\n    \n        # gcc style automatic dependencies, outputs a makefile (-MF) that lists\n        # all headers needed by a c file as a side effect of compilation (-MMD)\n        if getattr(self, '_auto_depends', False):\n            deps = ['-MMD', '-MF', obj + '.d']\n        else:\n            deps = []\n    \n        try:\n            self.spawn(self.compiler_so + cc_args + [src, '-o', obj] + deps +\n                       extra_postargs, display = display)\n        except DistutilsExecError as e:\n            msg = str(e)\n>           raise CompileError(msg) from None\nE           distutils.errors.CompileError: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmpofwvgpuo.cpp -o /tmp/tmp9d9ywg_g/tmp/tmpofwvgpuo.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/local/lib/python3.10/dist-packages/numpy/distutils/unixccompiler.py:58: CompileError\n\nDuring handling of the above exception, another exception occurred:\n\nmodule_name = 'test_map', cxxfile = '/tmp/tmpofwvgpuo.cpp', output_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpd9eo2fp4'\nbuildtmp = '/tmp/tmp9d9ywg_g'\nextension = <pythran.dist.PythranExtension('test_map') at 0x7f2889f311b0>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n>           setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n\npythran/toolchain.py:348: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.10/dist-packages/numpy/distutils/core.py:169: in setup\n    return old_setup(**new_attr)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nattrs = {'cmdclass': {'bdist_rpm': <class 'numpy.distutils.command.bdist_rpm.bdist_rpm'>, 'build': <class 'numpy.distutils.com...'ext_modules': [<pythran.dist.PythranExtension('test_map') at 0x7f2889f311b0>], 'headers': [], 'name': 'test_map', ...}\nklass = <class 'numpy.distutils.numpy_distribution.NumpyDistribution'>\ndist = <numpy.distutils.numpy_distribution.NumpyDistribution object at 0x7f2889f31150>\nok = True\n\n    def setup (**attrs):\n        \"\"\"The gateway to the Distutils: do everything your setup script needs\n        to do, in a highly flexible and user-driven way.  Briefly: create a\n        Distribution instance; find and parse config files; parse the command\n        line; run each Distutils command found there, customized by the options\n        supplied to 'setup()' (as keyword arguments), in config files, and on\n        the command line.\n    \n        The Distribution instance might be an instance of a class supplied via\n        the 'distclass' keyword argument to 'setup'; if no such class is\n        supplied, then the Distribution class (in dist.py) is instantiated.\n        All other arguments to 'setup' (except for 'cmdclass') are used to set\n        attributes of the Distribution instance.\n    \n        The 'cmdclass' argument, if supplied, is a dictionary mapping command\n        names to command classes.  Each command encountered on the command line\n        will be turned into a command class, which is in turn instantiated; any\n        class found in 'cmdclass' is used in place of the default, which is\n        (for command 'foo_bar') class 'foo_bar' in module\n        'distutils.command.foo_bar'.  The command class must provide a\n        'user_options' attribute which is a list of option specifiers for\n        'distutils.fancy_getopt'.  Any command-line options between the current\n        and the next command are used to set attributes of the current command\n        object.\n    \n        When the entire command-line has been successfully parsed, calls the\n        'run()' method on each command object in turn.  This method will be\n        driven entirely by the Distribution object (which each command object\n        has a reference to, thanks to its constructor), and the\n        command-specific options that became attributes of each command\n        object.\n        \"\"\"\n    \n        global _setup_stop_after, _setup_distribution\n    \n        # Determine the distribution class -- either caller-supplied or\n        # our Distribution (see below).\n        klass = attrs.get('distclass')\n        if klass:\n            del attrs['distclass']\n        else:\n            klass = Distribution\n    \n        if 'script_name' not in attrs:\n            attrs['script_name'] = os.path.basename(sys.argv[0])\n        if 'script_args'  not in attrs:\n            attrs['script_args'] = sys.argv[1:]\n    \n        # Create the Distribution instance, using the remaining arguments\n        # (ie. everything except distclass) to initialize it\n        try:\n            _setup_distribution = dist = klass(attrs)\n        except DistutilsSetupError as msg:\n            if 'name' not in attrs:\n                raise SystemExit(\"error in setup command: %s\" % msg)\n            else:\n                raise SystemExit(\"error in %s setup command: %s\" % \\\n                      (attrs['name'], msg))\n    \n        if _setup_stop_after == \"init\":\n            return dist\n    \n        # Find and parse the config file(s): they will override options from\n        # the setup script, but be overridden by the command line.\n        dist.parse_config_files()\n    \n        if DEBUG:\n            print(\"options (after parsing config files):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"config\":\n            return dist\n    \n        # Parse the command line and override config files; any\n        # command-line errors are the end user's fault, so turn them into\n        # SystemExit to suppress tracebacks.\n        try:\n            ok = dist.parse_command_line()\n        except DistutilsArgError as msg:\n            raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n    \n        if DEBUG:\n            print(\"options (after parsing command line):\")\n            dist.dump_option_dicts()\n    \n        if _setup_stop_after == \"commandline\":\n            return dist\n    \n        # And finally, run all the commands found on the command line.\n        if ok:\n            try:\n                dist.run_commands()\n            except KeyboardInterrupt:\n                raise SystemExit(\"interrupted\")\n            except OSError as exc:\n                if DEBUG:\n                    sys.stderr.write(\"error: %s\\n\" % (exc,))\n                    raise\n                else:\n                    raise SystemExit(\"error: %s\" % (exc,))\n    \n            except (DistutilsError,\n                    CCompilerError) as msg:\n                if DEBUG:\n                    raise\n                else:\n>                   raise SystemExit(\"error: \" + str(msg))\nE                   SystemExit: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmpofwvgpuo.cpp -o /tmp/tmp9d9ywg_g/tmp/tmpofwvgpuo.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\n/usr/lib/python3.10/distutils/core.py:163: SystemExit\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pythran.tests.test_advanced.TestAdvanced testMethod=test_conflicting_names>\n\n    def test_conflicting_names(self):\n>       self.run_test('def map(): return 5', map=[])\n\npythran/tests/test_advanced.py:151: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npythran/tests/__init__.py:313: in run_test\n    cxx_compiled = compile_pythrancode(\npythran/toolchain.py:466: in compile_pythrancode\n    output_file = compile_cxxcode(module_name,\npythran/toolchain.py:403: in compile_cxxcode\n    output_binary = compile_cxxfile(module_name, fdpath,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodule_name = 'test_map', cxxfile = '/tmp/tmpofwvgpuo.cpp', output_binary = None\nkwargs = {'extra_compile_args': ['-O0', '-UNDEBUG', '-U_FORTIFY_SOURCE']}\nPythranExtension = <class 'pythran.dist.PythranExtension'>\nPythranBuildExt = <class 'pythran.dist.PythranBuildExt'>\nsetup = <function setup at 0x7f289027b370>, builddir = '/tmp/tmpd9eo2fp4'\nbuildtmp = '/tmp/tmp9d9ywg_g'\nextension = <pythran.dist.PythranExtension('test_map') at 0x7f2889f311b0>\n\n    def compile_cxxfile(module_name, cxxfile, output_binary=None, **kwargs):\n        '''c++ file -> native module\n        Return the filename of the produced shared library\n        Raises PythranCompileError on failure\n    \n        '''\n        # local import so that we don't depend on setuptools for the code generation\n        # part\n        from pythran.dist import PythranExtension, PythranBuildExt\n        try:\n            # `numpy.distutils is deprecated, may not be present, or broken\n            from numpy.distutils.core import setup\n        except Exception:\n            from setuptools import setup\n    \n        builddir = mkdtemp()\n        buildtmp = mkdtemp()\n    \n        extension = PythranExtension(module_name,\n                                     [cxxfile],\n                                     **kwargs)\n    \n        try:\n            setup(name=module_name,\n                  ext_modules=[extension],\n                  cmdclass={\"build_ext\": PythranBuildExt},\n                  # fake CLI call\n                  script_name='setup.py',\n                  script_args=['--verbose'\n                               if logger.isEnabledFor(logging.INFO)\n                               else '--quiet',\n                               'build_ext',\n                               '--build-lib', builddir,\n                               '--build-temp', buildtmp]\n                  )\n        except SystemExit as e:\n>           raise PythranCompileError(str(e))\nE           pythran.errors.PythranCompileError: error: Command \"x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c /tmp/tmpofwvgpuo.cpp -o /tmp/tmp9d9ywg_g/tmp/tmpofwvgpuo.o -O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE\" failed with exit status 1\n\npythran/toolchain.py:361: PythranCompileError\n----------------------------- Captured stdout call -----------------------------\nrunning build_ext\nDEBUG: new_compiler returns <class 'distutils.unixccompiler.UnixCCompiler'>\nbuilding 'test_map' extension\nINFO: C compiler: x86_64-linux-gnu-gcc -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC\n\ncreating /tmp/tmp9d9ywg_g/tmp\nINFO: compile options: '-DENABLE_PYTHON_MODULE -DPYTHRAN_BLAS_NONE -I/app/repo_to_process/pythran -I/usr/local/lib/python3.10/dist-packages/numpy/_core/include -I/usr/include/python3.10 -c'\nextra options: '-O2 -std=c++11 -fno-math-errno -fvisibility=hidden -fno-wrapv -Wno-unused-function -Wno-int-in-bool-context -Wno-unknown-warning-option -O0 -UNDEBUG -U_FORTIFY_SOURCE'\nINFO: x86_64-linux-gnu-gcc: /tmp/tmpofwvgpuo.cpp\n----------------------------- Captured stderr call -----------------------------\nIn file included from /tmp/tmpofwvgpuo.cpp:1:\n/app/repo_to_process/pythran/pythonic/core.hpp:33:10: fatal error: pyconfig.h: No such file or directory\n   33 | #include \"pyconfig.h\"\n      |          ^~~~~~~~~~~~\ncompilation terminated.\nWARNING: Compilation error, trying hard to find its origin...\nWARNING: Nope, I'm going to flood you with C++ errors!\n------------------------------ Captured log call -------------------------------\nWARNING  pythran:toolchain.py:471 Compilation error, trying hard to find its origin...\nWARNING  pythran:toolchain.py:474 Nope, I'm going to flood you with C++ errors!\n=========================== short test summary info ============================\nFAILED pythran/tests/test_advanced.py::TestAdvanced::test_add_arrays - pythra...\nFAILED pythran/tests/test_advanced.py::TestAdvanced::test_annotations - pythr...\nFAILED pythran/tests/test_advanced.py::TestAdvanced::test_array_to_tuple - py...\nFAILED pythran/tests/test_advanced.py::TestAdvanced::test_assign_in_except - ...\nFAILED pythran/tests/test_advanced.py::TestAdvanced::test_augassign_floordiv\nFAILED pythran/tests/test_advanced.py::TestAdvanced::test_bool_op_casting - p...\nFAILED pythran/tests/test_advanced.py::TestAdvanced::test_builtin_constructors\nFAILED pythran/tests/test_advanced.py::TestAdvanced::test_builtin_slices - py...\nFAILED pythran/tests/test_advanced.py::TestAdvanced::test_combiner_on_empty_list\nFAILED pythran/tests/test_advanced.py::TestAdvanced::test_conflicting_names\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 10 failures !!!!!!!!!!!!!!!!!!!!!!!!!!\n================== 10 failed, 1 warning in 960.19s (0:16:00) ===================\n",
    "stderr": "",
    "execution_time": 962.7657194137573
  }
]