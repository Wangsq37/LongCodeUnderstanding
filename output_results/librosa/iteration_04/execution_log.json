[
  {
    "command": "pytest --maxfail=10 --disable-warnings",
    "success": false,
    "stdout": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.4.1, pluggy-1.6.0\nMatplotlib: 3.10.5\nFreetype: 2.6.1\nrootdir: /app/repo_to_process\nconfigfile: setup.cfg\nplugins: cov-6.2.1, mpl-0.17.0\ncollected 14200 items\n\ntests/test_beat.py s.................................................... [  0%]\n........................................................................ [  0%]\n....x.........EEEEEEEEEE\n--- Writing function-level test call chains report to report_functions.jsonl ---\nSuccessfully wrote 139 records to report_functions.jsonl\n\n--- Writing aggregated file-level test call chains report to report_files.jsonl ---\nSuccessfully wrote 1 records to report_files.jsonl\n\n--- End of Reports ---\n\n\n==================================== ERRORS ====================================\n___ ERROR at setup of test_beat[22050-None-100.0-None-60-False-False-False] ____\n\npath = 'tests/data/test1_22050.wav'\n\n    def load(\n        path: Union[\n            str, int, os.PathLike[Any], sf.SoundFile, audioread.AudioFile, BinaryIO\n        ],\n        *,\n        sr: Optional[float] = 22050,\n        mono: bool = True,\n        offset: float = 0.0,\n        duration: Optional[float] = None,\n        dtype: DTypeLike = np.float32,\n        res_type: str = \"soxr_hq\",\n    ) -> Tuple[np.ndarray, Union[int, float]]:\n        \"\"\"Load an audio file as a floating point time series.\n    \n        Audio will be automatically resampled to the given rate\n        (default ``sr=22050``).\n    \n        To preserve the native sampling rate of the file, use ``sr=None``.\n    \n        Parameters\n        ----------\n        path : string, int, pathlib.Path, soundfile.SoundFile, audioread object, or file-like object\n            path to the input file.\n    \n            Any codec supported by `soundfile` or `audioread` will work.\n    \n            Any string file paths, or any object implementing Python's\n            file interface (e.g. `pathlib.Path`) are supported as `path`.\n    \n            If the codec is supported by `soundfile`, then `path` can also be\n            an open file descriptor (int) or an existing `soundfile.SoundFile` object.\n    \n            Pre-constructed audioread decoders are also supported here, see the example\n            below.  This can be used, for example, to force a specific decoder rather\n            than relying upon audioread to select one for you.\n    \n            .. warning:: audioread support is deprecated as of version 0.10.0.\n                audioread support be removed in version 1.0.\n    \n        sr : number > 0 [scalar]\n            target sampling rate\n    \n            'None' uses the native sampling rate\n    \n        mono : bool\n            convert signal to mono\n    \n        offset : float\n            start reading after this time (in seconds)\n    \n        duration : float\n            only load up to this much audio (in seconds)\n    \n        dtype : numeric type\n            data type of ``y``\n    \n        res_type : str\n            resample type (see note)\n    \n            .. note::\n                By default, this uses `soxr`'s high-quality mode ('HQ').\n    \n                For alternative resampling modes, see `resample`\n    \n            .. note::\n               `audioread` may truncate the precision of the audio data to 16 bits.\n    \n               See :ref:`ioformats` for alternate loading methods.\n    \n        Returns\n        -------\n        y : np.ndarray [shape=(n,) or (..., n)]\n            audio time series. Multi-channel is supported.\n        sr : number > 0 [scalar]\n            sampling rate of ``y``\n    \n        Examples\n        --------\n        >>> # Load an ogg vorbis file\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename)\n        >>> y\n        array([-1.407e-03, -4.461e-04, ..., -3.042e-05,  1.277e-05],\n              dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load a file and resample to 11 KHz\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename, sr=11025)\n        >>> y\n        array([-8.746e-04, -3.363e-04, ..., -1.301e-05,  0.000e+00],\n              dtype=float32)\n        >>> sr\n        11025\n    \n        >>> # Load 5 seconds of a file, starting 15 seconds in\n        >>> filename = librosa.ex('brahms')\n        >>> y, sr = librosa.load(filename, offset=15.0, duration=5.0)\n        >>> y\n        array([0.146, 0.144, ..., 0.128, 0.015], dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load using an already open SoundFile object\n        >>> import soundfile\n        >>> sfo = soundfile.SoundFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(sfo)\n    \n        >>> # Load using an already open audioread object\n        >>> import audioread.ffdec  # Use ffmpeg decoder\n        >>> aro = audioread.ffdec.FFmpegAudioFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(aro)\n        \"\"\"\n        if isinstance(path, tuple(audioread.available_backends())):\n            # Force the audioread loader if we have a reader object already\n            y, sr_native = __audioread_load(path, offset, duration, dtype)\n        else:\n            # Otherwise try soundfile first, and then fall back if necessary\n            try:\n>               y, sr_native = __soundfile_load(path, offset, duration, dtype)\n\nlibrosa/core/audio.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:209: in __soundfile_load\n    context = sf.SoundFile(path)\n/usr/local/lib/python3.10/dist-packages/soundfile.py:690: in __init__\n    self._file = self._open(file, mode_int, closefd)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = SoundFile('tests/data/test1_22050.wav', mode='r', samplerate=0, channels=0, format='FILE', subtype='FILE', endian='FILE')\nfile = b'tests/data/test1_22050.wav', mode_int = 16, closefd = True\n\n    def _open(self, file, mode_int, closefd):\n        \"\"\"Call the appropriate sf_open*() function from libsndfile.\"\"\"\n        if isinstance(file, (_unicode, bytes)):\n            if _os.path.isfile(file):\n                if 'x' in self.mode:\n                    raise OSError(\"File exists: {0!r}\".format(self.name))\n                elif set(self.mode).issuperset('w+'):\n                    # truncate the file, because SFM_RDWR doesn't:\n                    _os.close(_os.open(file, _os.O_WRONLY | _os.O_TRUNC))\n            openfunction = _snd.sf_open\n            if isinstance(file, _unicode):\n                if _sys.platform == 'win32':\n                    openfunction = _snd.sf_wchar_open\n                else:\n                    file = file.encode(_sys.getfilesystemencoding())\n            file_ptr = openfunction(file, mode_int, self._info)\n        elif isinstance(file, int):\n            file_ptr = _snd.sf_open_fd(file, mode_int, self._info, closefd)\n        elif _has_virtual_io_attrs(file, mode_int):\n            file_ptr = _snd.sf_open_virtual(self._init_virtual_io(file),\n                                            mode_int, self._info, _ffi.NULL)\n        else:\n            raise TypeError(\"Invalid file: {0!r}\".format(self.name))\n        if file_ptr == _ffi.NULL:\n            # get the actual error code\n            err = _snd.sf_error(file_ptr)\n>           raise LibsndfileError(err, prefix=\"Error opening {0!r}: \".format(self.name))\nE           soundfile.LibsndfileError: Error opening 'tests/data/test1_22050.wav': System error.\n\n/usr/local/lib/python3.10/dist-packages/soundfile.py:1265: LibsndfileError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'ysr' for <Function test_beat[22050-None-100.0-None-60-False-False-False]>>\n\n    @pytest.fixture(scope=\"module\", params=[22050, 44100])\n    def ysr(request):\n>       return librosa.load(__EXAMPLE_FILE, sr=request.param)\n\ntests/test_beat.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:184: in load\n    y, sr_native = __audioread_load(path, offset, duration, dtype)\n/usr/local/lib/python3.10/dist-packages/decorator.py:235: in fun\n    return caller(func, *(extras + args), **kw)\nlibrosa/util/decorators.py:63: in __wrapper\n    return func(*args, **kwargs)\nlibrosa/core/audio.py:240: in __audioread_load\n    reader = audioread.audio_open(path)\n/usr/local/lib/python3.10/dist-packages/audioread/__init__.py:127: in audio_open\n    return BackendClass(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <audioread.rawread.RawAudioFile object at 0x7f4904833760>\nfilename = 'tests/data/test1_22050.wav'\n\n    def __init__(self, filename):\n>       self._fh = open(filename, 'rb')\nE       FileNotFoundError: [Errno 2] No such file or directory: 'tests/data/test1_22050.wav'\n\n/usr/local/lib/python3.10/dist-packages/audioread/rawread.py:59: FileNotFoundError\n____ ERROR at setup of test_beat[22050-None-100.0-None-60-False-False-True] ____\n\npath = 'tests/data/test1_22050.wav'\n\n    def load(\n        path: Union[\n            str, int, os.PathLike[Any], sf.SoundFile, audioread.AudioFile, BinaryIO\n        ],\n        *,\n        sr: Optional[float] = 22050,\n        mono: bool = True,\n        offset: float = 0.0,\n        duration: Optional[float] = None,\n        dtype: DTypeLike = np.float32,\n        res_type: str = \"soxr_hq\",\n    ) -> Tuple[np.ndarray, Union[int, float]]:\n        \"\"\"Load an audio file as a floating point time series.\n    \n        Audio will be automatically resampled to the given rate\n        (default ``sr=22050``).\n    \n        To preserve the native sampling rate of the file, use ``sr=None``.\n    \n        Parameters\n        ----------\n        path : string, int, pathlib.Path, soundfile.SoundFile, audioread object, or file-like object\n            path to the input file.\n    \n            Any codec supported by `soundfile` or `audioread` will work.\n    \n            Any string file paths, or any object implementing Python's\n            file interface (e.g. `pathlib.Path`) are supported as `path`.\n    \n            If the codec is supported by `soundfile`, then `path` can also be\n            an open file descriptor (int) or an existing `soundfile.SoundFile` object.\n    \n            Pre-constructed audioread decoders are also supported here, see the example\n            below.  This can be used, for example, to force a specific decoder rather\n            than relying upon audioread to select one for you.\n    \n            .. warning:: audioread support is deprecated as of version 0.10.0.\n                audioread support be removed in version 1.0.\n    \n        sr : number > 0 [scalar]\n            target sampling rate\n    \n            'None' uses the native sampling rate\n    \n        mono : bool\n            convert signal to mono\n    \n        offset : float\n            start reading after this time (in seconds)\n    \n        duration : float\n            only load up to this much audio (in seconds)\n    \n        dtype : numeric type\n            data type of ``y``\n    \n        res_type : str\n            resample type (see note)\n    \n            .. note::\n                By default, this uses `soxr`'s high-quality mode ('HQ').\n    \n                For alternative resampling modes, see `resample`\n    \n            .. note::\n               `audioread` may truncate the precision of the audio data to 16 bits.\n    \n               See :ref:`ioformats` for alternate loading methods.\n    \n        Returns\n        -------\n        y : np.ndarray [shape=(n,) or (..., n)]\n            audio time series. Multi-channel is supported.\n        sr : number > 0 [scalar]\n            sampling rate of ``y``\n    \n        Examples\n        --------\n        >>> # Load an ogg vorbis file\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename)\n        >>> y\n        array([-1.407e-03, -4.461e-04, ..., -3.042e-05,  1.277e-05],\n              dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load a file and resample to 11 KHz\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename, sr=11025)\n        >>> y\n        array([-8.746e-04, -3.363e-04, ..., -1.301e-05,  0.000e+00],\n              dtype=float32)\n        >>> sr\n        11025\n    \n        >>> # Load 5 seconds of a file, starting 15 seconds in\n        >>> filename = librosa.ex('brahms')\n        >>> y, sr = librosa.load(filename, offset=15.0, duration=5.0)\n        >>> y\n        array([0.146, 0.144, ..., 0.128, 0.015], dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load using an already open SoundFile object\n        >>> import soundfile\n        >>> sfo = soundfile.SoundFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(sfo)\n    \n        >>> # Load using an already open audioread object\n        >>> import audioread.ffdec  # Use ffmpeg decoder\n        >>> aro = audioread.ffdec.FFmpegAudioFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(aro)\n        \"\"\"\n        if isinstance(path, tuple(audioread.available_backends())):\n            # Force the audioread loader if we have a reader object already\n            y, sr_native = __audioread_load(path, offset, duration, dtype)\n        else:\n            # Otherwise try soundfile first, and then fall back if necessary\n            try:\n>               y, sr_native = __soundfile_load(path, offset, duration, dtype)\n\nlibrosa/core/audio.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:209: in __soundfile_load\n    context = sf.SoundFile(path)\n/usr/local/lib/python3.10/dist-packages/soundfile.py:690: in __init__\n    self._file = self._open(file, mode_int, closefd)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = SoundFile('tests/data/test1_22050.wav', mode='r', samplerate=0, channels=0, format='FILE', subtype='FILE', endian='FILE')\nfile = b'tests/data/test1_22050.wav', mode_int = 16, closefd = True\n\n    def _open(self, file, mode_int, closefd):\n        \"\"\"Call the appropriate sf_open*() function from libsndfile.\"\"\"\n        if isinstance(file, (_unicode, bytes)):\n            if _os.path.isfile(file):\n                if 'x' in self.mode:\n                    raise OSError(\"File exists: {0!r}\".format(self.name))\n                elif set(self.mode).issuperset('w+'):\n                    # truncate the file, because SFM_RDWR doesn't:\n                    _os.close(_os.open(file, _os.O_WRONLY | _os.O_TRUNC))\n            openfunction = _snd.sf_open\n            if isinstance(file, _unicode):\n                if _sys.platform == 'win32':\n                    openfunction = _snd.sf_wchar_open\n                else:\n                    file = file.encode(_sys.getfilesystemencoding())\n            file_ptr = openfunction(file, mode_int, self._info)\n        elif isinstance(file, int):\n            file_ptr = _snd.sf_open_fd(file, mode_int, self._info, closefd)\n        elif _has_virtual_io_attrs(file, mode_int):\n            file_ptr = _snd.sf_open_virtual(self._init_virtual_io(file),\n                                            mode_int, self._info, _ffi.NULL)\n        else:\n            raise TypeError(\"Invalid file: {0!r}\".format(self.name))\n        if file_ptr == _ffi.NULL:\n            # get the actual error code\n            err = _snd.sf_error(file_ptr)\n>           raise LibsndfileError(err, prefix=\"Error opening {0!r}: \".format(self.name))\nE           soundfile.LibsndfileError: Error opening 'tests/data/test1_22050.wav': System error.\n\n/usr/local/lib/python3.10/dist-packages/soundfile.py:1265: LibsndfileError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'ysr' for <Function test_beat[22050-None-100.0-None-60-False-False-False]>>\n\n    @pytest.fixture(scope=\"module\", params=[22050, 44100])\n    def ysr(request):\n>       return librosa.load(__EXAMPLE_FILE, sr=request.param)\n\ntests/test_beat.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:184: in load\n    y, sr_native = __audioread_load(path, offset, duration, dtype)\n/usr/local/lib/python3.10/dist-packages/decorator.py:235: in fun\n    return caller(func, *(extras + args), **kw)\nlibrosa/util/decorators.py:63: in __wrapper\n    return func(*args, **kwargs)\nlibrosa/core/audio.py:240: in __audioread_load\n    reader = audioread.audio_open(path)\n/usr/local/lib/python3.10/dist-packages/audioread/__init__.py:127: in audio_open\n    return BackendClass(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <audioread.rawread.RawAudioFile object at 0x7f4904833760>\nfilename = 'tests/data/test1_22050.wav'\n\n    def __init__(self, filename):\n>       self._fh = open(filename, 'rb')\nE       FileNotFoundError: [Errno 2] No such file or directory: 'tests/data/test1_22050.wav'\n\n/usr/local/lib/python3.10/dist-packages/audioread/rawread.py:59: FileNotFoundError\n____ ERROR at setup of test_beat[22050-None-100.0-None-60-False-True-False] ____\n\npath = 'tests/data/test1_22050.wav'\n\n    def load(\n        path: Union[\n            str, int, os.PathLike[Any], sf.SoundFile, audioread.AudioFile, BinaryIO\n        ],\n        *,\n        sr: Optional[float] = 22050,\n        mono: bool = True,\n        offset: float = 0.0,\n        duration: Optional[float] = None,\n        dtype: DTypeLike = np.float32,\n        res_type: str = \"soxr_hq\",\n    ) -> Tuple[np.ndarray, Union[int, float]]:\n        \"\"\"Load an audio file as a floating point time series.\n    \n        Audio will be automatically resampled to the given rate\n        (default ``sr=22050``).\n    \n        To preserve the native sampling rate of the file, use ``sr=None``.\n    \n        Parameters\n        ----------\n        path : string, int, pathlib.Path, soundfile.SoundFile, audioread object, or file-like object\n            path to the input file.\n    \n            Any codec supported by `soundfile` or `audioread` will work.\n    \n            Any string file paths, or any object implementing Python's\n            file interface (e.g. `pathlib.Path`) are supported as `path`.\n    \n            If the codec is supported by `soundfile`, then `path` can also be\n            an open file descriptor (int) or an existing `soundfile.SoundFile` object.\n    \n            Pre-constructed audioread decoders are also supported here, see the example\n            below.  This can be used, for example, to force a specific decoder rather\n            than relying upon audioread to select one for you.\n    \n            .. warning:: audioread support is deprecated as of version 0.10.0.\n                audioread support be removed in version 1.0.\n    \n        sr : number > 0 [scalar]\n            target sampling rate\n    \n            'None' uses the native sampling rate\n    \n        mono : bool\n            convert signal to mono\n    \n        offset : float\n            start reading after this time (in seconds)\n    \n        duration : float\n            only load up to this much audio (in seconds)\n    \n        dtype : numeric type\n            data type of ``y``\n    \n        res_type : str\n            resample type (see note)\n    \n            .. note::\n                By default, this uses `soxr`'s high-quality mode ('HQ').\n    \n                For alternative resampling modes, see `resample`\n    \n            .. note::\n               `audioread` may truncate the precision of the audio data to 16 bits.\n    \n               See :ref:`ioformats` for alternate loading methods.\n    \n        Returns\n        -------\n        y : np.ndarray [shape=(n,) or (..., n)]\n            audio time series. Multi-channel is supported.\n        sr : number > 0 [scalar]\n            sampling rate of ``y``\n    \n        Examples\n        --------\n        >>> # Load an ogg vorbis file\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename)\n        >>> y\n        array([-1.407e-03, -4.461e-04, ..., -3.042e-05,  1.277e-05],\n              dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load a file and resample to 11 KHz\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename, sr=11025)\n        >>> y\n        array([-8.746e-04, -3.363e-04, ..., -1.301e-05,  0.000e+00],\n              dtype=float32)\n        >>> sr\n        11025\n    \n        >>> # Load 5 seconds of a file, starting 15 seconds in\n        >>> filename = librosa.ex('brahms')\n        >>> y, sr = librosa.load(filename, offset=15.0, duration=5.0)\n        >>> y\n        array([0.146, 0.144, ..., 0.128, 0.015], dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load using an already open SoundFile object\n        >>> import soundfile\n        >>> sfo = soundfile.SoundFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(sfo)\n    \n        >>> # Load using an already open audioread object\n        >>> import audioread.ffdec  # Use ffmpeg decoder\n        >>> aro = audioread.ffdec.FFmpegAudioFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(aro)\n        \"\"\"\n        if isinstance(path, tuple(audioread.available_backends())):\n            # Force the audioread loader if we have a reader object already\n            y, sr_native = __audioread_load(path, offset, duration, dtype)\n        else:\n            # Otherwise try soundfile first, and then fall back if necessary\n            try:\n>               y, sr_native = __soundfile_load(path, offset, duration, dtype)\n\nlibrosa/core/audio.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:209: in __soundfile_load\n    context = sf.SoundFile(path)\n/usr/local/lib/python3.10/dist-packages/soundfile.py:690: in __init__\n    self._file = self._open(file, mode_int, closefd)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = SoundFile('tests/data/test1_22050.wav', mode='r', samplerate=0, channels=0, format='FILE', subtype='FILE', endian='FILE')\nfile = b'tests/data/test1_22050.wav', mode_int = 16, closefd = True\n\n    def _open(self, file, mode_int, closefd):\n        \"\"\"Call the appropriate sf_open*() function from libsndfile.\"\"\"\n        if isinstance(file, (_unicode, bytes)):\n            if _os.path.isfile(file):\n                if 'x' in self.mode:\n                    raise OSError(\"File exists: {0!r}\".format(self.name))\n                elif set(self.mode).issuperset('w+'):\n                    # truncate the file, because SFM_RDWR doesn't:\n                    _os.close(_os.open(file, _os.O_WRONLY | _os.O_TRUNC))\n            openfunction = _snd.sf_open\n            if isinstance(file, _unicode):\n                if _sys.platform == 'win32':\n                    openfunction = _snd.sf_wchar_open\n                else:\n                    file = file.encode(_sys.getfilesystemencoding())\n            file_ptr = openfunction(file, mode_int, self._info)\n        elif isinstance(file, int):\n            file_ptr = _snd.sf_open_fd(file, mode_int, self._info, closefd)\n        elif _has_virtual_io_attrs(file, mode_int):\n            file_ptr = _snd.sf_open_virtual(self._init_virtual_io(file),\n                                            mode_int, self._info, _ffi.NULL)\n        else:\n            raise TypeError(\"Invalid file: {0!r}\".format(self.name))\n        if file_ptr == _ffi.NULL:\n            # get the actual error code\n            err = _snd.sf_error(file_ptr)\n>           raise LibsndfileError(err, prefix=\"Error opening {0!r}: \".format(self.name))\nE           soundfile.LibsndfileError: Error opening 'tests/data/test1_22050.wav': System error.\n\n/usr/local/lib/python3.10/dist-packages/soundfile.py:1265: LibsndfileError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'ysr' for <Function test_beat[22050-None-100.0-None-60-False-False-False]>>\n\n    @pytest.fixture(scope=\"module\", params=[22050, 44100])\n    def ysr(request):\n>       return librosa.load(__EXAMPLE_FILE, sr=request.param)\n\ntests/test_beat.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:184: in load\n    y, sr_native = __audioread_load(path, offset, duration, dtype)\n/usr/local/lib/python3.10/dist-packages/decorator.py:235: in fun\n    return caller(func, *(extras + args), **kw)\nlibrosa/util/decorators.py:63: in __wrapper\n    return func(*args, **kwargs)\nlibrosa/core/audio.py:240: in __audioread_load\n    reader = audioread.audio_open(path)\n/usr/local/lib/python3.10/dist-packages/audioread/__init__.py:127: in audio_open\n    return BackendClass(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <audioread.rawread.RawAudioFile object at 0x7f4904833760>\nfilename = 'tests/data/test1_22050.wav'\n\n    def __init__(self, filename):\n>       self._fh = open(filename, 'rb')\nE       FileNotFoundError: [Errno 2] No such file or directory: 'tests/data/test1_22050.wav'\n\n/usr/local/lib/python3.10/dist-packages/audioread/rawread.py:59: FileNotFoundError\n____ ERROR at setup of test_beat[22050-None-100.0-None-60-False-True-True] _____\n\npath = 'tests/data/test1_22050.wav'\n\n    def load(\n        path: Union[\n            str, int, os.PathLike[Any], sf.SoundFile, audioread.AudioFile, BinaryIO\n        ],\n        *,\n        sr: Optional[float] = 22050,\n        mono: bool = True,\n        offset: float = 0.0,\n        duration: Optional[float] = None,\n        dtype: DTypeLike = np.float32,\n        res_type: str = \"soxr_hq\",\n    ) -> Tuple[np.ndarray, Union[int, float]]:\n        \"\"\"Load an audio file as a floating point time series.\n    \n        Audio will be automatically resampled to the given rate\n        (default ``sr=22050``).\n    \n        To preserve the native sampling rate of the file, use ``sr=None``.\n    \n        Parameters\n        ----------\n        path : string, int, pathlib.Path, soundfile.SoundFile, audioread object, or file-like object\n            path to the input file.\n    \n            Any codec supported by `soundfile` or `audioread` will work.\n    \n            Any string file paths, or any object implementing Python's\n            file interface (e.g. `pathlib.Path`) are supported as `path`.\n    \n            If the codec is supported by `soundfile`, then `path` can also be\n            an open file descriptor (int) or an existing `soundfile.SoundFile` object.\n    \n            Pre-constructed audioread decoders are also supported here, see the example\n            below.  This can be used, for example, to force a specific decoder rather\n            than relying upon audioread to select one for you.\n    \n            .. warning:: audioread support is deprecated as of version 0.10.0.\n                audioread support be removed in version 1.0.\n    \n        sr : number > 0 [scalar]\n            target sampling rate\n    \n            'None' uses the native sampling rate\n    \n        mono : bool\n            convert signal to mono\n    \n        offset : float\n            start reading after this time (in seconds)\n    \n        duration : float\n            only load up to this much audio (in seconds)\n    \n        dtype : numeric type\n            data type of ``y``\n    \n        res_type : str\n            resample type (see note)\n    \n            .. note::\n                By default, this uses `soxr`'s high-quality mode ('HQ').\n    \n                For alternative resampling modes, see `resample`\n    \n            .. note::\n               `audioread` may truncate the precision of the audio data to 16 bits.\n    \n               See :ref:`ioformats` for alternate loading methods.\n    \n        Returns\n        -------\n        y : np.ndarray [shape=(n,) or (..., n)]\n            audio time series. Multi-channel is supported.\n        sr : number > 0 [scalar]\n            sampling rate of ``y``\n    \n        Examples\n        --------\n        >>> # Load an ogg vorbis file\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename)\n        >>> y\n        array([-1.407e-03, -4.461e-04, ..., -3.042e-05,  1.277e-05],\n              dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load a file and resample to 11 KHz\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename, sr=11025)\n        >>> y\n        array([-8.746e-04, -3.363e-04, ..., -1.301e-05,  0.000e+00],\n              dtype=float32)\n        >>> sr\n        11025\n    \n        >>> # Load 5 seconds of a file, starting 15 seconds in\n        >>> filename = librosa.ex('brahms')\n        >>> y, sr = librosa.load(filename, offset=15.0, duration=5.0)\n        >>> y\n        array([0.146, 0.144, ..., 0.128, 0.015], dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load using an already open SoundFile object\n        >>> import soundfile\n        >>> sfo = soundfile.SoundFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(sfo)\n    \n        >>> # Load using an already open audioread object\n        >>> import audioread.ffdec  # Use ffmpeg decoder\n        >>> aro = audioread.ffdec.FFmpegAudioFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(aro)\n        \"\"\"\n        if isinstance(path, tuple(audioread.available_backends())):\n            # Force the audioread loader if we have a reader object already\n            y, sr_native = __audioread_load(path, offset, duration, dtype)\n        else:\n            # Otherwise try soundfile first, and then fall back if necessary\n            try:\n>               y, sr_native = __soundfile_load(path, offset, duration, dtype)\n\nlibrosa/core/audio.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:209: in __soundfile_load\n    context = sf.SoundFile(path)\n/usr/local/lib/python3.10/dist-packages/soundfile.py:690: in __init__\n    self._file = self._open(file, mode_int, closefd)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = SoundFile('tests/data/test1_22050.wav', mode='r', samplerate=0, channels=0, format='FILE', subtype='FILE', endian='FILE')\nfile = b'tests/data/test1_22050.wav', mode_int = 16, closefd = True\n\n    def _open(self, file, mode_int, closefd):\n        \"\"\"Call the appropriate sf_open*() function from libsndfile.\"\"\"\n        if isinstance(file, (_unicode, bytes)):\n            if _os.path.isfile(file):\n                if 'x' in self.mode:\n                    raise OSError(\"File exists: {0!r}\".format(self.name))\n                elif set(self.mode).issuperset('w+'):\n                    # truncate the file, because SFM_RDWR doesn't:\n                    _os.close(_os.open(file, _os.O_WRONLY | _os.O_TRUNC))\n            openfunction = _snd.sf_open\n            if isinstance(file, _unicode):\n                if _sys.platform == 'win32':\n                    openfunction = _snd.sf_wchar_open\n                else:\n                    file = file.encode(_sys.getfilesystemencoding())\n            file_ptr = openfunction(file, mode_int, self._info)\n        elif isinstance(file, int):\n            file_ptr = _snd.sf_open_fd(file, mode_int, self._info, closefd)\n        elif _has_virtual_io_attrs(file, mode_int):\n            file_ptr = _snd.sf_open_virtual(self._init_virtual_io(file),\n                                            mode_int, self._info, _ffi.NULL)\n        else:\n            raise TypeError(\"Invalid file: {0!r}\".format(self.name))\n        if file_ptr == _ffi.NULL:\n            # get the actual error code\n            err = _snd.sf_error(file_ptr)\n>           raise LibsndfileError(err, prefix=\"Error opening {0!r}: \".format(self.name))\nE           soundfile.LibsndfileError: Error opening 'tests/data/test1_22050.wav': System error.\n\n/usr/local/lib/python3.10/dist-packages/soundfile.py:1265: LibsndfileError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'ysr' for <Function test_beat[22050-None-100.0-None-60-False-False-False]>>\n\n    @pytest.fixture(scope=\"module\", params=[22050, 44100])\n    def ysr(request):\n>       return librosa.load(__EXAMPLE_FILE, sr=request.param)\n\ntests/test_beat.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:184: in load\n    y, sr_native = __audioread_load(path, offset, duration, dtype)\n/usr/local/lib/python3.10/dist-packages/decorator.py:235: in fun\n    return caller(func, *(extras + args), **kw)\nlibrosa/util/decorators.py:63: in __wrapper\n    return func(*args, **kwargs)\nlibrosa/core/audio.py:240: in __audioread_load\n    reader = audioread.audio_open(path)\n/usr/local/lib/python3.10/dist-packages/audioread/__init__.py:127: in audio_open\n    return BackendClass(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <audioread.rawread.RawAudioFile object at 0x7f4904833760>\nfilename = 'tests/data/test1_22050.wav'\n\n    def __init__(self, filename):\n>       self._fh = open(filename, 'rb')\nE       FileNotFoundError: [Errno 2] No such file or directory: 'tests/data/test1_22050.wav'\n\n/usr/local/lib/python3.10/dist-packages/audioread/rawread.py:59: FileNotFoundError\n____ ERROR at setup of test_beat[22050-None-100.0-None-60-True-False-False] ____\n\npath = 'tests/data/test1_22050.wav'\n\n    def load(\n        path: Union[\n            str, int, os.PathLike[Any], sf.SoundFile, audioread.AudioFile, BinaryIO\n        ],\n        *,\n        sr: Optional[float] = 22050,\n        mono: bool = True,\n        offset: float = 0.0,\n        duration: Optional[float] = None,\n        dtype: DTypeLike = np.float32,\n        res_type: str = \"soxr_hq\",\n    ) -> Tuple[np.ndarray, Union[int, float]]:\n        \"\"\"Load an audio file as a floating point time series.\n    \n        Audio will be automatically resampled to the given rate\n        (default ``sr=22050``).\n    \n        To preserve the native sampling rate of the file, use ``sr=None``.\n    \n        Parameters\n        ----------\n        path : string, int, pathlib.Path, soundfile.SoundFile, audioread object, or file-like object\n            path to the input file.\n    \n            Any codec supported by `soundfile` or `audioread` will work.\n    \n            Any string file paths, or any object implementing Python's\n            file interface (e.g. `pathlib.Path`) are supported as `path`.\n    \n            If the codec is supported by `soundfile`, then `path` can also be\n            an open file descriptor (int) or an existing `soundfile.SoundFile` object.\n    \n            Pre-constructed audioread decoders are also supported here, see the example\n            below.  This can be used, for example, to force a specific decoder rather\n            than relying upon audioread to select one for you.\n    \n            .. warning:: audioread support is deprecated as of version 0.10.0.\n                audioread support be removed in version 1.0.\n    \n        sr : number > 0 [scalar]\n            target sampling rate\n    \n            'None' uses the native sampling rate\n    \n        mono : bool\n            convert signal to mono\n    \n        offset : float\n            start reading after this time (in seconds)\n    \n        duration : float\n            only load up to this much audio (in seconds)\n    \n        dtype : numeric type\n            data type of ``y``\n    \n        res_type : str\n            resample type (see note)\n    \n            .. note::\n                By default, this uses `soxr`'s high-quality mode ('HQ').\n    \n                For alternative resampling modes, see `resample`\n    \n            .. note::\n               `audioread` may truncate the precision of the audio data to 16 bits.\n    \n               See :ref:`ioformats` for alternate loading methods.\n    \n        Returns\n        -------\n        y : np.ndarray [shape=(n,) or (..., n)]\n            audio time series. Multi-channel is supported.\n        sr : number > 0 [scalar]\n            sampling rate of ``y``\n    \n        Examples\n        --------\n        >>> # Load an ogg vorbis file\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename)\n        >>> y\n        array([-1.407e-03, -4.461e-04, ..., -3.042e-05,  1.277e-05],\n              dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load a file and resample to 11 KHz\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename, sr=11025)\n        >>> y\n        array([-8.746e-04, -3.363e-04, ..., -1.301e-05,  0.000e+00],\n              dtype=float32)\n        >>> sr\n        11025\n    \n        >>> # Load 5 seconds of a file, starting 15 seconds in\n        >>> filename = librosa.ex('brahms')\n        >>> y, sr = librosa.load(filename, offset=15.0, duration=5.0)\n        >>> y\n        array([0.146, 0.144, ..., 0.128, 0.015], dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load using an already open SoundFile object\n        >>> import soundfile\n        >>> sfo = soundfile.SoundFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(sfo)\n    \n        >>> # Load using an already open audioread object\n        >>> import audioread.ffdec  # Use ffmpeg decoder\n        >>> aro = audioread.ffdec.FFmpegAudioFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(aro)\n        \"\"\"\n        if isinstance(path, tuple(audioread.available_backends())):\n            # Force the audioread loader if we have a reader object already\n            y, sr_native = __audioread_load(path, offset, duration, dtype)\n        else:\n            # Otherwise try soundfile first, and then fall back if necessary\n            try:\n>               y, sr_native = __soundfile_load(path, offset, duration, dtype)\n\nlibrosa/core/audio.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:209: in __soundfile_load\n    context = sf.SoundFile(path)\n/usr/local/lib/python3.10/dist-packages/soundfile.py:690: in __init__\n    self._file = self._open(file, mode_int, closefd)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = SoundFile('tests/data/test1_22050.wav', mode='r', samplerate=0, channels=0, format='FILE', subtype='FILE', endian='FILE')\nfile = b'tests/data/test1_22050.wav', mode_int = 16, closefd = True\n\n    def _open(self, file, mode_int, closefd):\n        \"\"\"Call the appropriate sf_open*() function from libsndfile.\"\"\"\n        if isinstance(file, (_unicode, bytes)):\n            if _os.path.isfile(file):\n                if 'x' in self.mode:\n                    raise OSError(\"File exists: {0!r}\".format(self.name))\n                elif set(self.mode).issuperset('w+'):\n                    # truncate the file, because SFM_RDWR doesn't:\n                    _os.close(_os.open(file, _os.O_WRONLY | _os.O_TRUNC))\n            openfunction = _snd.sf_open\n            if isinstance(file, _unicode):\n                if _sys.platform == 'win32':\n                    openfunction = _snd.sf_wchar_open\n                else:\n                    file = file.encode(_sys.getfilesystemencoding())\n            file_ptr = openfunction(file, mode_int, self._info)\n        elif isinstance(file, int):\n            file_ptr = _snd.sf_open_fd(file, mode_int, self._info, closefd)\n        elif _has_virtual_io_attrs(file, mode_int):\n            file_ptr = _snd.sf_open_virtual(self._init_virtual_io(file),\n                                            mode_int, self._info, _ffi.NULL)\n        else:\n            raise TypeError(\"Invalid file: {0!r}\".format(self.name))\n        if file_ptr == _ffi.NULL:\n            # get the actual error code\n            err = _snd.sf_error(file_ptr)\n>           raise LibsndfileError(err, prefix=\"Error opening {0!r}: \".format(self.name))\nE           soundfile.LibsndfileError: Error opening 'tests/data/test1_22050.wav': System error.\n\n/usr/local/lib/python3.10/dist-packages/soundfile.py:1265: LibsndfileError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'ysr' for <Function test_beat[22050-None-100.0-None-60-False-False-False]>>\n\n    @pytest.fixture(scope=\"module\", params=[22050, 44100])\n    def ysr(request):\n>       return librosa.load(__EXAMPLE_FILE, sr=request.param)\n\ntests/test_beat.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:184: in load\n    y, sr_native = __audioread_load(path, offset, duration, dtype)\n/usr/local/lib/python3.10/dist-packages/decorator.py:235: in fun\n    return caller(func, *(extras + args), **kw)\nlibrosa/util/decorators.py:63: in __wrapper\n    return func(*args, **kwargs)\nlibrosa/core/audio.py:240: in __audioread_load\n    reader = audioread.audio_open(path)\n/usr/local/lib/python3.10/dist-packages/audioread/__init__.py:127: in audio_open\n    return BackendClass(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <audioread.rawread.RawAudioFile object at 0x7f4904833760>\nfilename = 'tests/data/test1_22050.wav'\n\n    def __init__(self, filename):\n>       self._fh = open(filename, 'rb')\nE       FileNotFoundError: [Errno 2] No such file or directory: 'tests/data/test1_22050.wav'\n\n/usr/local/lib/python3.10/dist-packages/audioread/rawread.py:59: FileNotFoundError\n____ ERROR at setup of test_beat[22050-None-100.0-None-60-True-False-True] _____\n\npath = 'tests/data/test1_22050.wav'\n\n    def load(\n        path: Union[\n            str, int, os.PathLike[Any], sf.SoundFile, audioread.AudioFile, BinaryIO\n        ],\n        *,\n        sr: Optional[float] = 22050,\n        mono: bool = True,\n        offset: float = 0.0,\n        duration: Optional[float] = None,\n        dtype: DTypeLike = np.float32,\n        res_type: str = \"soxr_hq\",\n    ) -> Tuple[np.ndarray, Union[int, float]]:\n        \"\"\"Load an audio file as a floating point time series.\n    \n        Audio will be automatically resampled to the given rate\n        (default ``sr=22050``).\n    \n        To preserve the native sampling rate of the file, use ``sr=None``.\n    \n        Parameters\n        ----------\n        path : string, int, pathlib.Path, soundfile.SoundFile, audioread object, or file-like object\n            path to the input file.\n    \n            Any codec supported by `soundfile` or `audioread` will work.\n    \n            Any string file paths, or any object implementing Python's\n            file interface (e.g. `pathlib.Path`) are supported as `path`.\n    \n            If the codec is supported by `soundfile`, then `path` can also be\n            an open file descriptor (int) or an existing `soundfile.SoundFile` object.\n    \n            Pre-constructed audioread decoders are also supported here, see the example\n            below.  This can be used, for example, to force a specific decoder rather\n            than relying upon audioread to select one for you.\n    \n            .. warning:: audioread support is deprecated as of version 0.10.0.\n                audioread support be removed in version 1.0.\n    \n        sr : number > 0 [scalar]\n            target sampling rate\n    \n            'None' uses the native sampling rate\n    \n        mono : bool\n            convert signal to mono\n    \n        offset : float\n            start reading after this time (in seconds)\n    \n        duration : float\n            only load up to this much audio (in seconds)\n    \n        dtype : numeric type\n            data type of ``y``\n    \n        res_type : str\n            resample type (see note)\n    \n            .. note::\n                By default, this uses `soxr`'s high-quality mode ('HQ').\n    \n                For alternative resampling modes, see `resample`\n    \n            .. note::\n               `audioread` may truncate the precision of the audio data to 16 bits.\n    \n               See :ref:`ioformats` for alternate loading methods.\n    \n        Returns\n        -------\n        y : np.ndarray [shape=(n,) or (..., n)]\n            audio time series. Multi-channel is supported.\n        sr : number > 0 [scalar]\n            sampling rate of ``y``\n    \n        Examples\n        --------\n        >>> # Load an ogg vorbis file\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename)\n        >>> y\n        array([-1.407e-03, -4.461e-04, ..., -3.042e-05,  1.277e-05],\n              dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load a file and resample to 11 KHz\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename, sr=11025)\n        >>> y\n        array([-8.746e-04, -3.363e-04, ..., -1.301e-05,  0.000e+00],\n              dtype=float32)\n        >>> sr\n        11025\n    \n        >>> # Load 5 seconds of a file, starting 15 seconds in\n        >>> filename = librosa.ex('brahms')\n        >>> y, sr = librosa.load(filename, offset=15.0, duration=5.0)\n        >>> y\n        array([0.146, 0.144, ..., 0.128, 0.015], dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load using an already open SoundFile object\n        >>> import soundfile\n        >>> sfo = soundfile.SoundFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(sfo)\n    \n        >>> # Load using an already open audioread object\n        >>> import audioread.ffdec  # Use ffmpeg decoder\n        >>> aro = audioread.ffdec.FFmpegAudioFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(aro)\n        \"\"\"\n        if isinstance(path, tuple(audioread.available_backends())):\n            # Force the audioread loader if we have a reader object already\n            y, sr_native = __audioread_load(path, offset, duration, dtype)\n        else:\n            # Otherwise try soundfile first, and then fall back if necessary\n            try:\n>               y, sr_native = __soundfile_load(path, offset, duration, dtype)\n\nlibrosa/core/audio.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:209: in __soundfile_load\n    context = sf.SoundFile(path)\n/usr/local/lib/python3.10/dist-packages/soundfile.py:690: in __init__\n    self._file = self._open(file, mode_int, closefd)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = SoundFile('tests/data/test1_22050.wav', mode='r', samplerate=0, channels=0, format='FILE', subtype='FILE', endian='FILE')\nfile = b'tests/data/test1_22050.wav', mode_int = 16, closefd = True\n\n    def _open(self, file, mode_int, closefd):\n        \"\"\"Call the appropriate sf_open*() function from libsndfile.\"\"\"\n        if isinstance(file, (_unicode, bytes)):\n            if _os.path.isfile(file):\n                if 'x' in self.mode:\n                    raise OSError(\"File exists: {0!r}\".format(self.name))\n                elif set(self.mode).issuperset('w+'):\n                    # truncate the file, because SFM_RDWR doesn't:\n                    _os.close(_os.open(file, _os.O_WRONLY | _os.O_TRUNC))\n            openfunction = _snd.sf_open\n            if isinstance(file, _unicode):\n                if _sys.platform == 'win32':\n                    openfunction = _snd.sf_wchar_open\n                else:\n                    file = file.encode(_sys.getfilesystemencoding())\n            file_ptr = openfunction(file, mode_int, self._info)\n        elif isinstance(file, int):\n            file_ptr = _snd.sf_open_fd(file, mode_int, self._info, closefd)\n        elif _has_virtual_io_attrs(file, mode_int):\n            file_ptr = _snd.sf_open_virtual(self._init_virtual_io(file),\n                                            mode_int, self._info, _ffi.NULL)\n        else:\n            raise TypeError(\"Invalid file: {0!r}\".format(self.name))\n        if file_ptr == _ffi.NULL:\n            # get the actual error code\n            err = _snd.sf_error(file_ptr)\n>           raise LibsndfileError(err, prefix=\"Error opening {0!r}: \".format(self.name))\nE           soundfile.LibsndfileError: Error opening 'tests/data/test1_22050.wav': System error.\n\n/usr/local/lib/python3.10/dist-packages/soundfile.py:1265: LibsndfileError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'ysr' for <Function test_beat[22050-None-100.0-None-60-False-False-False]>>\n\n    @pytest.fixture(scope=\"module\", params=[22050, 44100])\n    def ysr(request):\n>       return librosa.load(__EXAMPLE_FILE, sr=request.param)\n\ntests/test_beat.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:184: in load\n    y, sr_native = __audioread_load(path, offset, duration, dtype)\n/usr/local/lib/python3.10/dist-packages/decorator.py:235: in fun\n    return caller(func, *(extras + args), **kw)\nlibrosa/util/decorators.py:63: in __wrapper\n    return func(*args, **kwargs)\nlibrosa/core/audio.py:240: in __audioread_load\n    reader = audioread.audio_open(path)\n/usr/local/lib/python3.10/dist-packages/audioread/__init__.py:127: in audio_open\n    return BackendClass(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <audioread.rawread.RawAudioFile object at 0x7f4904833760>\nfilename = 'tests/data/test1_22050.wav'\n\n    def __init__(self, filename):\n>       self._fh = open(filename, 'rb')\nE       FileNotFoundError: [Errno 2] No such file or directory: 'tests/data/test1_22050.wav'\n\n/usr/local/lib/python3.10/dist-packages/audioread/rawread.py:59: FileNotFoundError\n____ ERROR at setup of test_beat[22050-None-100.0-None-60-True-True-False] _____\n\npath = 'tests/data/test1_22050.wav'\n\n    def load(\n        path: Union[\n            str, int, os.PathLike[Any], sf.SoundFile, audioread.AudioFile, BinaryIO\n        ],\n        *,\n        sr: Optional[float] = 22050,\n        mono: bool = True,\n        offset: float = 0.0,\n        duration: Optional[float] = None,\n        dtype: DTypeLike = np.float32,\n        res_type: str = \"soxr_hq\",\n    ) -> Tuple[np.ndarray, Union[int, float]]:\n        \"\"\"Load an audio file as a floating point time series.\n    \n        Audio will be automatically resampled to the given rate\n        (default ``sr=22050``).\n    \n        To preserve the native sampling rate of the file, use ``sr=None``.\n    \n        Parameters\n        ----------\n        path : string, int, pathlib.Path, soundfile.SoundFile, audioread object, or file-like object\n            path to the input file.\n    \n            Any codec supported by `soundfile` or `audioread` will work.\n    \n            Any string file paths, or any object implementing Python's\n            file interface (e.g. `pathlib.Path`) are supported as `path`.\n    \n            If the codec is supported by `soundfile`, then `path` can also be\n            an open file descriptor (int) or an existing `soundfile.SoundFile` object.\n    \n            Pre-constructed audioread decoders are also supported here, see the example\n            below.  This can be used, for example, to force a specific decoder rather\n            than relying upon audioread to select one for you.\n    \n            .. warning:: audioread support is deprecated as of version 0.10.0.\n                audioread support be removed in version 1.0.\n    \n        sr : number > 0 [scalar]\n            target sampling rate\n    \n            'None' uses the native sampling rate\n    \n        mono : bool\n            convert signal to mono\n    \n        offset : float\n            start reading after this time (in seconds)\n    \n        duration : float\n            only load up to this much audio (in seconds)\n    \n        dtype : numeric type\n            data type of ``y``\n    \n        res_type : str\n            resample type (see note)\n    \n            .. note::\n                By default, this uses `soxr`'s high-quality mode ('HQ').\n    \n                For alternative resampling modes, see `resample`\n    \n            .. note::\n               `audioread` may truncate the precision of the audio data to 16 bits.\n    \n               See :ref:`ioformats` for alternate loading methods.\n    \n        Returns\n        -------\n        y : np.ndarray [shape=(n,) or (..., n)]\n            audio time series. Multi-channel is supported.\n        sr : number > 0 [scalar]\n            sampling rate of ``y``\n    \n        Examples\n        --------\n        >>> # Load an ogg vorbis file\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename)\n        >>> y\n        array([-1.407e-03, -4.461e-04, ..., -3.042e-05,  1.277e-05],\n              dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load a file and resample to 11 KHz\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename, sr=11025)\n        >>> y\n        array([-8.746e-04, -3.363e-04, ..., -1.301e-05,  0.000e+00],\n              dtype=float32)\n        >>> sr\n        11025\n    \n        >>> # Load 5 seconds of a file, starting 15 seconds in\n        >>> filename = librosa.ex('brahms')\n        >>> y, sr = librosa.load(filename, offset=15.0, duration=5.0)\n        >>> y\n        array([0.146, 0.144, ..., 0.128, 0.015], dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load using an already open SoundFile object\n        >>> import soundfile\n        >>> sfo = soundfile.SoundFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(sfo)\n    \n        >>> # Load using an already open audioread object\n        >>> import audioread.ffdec  # Use ffmpeg decoder\n        >>> aro = audioread.ffdec.FFmpegAudioFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(aro)\n        \"\"\"\n        if isinstance(path, tuple(audioread.available_backends())):\n            # Force the audioread loader if we have a reader object already\n            y, sr_native = __audioread_load(path, offset, duration, dtype)\n        else:\n            # Otherwise try soundfile first, and then fall back if necessary\n            try:\n>               y, sr_native = __soundfile_load(path, offset, duration, dtype)\n\nlibrosa/core/audio.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:209: in __soundfile_load\n    context = sf.SoundFile(path)\n/usr/local/lib/python3.10/dist-packages/soundfile.py:690: in __init__\n    self._file = self._open(file, mode_int, closefd)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = SoundFile('tests/data/test1_22050.wav', mode='r', samplerate=0, channels=0, format='FILE', subtype='FILE', endian='FILE')\nfile = b'tests/data/test1_22050.wav', mode_int = 16, closefd = True\n\n    def _open(self, file, mode_int, closefd):\n        \"\"\"Call the appropriate sf_open*() function from libsndfile.\"\"\"\n        if isinstance(file, (_unicode, bytes)):\n            if _os.path.isfile(file):\n                if 'x' in self.mode:\n                    raise OSError(\"File exists: {0!r}\".format(self.name))\n                elif set(self.mode).issuperset('w+'):\n                    # truncate the file, because SFM_RDWR doesn't:\n                    _os.close(_os.open(file, _os.O_WRONLY | _os.O_TRUNC))\n            openfunction = _snd.sf_open\n            if isinstance(file, _unicode):\n                if _sys.platform == 'win32':\n                    openfunction = _snd.sf_wchar_open\n                else:\n                    file = file.encode(_sys.getfilesystemencoding())\n            file_ptr = openfunction(file, mode_int, self._info)\n        elif isinstance(file, int):\n            file_ptr = _snd.sf_open_fd(file, mode_int, self._info, closefd)\n        elif _has_virtual_io_attrs(file, mode_int):\n            file_ptr = _snd.sf_open_virtual(self._init_virtual_io(file),\n                                            mode_int, self._info, _ffi.NULL)\n        else:\n            raise TypeError(\"Invalid file: {0!r}\".format(self.name))\n        if file_ptr == _ffi.NULL:\n            # get the actual error code\n            err = _snd.sf_error(file_ptr)\n>           raise LibsndfileError(err, prefix=\"Error opening {0!r}: \".format(self.name))\nE           soundfile.LibsndfileError: Error opening 'tests/data/test1_22050.wav': System error.\n\n/usr/local/lib/python3.10/dist-packages/soundfile.py:1265: LibsndfileError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'ysr' for <Function test_beat[22050-None-100.0-None-60-False-False-False]>>\n\n    @pytest.fixture(scope=\"module\", params=[22050, 44100])\n    def ysr(request):\n>       return librosa.load(__EXAMPLE_FILE, sr=request.param)\n\ntests/test_beat.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:184: in load\n    y, sr_native = __audioread_load(path, offset, duration, dtype)\n/usr/local/lib/python3.10/dist-packages/decorator.py:235: in fun\n    return caller(func, *(extras + args), **kw)\nlibrosa/util/decorators.py:63: in __wrapper\n    return func(*args, **kwargs)\nlibrosa/core/audio.py:240: in __audioread_load\n    reader = audioread.audio_open(path)\n/usr/local/lib/python3.10/dist-packages/audioread/__init__.py:127: in audio_open\n    return BackendClass(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <audioread.rawread.RawAudioFile object at 0x7f4904833760>\nfilename = 'tests/data/test1_22050.wav'\n\n    def __init__(self, filename):\n>       self._fh = open(filename, 'rb')\nE       FileNotFoundError: [Errno 2] No such file or directory: 'tests/data/test1_22050.wav'\n\n/usr/local/lib/python3.10/dist-packages/audioread/rawread.py:59: FileNotFoundError\n_____ ERROR at setup of test_beat[22050-None-100.0-None-60-True-True-True] _____\n\npath = 'tests/data/test1_22050.wav'\n\n    def load(\n        path: Union[\n            str, int, os.PathLike[Any], sf.SoundFile, audioread.AudioFile, BinaryIO\n        ],\n        *,\n        sr: Optional[float] = 22050,\n        mono: bool = True,\n        offset: float = 0.0,\n        duration: Optional[float] = None,\n        dtype: DTypeLike = np.float32,\n        res_type: str = \"soxr_hq\",\n    ) -> Tuple[np.ndarray, Union[int, float]]:\n        \"\"\"Load an audio file as a floating point time series.\n    \n        Audio will be automatically resampled to the given rate\n        (default ``sr=22050``).\n    \n        To preserve the native sampling rate of the file, use ``sr=None``.\n    \n        Parameters\n        ----------\n        path : string, int, pathlib.Path, soundfile.SoundFile, audioread object, or file-like object\n            path to the input file.\n    \n            Any codec supported by `soundfile` or `audioread` will work.\n    \n            Any string file paths, or any object implementing Python's\n            file interface (e.g. `pathlib.Path`) are supported as `path`.\n    \n            If the codec is supported by `soundfile`, then `path` can also be\n            an open file descriptor (int) or an existing `soundfile.SoundFile` object.\n    \n            Pre-constructed audioread decoders are also supported here, see the example\n            below.  This can be used, for example, to force a specific decoder rather\n            than relying upon audioread to select one for you.\n    \n            .. warning:: audioread support is deprecated as of version 0.10.0.\n                audioread support be removed in version 1.0.\n    \n        sr : number > 0 [scalar]\n            target sampling rate\n    \n            'None' uses the native sampling rate\n    \n        mono : bool\n            convert signal to mono\n    \n        offset : float\n            start reading after this time (in seconds)\n    \n        duration : float\n            only load up to this much audio (in seconds)\n    \n        dtype : numeric type\n            data type of ``y``\n    \n        res_type : str\n            resample type (see note)\n    \n            .. note::\n                By default, this uses `soxr`'s high-quality mode ('HQ').\n    \n                For alternative resampling modes, see `resample`\n    \n            .. note::\n               `audioread` may truncate the precision of the audio data to 16 bits.\n    \n               See :ref:`ioformats` for alternate loading methods.\n    \n        Returns\n        -------\n        y : np.ndarray [shape=(n,) or (..., n)]\n            audio time series. Multi-channel is supported.\n        sr : number > 0 [scalar]\n            sampling rate of ``y``\n    \n        Examples\n        --------\n        >>> # Load an ogg vorbis file\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename)\n        >>> y\n        array([-1.407e-03, -4.461e-04, ..., -3.042e-05,  1.277e-05],\n              dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load a file and resample to 11 KHz\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename, sr=11025)\n        >>> y\n        array([-8.746e-04, -3.363e-04, ..., -1.301e-05,  0.000e+00],\n              dtype=float32)\n        >>> sr\n        11025\n    \n        >>> # Load 5 seconds of a file, starting 15 seconds in\n        >>> filename = librosa.ex('brahms')\n        >>> y, sr = librosa.load(filename, offset=15.0, duration=5.0)\n        >>> y\n        array([0.146, 0.144, ..., 0.128, 0.015], dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load using an already open SoundFile object\n        >>> import soundfile\n        >>> sfo = soundfile.SoundFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(sfo)\n    \n        >>> # Load using an already open audioread object\n        >>> import audioread.ffdec  # Use ffmpeg decoder\n        >>> aro = audioread.ffdec.FFmpegAudioFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(aro)\n        \"\"\"\n        if isinstance(path, tuple(audioread.available_backends())):\n            # Force the audioread loader if we have a reader object already\n            y, sr_native = __audioread_load(path, offset, duration, dtype)\n        else:\n            # Otherwise try soundfile first, and then fall back if necessary\n            try:\n>               y, sr_native = __soundfile_load(path, offset, duration, dtype)\n\nlibrosa/core/audio.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:209: in __soundfile_load\n    context = sf.SoundFile(path)\n/usr/local/lib/python3.10/dist-packages/soundfile.py:690: in __init__\n    self._file = self._open(file, mode_int, closefd)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = SoundFile('tests/data/test1_22050.wav', mode='r', samplerate=0, channels=0, format='FILE', subtype='FILE', endian='FILE')\nfile = b'tests/data/test1_22050.wav', mode_int = 16, closefd = True\n\n    def _open(self, file, mode_int, closefd):\n        \"\"\"Call the appropriate sf_open*() function from libsndfile.\"\"\"\n        if isinstance(file, (_unicode, bytes)):\n            if _os.path.isfile(file):\n                if 'x' in self.mode:\n                    raise OSError(\"File exists: {0!r}\".format(self.name))\n                elif set(self.mode).issuperset('w+'):\n                    # truncate the file, because SFM_RDWR doesn't:\n                    _os.close(_os.open(file, _os.O_WRONLY | _os.O_TRUNC))\n            openfunction = _snd.sf_open\n            if isinstance(file, _unicode):\n                if _sys.platform == 'win32':\n                    openfunction = _snd.sf_wchar_open\n                else:\n                    file = file.encode(_sys.getfilesystemencoding())\n            file_ptr = openfunction(file, mode_int, self._info)\n        elif isinstance(file, int):\n            file_ptr = _snd.sf_open_fd(file, mode_int, self._info, closefd)\n        elif _has_virtual_io_attrs(file, mode_int):\n            file_ptr = _snd.sf_open_virtual(self._init_virtual_io(file),\n                                            mode_int, self._info, _ffi.NULL)\n        else:\n            raise TypeError(\"Invalid file: {0!r}\".format(self.name))\n        if file_ptr == _ffi.NULL:\n            # get the actual error code\n            err = _snd.sf_error(file_ptr)\n>           raise LibsndfileError(err, prefix=\"Error opening {0!r}: \".format(self.name))\nE           soundfile.LibsndfileError: Error opening 'tests/data/test1_22050.wav': System error.\n\n/usr/local/lib/python3.10/dist-packages/soundfile.py:1265: LibsndfileError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'ysr' for <Function test_beat[22050-None-100.0-None-60-False-False-False]>>\n\n    @pytest.fixture(scope=\"module\", params=[22050, 44100])\n    def ysr(request):\n>       return librosa.load(__EXAMPLE_FILE, sr=request.param)\n\ntests/test_beat.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:184: in load\n    y, sr_native = __audioread_load(path, offset, duration, dtype)\n/usr/local/lib/python3.10/dist-packages/decorator.py:235: in fun\n    return caller(func, *(extras + args), **kw)\nlibrosa/util/decorators.py:63: in __wrapper\n    return func(*args, **kwargs)\nlibrosa/core/audio.py:240: in __audioread_load\n    reader = audioread.audio_open(path)\n/usr/local/lib/python3.10/dist-packages/audioread/__init__.py:127: in audio_open\n    return BackendClass(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <audioread.rawread.RawAudioFile object at 0x7f4904833760>\nfilename = 'tests/data/test1_22050.wav'\n\n    def __init__(self, filename):\n>       self._fh = open(filename, 'rb')\nE       FileNotFoundError: [Errno 2] No such file or directory: 'tests/data/test1_22050.wav'\n\n/usr/local/lib/python3.10/dist-packages/audioread/rawread.py:59: FileNotFoundError\n___ ERROR at setup of test_beat[22050-None-100.0-None-120-False-False-False] ___\n\npath = 'tests/data/test1_22050.wav'\n\n    def load(\n        path: Union[\n            str, int, os.PathLike[Any], sf.SoundFile, audioread.AudioFile, BinaryIO\n        ],\n        *,\n        sr: Optional[float] = 22050,\n        mono: bool = True,\n        offset: float = 0.0,\n        duration: Optional[float] = None,\n        dtype: DTypeLike = np.float32,\n        res_type: str = \"soxr_hq\",\n    ) -> Tuple[np.ndarray, Union[int, float]]:\n        \"\"\"Load an audio file as a floating point time series.\n    \n        Audio will be automatically resampled to the given rate\n        (default ``sr=22050``).\n    \n        To preserve the native sampling rate of the file, use ``sr=None``.\n    \n        Parameters\n        ----------\n        path : string, int, pathlib.Path, soundfile.SoundFile, audioread object, or file-like object\n            path to the input file.\n    \n            Any codec supported by `soundfile` or `audioread` will work.\n    \n            Any string file paths, or any object implementing Python's\n            file interface (e.g. `pathlib.Path`) are supported as `path`.\n    \n            If the codec is supported by `soundfile`, then `path` can also be\n            an open file descriptor (int) or an existing `soundfile.SoundFile` object.\n    \n            Pre-constructed audioread decoders are also supported here, see the example\n            below.  This can be used, for example, to force a specific decoder rather\n            than relying upon audioread to select one for you.\n    \n            .. warning:: audioread support is deprecated as of version 0.10.0.\n                audioread support be removed in version 1.0.\n    \n        sr : number > 0 [scalar]\n            target sampling rate\n    \n            'None' uses the native sampling rate\n    \n        mono : bool\n            convert signal to mono\n    \n        offset : float\n            start reading after this time (in seconds)\n    \n        duration : float\n            only load up to this much audio (in seconds)\n    \n        dtype : numeric type\n            data type of ``y``\n    \n        res_type : str\n            resample type (see note)\n    \n            .. note::\n                By default, this uses `soxr`'s high-quality mode ('HQ').\n    \n                For alternative resampling modes, see `resample`\n    \n            .. note::\n               `audioread` may truncate the precision of the audio data to 16 bits.\n    \n               See :ref:`ioformats` for alternate loading methods.\n    \n        Returns\n        -------\n        y : np.ndarray [shape=(n,) or (..., n)]\n            audio time series. Multi-channel is supported.\n        sr : number > 0 [scalar]\n            sampling rate of ``y``\n    \n        Examples\n        --------\n        >>> # Load an ogg vorbis file\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename)\n        >>> y\n        array([-1.407e-03, -4.461e-04, ..., -3.042e-05,  1.277e-05],\n              dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load a file and resample to 11 KHz\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename, sr=11025)\n        >>> y\n        array([-8.746e-04, -3.363e-04, ..., -1.301e-05,  0.000e+00],\n              dtype=float32)\n        >>> sr\n        11025\n    \n        >>> # Load 5 seconds of a file, starting 15 seconds in\n        >>> filename = librosa.ex('brahms')\n        >>> y, sr = librosa.load(filename, offset=15.0, duration=5.0)\n        >>> y\n        array([0.146, 0.144, ..., 0.128, 0.015], dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load using an already open SoundFile object\n        >>> import soundfile\n        >>> sfo = soundfile.SoundFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(sfo)\n    \n        >>> # Load using an already open audioread object\n        >>> import audioread.ffdec  # Use ffmpeg decoder\n        >>> aro = audioread.ffdec.FFmpegAudioFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(aro)\n        \"\"\"\n        if isinstance(path, tuple(audioread.available_backends())):\n            # Force the audioread loader if we have a reader object already\n            y, sr_native = __audioread_load(path, offset, duration, dtype)\n        else:\n            # Otherwise try soundfile first, and then fall back if necessary\n            try:\n>               y, sr_native = __soundfile_load(path, offset, duration, dtype)\n\nlibrosa/core/audio.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:209: in __soundfile_load\n    context = sf.SoundFile(path)\n/usr/local/lib/python3.10/dist-packages/soundfile.py:690: in __init__\n    self._file = self._open(file, mode_int, closefd)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = SoundFile('tests/data/test1_22050.wav', mode='r', samplerate=0, channels=0, format='FILE', subtype='FILE', endian='FILE')\nfile = b'tests/data/test1_22050.wav', mode_int = 16, closefd = True\n\n    def _open(self, file, mode_int, closefd):\n        \"\"\"Call the appropriate sf_open*() function from libsndfile.\"\"\"\n        if isinstance(file, (_unicode, bytes)):\n            if _os.path.isfile(file):\n                if 'x' in self.mode:\n                    raise OSError(\"File exists: {0!r}\".format(self.name))\n                elif set(self.mode).issuperset('w+'):\n                    # truncate the file, because SFM_RDWR doesn't:\n                    _os.close(_os.open(file, _os.O_WRONLY | _os.O_TRUNC))\n            openfunction = _snd.sf_open\n            if isinstance(file, _unicode):\n                if _sys.platform == 'win32':\n                    openfunction = _snd.sf_wchar_open\n                else:\n                    file = file.encode(_sys.getfilesystemencoding())\n            file_ptr = openfunction(file, mode_int, self._info)\n        elif isinstance(file, int):\n            file_ptr = _snd.sf_open_fd(file, mode_int, self._info, closefd)\n        elif _has_virtual_io_attrs(file, mode_int):\n            file_ptr = _snd.sf_open_virtual(self._init_virtual_io(file),\n                                            mode_int, self._info, _ffi.NULL)\n        else:\n            raise TypeError(\"Invalid file: {0!r}\".format(self.name))\n        if file_ptr == _ffi.NULL:\n            # get the actual error code\n            err = _snd.sf_error(file_ptr)\n>           raise LibsndfileError(err, prefix=\"Error opening {0!r}: \".format(self.name))\nE           soundfile.LibsndfileError: Error opening 'tests/data/test1_22050.wav': System error.\n\n/usr/local/lib/python3.10/dist-packages/soundfile.py:1265: LibsndfileError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'ysr' for <Function test_beat[22050-None-100.0-None-60-False-False-False]>>\n\n    @pytest.fixture(scope=\"module\", params=[22050, 44100])\n    def ysr(request):\n>       return librosa.load(__EXAMPLE_FILE, sr=request.param)\n\ntests/test_beat.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:184: in load\n    y, sr_native = __audioread_load(path, offset, duration, dtype)\n/usr/local/lib/python3.10/dist-packages/decorator.py:235: in fun\n    return caller(func, *(extras + args), **kw)\nlibrosa/util/decorators.py:63: in __wrapper\n    return func(*args, **kwargs)\nlibrosa/core/audio.py:240: in __audioread_load\n    reader = audioread.audio_open(path)\n/usr/local/lib/python3.10/dist-packages/audioread/__init__.py:127: in audio_open\n    return BackendClass(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <audioread.rawread.RawAudioFile object at 0x7f4904833760>\nfilename = 'tests/data/test1_22050.wav'\n\n    def __init__(self, filename):\n>       self._fh = open(filename, 'rb')\nE       FileNotFoundError: [Errno 2] No such file or directory: 'tests/data/test1_22050.wav'\n\n/usr/local/lib/python3.10/dist-packages/audioread/rawread.py:59: FileNotFoundError\n___ ERROR at setup of test_beat[22050-None-100.0-None-120-False-False-True] ____\n\npath = 'tests/data/test1_22050.wav'\n\n    def load(\n        path: Union[\n            str, int, os.PathLike[Any], sf.SoundFile, audioread.AudioFile, BinaryIO\n        ],\n        *,\n        sr: Optional[float] = 22050,\n        mono: bool = True,\n        offset: float = 0.0,\n        duration: Optional[float] = None,\n        dtype: DTypeLike = np.float32,\n        res_type: str = \"soxr_hq\",\n    ) -> Tuple[np.ndarray, Union[int, float]]:\n        \"\"\"Load an audio file as a floating point time series.\n    \n        Audio will be automatically resampled to the given rate\n        (default ``sr=22050``).\n    \n        To preserve the native sampling rate of the file, use ``sr=None``.\n    \n        Parameters\n        ----------\n        path : string, int, pathlib.Path, soundfile.SoundFile, audioread object, or file-like object\n            path to the input file.\n    \n            Any codec supported by `soundfile` or `audioread` will work.\n    \n            Any string file paths, or any object implementing Python's\n            file interface (e.g. `pathlib.Path`) are supported as `path`.\n    \n            If the codec is supported by `soundfile`, then `path` can also be\n            an open file descriptor (int) or an existing `soundfile.SoundFile` object.\n    \n            Pre-constructed audioread decoders are also supported here, see the example\n            below.  This can be used, for example, to force a specific decoder rather\n            than relying upon audioread to select one for you.\n    \n            .. warning:: audioread support is deprecated as of version 0.10.0.\n                audioread support be removed in version 1.0.\n    \n        sr : number > 0 [scalar]\n            target sampling rate\n    \n            'None' uses the native sampling rate\n    \n        mono : bool\n            convert signal to mono\n    \n        offset : float\n            start reading after this time (in seconds)\n    \n        duration : float\n            only load up to this much audio (in seconds)\n    \n        dtype : numeric type\n            data type of ``y``\n    \n        res_type : str\n            resample type (see note)\n    \n            .. note::\n                By default, this uses `soxr`'s high-quality mode ('HQ').\n    \n                For alternative resampling modes, see `resample`\n    \n            .. note::\n               `audioread` may truncate the precision of the audio data to 16 bits.\n    \n               See :ref:`ioformats` for alternate loading methods.\n    \n        Returns\n        -------\n        y : np.ndarray [shape=(n,) or (..., n)]\n            audio time series. Multi-channel is supported.\n        sr : number > 0 [scalar]\n            sampling rate of ``y``\n    \n        Examples\n        --------\n        >>> # Load an ogg vorbis file\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename)\n        >>> y\n        array([-1.407e-03, -4.461e-04, ..., -3.042e-05,  1.277e-05],\n              dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load a file and resample to 11 KHz\n        >>> filename = librosa.ex('trumpet')\n        >>> y, sr = librosa.load(filename, sr=11025)\n        >>> y\n        array([-8.746e-04, -3.363e-04, ..., -1.301e-05,  0.000e+00],\n              dtype=float32)\n        >>> sr\n        11025\n    \n        >>> # Load 5 seconds of a file, starting 15 seconds in\n        >>> filename = librosa.ex('brahms')\n        >>> y, sr = librosa.load(filename, offset=15.0, duration=5.0)\n        >>> y\n        array([0.146, 0.144, ..., 0.128, 0.015], dtype=float32)\n        >>> sr\n        22050\n    \n        >>> # Load using an already open SoundFile object\n        >>> import soundfile\n        >>> sfo = soundfile.SoundFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(sfo)\n    \n        >>> # Load using an already open audioread object\n        >>> import audioread.ffdec  # Use ffmpeg decoder\n        >>> aro = audioread.ffdec.FFmpegAudioFile(librosa.ex('brahms'))\n        >>> y, sr = librosa.load(aro)\n        \"\"\"\n        if isinstance(path, tuple(audioread.available_backends())):\n            # Force the audioread loader if we have a reader object already\n            y, sr_native = __audioread_load(path, offset, duration, dtype)\n        else:\n            # Otherwise try soundfile first, and then fall back if necessary\n            try:\n>               y, sr_native = __soundfile_load(path, offset, duration, dtype)\n\nlibrosa/core/audio.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:209: in __soundfile_load\n    context = sf.SoundFile(path)\n/usr/local/lib/python3.10/dist-packages/soundfile.py:690: in __init__\n    self._file = self._open(file, mode_int, closefd)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = SoundFile('tests/data/test1_22050.wav', mode='r', samplerate=0, channels=0, format='FILE', subtype='FILE', endian='FILE')\nfile = b'tests/data/test1_22050.wav', mode_int = 16, closefd = True\n\n    def _open(self, file, mode_int, closefd):\n        \"\"\"Call the appropriate sf_open*() function from libsndfile.\"\"\"\n        if isinstance(file, (_unicode, bytes)):\n            if _os.path.isfile(file):\n                if 'x' in self.mode:\n                    raise OSError(\"File exists: {0!r}\".format(self.name))\n                elif set(self.mode).issuperset('w+'):\n                    # truncate the file, because SFM_RDWR doesn't:\n                    _os.close(_os.open(file, _os.O_WRONLY | _os.O_TRUNC))\n            openfunction = _snd.sf_open\n            if isinstance(file, _unicode):\n                if _sys.platform == 'win32':\n                    openfunction = _snd.sf_wchar_open\n                else:\n                    file = file.encode(_sys.getfilesystemencoding())\n            file_ptr = openfunction(file, mode_int, self._info)\n        elif isinstance(file, int):\n            file_ptr = _snd.sf_open_fd(file, mode_int, self._info, closefd)\n        elif _has_virtual_io_attrs(file, mode_int):\n            file_ptr = _snd.sf_open_virtual(self._init_virtual_io(file),\n                                            mode_int, self._info, _ffi.NULL)\n        else:\n            raise TypeError(\"Invalid file: {0!r}\".format(self.name))\n        if file_ptr == _ffi.NULL:\n            # get the actual error code\n            err = _snd.sf_error(file_ptr)\n>           raise LibsndfileError(err, prefix=\"Error opening {0!r}: \".format(self.name))\nE           soundfile.LibsndfileError: Error opening 'tests/data/test1_22050.wav': System error.\n\n/usr/local/lib/python3.10/dist-packages/soundfile.py:1265: LibsndfileError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'ysr' for <Function test_beat[22050-None-100.0-None-60-False-False-False]>>\n\n    @pytest.fixture(scope=\"module\", params=[22050, 44100])\n    def ysr(request):\n>       return librosa.load(__EXAMPLE_FILE, sr=request.param)\n\ntests/test_beat.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlibrosa/core/audio.py:184: in load\n    y, sr_native = __audioread_load(path, offset, duration, dtype)\n/usr/local/lib/python3.10/dist-packages/decorator.py:235: in fun\n    return caller(func, *(extras + args), **kw)\nlibrosa/util/decorators.py:63: in __wrapper\n    return func(*args, **kwargs)\nlibrosa/core/audio.py:240: in __audioread_load\n    reader = audioread.audio_open(path)\n/usr/local/lib/python3.10/dist-packages/audioread/__init__.py:127: in audio_open\n    return BackendClass(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <audioread.rawread.RawAudioFile object at 0x7f4904833760>\nfilename = 'tests/data/test1_22050.wav'\n\n    def __init__(self, filename):\n>       self._fh = open(filename, 'rb')\nE       FileNotFoundError: [Errno 2] No such file or directory: 'tests/data/test1_22050.wav'\n\n/usr/local/lib/python3.10/dist-packages/audioread/rawread.py:59: FileNotFoundError\n=========================== short test summary info ============================\nERROR tests/test_beat.py::test_beat[22050-None-100.0-None-60-False-False-False]\nERROR tests/test_beat.py::test_beat[22050-None-100.0-None-60-False-False-True]\nERROR tests/test_beat.py::test_beat[22050-None-100.0-None-60-False-True-False]\nERROR tests/test_beat.py::test_beat[22050-None-100.0-None-60-False-True-True]\nERROR tests/test_beat.py::test_beat[22050-None-100.0-None-60-True-False-False]\nERROR tests/test_beat.py::test_beat[22050-None-100.0-None-60-True-False-True]\nERROR tests/test_beat.py::test_beat[22050-None-100.0-None-60-True-True-False]\nERROR tests/test_beat.py::test_beat[22050-None-100.0-None-60-True-True-True]\nERROR tests/test_beat.py::test_beat[22050-None-100.0-None-120-False-False-False]\nERROR tests/test_beat.py::test_beat[22050-None-100.0-None-120-False-False-True]\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 10 failures !!!!!!!!!!!!!!!!!!!!!!!!!!\n====== 137 passed, 1 skipped, 1 xfailed, 2 warnings, 10 errors in 34.08s =======\n",
    "stderr": "",
    "execution_time": 35.423733949661255
  }
]