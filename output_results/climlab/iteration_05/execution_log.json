[
  {
    "command": "pytest",
    "success": false,
    "stdout": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.4.1, pluggy-1.6.0\nrootdir: /app/repo_to_process\nconfigfile: pyproject.toml\ncollected 55 items\n\nclimlab/tests/test_advdiff_solver.py ..F                                 [  5%]\nclimlab/tests/test_bandrc.py .FF.                                        [ 12%]\nclimlab/tests/test_cam3rad.py FFFF                                       [ 20%]\nclimlab/tests/test_domain2D.py .FF.                                      [ 27%]\nclimlab/tests/test_ebm.py .FFFFFFFF                                      [ 43%]\nclimlab/tests/test_emanuel_convection.py FFF                             [ 49%]\nclimlab/tests/test_grey_radiation.py ....F.                              [ 60%]\nclimlab/tests/test_insolation.py ....F                                   [ 69%]\nclimlab/tests/test_rcm.py FF.                                            [ 74%]\nclimlab/tests/test_rrtm.py .FFFFFF.FF..                                  [ 96%]\nclimlab/tests/test_thermo.py ..                                          [100%]\n--- Writing function-level test call chains report to report_functions.jsonl ---\nSuccessfully wrote 55 records to report_functions.jsonl\n\n--- Writing aggregated file-level test call chains report to report_files.jsonl ---\nSuccessfully wrote 11 records to report_files.jsonl\n\n--- End of Reports ---\n\n\n=================================== FAILURES ===================================\n___________________________ test_nonuniform_multidim ___________________________\n\n    @pytest.mark.fast\n    def test_nonuniform_multidim():\n        P=7; N = 4; M = 5  # arbitrary\n        X = np.zeros((P,N,M,J))\n        Xb = np.zeros((P,N,M,J+1))\n        for p in range(P):\n            for n in range(N):\n                for m in range(M):\n                    Xb[p,n,m,:] = np.geomspace(x0+offset, xJ+offset, J+1)-offset\n                    Xb[p,n,m,0] = 0.; Xb[p,n,m,-1] = xJ\n                    X[p,n,m,:] = Xb[p,n,m,:-1] + (Xb[p,n,m,1:]-Xb[p,n,m,:-1])/2\n        Psi = Psi0 * (np.sin(np.pi*X/L))**2\n        K = np.ones_like(Xb) * Kconst\n        U = U0 * np.sin(np.pi*Xb/L)\n        prescribed_flux = np.zeros_like(U)\n        prescribed_source = np.zeros_like(Psi)\n        source = adv_diff_numerics.compute_source(X,Xb)\n        tridiag = adv_diff_numerics.advdiff_tridiag(X, Xb, K, U)\n        F_analytical = flux_analytical(Xb, Psi0, U0, Kconst, L)\n        F_numerical = adv_diff_numerics.total_flux(X, Xb, K, U, Psi)\n        dPsidt_analytical = tendency_analytical(X, Psi0, U0, Kconst, L)\n        dPsidt_numerical = adv_diff_numerics.compute_tendency(Psi, tridiag, source)\n        assert F_numerical == pytest.approx(F_analytical, abs=0.01, rel=0.01)\n        assert dPsidt_numerical == pytest.approx(dPsidt_analytical, abs=0.01, rel=0.01)\n>       adv_diff_numerics.implicit_step_forward(Psi, tridiag, source, timestep, use_banded_solver=False)\n\nclimlab/tests/test_advdiff_solver.py:94: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[[[ 17.07392702, -15.80251719,   0.        , ...,\n             0.        ,   0.        ,   0.        ],\n      ...0.        ,   0.        , ...,\n             0.        ,  -0.63064471,   1.36000707]]]]],\n      shape=(7, 4, 5, 50, 50))\nb = array([[[[0.00013137, 0.00121086, 0.00347679, ..., 0.10044926,\n          0.03820201, 0.0043961 ],\n         [0.00013137...       [0.00013137, 0.00121086, 0.00347679, ..., 0.10044926,\n          0.03820201, 0.0043961 ]]]], shape=(7, 4, 5, 50))\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 5 is different from 50)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n________________________________ test_diffmodel ________________________________\n\ndiffmodel = <climlab.model.column.BandRCModel object at 0x7efc16e168f0>\n\n    @pytest.mark.fast\n    def test_diffmodel(diffmodel):\n        \"\"\"Check that we can integrate the model with diffusion.\"\"\"\n>       diffmodel.step_forward()\n\nclimlab/tests/test_bandrc.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[ 1.00000000e+00, -5.11162101e-13,  0.00000000e+00, ...,\n          0.00000000e+00,  0.00000000e+00,  0.0000000...000e+00,  0.00000000e+00, ...,\n          0.00000000e+00, -5.11162101e-13,  1.00000000e+00]]],\n      shape=(30, 90, 90))\nb = array([[199.82020087, 199.82020124, 199.82020196, ..., 199.82020105,\n        199.82020032, 199.82019996],\n       [202....    [279.64149453, 279.64179173, 279.64238821, ..., 279.64163698,\n        279.64103866, 279.64074054]], shape=(30, 90))\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 30 is different from 90)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n___________________________ test_diffmodel_surfflux ____________________________\n\ndiffmodel_surfflux = <climlab.model.column.BandRCModel object at 0x7efc16e95ea0>\n\n    @pytest.mark.fast\n    def test_diffmodel_surfflux(diffmodel_surfflux):\n        \"\"\"Check that we can integrate the model with diffusion.\"\"\"\n>       diffmodel_surfflux.step_forward()\n\nclimlab/tests/test_bandrc.py:75: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[ 1.00000000e+00, -5.11162101e-13,  0.00000000e+00, ...,\n          0.00000000e+00,  0.00000000e+00,  0.0000000...000e+00,  0.00000000e+00, ...,\n          0.00000000e+00, -5.11162101e-13,  1.00000000e+00]]],\n      shape=(30, 90, 90))\nb = array([[199.82020087, 199.82020124, 199.82020196, ..., 199.82020105,\n        199.82020032, 199.82019996],\n       [202....    [300.34695792, 300.34725512, 300.3478516 , ..., 300.34710037,\n        300.34650205, 300.34620393]], shape=(30, 90))\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 30 is different from 90)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n___________________________________ test_rce ___________________________________\n\nrcm = <climlab.process.time_dependent_process.TimeDependentProcess object at 0x7efc16e96ec0>\n\n    @pytest.mark.compiled\n    @pytest.mark.fast\n    def test_rce(rcm):\n        '''Test a single-column radiative-convective model with CAM3 radiation and\n        fixed relative humidity.'''\n>       rcm.step_forward()\n\nclimlab/tests/test_cam3rad.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.cam3.CAM3 object at 0x7efc16e95f00>\n\n    def _compute_heating_rates(self):\n        # List of arguments to be passed to extension\n        args = self._prepare_arguments()\n        (TdotRad, SrfRadFlx, qrs, qrl, swflx, swflxc, lwflx, lwflxc, SwToaCf,\n            SwSrfCf, LwToaCf, LwSrfCf, LwToa, LwSrf, SwToa, SwSrf,\n            swuflx, swdflx, swuflxc, swdflxc,\n>           lwuflx, lwdflx, lwuflxc, lwdflxc) = _cam3.driver(*args)\nE       NameError: name '_cam3' is not defined\n\nclimlab/radiation/cam3.py:175: NameError\n__________________________ test_re_radiative_forcing ___________________________\n\n    @pytest.mark.compiled\n    @pytest.mark.slow\n    def test_re_radiative_forcing():\n        state = climlab.column_state(num_lev=num_lev)\n        rad = climlab.radiation.CAM3(state=state)\n>       rad.integrate_years(2)\n\nclimlab/tests/test_cam3rad.py:45: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:419: in integrate_years\n    self.step_forward()\nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.cam3.CAM3 object at 0x7efc179f6dd0>\n\n    def _compute_heating_rates(self):\n        # List of arguments to be passed to extension\n        args = self._prepare_arguments()\n        (TdotRad, SrfRadFlx, qrs, qrl, swflx, swflxc, lwflx, lwflxc, SwToaCf,\n            SwSrfCf, LwToaCf, LwSrfCf, LwToa, LwSrf, SwToa, SwSrf,\n            swuflx, swdflx, swuflxc, swdflxc,\n>           lwuflx, lwdflx, lwuflxc, lwdflxc) = _cam3.driver(*args)\nE       NameError: name '_cam3' is not defined\n\nclimlab/radiation/cam3.py:175: NameError\n----------------------------- Captured stdout call -----------------------------\nIntegrating for 730 steps, 730.4844 days, or 2 years.\n__________________________ test_rce_radiative_forcing __________________________\n\nrcm = <climlab.process.time_dependent_process.TimeDependentProcess object at 0x7efc1928da80>\n\n    @pytest.mark.compiled\n    @pytest.mark.slow\n    def test_rce_radiative_forcing(rcm):\n        '''Run a single-column radiative-convective model with CAM3 radiation\n        out to equilibrium. Clone the model, double CO2 and measure the instantaneous\n        change in TOA flux. It should be positive net downward flux.'''\n>       rcm.integrate_years(5.)\n\nclimlab/tests/test_cam3rad.py:58: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:419: in integrate_years\n    self.step_forward()\nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.cam3.CAM3 object at 0x7efc1928e140>\n\n    def _compute_heating_rates(self):\n        # List of arguments to be passed to extension\n        args = self._prepare_arguments()\n        (TdotRad, SrfRadFlx, qrs, qrl, swflx, swflxc, lwflx, lwflxc, SwToaCf,\n            SwSrfCf, LwToaCf, LwSrfCf, LwToa, LwSrf, SwToa, SwSrf,\n            swuflx, swdflx, swuflxc, swdflxc,\n>           lwuflx, lwdflx, lwuflxc, lwdflxc) = _cam3.driver(*args)\nE       NameError: name '_cam3' is not defined\n\nclimlab/radiation/cam3.py:175: NameError\n----------------------------- Captured stdout call -----------------------------\nIntegrating for 1826 steps, 1826.2110000000002 days, or 5.0 years.\n______________________________ test_cam3_multidim ______________________________\n\n    @pytest.mark.compiled\n    @pytest.mark.fast\n    def test_cam3_multidim():\n        state = climlab.column_state(num_lev=40, num_lat=3, water_depth=5.)\n        rad = climlab.radiation.CAM3(state=state)\n        # Can we integrate?\n>       rad.step_forward()\n\nclimlab/tests/test_cam3rad.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.cam3.CAM3 object at 0x7efc179f6ef0>\n\n    def _compute_heating_rates(self):\n        # List of arguments to be passed to extension\n        args = self._prepare_arguments()\n        (TdotRad, SrfRadFlx, qrs, qrl, swflx, swflxc, lwflx, lwflxc, SwToaCf,\n            SwSrfCf, LwToaCf, LwSrfCf, LwToa, LwSrf, SwToa, SwSrf,\n            swuflx, swdflx, swuflxc, swdflxc,\n>           lwuflx, lwdflx, lwuflxc, lwdflxc) = _cam3.driver(*args)\nE       NameError: name '_cam3' is not defined\n\nclimlab/radiation/cam3.py:175: NameError\n_________________________________ test_2D_EBM __________________________________\n\n    @pytest.mark.fast\n    def test_2D_EBM():\n        '''Can we step forward a 2D lat/lon EBM?'''\n        #state = climlab.surface_state(num_lon=4)\n        #m = climlab.EBM_annual(state=state)\n        m = climlab.EBM_annual(num_lon=4)\n>       m.step_forward()\n\nclimlab/tests/test_domain2D.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[[ 8.63805809, -7.63805809,  0.        , ...,  0.        ,\n           0.        ,  0.        ],\n         [-2.5...[ 0.        ,  0.        ,  0.        , ...,  0.        ,\n          -7.63805809,  8.63805809]]]], shape=(4, 1, 90, 90))\nb = array([[[-28.66402299, -28.51746002, -28.22502207, -27.78807314,\n         -27.2085789 , -26.48919369, -25.6332198 , -2... -25.63321979,\n         -26.48919368, -27.2085789 , -27.78807313, -28.22502207,\n         -28.51746001, -28.66402298]]])\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 1 is different from 90)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n_____________________________ test_2D_EBM_seasonal _____________________________\n\n    @pytest.mark.fast\n    def test_2D_EBM_seasonal():\n        '''Can we step forward a 2D seasonal lat/lon EBM?'''\n        #state = climlab.surface_state(num_lon=4)\n        #m = climlab.EBM_annual(state=state)\n        m = climlab.EBM_seasonal(num_lon=4)\n>       m.step_forward()\n\nclimlab/tests/test_domain2D.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[[ 8.63805809, -7.63805809,  0.        , ...,  0.        ,\n           0.        ,  0.        ],\n         [-2.5...[ 0.        ,  0.        ,  0.        , ...,  0.        ,\n          -7.63805809,  8.63805809]]]], shape=(4, 1, 90, 90))\nb = array([[[-27.31758568, -27.17210544, -26.88189345, -26.44844265,\n         -25.87398258, -25.16146747, -24.3145606 , -2... -26.30614489,\n         -27.14355499, -27.84772346, -28.41521967, -28.84327883,\n         -29.12981549, -29.27343367]]])\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 1 is different from 90)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n_____________________________ test_integrate_years _____________________________\n\nEBM_seasonal = <climlab.model.ebm.EBM_seasonal object at 0x7efc192f7490>\n\n    @pytest.mark.fast\n    def test_integrate_years(EBM_seasonal):\n        \"\"\"Check that we can integrate forward the model and get the expected\n        surface temperature.\"\"\"\n>       EBM_seasonal.step_forward()\n\nclimlab/tests/test_ebm.py:37: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[ 8.63805809, -7.63805809,  0.        , ...,  0.        ,\n          0.        ,  0.        ],\n        [-2.5470...     [ 0.        ,  0.        ,  0.        , ...,  0.        ,\n         -7.63805809,  8.63805809]]], shape=(1, 90, 90))\nb = array([[-27.31758568, -27.17210544, -26.88189345, -26.44844265,\n        -25.87398258, -25.16146747, -24.3145606 , -23....96, -26.30614489,\n        -27.14355499, -27.84772346, -28.41521967, -28.84327883,\n        -29.12981549, -29.27343367]])\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 1 is different from 90)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n_____________________________ test_high_obliquity ______________________________\n\nEBM_highobliquity = <climlab.model.ebm.EBM_seasonal object at 0x7efc5f3f12a0>\n\n    @pytest.mark.fast\n    def test_high_obliquity(EBM_highobliquity):\n        \"\"\"Check that we can integrate forward the model and get the expected\n        surface temperature.\"\"\"\n>       EBM_highobliquity.step_forward()\n\nclimlab/tests/test_ebm.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[ 8.63805809, -7.63805809,  0.        , ...,  0.        ,\n          0.        ,  0.        ],\n        [-2.5470...     [ 0.        ,  0.        ,  0.        , ...,  0.        ,\n         -7.63805809,  8.63805809]]], shape=(1, 90, 90))\nb = array([[-24.55535629, -24.40724629, -24.11184364, -23.67077829,\n        -23.0864832 , -22.3621802 , -21.50186111, -20....96, -26.30614489,\n        -27.14355499, -27.84772346, -28.41521967, -28.84327883,\n        -29.12981549, -29.27343367]])\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 1 is different from 90)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n_____________________________ test_annual_iceline ______________________________\n\nEBM_iceline = <climlab.model.ebm.EBM_annual object at 0x7efc179c7af0>\n\n    @pytest.mark.fast\n    def test_annual_iceline(EBM_iceline):\n        '''Check that the annual mean EBM with interactive ice edge gives expected\n        result (ice at 70degrees).'''\n>       EBM_iceline.integrate_years(5.)\n\nclimlab/tests/test_ebm.py:56: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:419: in integrate_years\n    self.step_forward()\nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[ 8.63805809, -7.63805809,  0.        , ...,  0.        ,\n          0.        ,  0.        ],\n        [-2.5470...     [ 0.        ,  0.        ,  0.        , ...,  0.        ,\n         -7.63805809,  8.63805809]]], shape=(1, 90, 90))\nb = array([[-28.722212  , -28.57713122, -28.28767193, -27.85522734,\n        -27.28181478, -26.57015349, -25.72362679, -24....87, -25.72362678,\n        -26.57015349, -27.28181478, -27.85522734, -28.28767193,\n        -28.57713122, -28.722212  ]])\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 1 is different from 90)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n----------------------------- Captured stdout call -----------------------------\nIntegrating for 450 steps, 1826.2110000000002 days, or 5.0 years.\n______________________________ test_decreased_S0 _______________________________\n\nEBM_iceline = <climlab.model.ebm.EBM_annual object at 0x7efc192b70a0>\n\n    @pytest.mark.fast\n    def test_decreased_S0(EBM_iceline):\n        '''Check that a decrease in solar constant to 1200 W/m2 will give a\n        Snowball Earth result in the annual mean EBM.'''\n        #EBM_iceline.subprocess['insolation'].S0 = 1200.\n        EBM_iceline.S0 = 1200.\n>       EBM_iceline.integrate_years(5.)\n\nclimlab/tests/test_ebm.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:419: in integrate_years\n    self.step_forward()\nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[ 8.63805809, -7.63805809,  0.        , ...,  0.        ,\n          0.        ,  0.        ],\n        [-2.5470...     [ 0.        ,  0.        ,  0.        , ...,  0.        ,\n         -7.63805809,  8.63805809]]], shape=(1, 90, 90))\nb = array([[-28.78891419, -28.64401039, -28.35490476, -27.92299085,\n        -27.35029421, -26.63953961, -25.79411608, -24....8 , -25.79411608,\n        -26.63953961, -27.35029421, -27.92299084, -28.35490476,\n        -28.64401039, -28.78891418]])\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 1 is different from 90)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n----------------------------- Captured stdout call -----------------------------\nIntegrating for 450 steps, 1826.2110000000002 days, or 5.0 years.\n__________________________________ test_float __________________________________\n\n    @pytest.mark.fast\n    def test_float():\n        '''Check that we can step forward the model after setting the state\n        variable with an ndarray of integers through 2 different methods'''\n        from climlab.domain import initial\n        from climlab.domain.field import Field\n        state = initial.surface_state()\n        sfc = climlab.domain.zonal_mean_surface(num_lat=4)\n        state.Ts = Field([10,15,15,10],domain=sfc)\n        m = climlab.EBM(state=state)\n>       m.step_forward()\n\nclimlab/tests/test_ebm.py:78: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[ 1.01394118, -0.01394118,  0.        ,  0.        ],\n        [-0.00577462,  1.01394118, -0.00816655,  0.     ...  [ 0.        , -0.00816655,  1.01394118, -0.00577462],\n        [ 0.        ,  0.        , -0.01394118,  1.01394118]]])\nb = array([[ 9.21536108, 15.33144023, 15.33144023,  9.21536108]])\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 1 is different from 4)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n_________________________________ test_albedo __________________________________\n\n    @pytest.mark.fast\n    def test_albedo():\n        '''Check that we can integrate forward a model after changing the albedo\n        subprocess and get the expected icelat'''\n        import numpy as np\n        m = climlab.EBM()\n        m.add_subprocess('albedo', climlab.surface.ConstantAlbedo(state=m.state, **m.param))\n        m.subprocess['SW'].albedo = m.subprocess['albedo'].albedo\n>       m.integrate_years(1)\n\nclimlab/tests/test_ebm.py:91: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:419: in integrate_years\n    self.step_forward()\nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[ 8.63805809, -7.63805809,  0.        , ...,  0.        ,\n          0.        ,  0.        ],\n        [-2.5470...     [ 0.        ,  0.        ,  0.        , ...,  0.        ,\n         -7.63805809,  8.63805809]]], shape=(1, 90, 90))\nb = array([[-28.27587509, -28.12889576, -27.83565318, -27.39757597,\n        -26.81679843, -26.09615003, -25.23914171, -24....71, -25.23914171,\n        -26.09615003, -26.81679843, -27.39757597, -27.83565318,\n        -28.12889576, -28.27587509]])\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 1 is different from 90)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n----------------------------- Captured stdout call -----------------------------\nIntegrating for 90 steps, 365.2422 days, or 1 years.\n_______________________________ test_analytical ________________________________\n\n    @pytest.mark.fast\n    def test_analytical():\n        '''Check to see if the the numerical solution converges to the analytical\n        steady-state solution of the simple EBM with constant albedo'''\n        param = {'a0': 0.3,\n                 'a2': 0.,\n                 'ai': 0.3,\n                 's2': -0.48,\n                 'S0': 1360.,\n                 'A': 210.,\n                 'B': 2.,\n                 'D': 0.55,\n                 'Tf': -1000., # effectively makes albedo constant\n                }\n        m = climlab.EBM(**param)\n>       m.integrate_years(5)\n\nclimlab/tests/test_ebm.py:118: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:419: in integrate_years\n    self.step_forward()\nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[ 8.56924675, -7.56924675,  0.        , ...,  0.        ,\n          0.        ,  0.        ],\n        [-2.5241...     [ 0.        ,  0.        ,  0.        , ...,  0.        ,\n         -7.56924675,  8.56924675]]], shape=(1, 90, 90))\nb = array([[-28.23517809, -28.08806164, -27.79454547, -27.35605957,\n        -26.77474019, -26.05341947, -25.1956116 , -24....75, -25.1956116 ,\n        -26.05341947, -26.77474019, -27.35605957, -27.79454547,\n        -28.08806164, -28.23517809]])\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 1 is different from 90)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n----------------------------- Captured stdout call -----------------------------\nIntegrating for 450 steps, 1826.2110000000002 days, or 5 years.\n___________________________ test_moist_EBM_creation ____________________________\n\n    @pytest.mark.fast\n    def test_moist_EBM_creation():\n        '''See if we can swap a moist diffusion module for the dry diffusion\n        and just step forward once.'''\n        m = climlab.EBM()\n        m.remove_subprocess('diffusion')\n        diff = climlab.dynamics.MeridionalMoistDiffusion(state=m.state, timestep=m.timestep)\n        m.add_subprocess('diffusion', diff)\n>       m.step_forward()\n\nclimlab/tests/test_ebm.py:133: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/meridional_moist_diffusion.py:142: in _implicit_solver\n    return super(MeridionalMoistDiffusion, self)._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[ 4.52424331, -3.52424331,  0.        , ...,  0.        ,\n          0.        ,  0.        ],\n        [-1.1752...     [ 0.        ,  0.        ,  0.        , ...,  0.        ,\n         -3.52424331,  4.52424331]]], shape=(1, 90, 90))\nb = array([[-28.70765418, -28.56212968, -28.27178965, -27.83804862,\n        -27.26301971, -26.54950442, -25.70097891, -24....12, -25.70097891,\n        -26.54950442, -27.26301971, -27.83804862, -28.27178965,\n        -28.56212968, -28.70765418]])\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 1 is different from 90)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n___________________________ test_convect_tendencies ____________________________\n\n    @pytest.mark.compiled\n    @pytest.mark.fast\n    def test_convect_tendencies():\n        # Temperatures in a single column\n        state = climlab.column_state(num_lev=num_lev)\n        state.Tatm[:] = T\n        state['q'] = state.Tatm * 0. + Q\n        state['U'] = state.Tatm * 0. + U\n        state['V'] = state.Tatm * 0. + V\n        assert hasattr(state, 'Tatm')\n        assert hasattr(state, 'q')\n        assert hasattr(state, 'U')\n        assert hasattr(state, 'V')\n        conv = emanuel_convection.EmanuelConvection(state=state, timestep=DELT)\n>       conv.step_forward()\n\nclimlab/tests/test_emanuel_convection.py:74: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.convection.emanuel_convection.EmanuelConvection object at 0x7efc1928af50>\n\n    def _compute(self):\n        #  Invert arrays so the first element is the bottom of column\n        T = _climlab_to_convect(self.state['Tatm'])\n        dom = self.state['Tatm'].domain\n        P = _climlab_to_convect(dom.lev.points)\n        PH = _climlab_to_convect(dom.lev.bounds)\n        Q = _climlab_to_convect(self.state['q'])\n        QS = qsat(T,P)\n        ND = np.size(T, axis=1)\n        NCOL = np.size(T, axis=0)\n        NL = ND-1\n        try:\n            U = _climlab_to_convect(self.state['U'])\n        except:\n            U = np.zeros_like(T)\n        try:\n            V = _climlab_to_convect(self.state['V'])\n        except:\n            V = np.zeros_like(T)\n        NTRA = 1\n        TRA = np.zeros((NCOL,ND,NTRA), order='F')  # tracers ignored\n        DELT = float(self.timestep)\n        CBMF = self.CBMF\n        (IFLAG, FT, FQ, FU, FV, FTRA, PRECIP, WD, TPRIME, QPRIME, CBMFnew,\n        Tout, Qout, QSout, Uout, Vout, TRAout) = \\\n>           convect(T, Q, QS, U, V, TRA, P, PH, NCOL, ND, NL, NTRA, DELT, self.IPBL, CBMF,\n                    CPD, CPV, CL, RV, RD, LV0, G, ROWL, self.MINORIG,\n                    self.ELCRIT, self.TLCRIT, self.ENTP, self.SIGD, self.SIGS,\n                    self.OMTRAIN, self.OMTSNOW, self.COEFFR, self.COEFFS,\n                    self.CU, self.BETA, self.DTMAX, self.ALPHA, self.DAMP\n                    )\nE       NameError: name 'convect' is not defined\n\nclimlab/convection/emanuel_convection.py:227: NameError\n___________________________ test_multidim_tendencies ___________________________\n\n    @pytest.mark.compiled\n    @pytest.mark.fast\n    def test_multidim_tendencies():\n        # Same test just repeated in two parallel columns\n        num_lat = 2\n        state = climlab.column_state(num_lev=num_lev, num_lat=num_lat)\n        state['q'] = state.Tatm * 0. #+ Q\n        state['U'] = state.Tatm * 0. #+ U\n        state['V'] = state.Tatm * 0. #+ V\n        for i in range(num_lat):\n            state.Tatm[i,:] = T\n            state['q'][i,:] += Q\n            state['U'][i,:] += U\n            state['V'][i,:] += V\n        assert hasattr(state, 'Tatm')\n        assert hasattr(state, 'q')\n        assert hasattr(state, 'U')\n        assert hasattr(state, 'V')\n        conv = emanuel_convection.EmanuelConvection(state=state, timestep=DELT)\n>       conv.step_forward()\n\nclimlab/tests/test_emanuel_convection.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.convection.emanuel_convection.EmanuelConvection object at 0x7efc193cf5e0>\n\n    def _compute(self):\n        #  Invert arrays so the first element is the bottom of column\n        T = _climlab_to_convect(self.state['Tatm'])\n        dom = self.state['Tatm'].domain\n        P = _climlab_to_convect(dom.lev.points)\n        PH = _climlab_to_convect(dom.lev.bounds)\n        Q = _climlab_to_convect(self.state['q'])\n        QS = qsat(T,P)\n        ND = np.size(T, axis=1)\n        NCOL = np.size(T, axis=0)\n        NL = ND-1\n        try:\n            U = _climlab_to_convect(self.state['U'])\n        except:\n            U = np.zeros_like(T)\n        try:\n            V = _climlab_to_convect(self.state['V'])\n        except:\n            V = np.zeros_like(T)\n        NTRA = 1\n        TRA = np.zeros((NCOL,ND,NTRA), order='F')  # tracers ignored\n        DELT = float(self.timestep)\n        CBMF = self.CBMF\n        (IFLAG, FT, FQ, FU, FV, FTRA, PRECIP, WD, TPRIME, QPRIME, CBMFnew,\n        Tout, Qout, QSout, Uout, Vout, TRAout) = \\\n>           convect(T, Q, QS, U, V, TRA, P, PH, NCOL, ND, NL, NTRA, DELT, self.IPBL, CBMF,\n                    CPD, CPV, CL, RV, RD, LV0, G, ROWL, self.MINORIG,\n                    self.ELCRIT, self.TLCRIT, self.ENTP, self.SIGD, self.SIGS,\n                    self.OMTRAIN, self.OMTSNOW, self.COEFFR, self.COEFFS,\n                    self.CU, self.BETA, self.DTMAX, self.ALPHA, self.DAMP\n                    )\nE       NameError: name 'convect' is not defined\n\nclimlab/convection/emanuel_convection.py:227: NameError\n_______________________________ test_rcm_emanuel _______________________________\n\n    @pytest.mark.compiled\n    @pytest.mark.fast\n    def test_rcm_emanuel():\n        num_lev = 30\n        water_depth = 5.\n        # Temperatures in a single column\n        state = climlab.column_state(num_lev=num_lev, water_depth=water_depth)\n        #  Initialize a nearly dry column (small background stratospheric humidity)\n        state['q'] = np.ones_like(state.Tatm) * 5.E-6\n        #  ASYNCHRONOUS COUPLING -- the radiation uses a much longer timestep\n        short_timestep = climlab.constants.seconds_per_hour\n        #  The top-level model\n        model = climlab.TimeDependentProcess(name='Radiative-Convective Model',\n                            state=state,\n                            timestep=short_timestep)\n        #  Radiation coupled to water vapor\n        rad = climlab.radiation.RRTMG(name='Radiation',\n                            state=state,\n                            specific_humidity=state.q,\n                            albedo=0.3,\n                            timestep=24*short_timestep)\n        #  Convection scheme -- water vapor is a state variable\n        conv = climlab.convection.EmanuelConvection(name='Convection',\n                                      state=state,\n                                      timestep=short_timestep)\n        #  Surface heat flux processes\n        shf = climlab.surface.SensibleHeatFlux(name='SHF',\n                                      state=state, Cd=0.5E-3,\n                                      timestep=climlab.constants.seconds_per_hour)\n        lhf = climlab.surface.LatentHeatFlux(name='LHF',\n                                      state=state, Cd=0.5E-3,\n                                      timestep=short_timestep)\n        #  Couple all the submodels together\n        for proc in [rad, conv, shf, lhf]:\n            model.add_subprocess(proc.name, proc)\n>       model.step_forward()\n\nclimlab/tests/test_emanuel_convection.py:152: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.rrtm.rrtmg_sw.RRTMG_SW object at 0x7efc192b6050>\n\n    def _compute_heating_rates(self):\n        '''Prepare arguments and call the RRTGM_SW driver to calculate\n        radiative fluxes and heating rates'''\n        (ncol, nlay, icld, iaer, permuteseed, irng,\n         play, plev, tlay, tlev, tsfc,\n         h2ovmr, o3vmr, co2vmr, ch4vmr, n2ovmr, o2vmr,\n         aldif, aldir, asdif, asdir, coszen, adjes, dyofyr, scon, isolvar,\n         indsolvar, bndsolvar, solcycfrac,\n         inflgsw, iceflgsw, liqflgsw,\n         cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc,\n         tauaer, ssaaer, asmaer, ecaer,) = self._prepare_sw_arguments()\n        if icld == 0:  # clear-sky only\n            cldfmcl = np.zeros((ngptsw,ncol,nlay))\n            ciwpmcl = np.zeros((ngptsw,ncol,nlay))\n            clwpmcl = np.zeros((ngptsw,ncol,nlay))\n            reicmcl = np.zeros((ncol,nlay))\n            relqmcl = np.zeros((ncol,nlay))\n            taucmcl = np.zeros((ngptsw,ncol,nlay))\n            ssacmcl = np.zeros((ngptsw,ncol,nlay))\n            asmcmcl = np.zeros((ngptsw,ncol,nlay))\n            fsfcmcl = np.zeros((ngptsw,ncol,nlay))\n        else:\n            #  Call the Monte Carlo Independent Column Approximation (McICA, Pincus et al., JC, 2003)\n            (cldfmcl, ciwpmcl, clwpmcl, reicmcl, relqmcl, taucmcl,\n>           ssacmcl, asmcmcl, fsfcmcl) = _rrtmg_sw.climlab_mcica_subcol_sw(\n                            ncol, nlay, icld, permuteseed, irng, play,\n                            cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc)\nE           NameError: name '_rrtmg_sw' is not defined\n\nclimlab/radiation/rrtm/rrtmg_sw.py:208: NameError\n________________________________ test_diffmodel ________________________________\n\ndiffmodel = <climlab.model.column.RadiativeConvectiveModel object at 0x7efc193655d0>\n\n    @pytest.mark.slow\n    def test_diffmodel(diffmodel):\n        \"\"\"Check that we can integrate the model with diffusion.\"\"\"\n>       diffmodel.step_forward()\n\nclimlab/tests/test_grey_radiation.py:78: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[ 21.76091467, -20.76091467,   0.        , ...,   0.        ,\n           0.        ,   0.        ],\n        [ ... 0.        ,   0.        ,   0.        , ...,   0.        ,\n         -20.76091467,  21.76091467]]], shape=(30, 90, 90))\nb = array([[200.59660818, 200.59660818, 200.59660818, ..., 200.59660818,\n        200.59660818, 200.59660818],\n       [203....    [276.58799194, 276.58799194, 276.58799194, ..., 276.58799194,\n        276.58799194, 276.58799194]], shape=(30, 90))\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 30 is different from 90)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n_____________________________ test_orbital_cycles ______________________________\n\n    @pytest.mark.slow\n    def test_orbital_cycles():\n        ebm = EBM_seasonal()\n        #  add an albedo feedback\n        alb = StepFunctionAlbedo(state=ebm.state, **ebm.param)\n        ebm.add_subprocess('albedo', alb)\n        ebm.subprocess['SW'].albedo = alb.albedo\n        #  run for 1,000 orbital years, but only 100 model years\n>       experiment = OrbitalCycles(ebm, kyear_start=-20, kyear_stop=-19,\n                                   orbital_year_factor=10.)\n\nclimlab/tests/test_insolation.py:79: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/solar/orbital_cycles.py:158: in __init__\n    self.model.integrate_years(segment_length_years-1., verbose=False)\nclimlab/process/time_dependent_process.py:419: in integrate_years\n    self.step_forward()\nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:220: in compute\n    tendencies['implicit'] = self._compute_type('implicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/implicit.py:47: in _compute\n    newstate = self._implicit_solver()\nclimlab/dynamics/advection_diffusion.py:193: in _implicit_solver\n    result = adv_diff_numerics.implicit_step_forward(field,\nclimlab/dynamics/adv_diff_numerics.py:428: in implicit_step_forward\n    return solve(IminusTdt, RHS)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([[[ 8.63805809, -7.63805809,  0.        , ...,  0.        ,\n          0.        ,  0.        ],\n        [-2.5470...     [ 0.        ,  0.        ,  0.        , ...,  0.        ,\n         -7.63805809,  8.63805809]]], shape=(1, 90, 90))\nb = array([[-27.52315749, -27.38167176, -27.09939738, -26.67772515,\n        -26.11873275, -25.42517459, -24.6004684 , -23....96, -26.30614489,\n        -27.14355499, -27.84772346, -28.41521967, -28.84327883,\n        -29.12981549, -29.27343367]])\n\n    @array_function_dispatch(_solve_dispatcher)\n    def solve(a, b):\n        \"\"\"\n        Solve a linear matrix equation, or system of linear scalar equations.\n    \n        Computes the \"exact\" solution, `x`, of the well-determined, i.e., full\n        rank, linear matrix equation `ax = b`.\n    \n        Parameters\n        ----------\n        a : (..., M, M) array_like\n            Coefficient matrix.\n        b : {(M,), (..., M, K)}, array_like\n            Ordinate or \"dependent variable\" values.\n    \n        Returns\n        -------\n        x : {(..., M,), (..., M, K)} ndarray\n            Solution to the system a x = b.  Returned shape is (..., M) if b is\n            shape (M,) and (..., M, K) if b is (..., M, K), where the \"...\" part is\n            broadcasted between a and b.\n    \n        Raises\n        ------\n        LinAlgError\n            If `a` is singular or not square.\n    \n        See Also\n        --------\n        scipy.linalg.solve : Similar function in SciPy.\n    \n        Notes\n        -----\n        Broadcasting rules apply, see the `numpy.linalg` documentation for\n        details.\n    \n        The solutions are computed using LAPACK routine ``_gesv``.\n    \n        `a` must be square and of full-rank, i.e., all rows (or, equivalently,\n        columns) must be linearly independent; if either is not true, use\n        `lstsq` for the least-squares best \"solution\" of the\n        system/equation.\n    \n        .. versionchanged:: 2.0\n    \n           The b array is only treated as a shape (M,) column vector if it is\n           exactly 1-dimensional. In all other instances it is treated as a stack\n           of (M, K) matrices. Previously b would be treated as a stack of (M,)\n           vectors if b.ndim was equal to a.ndim - 1.\n    \n        References\n        ----------\n        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n               FL, Academic Press, Inc., 1980, pg. 22.\n    \n        Examples\n        --------\n        Solve the system of equations:\n        ``x0 + 2 * x1 = 1`` and\n        ``3 * x0 + 5 * x1 = 2``:\n    \n        >>> import numpy as np\n        >>> a = np.array([[1, 2], [3, 5]])\n        >>> b = np.array([1, 2])\n        >>> x = np.linalg.solve(a, b)\n        >>> x\n        array([-1.,  1.])\n    \n        Check that the solution is correct:\n    \n        >>> np.allclose(np.dot(a, x), b)\n        True\n    \n        \"\"\"\n        a, _ = _makearray(a)\n        _assert_stacked_2d(a)\n        _assert_stacked_square(a)\n        b, wrap = _makearray(b)\n        t, result_t = _commonType(a, b)\n    \n        # We use the b = (..., M,) logic, only if the number of extra dimensions\n        # match exactly\n        if b.ndim == 1:\n            gufunc = _umath_linalg.solve1\n        else:\n            gufunc = _umath_linalg.solve\n    \n        signature = 'DD->D' if isComplexType(t) else 'dd->d'\n        with errstate(call=_raise_linalgerror_singular, invalid='call',\n                      over='ignore', divide='ignore', under='ignore'):\n>           r = gufunc(a, b, signature=signature)\nE           ValueError: solve: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (m,m),(m,n)->(m,n) (size 1 is different from 90)\n\n/usr/local/lib/python3.10/dist-packages/numpy/linalg/_linalg.py:410: ValueError\n----------------------------- Captured stdout call -----------------------------\n---------  OrbitalCycles  START ----------\nBeginning integration for the model from -20 to -19 kyears before present.\nIntegration time for each set of orbital parameters is 100.0 years.\nOrbital cycles will be sped up by a factor 10.0\nTotal number of segments is 1\n-------------------------\nSegment 0 out of 1\nUsing orbital parameters from -20 kyears before present.\n__________________________ test_convective_adjustment __________________________\n\nrcm = <climlab.process.time_dependent_process.TimeDependentProcess object at 0x7efc16e1ef80>\n\n    @pytest.mark.compiled\n    @pytest.mark.fast\n    def test_convective_adjustment(rcm):\n>       rcm.step_forward()\n\nclimlab/tests/test_rcm.py:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.rrtm.rrtmg_sw.RRTMG_SW object at 0x7efc16e1da50>\n\n    def _compute_heating_rates(self):\n        '''Prepare arguments and call the RRTGM_SW driver to calculate\n        radiative fluxes and heating rates'''\n        (ncol, nlay, icld, iaer, permuteseed, irng,\n         play, plev, tlay, tlev, tsfc,\n         h2ovmr, o3vmr, co2vmr, ch4vmr, n2ovmr, o2vmr,\n         aldif, aldir, asdif, asdir, coszen, adjes, dyofyr, scon, isolvar,\n         indsolvar, bndsolvar, solcycfrac,\n         inflgsw, iceflgsw, liqflgsw,\n         cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc,\n         tauaer, ssaaer, asmaer, ecaer,) = self._prepare_sw_arguments()\n        if icld == 0:  # clear-sky only\n            cldfmcl = np.zeros((ngptsw,ncol,nlay))\n            ciwpmcl = np.zeros((ngptsw,ncol,nlay))\n            clwpmcl = np.zeros((ngptsw,ncol,nlay))\n            reicmcl = np.zeros((ncol,nlay))\n            relqmcl = np.zeros((ncol,nlay))\n            taucmcl = np.zeros((ngptsw,ncol,nlay))\n            ssacmcl = np.zeros((ngptsw,ncol,nlay))\n            asmcmcl = np.zeros((ngptsw,ncol,nlay))\n            fsfcmcl = np.zeros((ngptsw,ncol,nlay))\n        else:\n            #  Call the Monte Carlo Independent Column Approximation (McICA, Pincus et al., JC, 2003)\n            (cldfmcl, ciwpmcl, clwpmcl, reicmcl, relqmcl, taucmcl,\n>           ssacmcl, asmcmcl, fsfcmcl) = _rrtmg_sw.climlab_mcica_subcol_sw(\n                            ncol, nlay, icld, permuteseed, irng, play,\n                            cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc)\nE           NameError: name '_rrtmg_sw' is not defined\n\nclimlab/radiation/rrtm/rrtmg_sw.py:208: NameError\n_______________________________ test_coupled_rcm _______________________________\n\nrcm = <climlab.process.time_dependent_process.TimeDependentProcess object at 0x7efc193ce890>\n\n    @pytest.mark.compiled\n    @pytest.mark.fast\n    def test_coupled_rcm(rcm):\n        deltat = rcm.timestep\n        ocean_bounds = np.arange(0., 2010., 100.)\n        depthax = climlab.Axis(axis_type='depth', bounds=ocean_bounds)\n        ocean = climlab.domain.domain.Ocean(axes=depthax)\n        ocean_diff = 5.E-4\n        Tinitial_ocean = rcm.Ts * np.ones(ocean.shape)\n        Tocean = climlab.Field(Tinitial_ocean.copy(), domain=ocean)\n        Tatm = rcm.Tatm\n        #  Surface temperature Ts is the upper-most grid box of the ocean\n        Ts = Tocean[0:1]\n        atm_state = {'Tatm': Tatm, 'Ts': Ts}\n        rad = climlab.radiation.RRTMG(name='Radiation',\n                                      state=atm_state,\n                                      specific_humidity=rcm.specific_humidity,\n                                      timestep = deltat,\n                                      albedo = 0.25,\n                                     )\n        conv = climlab.convection.ConvectiveAdjustment(name='Convection',\n                                                       state=atm_state,\n                                                       adj_lapse_rate=6.5,\n                                                       timestep=deltat,)\n    \n        model = rad + conv\n        model.set_state('Tocean', Tocean)\n        diff = climlab.dynamics.Diffusion(state={'Tocean': Tocean},\n                                    K=ocean_diff,\n                                    diffusion_axis='depth',\n                                    timestep=deltat * 10,)\n        model.add_subprocess('Ocean Heat Uptake', diff)\n        for i in range(10):\n>           model.step_forward()\n\nclimlab/tests/test_rcm.py:77: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.rrtm.rrtmg_sw.RRTMG_SW object at 0x7efc193cee60>\n\n    def _compute_heating_rates(self):\n        '''Prepare arguments and call the RRTGM_SW driver to calculate\n        radiative fluxes and heating rates'''\n        (ncol, nlay, icld, iaer, permuteseed, irng,\n         play, plev, tlay, tlev, tsfc,\n         h2ovmr, o3vmr, co2vmr, ch4vmr, n2ovmr, o2vmr,\n         aldif, aldir, asdif, asdir, coszen, adjes, dyofyr, scon, isolvar,\n         indsolvar, bndsolvar, solcycfrac,\n         inflgsw, iceflgsw, liqflgsw,\n         cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc,\n         tauaer, ssaaer, asmaer, ecaer,) = self._prepare_sw_arguments()\n        if icld == 0:  # clear-sky only\n            cldfmcl = np.zeros((ngptsw,ncol,nlay))\n            ciwpmcl = np.zeros((ngptsw,ncol,nlay))\n            clwpmcl = np.zeros((ngptsw,ncol,nlay))\n            reicmcl = np.zeros((ncol,nlay))\n            relqmcl = np.zeros((ncol,nlay))\n            taucmcl = np.zeros((ngptsw,ncol,nlay))\n            ssacmcl = np.zeros((ngptsw,ncol,nlay))\n            asmcmcl = np.zeros((ngptsw,ncol,nlay))\n            fsfcmcl = np.zeros((ngptsw,ncol,nlay))\n        else:\n            #  Call the Monte Carlo Independent Column Approximation (McICA, Pincus et al., JC, 2003)\n            (cldfmcl, ciwpmcl, clwpmcl, reicmcl, relqmcl, taucmcl,\n>           ssacmcl, asmcmcl, fsfcmcl) = _rrtmg_sw.climlab_mcica_subcol_sw(\n                            ncol, nlay, icld, permuteseed, irng, play,\n                            cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc)\nE           NameError: name '_rrtmg_sw' is not defined\n\nclimlab/radiation/rrtm/rrtmg_sw.py:208: NameError\n______________________________ test_rrtm_creation ______________________________\n\n    @pytest.mark.compiled\n    @pytest.mark.fast\n    def test_rrtm_creation():\n        # initial state (temperatures)\n        state = climlab.column_state(num_lev=num_lev, num_lat=1, water_depth=5.)\n        #  Create a RRTM radiation model\n        rad = climlab.radiation.RRTMG(state=state)\n>       rad.step_forward()\n\nclimlab/tests/test_rrtm.py:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.rrtm.rrtmg_sw.RRTMG_SW object at 0x7efc179c7f40>\n\n    def _compute_heating_rates(self):\n        '''Prepare arguments and call the RRTGM_SW driver to calculate\n        radiative fluxes and heating rates'''\n        (ncol, nlay, icld, iaer, permuteseed, irng,\n         play, plev, tlay, tlev, tsfc,\n         h2ovmr, o3vmr, co2vmr, ch4vmr, n2ovmr, o2vmr,\n         aldif, aldir, asdif, asdir, coszen, adjes, dyofyr, scon, isolvar,\n         indsolvar, bndsolvar, solcycfrac,\n         inflgsw, iceflgsw, liqflgsw,\n         cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc,\n         tauaer, ssaaer, asmaer, ecaer,) = self._prepare_sw_arguments()\n        if icld == 0:  # clear-sky only\n            cldfmcl = np.zeros((ngptsw,ncol,nlay))\n            ciwpmcl = np.zeros((ngptsw,ncol,nlay))\n            clwpmcl = np.zeros((ngptsw,ncol,nlay))\n            reicmcl = np.zeros((ncol,nlay))\n            relqmcl = np.zeros((ncol,nlay))\n            taucmcl = np.zeros((ngptsw,ncol,nlay))\n            ssacmcl = np.zeros((ngptsw,ncol,nlay))\n            asmcmcl = np.zeros((ngptsw,ncol,nlay))\n            fsfcmcl = np.zeros((ngptsw,ncol,nlay))\n        else:\n            #  Call the Monte Carlo Independent Column Approximation (McICA, Pincus et al., JC, 2003)\n            (cldfmcl, ciwpmcl, clwpmcl, reicmcl, relqmcl, taucmcl,\n>           ssacmcl, asmcmcl, fsfcmcl) = _rrtmg_sw.climlab_mcica_subcol_sw(\n                            ncol, nlay, icld, permuteseed, irng, play,\n                            cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc)\nE           NameError: name '_rrtmg_sw' is not defined\n\nclimlab/radiation/rrtm/rrtmg_sw.py:208: NameError\n_____________________________ test_swap_component ______________________________\n\n    @pytest.mark.compiled\n    @pytest.mark.fast\n    def test_swap_component():\n        # initial state (temperatures)\n        state = climlab.column_state(num_lev=num_lev, num_lat=1, water_depth=5.)\n        #  Create a RRTM radiation model\n        rad = climlab.radiation.RRTMG(state=state)\n>       rad.step_forward()\n\nclimlab/tests/test_rrtm.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.rrtm.rrtmg_sw.RRTMG_SW object at 0x7efc179b4760>\n\n    def _compute_heating_rates(self):\n        '''Prepare arguments and call the RRTGM_SW driver to calculate\n        radiative fluxes and heating rates'''\n        (ncol, nlay, icld, iaer, permuteseed, irng,\n         play, plev, tlay, tlev, tsfc,\n         h2ovmr, o3vmr, co2vmr, ch4vmr, n2ovmr, o2vmr,\n         aldif, aldir, asdif, asdir, coszen, adjes, dyofyr, scon, isolvar,\n         indsolvar, bndsolvar, solcycfrac,\n         inflgsw, iceflgsw, liqflgsw,\n         cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc,\n         tauaer, ssaaer, asmaer, ecaer,) = self._prepare_sw_arguments()\n        if icld == 0:  # clear-sky only\n            cldfmcl = np.zeros((ngptsw,ncol,nlay))\n            ciwpmcl = np.zeros((ngptsw,ncol,nlay))\n            clwpmcl = np.zeros((ngptsw,ncol,nlay))\n            reicmcl = np.zeros((ncol,nlay))\n            relqmcl = np.zeros((ncol,nlay))\n            taucmcl = np.zeros((ngptsw,ncol,nlay))\n            ssacmcl = np.zeros((ngptsw,ncol,nlay))\n            asmcmcl = np.zeros((ngptsw,ncol,nlay))\n            fsfcmcl = np.zeros((ngptsw,ncol,nlay))\n        else:\n            #  Call the Monte Carlo Independent Column Approximation (McICA, Pincus et al., JC, 2003)\n            (cldfmcl, ciwpmcl, clwpmcl, reicmcl, relqmcl, taucmcl,\n>           ssacmcl, asmcmcl, fsfcmcl) = _rrtmg_sw.climlab_mcica_subcol_sw(\n                            ncol, nlay, icld, permuteseed, irng, play,\n                            cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc)\nE           NameError: name '_rrtmg_sw' is not defined\n\nclimlab/radiation/rrtm/rrtmg_sw.py:208: NameError\n________________________________ test_multidim _________________________________\n\n    @pytest.mark.compiled\n    @pytest.mark.fast\n    def test_multidim():\n        state = climlab.column_state(num_lev=40, num_lat=3, water_depth=5.)\n        rad = climlab.radiation.RRTMG_LW(state=state)\n        #  are the transformations reversible?\n        assert np.all(_rrtm_to_climlab(_climlab_to_rrtm(rad.Ts)) == rad.Ts)\n        assert np.all(_rrtm_to_climlab(_climlab_to_rrtm(rad.Tatm)) == rad.Tatm)\n        # Can we integrate?\n>       rad.step_forward()\n\nclimlab/tests/test_rrtm.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.rrtm.rrtmg_lw.RRTMG_LW object at 0x7efc193659f0>\n\n    def _compute_heating_rates(self):\n        '''Prepare arguments and call the RRTGM_LW driver to calculate\n        radiative fluxes and heating rates'''\n        (ncol, nlay, icld, ispec, permuteseed, irng, idrv, cp,\n                play, plev, tlay, tlev, tsfc,\n                h2ovmr, o3vmr, co2vmr, ch4vmr, n2ovmr, o2vmr,\n                cfc11vmr, cfc12vmr, cfc22vmr, ccl4vmr, emis,\n                inflglw, iceflglw, liqflglw,\n                cldfrac, ciwp, clwp, reic, relq, tauc, tauaer,) = self._prepare_lw_arguments()\n        if icld == 0:  # clear-sky only\n            cldfmcl = np.zeros((ngptlw,ncol,nlay))\n            ciwpmcl = np.zeros((ngptlw,ncol,nlay))\n            clwpmcl = np.zeros((ngptlw,ncol,nlay))\n            reicmcl = np.zeros((ncol,nlay))\n            relqmcl = np.zeros((ncol,nlay))\n            taucmcl = np.zeros((ngptlw,ncol,nlay))\n        else:\n            #  Call the Monte Carlo Independent Column Approximation (McICA, Pincus et al., JC, 2003)\n            (cldfmcl, ciwpmcl, clwpmcl, reicmcl, relqmcl, taucmcl) = \\\n>               _rrtmg_lw.climlab_mcica_subcol_lw(\n                            ncol, nlay, icld,\n                            permuteseed, irng, play,\n                            cldfrac, ciwp, clwp, reic, relq, tauc)\nE           NameError: name '_rrtmg_lw' is not defined\n\nclimlab/radiation/rrtm/rrtmg_lw.py:129: NameError\n__________________________________ test_cloud __________________________________\n\n    @pytest.mark.compiled\n    @pytest.mark.fast\n    def test_cloud():\n        '''Put a high cloud layer in a radiative model.\n        The all-sky ASR should be lower than clear-sky ASR.\n        The all-sky OLR should be lower than clear-sky OLR.'''\n        #  State variables (Air and surface temperature)\n        state = climlab.column_state(num_lev=50, water_depth=1.)\n        lev = state.Tatm.domain.axes['lev'].points\n        #  Define some local cloud characteristics\n        cldfrac = 0.5  # layer cloud fraction\n        r_liq = 14.  # Cloud water drop effective radius (microns)\n        clwp = 60.  # in-cloud liquid water path (g/m2)\n        #  The cloud fraction is a Gaussian bump centered at level i\n        i = 25\n        mycloud = {'cldfrac': cldfrac*np.exp(-(lev-lev[i])**2/(2*25.)**2),\n                   'clwp': np.zeros_like(state.Tatm) + clwp,\n                   'r_liq': np.zeros_like(state.Tatm) + r_liq,}\n        #  Test both RRTMG and CAM3:\n        #for module in [climlab.radiation.RRTMG, climlab.radiation.CAM3]:\n        #  Apparently clouds in CAM3 are not working. Save this for later\n        for module in [climlab.radiation.RRTMG]:\n            rad = module(state=state, **mycloud)\n>           rad.compute_diagnostics()\n\nclimlab/tests/test_rrtm.py:86: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:352: in compute_diagnostics\n    ignored = self.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.rrtm.rrtmg_sw.RRTMG_SW object at 0x7efc193d4e80>\n\n    def _compute_heating_rates(self):\n        '''Prepare arguments and call the RRTGM_SW driver to calculate\n        radiative fluxes and heating rates'''\n        (ncol, nlay, icld, iaer, permuteseed, irng,\n         play, plev, tlay, tlev, tsfc,\n         h2ovmr, o3vmr, co2vmr, ch4vmr, n2ovmr, o2vmr,\n         aldif, aldir, asdif, asdir, coszen, adjes, dyofyr, scon, isolvar,\n         indsolvar, bndsolvar, solcycfrac,\n         inflgsw, iceflgsw, liqflgsw,\n         cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc,\n         tauaer, ssaaer, asmaer, ecaer,) = self._prepare_sw_arguments()\n        if icld == 0:  # clear-sky only\n            cldfmcl = np.zeros((ngptsw,ncol,nlay))\n            ciwpmcl = np.zeros((ngptsw,ncol,nlay))\n            clwpmcl = np.zeros((ngptsw,ncol,nlay))\n            reicmcl = np.zeros((ncol,nlay))\n            relqmcl = np.zeros((ncol,nlay))\n            taucmcl = np.zeros((ngptsw,ncol,nlay))\n            ssacmcl = np.zeros((ngptsw,ncol,nlay))\n            asmcmcl = np.zeros((ngptsw,ncol,nlay))\n            fsfcmcl = np.zeros((ngptsw,ncol,nlay))\n        else:\n            #  Call the Monte Carlo Independent Column Approximation (McICA, Pincus et al., JC, 2003)\n            (cldfmcl, ciwpmcl, clwpmcl, reicmcl, relqmcl, taucmcl,\n>           ssacmcl, asmcmcl, fsfcmcl) = _rrtmg_sw.climlab_mcica_subcol_sw(\n                            ncol, nlay, icld, permuteseed, irng, play,\n                            cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc)\nE           NameError: name '_rrtmg_sw' is not defined\n\nclimlab/radiation/rrtm/rrtmg_sw.py:208: NameError\n____________________________ test_radiative_forcing ____________________________\n\n    @pytest.mark.compiled\n    @pytest.mark.slow\n    def test_radiative_forcing():\n        '''Run a single-column radiative-convective model with RRTMG radiation\n        out to equilibrium. Clone the model, double CO2 and measure the instantaneous\n        change in TOA flux. It should be positive net downward flux.'''\n        #  State variables (Air and surface temperature)\n        state = climlab.column_state(num_lev=30, water_depth=1.)\n        #  Fixed relative humidity\n        h2o = climlab.radiation.ManabeWaterVapor(name='WaterVapor', state=state)\n        #  Couple water vapor to radiation\n        #   Set icld=0 for clear-sky only (no need to call cloud overlap routine)\n        rad = climlab.radiation.RRTMG(name='Radiation',\n                                      state=state,\n                                      specific_humidity=h2o.q,\n                                      icld=0)\n        #  Convective adjustment\n        conv = climlab.convection.ConvectiveAdjustment(name='Convection',\n                                                       state=state,\n                                                       adj_lapse_rate=6.5)\n        #  Couple everything together\n        rcm = climlab.couple([rad,h2o,conv], name='Radiative-Convective Model')\n    \n>       rcm.integrate_years(5.)\n\nclimlab/tests/test_rrtm.py:113: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:419: in integrate_years\n    self.step_forward()\nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.rrtm.rrtmg_sw.RRTMG_SW object at 0x7efc1938eda0>\n\n    def _compute_heating_rates(self):\n        '''Prepare arguments and call the RRTGM_SW driver to calculate\n        radiative fluxes and heating rates'''\n        (ncol, nlay, icld, iaer, permuteseed, irng,\n         play, plev, tlay, tlev, tsfc,\n         h2ovmr, o3vmr, co2vmr, ch4vmr, n2ovmr, o2vmr,\n         aldif, aldir, asdif, asdir, coszen, adjes, dyofyr, scon, isolvar,\n         indsolvar, bndsolvar, solcycfrac,\n         inflgsw, iceflgsw, liqflgsw,\n         cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc,\n         tauaer, ssaaer, asmaer, ecaer,) = self._prepare_sw_arguments()\n        if icld == 0:  # clear-sky only\n            cldfmcl = np.zeros((ngptsw,ncol,nlay))\n            ciwpmcl = np.zeros((ngptsw,ncol,nlay))\n            clwpmcl = np.zeros((ngptsw,ncol,nlay))\n            reicmcl = np.zeros((ncol,nlay))\n            relqmcl = np.zeros((ncol,nlay))\n            taucmcl = np.zeros((ngptsw,ncol,nlay))\n            ssacmcl = np.zeros((ngptsw,ncol,nlay))\n            asmcmcl = np.zeros((ngptsw,ncol,nlay))\n            fsfcmcl = np.zeros((ngptsw,ncol,nlay))\n        else:\n            #  Call the Monte Carlo Independent Column Approximation (McICA, Pincus et al., JC, 2003)\n            (cldfmcl, ciwpmcl, clwpmcl, reicmcl, relqmcl, taucmcl,\n            ssacmcl, asmcmcl, fsfcmcl) = _rrtmg_sw.climlab_mcica_subcol_sw(\n                            ncol, nlay, icld, permuteseed, irng, play,\n                            cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc)\n        #  Call the RRTMG_SW driver to compute radiative fluxes\n        (swuflx, swdflx, swhr, swuflxc, swdflxc, swhrc) = \\\n>           _rrtmg_sw.climlab_rrtmg_sw(ncol, nlay, icld, iaer,\n                play, plev, tlay, tlev, tsfc,\n                h2ovmr, o3vmr, co2vmr, ch4vmr, n2ovmr, o2vmr,\n                asdir, asdif, aldir, aldif,\n                coszen, adjes, dyofyr, scon, isolvar,\n                inflgsw, iceflgsw, liqflgsw, cldfmcl,\n                taucmcl, ssacmcl, asmcmcl, fsfcmcl,\n                ciwpmcl, clwpmcl, reicmcl, relqmcl,\n                tauaer, ssaaer, asmaer, ecaer,\n                bndsolvar, indsolvar, solcycfrac)\nE       NameError: name '_rrtmg_sw' is not defined\n\nclimlab/radiation/rrtm/rrtmg_sw.py:213: NameError\n----------------------------- Captured stdout call -----------------------------\nIntegrating for 1826 steps, 1826.2110000000002 days, or 5.0 years.\n________________________________ test_latitude _________________________________\n\n    @pytest.mark.compiled\n    @pytest.mark.slow\n    def test_latitude():\n        '''\n        Run a radiative equilibrum model with RRTMG radiation out to equilibrium\n        with an annual mean insolation profile as a function of latitude.\n        '''\n        num_lat = 8\n        #  State variables (Air and surface temperature)\n        state = climlab.column_state(num_lev=30, num_lat=num_lat, water_depth=1.)\n        #  insolation\n        #sol = climlab.radiation.AnnualMeanInsolation(domains=model.Ts.domain)\n        sol = climlab.radiation.AnnualMeanInsolation(name='Insolation',\n                                                     domains=state.Ts.domain)\n        #  radiation module with insolation as input\n        #   Set icld=0 for clear-sky only (no need to call cloud overlap routine)\n        rad = climlab.radiation.RRTMG(name='Radiation', state=state, icld=0,\n                                      S0=sol.S0,\n                                      insolation=sol.insolation,\n                                      coszen=sol.coszen)\n        #  Couple everything together\n        model = rad + sol\n        #  Run out to equilibrium\n>       model.integrate_years(2.)\n\nclimlab/tests/test_rrtm.py:145: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:419: in integrate_years\n    self.step_forward()\nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.rrtm.rrtmg_sw.RRTMG_SW object at 0x7efc179b6e90>\n\n    def _compute_heating_rates(self):\n        '''Prepare arguments and call the RRTGM_SW driver to calculate\n        radiative fluxes and heating rates'''\n        (ncol, nlay, icld, iaer, permuteseed, irng,\n         play, plev, tlay, tlev, tsfc,\n         h2ovmr, o3vmr, co2vmr, ch4vmr, n2ovmr, o2vmr,\n         aldif, aldir, asdif, asdir, coszen, adjes, dyofyr, scon, isolvar,\n         indsolvar, bndsolvar, solcycfrac,\n         inflgsw, iceflgsw, liqflgsw,\n         cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc,\n         tauaer, ssaaer, asmaer, ecaer,) = self._prepare_sw_arguments()\n        if icld == 0:  # clear-sky only\n            cldfmcl = np.zeros((ngptsw,ncol,nlay))\n            ciwpmcl = np.zeros((ngptsw,ncol,nlay))\n            clwpmcl = np.zeros((ngptsw,ncol,nlay))\n            reicmcl = np.zeros((ncol,nlay))\n            relqmcl = np.zeros((ncol,nlay))\n            taucmcl = np.zeros((ngptsw,ncol,nlay))\n            ssacmcl = np.zeros((ngptsw,ncol,nlay))\n            asmcmcl = np.zeros((ngptsw,ncol,nlay))\n            fsfcmcl = np.zeros((ngptsw,ncol,nlay))\n        else:\n            #  Call the Monte Carlo Independent Column Approximation (McICA, Pincus et al., JC, 2003)\n            (cldfmcl, ciwpmcl, clwpmcl, reicmcl, relqmcl, taucmcl,\n            ssacmcl, asmcmcl, fsfcmcl) = _rrtmg_sw.climlab_mcica_subcol_sw(\n                            ncol, nlay, icld, permuteseed, irng, play,\n                            cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc)\n        #  Call the RRTMG_SW driver to compute radiative fluxes\n        (swuflx, swdflx, swhr, swuflxc, swdflxc, swhrc) = \\\n>           _rrtmg_sw.climlab_rrtmg_sw(ncol, nlay, icld, iaer,\n                play, plev, tlay, tlev, tsfc,\n                h2ovmr, o3vmr, co2vmr, ch4vmr, n2ovmr, o2vmr,\n                asdir, asdif, aldir, aldif,\n                coszen, adjes, dyofyr, scon, isolvar,\n                inflgsw, iceflgsw, liqflgsw, cldfmcl,\n                taucmcl, ssacmcl, asmcmcl, fsfcmcl,\n                ciwpmcl, clwpmcl, reicmcl, relqmcl,\n                tauaer, ssaaer, asmaer, ecaer,\n                bndsolvar, indsolvar, solcycfrac)\nE       NameError: name '_rrtmg_sw' is not defined\n\nclimlab/radiation/rrtm/rrtmg_sw.py:213: NameError\n----------------------------- Captured stdout call -----------------------------\nIntegrating for 730 steps, 730.4844 days, or 2.0 years.\n____________________________ test_fixed_insolation _____________________________\n\n    @pytest.mark.compiled\n    @pytest.mark.fast\n    def test_fixed_insolation():\n        '''Make sure that we can run a model forward with specified time-invariant insolation'''\n        num_lat = 4; num_lev = 20   # grid size\n        day_of_year = 80.  # days since Jan 1\n        lat = np.linspace(-80., 80., num_lat)\n        state = climlab.column_state(num_lev=num_lev, lat=lat)\n        insolation = climlab.solar.insolation.daily_insolation(lat=lat, day=day_of_year)\n        ins_array = insolation.values\n        rad = climlab.radiation.RRTMG(name='Radiation', state=state, insolation=ins_array)\n>       rad.step_forward()\n\nclimlab/tests/test_rrtm.py:181: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:213: in compute\n    tendencies['explicit'] = self._compute_type('explicit')\nclimlab/process/time_dependent_process.py:261: in _compute_type\n    tenddict = proc.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.rrtm.rrtmg_sw.RRTMG_SW object at 0x7efc19367e20>\n\n    def _compute_heating_rates(self):\n        '''Prepare arguments and call the RRTGM_SW driver to calculate\n        radiative fluxes and heating rates'''\n        (ncol, nlay, icld, iaer, permuteseed, irng,\n         play, plev, tlay, tlev, tsfc,\n         h2ovmr, o3vmr, co2vmr, ch4vmr, n2ovmr, o2vmr,\n         aldif, aldir, asdif, asdir, coszen, adjes, dyofyr, scon, isolvar,\n         indsolvar, bndsolvar, solcycfrac,\n         inflgsw, iceflgsw, liqflgsw,\n         cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc,\n         tauaer, ssaaer, asmaer, ecaer,) = self._prepare_sw_arguments()\n        if icld == 0:  # clear-sky only\n            cldfmcl = np.zeros((ngptsw,ncol,nlay))\n            ciwpmcl = np.zeros((ngptsw,ncol,nlay))\n            clwpmcl = np.zeros((ngptsw,ncol,nlay))\n            reicmcl = np.zeros((ncol,nlay))\n            relqmcl = np.zeros((ncol,nlay))\n            taucmcl = np.zeros((ngptsw,ncol,nlay))\n            ssacmcl = np.zeros((ngptsw,ncol,nlay))\n            asmcmcl = np.zeros((ngptsw,ncol,nlay))\n            fsfcmcl = np.zeros((ngptsw,ncol,nlay))\n        else:\n            #  Call the Monte Carlo Independent Column Approximation (McICA, Pincus et al., JC, 2003)\n            (cldfmcl, ciwpmcl, clwpmcl, reicmcl, relqmcl, taucmcl,\n>           ssacmcl, asmcmcl, fsfcmcl) = _rrtmg_sw.climlab_mcica_subcol_sw(\n                            ncol, nlay, icld, permuteseed, irng, play,\n                            cldfrac, ciwp, clwp, reic, relq, tauc, ssac, asmc, fsfc)\nE           NameError: name '_rrtmg_sw' is not defined\n\nclimlab/radiation/rrtm/rrtmg_sw.py:208: NameError\n_______________________________ test_large_grid ________________________________\n\n    @pytest.mark.compiled\n    @pytest.mark.fast\n    def test_large_grid():\n        num_lev = 50; num_lat=90\n        state = climlab.column_state(num_lev=num_lev, num_lat=num_lat, water_depth=10.)\n        rad1 = climlab.radiation.CAM3(state=state)\n>       rad1.step_forward()\n\nclimlab/tests/test_rrtm.py:189: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nclimlab/process/time_dependent_process.py:333: in step_forward\n    tenddict = self.compute()\nclimlab/process/time_dependent_process.py:235: in compute\n    self_tend = self._compute()\nclimlab/process/energy_budget.py:72: in _compute\n    tendencies = self._temperature_tendencies()\nclimlab/process/energy_budget.py:60: in _temperature_tendencies\n    self._compute_heating_rates()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <climlab.radiation.cam3.CAM3 object at 0x7efc16e94a60>\n\n    def _compute_heating_rates(self):\n        # List of arguments to be passed to extension\n        args = self._prepare_arguments()\n        (TdotRad, SrfRadFlx, qrs, qrl, swflx, swflxc, lwflx, lwflxc, SwToaCf,\n            SwSrfCf, LwToaCf, LwSrfCf, LwToa, LwSrf, SwToa, SwSrf,\n            swuflx, swdflx, swuflxc, swdflxc,\n>           lwuflx, lwdflx, lwuflxc, lwdflxc) = _cam3.driver(*args)\nE       NameError: name '_cam3' is not defined\n\nclimlab/radiation/cam3.py:175: NameError\n=============================== warnings summary ===============================\nclimlab/radiation/cam3.py:46\n  /app/repo_to_process/climlab/radiation/cam3.py:46: UserWarning: Cannot import and initialize compiled Fortran extension, CAM3 module will not be functional.\n    warnings.warn('Cannot import and initialize compiled Fortran extension, CAM3 module will not be functional.')\n\nclimlab/radiation/rrtm/rrtmg_lw.py:19\n  /app/repo_to_process/climlab/radiation/rrtm/rrtmg_lw.py:19: UserWarning: Cannot import and initialize compiled Fortran extension, RRTMG_LW module will not be functional.\n    warnings.warn('Cannot import and initialize compiled Fortran extension, RRTMG_LW module will not be functional.')\n\nclimlab/radiation/rrtm/rrtmg_sw.py:19\n  /app/repo_to_process/climlab/radiation/rrtm/rrtmg_sw.py:19: UserWarning: Cannot import and initialize compiled Fortran extension, RRTMG_SW module will not be functional.\n    warnings.warn('Cannot import and initialize compiled Fortran extension, RRTMG_SW module will not be functional.')\n\nclimlab/convection/emanuel_convection.py:14\n  /app/repo_to_process/climlab/convection/emanuel_convection.py:14: UserWarning: Cannot import EmanuelConvection fortran extension, this module will not be functional.\n    warnings.warn('Cannot import EmanuelConvection fortran extension, this module will not be functional.')\n\nclimlab/solar/orbital/table.py:18\n  /app/repo_to_process/climlab/solar/orbital/table.py:18: FutureWarning: The 'delim_whitespace' keyword in pd.read_csv is deprecated and will be removed in a future version. Use ``sep='\\s+'`` instead\n    orbit91_pd = pd.read_csv(orbit91handle, delim_whitespace=True, skiprows=1, verbose=True)\n\nclimlab/solar/orbital/table.py:18\n  /app/repo_to_process/climlab/solar/orbital/table.py:18: FutureWarning: The 'verbose' keyword in pd.read_csv is deprecated and will be removed in a future version.\n    orbit91_pd = pd.read_csv(orbit91handle, delim_whitespace=True, skiprows=1, verbose=True)\n\nclimlab/solar/orbital/long.py:28\nclimlab/solar/orbital/long.py:28\n  /app/repo_to_process/climlab/solar/orbital/long.py:28: FutureWarning: The 'delim_whitespace' keyword in pd.read_csv is deprecated and will be removed in a future version. Use ``sep='\\s+'`` instead\n    longorbit[time] = pd.read_csv(longorbithandle[time], **pandas_kwargs)\n\nclimlab/tests/test_rcm.py:8\n  /app/repo_to_process/climlab/tests/test_rcm.py:8: PytestRemovedIn9Warning: Marks applied to fixtures have no effect\n  See docs: https://docs.pytest.org/en/stable/deprecations.html#applying-a-mark-to-a-fixture-function\n    def rcm():\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: flux_reflected_up excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: OLR excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: LW_down_sfc excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: LW_up_sfc excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: LW_absorbed_sfc excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: LW_absorbed_atm excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: LW_emission excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: ASR excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: SW_absorbed_sfc excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: SW_absorbed_atm excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: SW_up_sfc excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: SW_up_TOA excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: SW_down_TOA excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_grey_radiation.py::test_model_creation\n  /app/repo_to_process/climlab/domain/xarray.py:59: UserWarning: planetary_albedo excluded from Dataset because it is not a Field variable.\n    warnings.warn('{} excluded from Dataset because it is not a Field variable.'.format(name))\n\nclimlab/tests/test_rrtm.py::test_large_grid\n  /app/repo_to_process/climlab/radiation/radiation.py:156: UserWarning: Some grid points are beyond the bounds of the ozone file. Ozone values will be extrapolated.\n    warnings.warn('Some grid points are beyond the bounds of the ozone file. Ozone values will be extrapolated.')\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n=========================== short test summary info ============================\nFAILED climlab/tests/test_advdiff_solver.py::test_nonuniform_multidim - Value...\nFAILED climlab/tests/test_bandrc.py::test_diffmodel - ValueError: solve: Inpu...\nFAILED climlab/tests/test_bandrc.py::test_diffmodel_surfflux - ValueError: so...\nFAILED climlab/tests/test_cam3rad.py::test_rce - NameError: name '_cam3' is n...\nFAILED climlab/tests/test_cam3rad.py::test_re_radiative_forcing - NameError: ...\nFAILED climlab/tests/test_cam3rad.py::test_rce_radiative_forcing - NameError:...\nFAILED climlab/tests/test_cam3rad.py::test_cam3_multidim - NameError: name '_...\nFAILED climlab/tests/test_domain2D.py::test_2D_EBM - ValueError: solve: Input...\nFAILED climlab/tests/test_domain2D.py::test_2D_EBM_seasonal - ValueError: sol...\nFAILED climlab/tests/test_ebm.py::test_integrate_years - ValueError: solve: I...\nFAILED climlab/tests/test_ebm.py::test_high_obliquity - ValueError: solve: In...\nFAILED climlab/tests/test_ebm.py::test_annual_iceline - ValueError: solve: In...\nFAILED climlab/tests/test_ebm.py::test_decreased_S0 - ValueError: solve: Inpu...\nFAILED climlab/tests/test_ebm.py::test_float - ValueError: solve: Input opera...\nFAILED climlab/tests/test_ebm.py::test_albedo - ValueError: solve: Input oper...\nFAILED climlab/tests/test_ebm.py::test_analytical - ValueError: solve: Input ...\nFAILED climlab/tests/test_ebm.py::test_moist_EBM_creation - ValueError: solve...\nFAILED climlab/tests/test_emanuel_convection.py::test_convect_tendencies - Na...\nFAILED climlab/tests/test_emanuel_convection.py::test_multidim_tendencies - N...\nFAILED climlab/tests/test_emanuel_convection.py::test_rcm_emanuel - NameError...\nFAILED climlab/tests/test_grey_radiation.py::test_diffmodel - ValueError: sol...\nFAILED climlab/tests/test_insolation.py::test_orbital_cycles - ValueError: so...\nFAILED climlab/tests/test_rcm.py::test_convective_adjustment - NameError: nam...\nFAILED climlab/tests/test_rcm.py::test_coupled_rcm - NameError: name '_rrtmg_...\nFAILED climlab/tests/test_rrtm.py::test_rrtm_creation - NameError: name '_rrt...\nFAILED climlab/tests/test_rrtm.py::test_swap_component - NameError: name '_rr...\nFAILED climlab/tests/test_rrtm.py::test_multidim - NameError: name '_rrtmg_lw...\nFAILED climlab/tests/test_rrtm.py::test_cloud - NameError: name '_rrtmg_sw' i...\nFAILED climlab/tests/test_rrtm.py::test_radiative_forcing - NameError: name '...\nFAILED climlab/tests/test_rrtm.py::test_latitude - NameError: name '_rrtmg_sw...\nFAILED climlab/tests/test_rrtm.py::test_fixed_insolation - NameError: name '_...\nFAILED climlab/tests/test_rrtm.py::test_large_grid - NameError: name '_cam3' ...\n============ 32 failed, 23 passed, 24 warnings in 89.64s (0:01:29) =============\n",
    "stderr": "",
    "execution_time": 89.99621248245239
  }
]