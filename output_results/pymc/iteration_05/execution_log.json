[
  {
    "command": "pip install numpyro",
    "success": true,
    "stdout": "Looking in indexes: https://repo.huaweicloud.com/repository/pypi/simple/\nCollecting numpyro\n  Downloading https://repo.huaweicloud.com/repository/pypi/packages/88/31/9b5da5995988437756bc3f1eead2e314d8916259875c6924cb41692f2b41/numpyro-0.19.0-py3-none-any.whl (370 kB)\nRequirement already satisfied: jax>=0.4.25 in /usr/local/lib/python3.10/dist-packages (from numpyro) (0.6.2)\nRequirement already satisfied: jaxlib>=0.4.25 in /usr/local/lib/python3.10/dist-packages (from numpyro) (0.6.2)\nRequirement already satisfied: multipledispatch in /usr/local/lib/python3.10/dist-packages (from numpyro) (1.0.0)\nRequirement already satisfied: numpy in /usr/local/lib/python3.10/dist-packages (from numpyro) (2.2.6)\nCollecting tqdm (from numpyro)\n  Downloading https://repo.huaweicloud.com/repository/pypi/packages/d0/30/dc54f88dd4a2b5dc8a0279bdd7270e735851848b762aeb1c1184ed1f6b14/tqdm-4.67.1-py3-none-any.whl (78 kB)\nRequirement already satisfied: ml_dtypes>=0.5.0 in /usr/local/lib/python3.10/dist-packages (from jax>=0.4.25->numpyro) (0.5.3)\nRequirement already satisfied: opt_einsum in /usr/local/lib/python3.10/dist-packages (from jax>=0.4.25->numpyro) (3.4.0)\nRequirement already satisfied: scipy>=1.12 in /usr/local/lib/python3.10/dist-packages (from jax>=0.4.25->numpyro) (1.15.3)\nInstalling collected packages: tqdm, numpyro\n\nSuccessfully installed numpyro-0.19.0 tqdm-4.67.1\n",
    "stderr": "WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.\n",
    "execution_time": 3.2175686359405518
  },
  {
    "command": "pytest",
    "success": false,
    "stdout": "\u001b[1m============================= test session starts ==============================\u001b[0m\nplatform linux -- Python 3.10.12, pytest-8.4.1, pluggy-1.6.0\nrootdir: /app/repo_to_process\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.2.1\ncollected 3731 items\n\ntests/backends/test_arviz.py \u001b[31mE\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[31mE\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31m [  1%]\n\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                                 [  1%]\u001b[0m\ntests/backends/test_base.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                          [  1%]\u001b[0m\ntests/backends/test_mcbackend.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                             [  1%]\u001b[0m\ntests/backends/test_ndarray.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [  2%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [  4%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                   [  6%]\u001b[0m\ntests/backends/test_zarr.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[31m [  7%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[31m [  9%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 11%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 13%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                     [ 13%]\u001b[0m\ntests/dims/distributions/test_core.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                 [ 13%]\u001b[0m\ntests/dims/distributions/test_scalar.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                   [ 14%]\u001b[0m\ntests/dims/distributions/test_vector.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                              [ 14%]\u001b[0m\ntests/dims/test_model.py \u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                            [ 14%]\u001b[0m\ntests/distributions/moments/test_means.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 15%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                              [ 15%]\u001b[0m\ntests/distributions/test_censored.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                            [ 16%]\u001b[0m\ntests/distributions/test_continuous.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 16%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 18%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 20%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 22%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                 [ 23%]\u001b[0m\ntests/distributions/test_custom.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 24%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                        [ 25%]\u001b[0m\ntests/distributions/test_discrete.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 26%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 28%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                             [ 28%]\u001b[0m\ntests/distributions/test_dist_math.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m              [ 29%]\u001b[0m\ntests/distributions/test_distribution.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m  [ 29%]\u001b[0m\ntests/distributions/test_mixture.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 30%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 32%]\n\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 34%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                 [ 35%]\u001b[0m\ntests/distributions/test_multivariate.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 36%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31m [ 38%]\n\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 39%]\n\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 41%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                [ 43%]\u001b[0m\ntests/distributions/test_random_alternative_backends.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[31m     [ 43%]\u001b[0m\ntests/distributions/test_shape_utils.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 44%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 46%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                            [ 46%]\u001b[0m\ntests/distributions/test_simulator.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m        [ 47%]\u001b[0m\ntests/distributions/test_timeseries.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 48%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                           [ 49%]\u001b[0m\ntests/distributions/test_transform.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 50%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                              [ 51%]\u001b[0m\ntests/distributions/test_truncated.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 52%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[31m                  [ 53%]\u001b[0m\ntests/gp/test_cov.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 55%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                     [ 56%]\u001b[0m\ntests/gp/test_gp.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                              [ 56%]\u001b[0m\ntests/gp/test_hsgp_approx.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                              [ 57%]\u001b[0m\ntests/gp/test_mean.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                            [ 57%]\u001b[0m\ntests/gp/test_util.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                            [ 57%]\u001b[0m\ntests/logprob/test_abstract.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                       [ 57%]\u001b[0m\ntests/logprob/test_basic.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                   [ 58%]\u001b[0m\ntests/logprob/test_binary.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                              [ 58%]\u001b[0m\ntests/logprob/test_censoring.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                           [ 58%]\u001b[0m\ntests/logprob/test_checks.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                          [ 59%]\u001b[0m\ntests/logprob/test_composite_logprob.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                       [ 59%]\u001b[0m\ntests/logprob/test_cumsum.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                            [ 59%]\u001b[0m\ntests/logprob/test_linalg.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                      [ 59%]\u001b[0m\ntests/logprob/test_mixture.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 61%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                           [ 61%]\u001b[0m\ntests/logprob/test_order.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m             [ 62%]\u001b[0m\ntests/logprob/test_rewriting.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                      [ 62%]\u001b[0m\ntests/logprob/test_scan.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                   [ 62%]\u001b[0m\ntests/logprob/test_tensor.py \u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 63%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                                       [ 63%]\u001b[0m\ntests/logprob/test_transform_value.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m  [ 64%]\u001b[0m\ntests/logprob/test_transforms.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 65%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[31m                                  [ 66%]\u001b[0m\ntests/logprob/test_utils.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                [ 67%]\u001b[0m\ntests/model/test_core.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 68%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 70%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                                    [ 70%]\u001b[0m\ntests/model/test_fgraph.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                    [ 70%]\u001b[0m\ntests/model/transform/test_basic.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                   [ 70%]\u001b[0m\ntests/model/transform/test_conditioning.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m           [ 71%]\u001b[0m\ntests/model/transform/test_optimization.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                         [ 71%]\u001b[0m\ntests/ode/test_ode.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                           [ 72%]\u001b[0m\ntests/ode/test_utils.py \u001b[32m.\u001b[0m\u001b[31m                                                [ 72%]\u001b[0m\ntests/sampling/test_deterministic.py \u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[31m                                  [ 72%]\u001b[0m\ntests/sampling/test_forward.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 73%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 75%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                                   [ 75%]\u001b[0m\ntests/sampling/test_jax.py \u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 76%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[31m                                                        [ 77%]\u001b[0m\ntests/sampling/test_mcmc.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 78%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m              [ 79%]\u001b[0m\ntests/sampling/test_mcmc_external.py \u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                           [ 80%]\u001b[0m\ntests/sampling/test_parallel.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                             [ 80%]\u001b[0m\ntests/sampling/test_population.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                   [ 80%]\u001b[0m\ntests/smc/test_smc.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                    [ 80%]\u001b[0m\ntests/stats/test_convergence.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                   [ 80%]\u001b[0m\ntests/stats/test_log_density.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                               [ 81%]\u001b[0m\ntests/step_methods/hmc/test_hmc.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                 [ 81%]\u001b[0m\ntests/step_methods/hmc/test_nuts.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[31m [ 82%]\n\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                         [ 82%]\u001b[0m\ntests/step_methods/hmc/test_quadpotential.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m             [ 83%]\u001b[0m\ntests/step_methods/test_compound.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                           [ 83%]\u001b[0m\ntests/step_methods/test_metropolis.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 84%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                              [ 84%]\u001b[0m\ntests/step_methods/test_slicer.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                               [ 84%]\u001b[0m\ntests/step_methods/test_state.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                    [ 84%]\u001b[0m\ntests/test_data.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33mx\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                           [ 85%]\u001b[0m\ntests/test_func_utils.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                 [ 86%]\u001b[0m\ntests/test_initial_point.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                       [ 87%]\u001b[0m\ntests/test_math.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                            [ 87%]\u001b[0m\ntests/test_model_graph.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m       [ 88%]\u001b[0m\ntests/test_printing.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                        [ 88%]\u001b[0m\ntests/test_progress_bar.py \u001b[32m.\u001b[0m\u001b[31m                                             [ 88%]\u001b[0m\ntests/test_pytensorf.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 90%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                                       [ 90%]\u001b[0m\ntests/test_testing.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                        [ 90%]\u001b[0m\ntests/test_util.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                           [ 90%]\u001b[0m\ntests/tuning/test_scaling.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                          [ 90%]\u001b[0m\ntests/tuning/test_starting.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                [ 91%]\u001b[0m\ntests/variational/test_approximations.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                      [ 91%]\u001b[0m\ntests/variational/test_callbacks.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                              [ 91%]\u001b[0m\ntests/variational/test_inference.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 92%]\n\u001b[0m\u001b[33ms\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                                     [ 93%]\u001b[0m\ntests/variational/test_minibatch_rv.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                          [ 93%]\u001b[0m\ntests/variational/test_opvi.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[31m     [ 94%]\u001b[0m\ntests/variational/test_updates.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 95%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 97%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m [ 99%]\n\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[31m                                       [100%]\u001b[0m\n\n==================================== ERRORS ====================================\n\u001b[31m\u001b[1m_________________ ERROR at setup of TestDataPyMC.test_to_idata _________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 843, in pytest_runtest_setup\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 895, in pytest_runtest_setup\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 153, in pytest_runtest_setup\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n---------------------------- Captured stdout setup -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     1500    0         0.651     7         1283.55   0:00:01   0:00:00   \n                                                  draws/s                       \n     1500    1         0.470     7         1313.40   0:00:01   0:00:00   \n                                                  draws/s                       \n                                                                                \n---------------------------- Captured stderr setup -----------------------------\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [mu, tau, eta]\nSampling 2 chains for 1_000 tune and 500 draw iterations (2_000 + 1_000 draws total) took 1 seconds.\nThere was 1 divergence after tuning. Increase `target_accept` or reparameterize.\nWe recommend running at least 4 chains for robust computation of convergence diagnostics\n------------------------------ Captured log setup ------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [mu, tau, eta]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 1_000 tune and 500 draw iterations (2_000 + 1_000 draws total) took 1 seconds.\n\u001b[1m\u001b[31mERROR   \u001b[0m pymc.stats.convergence:convergence.py:187 There was 1 divergence after tuning. Increase `target_accept` or reparameterize.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 We recommend running at least 4 chains for robust computation of convergence diagnostics\n\u001b[31m\u001b[1m_______ ERROR at teardown of TestDataPyMC.test_multivariate_observations _______\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 858, in pytest_runtest_teardown\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 905, in pytest_runtest_teardown\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 163, in pytest_runtest_teardown\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     150     0         0.179     3         556.34    0:00:00   0:00:00   \n                                                  draws/s                       \n     150     0         0.118     3         540.91    0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \n----------------------------- Captured stderr call -----------------------------\nOnly 50 samples per chain. Reliable r-hat and ESS diagnostics require longer chains for accurate estimate.\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [p]\nSampling 2 chains for 100 tune and 50 draw iterations (200 + 100 draws total) took 0 seconds.\nThe number of samples is too small to check convergence reliably.\n------------------------------ Captured log call -------------------------------\n\u001b[33mWARNING \u001b[0m pymc.sampling.mcmc:mcmc.py:780 Only 50 samples per chain. Reliable r-hat and ESS diagnostics require longer chains for accurate estimate.\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [p]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 100 tune and 50 draw iterations (200 + 100 draws total) took 0 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 The number of samples is too small to check convergence reliably.\n=================================== FAILURES ===================================\n\u001b[31m\u001b[1m________________ TestDataPyMC.test_posterior_predictive_thinned ________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     25      0         0.601     7         288.60    0:00:00   0:00:00   \n                                                  draws/s                       \n     25      0         0.949     3         205.65    0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \nSampling ...  100% 0:00:00 / 0:00:00\n----------------------------- Captured stderr call -----------------------------\nOnly 20 samples per chain. Reliable r-hat and ESS diagnostics require longer chains for accurate estimate.\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [mu, tau, eta]\nSampling 2 chains for 5 tune and 20 draw iterations (10 + 40 draws total) took 0 seconds.\nThe number of samples is too small to check convergence reliably.\nSampling: [obs]\n------------------------------ Captured log call -------------------------------\n\u001b[33mWARNING \u001b[0m pymc.sampling.mcmc:mcmc.py:780 Only 20 samples per chain. Reliable r-hat and ESS diagnostics require longer chains for accurate estimate.\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [mu, tau, eta]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 5 tune and 20 draw iterations (10 + 40 draws total) took 0 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 The number of samples is too small to check convergence reliably.\n\u001b[32mINFO    \u001b[0m pymc.sampling.forward:forward.py:919 Sampling: [obs]\n\u001b[31m\u001b[1m________________ TestDataPyMC.test_overwrite_model_coords_dims _________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (4 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 3 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 4 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     200     0         0.528     1         849.22    0:00:00   0:00:00   \n                                                  draws/s                       \n     200     0         0.197     3         779.48    0:00:00   0:00:00   \n                                                  draws/s                       \n     200     0         0.252     7         702.44    0:00:00   0:00:00   \n                                                  draws/s                       \n     200     0         0.382     3         654.47    0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \n----------------------------- Captured stderr call -----------------------------\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (4 chains in 4 jobs)\nNUTS: [beta]\nSampling 4 chains for 100 tune and 100 draw iterations (400 + 400 draws total) took 0 seconds.\nThe rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\nThe effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (4 chains in 4 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [beta]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 4 chains for 100 tune and 100 draw iterations (400 + 400 draws total) took 0 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 The rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\n\u001b[1m\u001b[31mERROR   \u001b[0m pymc.stats.convergence:convergence.py:187 The effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n\u001b[31m\u001b[1m_____________________ TestDataPyMC.test_missing_data_model _____________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     1100    0         0.823     3         1608.38   0:00:00   0:00:00   \n                                                  draws/s                       \n     1100    0         1.150     3         1592.88   0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \n----------------------------- Captured stderr call -----------------------------\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [x, y_unobserved]\nSampling 2 chains for 1_000 tune and 100 draw iterations (2_000 + 200 draws total) took 1 seconds.\nWe recommend running at least 4 chains for robust computation of convergence diagnostics\nThe rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\nThe effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [x, y_unobserved]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 1_000 tune and 100 draw iterations (2_000 + 200 draws total) took 1 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 We recommend running at least 4 chains for robust computation of convergence diagnostics\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 The rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\n\u001b[1m\u001b[31mERROR   \u001b[0m pymc.stats.convergence:convergence.py:187 The effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n\u001b[31m\u001b[1m___________________ TestDataPyMC.test_mv_missing_data_model ____________________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = VMLinker(use_cloop=True, lazy=None, allow_partial_eval=None, allow_gc=True)\nprofiler = None, input_storage = [[None], [None]], output_storage = [[None]]\nstorage_map = {NominalTensorVariable(0, TensorType(float64, shape=(1, 2, 2))): [None], NominalTensorVariable(1, TensorType(float64, shape=(1, 2, 2))): [None], Squeeze{axis=0}.0: [None], DimShuffle{order=[2,1]}.0: [None], ...}\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_all\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        \u001b[96mself\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        profiler=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        input_storage=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        output_storage=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        storage_map=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n        fgraph = \u001b[96mself\u001b[39;49;00m.fgraph\u001b[90m\u001b[39;49;00m\n        order = \u001b[96mself\u001b[39;49;00m.schedule(fgraph)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        input_storage, output_storage, storage_map = map_storage(\u001b[90m\u001b[39;49;00m\n            fgraph, order, input_storage, output_storage, storage_map\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        compute_map = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mfor\u001b[39;49;00m k \u001b[95min\u001b[39;49;00m storage_map:\u001b[90m\u001b[39;49;00m\n            compute_map[k] = [k.owner \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        thunks = []\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        linker_make_thunk_time = {}\u001b[90m\u001b[39;49;00m\n        impl = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.c_thunks \u001b[95mis\u001b[39;49;00m \u001b[94mFalse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            impl = \u001b[33m\"\u001b[39;49;00m\u001b[33mpy\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mfor\u001b[39;49;00m node \u001b[95min\u001b[39;49;00m order:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                thunk_start = time.perf_counter()\u001b[90m\u001b[39;49;00m\n                \u001b[90m# no-recycling is done at each VM.__call__ So there is\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# no need to cause duplicate c code by passing\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# no_recycling here.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                thunks.append(\u001b[90m\u001b[39;49;00m\n>                   node.op.make_thunk(node, storage_map, compute_map, [], impl=impl)\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/vm.py\u001b[0m:1230: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/op.py\u001b[0m:125: in make_thunk\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.make_c_thunk(node, storage_map, compute_map, no_recycling)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/op.py\u001b[0m:84: in make_c_thunk\n    \u001b[0moutputs = cl.make_thunk(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:1185: in make_thunk\n    \u001b[0mcthunk, module, in_storage, out_storage, error_storage = \u001b[96mself\u001b[39;49;00m.__compile__(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:1102: in __compile__\n    \u001b[0mthunk, module = \u001b[96mself\u001b[39;49;00m.cthunk_factory(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:1613: in cthunk_factory\n    \u001b[0mkey = \u001b[96mself\u001b[39;49;00m.cmodule_key()\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:1269: in cmodule_key\n    \u001b[0mcompile_args=\u001b[96mself\u001b[39;49;00m.compile_args(),\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:946: in compile_args\n    \u001b[0mret += x.c_compile_args(c_compiler=c_compiler)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/tensor/blas.py\u001b[0m:489: in c_compile_args\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m ldflags(libs=\u001b[94mFalse\u001b[39;49;00m, flags=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/tensor/blas.py\u001b[0m:336: in ldflags\n    \u001b[0mldflags_str = config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.link.vm.Loop object at 0x7f6634ddb400>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.time_thunks:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m cont \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.pre_call_clear:\u001b[90m\u001b[39;49;00m\n                cont[\u001b[94m0\u001b[39;49;00m] = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                i = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m thunk, node, old_storage \u001b[95min\u001b[39;49;00m zip_longest(\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m.thunks, \u001b[96mself\u001b[39;49;00m.nodes, \u001b[96mself\u001b[39;49;00m.post_thunk_clear, fillvalue=()\u001b[90m\u001b[39;49;00m\n                ):\u001b[90m\u001b[39;49;00m\n                    t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n                    thunk()\u001b[90m\u001b[39;49;00m\n                    t1 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m.call_counts[i] += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m.call_times[i] += t1 - t0\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m old_s \u001b[95min\u001b[39;49;00m old_storage:\u001b[90m\u001b[39;49;00m\n                        old_s[\u001b[94m0\u001b[39;49;00m] = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    i += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                raise_with_op(\u001b[96mself\u001b[39;49;00m.fgraph, node, thunk)\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m cont \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.pre_call_clear:\u001b[90m\u001b[39;49;00m\n                cont[\u001b[94m0\u001b[39;49;00m] = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m thunk, node, old_storage \u001b[95min\u001b[39;49;00m zip_longest(\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m.thunks, \u001b[96mself\u001b[39;49;00m.nodes, \u001b[96mself\u001b[39;49;00m.post_thunk_clear, fillvalue=()\u001b[90m\u001b[39;49;00m\n                ):\u001b[90m\u001b[39;49;00m\n>                   thunk()\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/vm.py\u001b[0m:406: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\u001b[0m:544: in rval\n    \u001b[0mr = p(n, [x[\u001b[94m0\u001b[39;49;00m] \u001b[94mfor\u001b[39;49;00m x \u001b[95min\u001b[39;49;00m i], o)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/builders.py\u001b[0m:875: in perform\n    \u001b[0mvariables = \u001b[96mself\u001b[39;49;00m.fn(*inputs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/builders.py\u001b[0m:856: in fn\n    \u001b[0m\u001b[96mself\u001b[39;49;00m._fn = function(\u001b[96mself\u001b[39;49;00m.inner_inputs, \u001b[96mself\u001b[39;49;00m.inner_outputs, **\u001b[96mself\u001b[39;49;00m.kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1835: in orig_function\n    \u001b[0mfn = m.create(defaults)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1719: in create\n    \u001b[0m_fn, _i, _o = \u001b[96mself\u001b[39;49;00m.linker.make_thunk(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/basic.py\u001b[0m:245: in make_thunk\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.make_all(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/vm.py\u001b[0m:1239: in make_all\n    \u001b[0mraise_with_op(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/vm.py\u001b[0m:1230: in make_all\n    \u001b[0mnode.op.make_thunk(node, storage_map, compute_map, [], impl=impl)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/op.py\u001b[0m:125: in make_thunk\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.make_c_thunk(node, storage_map, compute_map, no_recycling)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/op.py\u001b[0m:84: in make_c_thunk\n    \u001b[0moutputs = cl.make_thunk(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:1185: in make_thunk\n    \u001b[0mcthunk, module, in_storage, out_storage, error_storage = \u001b[96mself\u001b[39;49;00m.__compile__(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:1102: in __compile__\n    \u001b[0mthunk, module = \u001b[96mself\u001b[39;49;00m.cthunk_factory(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:1613: in cthunk_factory\n    \u001b[0mkey = \u001b[96mself\u001b[39;49;00m.cmodule_key()\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:1269: in cmodule_key\n    \u001b[0mcompile_args=\u001b[96mself\u001b[39;49;00m.compile_args(),\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:946: in compile_args\n    \u001b[0mret += x.c_compile_args(c_compiler=c_compiler)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/tensor/blas.py\u001b[0m:489: in c_compile_args\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m ldflags(libs=\u001b[94mFalse\u001b[39;49;00m, flags=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/tensor/blas.py\u001b[0m:336: in ldflags\n    \u001b[0mldflags_str = config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\u001b[1m\u001b[31mE       Apply node that caused the error: Dot22(DimShuffle{order=[2,1]}.0, Squeeze{axis=0}.0)\u001b[0m\n\u001b[1m\u001b[31mE       Toposort index: 2\u001b[0m\n\u001b[1m\u001b[31mE       Inputs types: [TensorType(float64, shape=(2, 2)), TensorType(float64, shape=(2, 2))]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE       Dot22 [id A] <Matrix(float64, shape=(2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE         DimShuffle{order=[2,1]} [id B] <Matrix(float64, shape=(2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE           *0-<Tensor3(float64, shape=(1, 2, 2))> [id C] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE         Squeeze{axis=0} [id D] <Matrix(float64, shape=(2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE            *1-<Tensor3(float64, shape=(1, 2, 2))> [id E] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       HINT: Use a linker other than the C linker to print the inputs' shapes and strides.\u001b[0m\n\u001b[1m\u001b[31mE       HINT: Re-running with most PyTensor optimizations disabled could provide a back-trace showing when this node was created. This can be done by setting the PyTensor flag 'optimizer=fast_compile'. If that does not work, PyTensor optimizations can be disabled with 'optimizer=None'.\u001b[0m\n\u001b[1m\u001b[31mE       HINT: Use the PyTensor flag `exception_verbosity=high` for a debug print-out and storage map footprint of this Apply node.\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestDataPyMC object at 0x7f6605e72500>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_mv_missing_data_model\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        data = ma.masked_values([[\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m], [\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m], [-\u001b[94m1\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m], [\u001b[94m2\u001b[39;49;00m, -\u001b[94m1\u001b[39;49;00m], [-\u001b[94m1\u001b[39;49;00m, -\u001b[94m1\u001b[39;49;00m]], value=-\u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        model = pm.Model()\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            mu = pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mmu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, size=\u001b[94m2\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            sd_dist = pm.HalfNormal.dist(\u001b[94m1.0\u001b[39;49;00m, size=\u001b[94m2\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            chol, *_ = pm.LKJCholeskyCov(\u001b[33m\"\u001b[39;49;00m\u001b[33mchol_cov\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, n=\u001b[94m2\u001b[39;49;00m, eta=\u001b[94m1\u001b[39;49;00m, sd_dist=sd_dist)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m pytest.warns(ImputationWarning):\u001b[90m\u001b[39;49;00m\n                y = pm.MvNormal(\u001b[33m\"\u001b[39;49;00m\u001b[33my\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, mu=mu, chol=chol, observed=data)\u001b[90m\u001b[39;49;00m\n            inference_data = pm.sample(\u001b[90m\u001b[39;49;00m\n                tune=\u001b[94m10\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                draws=\u001b[94m10\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                chains=\u001b[94m2\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>               step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33mlog_likelihood\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mTrue\u001b[39;49;00m},\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:373: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:199: in __init__\n    \u001b[0minitial_point = model.initial_point()\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/model/core.py\u001b[0m:1034: in initial_point\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m Point(fn(random_seed), model=\u001b[96mself\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/initial_point.py\u001b[0m:192: in inner\n    \u001b[0mvalues = func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: in __call__\n    \u001b[0moutputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/vm.py\u001b[0m:410: in __call__\n    \u001b[0mraise_with_op(\u001b[96mself\u001b[39;49;00m.fgraph, node, thunk)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/vm.py\u001b[0m:406: in __call__\n    \u001b[0mthunk()\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\u001b[0m:544: in rval\n    \u001b[0mr = p(n, [x[\u001b[94m0\u001b[39;49;00m] \u001b[94mfor\u001b[39;49;00m x \u001b[95min\u001b[39;49;00m i], o)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/builders.py\u001b[0m:875: in perform\n    \u001b[0mvariables = \u001b[96mself\u001b[39;49;00m.fn(*inputs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/builders.py\u001b[0m:856: in fn\n    \u001b[0m\u001b[96mself\u001b[39;49;00m._fn = function(\u001b[96mself\u001b[39;49;00m.inner_inputs, \u001b[96mself\u001b[39;49;00m.inner_outputs, **\u001b[96mself\u001b[39;49;00m.kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1835: in orig_function\n    \u001b[0mfn = m.create(defaults)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1719: in create\n    \u001b[0m_fn, _i, _o = \u001b[96mself\u001b[39;49;00m.linker.make_thunk(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/basic.py\u001b[0m:245: in make_thunk\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.make_all(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/vm.py\u001b[0m:1239: in make_all\n    \u001b[0mraise_with_op(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/vm.py\u001b[0m:1230: in make_all\n    \u001b[0mnode.op.make_thunk(node, storage_map, compute_map, [], impl=impl)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/op.py\u001b[0m:125: in make_thunk\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.make_c_thunk(node, storage_map, compute_map, no_recycling)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/op.py\u001b[0m:84: in make_c_thunk\n    \u001b[0moutputs = cl.make_thunk(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:1185: in make_thunk\n    \u001b[0mcthunk, module, in_storage, out_storage, error_storage = \u001b[96mself\u001b[39;49;00m.__compile__(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:1102: in __compile__\n    \u001b[0mthunk, module = \u001b[96mself\u001b[39;49;00m.cthunk_factory(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:1613: in cthunk_factory\n    \u001b[0mkey = \u001b[96mself\u001b[39;49;00m.cmodule_key()\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:1269: in cmodule_key\n    \u001b[0mcompile_args=\u001b[96mself\u001b[39;49;00m.compile_args(),\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/basic.py\u001b[0m:946: in compile_args\n    \u001b[0mret += x.c_compile_args(c_compiler=c_compiler)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/tensor/blas.py\u001b[0m:489: in c_compile_args\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m ldflags(libs=\u001b[94mFalse\u001b[39;49;00m, flags=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/tensor/blas.py\u001b[0m:336: in ldflags\n    \u001b[0mldflags_str = config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\u001b[1m\u001b[31mE       Apply node that caused the error: Dot22(DimShuffle{order=[2,1]}.0, Squeeze{axis=0}.0)\u001b[0m\n\u001b[1m\u001b[31mE       Toposort index: 2\u001b[0m\n\u001b[1m\u001b[31mE       Inputs types: [TensorType(float64, shape=(2, 2)), TensorType(float64, shape=(2, 2))]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE       Dot22 [id A] <Matrix(float64, shape=(2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE         DimShuffle{order=[2,1]} [id B] <Matrix(float64, shape=(2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE           *0-<Tensor3(float64, shape=(1, 2, 2))> [id C] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE         Squeeze{axis=0} [id D] <Matrix(float64, shape=(2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE            *1-<Tensor3(float64, shape=(1, 2, 2))> [id E] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       HINT: Use a linker other than the C linker to print the inputs' shapes and strides.\u001b[0m\n\u001b[1m\u001b[31mE       HINT: Re-running with most PyTensor optimizations disabled could provide a back-trace showing when this node was created. This can be done by setting the PyTensor flag 'optimizer=fast_compile'. If that does not work, PyTensor optimizations can be disabled with 'optimizer=None'.\u001b[0m\n\u001b[1m\u001b[31mE       HINT: Use the PyTensor flag `exception_verbosity=high` for a debug print-out and storage map footprint of this Apply node.\u001b[0m\n\u001b[1m\u001b[31mE       Apply node that caused the error: Einsum{self.subscripts='...ji,...jk->...ik', self.path=((1, 0),), self.optimized=True}(SetSubtensor{:, i, j}.0, SetSubtensor{:, i, j}.0)\u001b[0m\n\u001b[1m\u001b[31mE       Toposort index: 13\u001b[0m\n\u001b[1m\u001b[31mE       Inputs types: [TensorType(float64, shape=(1, 2, 2)), TensorType(float64, shape=(1, 2, 2))]\u001b[0m\n\u001b[1m\u001b[31mE       Inputs shapes: [(1, 2, 2), (1, 2, 2)]\u001b[0m\n\u001b[1m\u001b[31mE       Inputs strides: [(32, 16, 8), (32, 16, 8)]\u001b[0m\n\u001b[1m\u001b[31mE       Inputs values: [array([[[ 1.        , -0.88307595],\u001b[0m\n\u001b[1m\u001b[31mE               [ 0.        ,  0.46923008]]]), array([[[ 1.        , -0.88307595],\u001b[0m\n\u001b[1m\u001b[31mE               [ 0.        ,  0.46923008]]])]\u001b[0m\n\u001b[1m\u001b[31mE       Inputs type_num: [12, 12]\u001b[0m\n\u001b[1m\u001b[31mE       Outputs clients: [[Mul(Einsum{self.subscripts='...ji,...jk->...ik', self.path=((1, 0),), self.optimized=True}.0, ExpandDims{axes=[0, 2]}.0, ExpandDims{axes=[0, 1]}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE         File \"/usr/local/lib/python3.10/dist-packages/_pytest/python.py\", line 157, in pytest_pyfunc_call\u001b[0m\n\u001b[1m\u001b[31mE           result = testfunction(**testargs)\u001b[0m\n\u001b[1m\u001b[31mE         File \"/app/repo_to_process/tests/backends/test_arviz.py\", line 366, in test_mv_missing_data_model\u001b[0m\n\u001b[1m\u001b[31mE           chol, *_ = pm.LKJCholeskyCov(\"chol_cov\", n=2, eta=1, sd_dist=sd_dist)\u001b[0m\n\u001b[1m\u001b[31mE         File \"/app/repo_to_process/pymc/distributions/multivariate.py\", line 1471, in __new__\u001b[0m\n\u001b[1m\u001b[31mE           packed_chol = _LKJCholeskyCov(name, eta=eta, n=n, sd_dist=sd_dist, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE         File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 529, in __new__\u001b[0m\n\u001b[1m\u001b[31mE           rv_out = cls.dist(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE         File \"/app/repo_to_process/pymc/distributions/multivariate.py\", line 1258, in dist\u001b[0m\n\u001b[1m\u001b[31mE           return super().dist([n, eta, sd_dist], **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE         File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 598, in dist\u001b[0m\n\u001b[1m\u001b[31mE           return cls.rv_op(*dist_params, size=create_size, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE         File \"/app/repo_to_process/pymc/distributions/multivariate.py\", line 1216, in rv_op\u001b[0m\n\u001b[1m\u001b[31mE           next_rng, C = LKJCorrRV._random_corr_matrix(rng=rng, n=n, eta=eta, flat_size=flat_size)\u001b[0m\n\u001b[1m\u001b[31mE         File \"/app/repo_to_process/pymc/distributions/multivariate.py\", line 1576, in _random_corr_matrix\u001b[0m\n\u001b[1m\u001b[31mE           C = pt.einsum(\"...ji,...jk->...ik\", P, P.copy())\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE       Einsum{self.subscripts='...ji,...jk->...ik', self.path=((1, 0),), self.optimized=True} [id A] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE         SetSubtensor{:, i, j} [id B] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE           SetSubtensor{:, i, j} [id C] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[1. 0.]  [0. 1.]]] [id D] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             Add [id E] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE               [-1.] [id F] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE               Mul [id G] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE                  [2.] [id H] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE                  beta_rv{\"(),()->()\"}.1 [id I] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE                     RNG(<Generator(PCG64) at 0x7F6634F35C40>) [id J] <RandomGeneratorType>\u001b[0m\n\u001b[1m\u001b[31mE                     [1] [id K] <Vector(int64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE                     [1.] [id L] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE                     [1.] [id L] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE             0 [id M] <int64>\u001b[0m\n\u001b[1m\u001b[31mE             1 [id N] <int64>\u001b[0m\n\u001b[1m\u001b[31mE           Sqrt [id O] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE             Sub [id P] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE                [1.] [id L] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE                Pow [id Q] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE                   Add [id E] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE                     \u001b[0m\n\u001b[1m\u001b[31mE                   [2] [id R] <Vector(int8, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE           1 [id N] <int64>\u001b[0m\n\u001b[1m\u001b[31mE           1 [id N] <int64>\u001b[0m\n\u001b[1m\u001b[31mE         SetSubtensor{:, i, j} [id B] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE            \u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       Inner graphs:\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       Einsum{self.subscripts='...ji,...jk->...ik', self.path=((1, 0),), self.optimized=True} [id A]\u001b[0m\n\u001b[1m\u001b[31mE         Matmul [id S] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE            Transpose{axes=[0, 2, 1]} [id T] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE              *0-<Tensor3(float64, shape=(1, 2, 2))> [id U] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE            *1-<Tensor3(float64, shape=(1, 2, 2))> [id V] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       HINT: Use the PyTensor flag `exception_verbosity=high` for a debug print-out and storage map footprint of this Apply node.\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n\u001b[31m\u001b[1m_________________ TestDataPyMC.test_multiple_observed_rv[True] _________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     1100    0         1.433     1         2128.18   0:00:00   0:00:00   \n                                                  draws/s                       \n     1100    0         0.746     3         2155.80   0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \n----------------------------- Captured stderr call -----------------------------\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [x]\nSampling 2 chains for 1_000 tune and 100 draw iterations (2_000 + 200 draws total) took 1 seconds.\nWe recommend running at least 4 chains for robust computation of convergence diagnostics\nThe effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [x]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 1_000 tune and 100 draw iterations (2_000 + 200 draws total) took 1 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 We recommend running at least 4 chains for robust computation of convergence diagnostics\n\u001b[1m\u001b[31mERROR   \u001b[0m pymc.stats.convergence:convergence.py:187 The effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n\u001b[31m\u001b[1m________________ TestDataPyMC.test_multiple_observed_rv[False] _________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     1100    0         1.388     1         2285.25   0:00:00   0:00:00   \n                                                  draws/s                       \n     1100    0         2.173     3         2174.81   0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \n----------------------------- Captured stderr call -----------------------------\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [x]\nSampling 2 chains for 1_000 tune and 100 draw iterations (2_000 + 200 draws total) took 1 seconds.\nWe recommend running at least 4 chains for robust computation of convergence diagnostics\nThe rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\nThe effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [x]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 1_000 tune and 100 draw iterations (2_000 + 200 draws total) took 1 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 We recommend running at least 4 chains for robust computation of convergence diagnostics\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 The rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\n\u001b[1m\u001b[31mERROR   \u001b[0m pymc.stats.convergence:convergence.py:187 The effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n\u001b[31m\u001b[1m___________ TestDataPyMC.test_multiple_observed_rv[log_likelihood2] ____________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     1100    0         1.050     3         2132.18   0:00:00   0:00:00   \n                                                  draws/s                       \n     1100    0         1.547     1         2064.89   0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \n----------------------------- Captured stderr call -----------------------------\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [x]\nSampling 2 chains for 1_000 tune and 100 draw iterations (2_000 + 200 draws total) took 1 seconds.\nWe recommend running at least 4 chains for robust computation of convergence diagnostics\nThe rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\nThe effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [x]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 1_000 tune and 100 draw iterations (2_000 + 200 draws total) took 1 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 We recommend running at least 4 chains for robust computation of convergence diagnostics\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 The rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\n\u001b[1m\u001b[31mERROR   \u001b[0m pymc.stats.convergence:convergence.py:187 The effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n\u001b[31m\u001b[1m_____________________ TestDataPyMC.test_single_observation _____________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     1500    0         1.629     1         2477.91   0:00:00   0:00:00   \n                                                  draws/s                       \n     1500    0         1.147     3         2382.54   0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \n----------------------------- Captured stderr call -----------------------------\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [p]\nSampling 2 chains for 1_000 tune and 500 draw iterations (2_000 + 1_000 draws total) took 1 seconds.\nWe recommend running at least 4 chains for robust computation of convergence diagnostics\nThe rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [p]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 1_000 tune and 500 draw iterations (2_000 + 1_000 draws total) took 1 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 We recommend running at least 4 chains for robust computation of convergence diagnostics\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 The rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\n\u001b[31m\u001b[1m_________________________ TestDataPyMC.test_potential __________________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     1100    0         0.955     3         2176.39   0:00:00   0:00:00   \n                                                  draws/s                       \n     1100    0         1.538     1         2121.97   0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \n----------------------------- Captured stderr call -----------------------------\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [x]\nSampling 2 chains for 1_000 tune and 100 draw iterations (2_000 + 200 draws total) took 1 seconds.\nWe recommend running at least 4 chains for robust computation of convergence diagnostics\nThe rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\nThe effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [x]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 1_000 tune and 100 draw iterations (2_000 + 200 draws total) took 1 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 We recommend running at least 4 chains for robust computation of convergence diagnostics\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 The rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\n\u001b[1m\u001b[31mERROR   \u001b[0m pymc.stats.convergence:convergence.py:187 The effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n\u001b[31m\u001b[1m____________________ TestDataPyMC.test_constant_data[True] _____________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     200     0         0.407     3         1022.44   0:00:00   0:00:00   \n                                                  draws/s                       \n     200     0         0.172     1         930.25    0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \n----------------------------- Captured stderr call -----------------------------\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [beta]\nSampling 2 chains for 100 tune and 100 draw iterations (200 + 200 draws total) took 0 seconds.\nWe recommend running at least 4 chains for robust computation of convergence diagnostics\nThe effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [beta]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 100 tune and 100 draw iterations (200 + 200 draws total) took 0 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 We recommend running at least 4 chains for robust computation of convergence diagnostics\n\u001b[1m\u001b[31mERROR   \u001b[0m pymc.stats.convergence:convergence.py:187 The effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n\u001b[31m\u001b[1m____________________ TestDataPyMC.test_constant_data[False] ____________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     200     0         0.246     1         1078.03   0:00:00   0:00:00   \n                                                  draws/s                       \n     200     0         0.439     3         1024.96   0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \n----------------------------- Captured stderr call -----------------------------\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [beta]\nSampling 2 chains for 100 tune and 100 draw iterations (200 + 200 draws total) took 0 seconds.\nWe recommend running at least 4 chains for robust computation of convergence diagnostics\nThe rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\nThe effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [beta]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 100 tune and 100 draw iterations (200 + 200 draws total) took 0 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 We recommend running at least 4 chains for robust computation of convergence diagnostics\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 The rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\n\u001b[1m\u001b[31mERROR   \u001b[0m pymc.stats.convergence:convergence.py:187 The effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n\u001b[31m\u001b[1m_________________ TestDataPyMC.test_predictions_constant_data __________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (4 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 3 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 4 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     200     0         0.470     1         839.78    0:00:00   0:00:00   \n                                                  draws/s                       \n     200     0         0.209     3         783.10    0:00:00   0:00:00   \n                                                  draws/s                       \n     200     0         0.273     3         734.45    0:00:00   0:00:00   \n                                                  draws/s                       \n     200     0         0.490     3         673.98    0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \nSampling ...  100% 0:00:00 / 0:00:00\n----------------------------- Captured stderr call -----------------------------\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (4 chains in 4 jobs)\nNUTS: [beta]\nSampling 4 chains for 100 tune and 100 draw iterations (400 + 400 draws total) took 0 seconds.\nThe rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\nThe effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\nSampling: [obs]\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (4 chains in 4 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [beta]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 4 chains for 100 tune and 100 draw iterations (400 + 400 draws total) took 0 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 The rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\n\u001b[1m\u001b[31mERROR   \u001b[0m pymc.stats.convergence:convergence.py:187 The effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n\u001b[32mINFO    \u001b[0m pymc.sampling.forward:forward.py:919 Sampling: [obs]\n\u001b[31m\u001b[1m__________________________ TestDataPyMC.test_no_trace __________________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (4 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 3 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 4 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     200     0         0.225     3         839.04    0:00:00   0:00:00   \n                                                  draws/s                       \n     200     0         0.357     1         799.87    0:00:00   0:00:00   \n                                                  draws/s                       \n     200     0         0.211     1         706.34    0:00:00   0:00:00   \n                                                  draws/s                       \n     200     0         0.097     3         632.76    0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \nSampling ...  100% 0:00:00 / 0:00:00\n----------------------------- Captured stderr call -----------------------------\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (4 chains in 4 jobs)\nNUTS: [beta]\nSampling 4 chains for 100 tune and 100 draw iterations (400 + 400 draws total) took 0 seconds.\nThe rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\nThe effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\nSampling: [beta, obs]\nSampling: [obs]\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (4 chains in 4 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [beta]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 4 chains for 100 tune and 100 draw iterations (400 + 400 draws total) took 0 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 The rhat statistic is larger than 1.01 for some parameters. This indicates problems during sampling. See https://arxiv.org/abs/1903.08008 for details\n\u001b[1m\u001b[31mERROR   \u001b[0m pymc.stats.convergence:convergence.py:187 The effective sample size per chain is smaller than 100 for some parameters.  A higher number is needed for reliable rhat and ess computation. See https://arxiv.org/abs/1903.08008 for details\n\u001b[32mINFO    \u001b[0m pymc.sampling.forward:forward.py:479 Sampling: [beta, obs]\n\u001b[32mINFO    \u001b[0m pymc.sampling.forward:forward.py:919 Sampling: [obs]\n\u001b[31m\u001b[1m_________________ TestDataPyMC.test_multivariate_observations __________________\u001b[0m\n\nself = <tests.backends.test_arviz.TestDataPyMC object at 0x7f6605e73a90>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multivariate_observations\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        coords = {\u001b[33m\"\u001b[39;49;00m\u001b[33mdirection\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33my\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mz\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m], \u001b[33m\"\u001b[39;49;00m\u001b[33mexperiment\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: np.arange(\u001b[94m20\u001b[39;49;00m)}\u001b[90m\u001b[39;49;00m\n        data = np.random.multinomial(\u001b[94m20\u001b[39;49;00m, [\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], size=\u001b[94m20\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model(coords=coords):\u001b[90m\u001b[39;49;00m\n            p = pm.Beta(\u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, size=(\u001b[94m3\u001b[39;49;00m,))\u001b[90m\u001b[39;49;00m\n            p = p / p.sum()\u001b[90m\u001b[39;49;00m\n            pm.Multinomial(\u001b[33m\"\u001b[39;49;00m\u001b[33my\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m20\u001b[39;49;00m, p, dims=(\u001b[33m\"\u001b[39;49;00m\u001b[33mexperiment\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mdirection\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m), observed=data)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.*number of samples.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                idata = pm.sample(\u001b[90m\u001b[39;49;00m\n                    draws=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    chains=\u001b[94m2\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    tune=\u001b[94m100\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33mlog_likelihood\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mTrue\u001b[39;49;00m},\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n        test_dict = {\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mposterior\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33msample_stats\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mlp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mlog_likelihood\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33my\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mobserved_data\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33my\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        }\u001b[90m\u001b[39;49;00m\n        fails = check_multiple_attrs(test_dict, idata)\u001b[90m\u001b[39;49;00m\n        \u001b[94massert\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m fails\u001b[90m\u001b[39;49;00m\n        \u001b[94massert\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33mdirection\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m idata.log_likelihood.dims\u001b[90m\u001b[39;49;00m\n        \u001b[94massert\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33mdirection\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m \u001b[95min\u001b[39;49;00m idata.observed_data.dims\u001b[90m\u001b[39;49;00m\n>       \u001b[94massert\u001b[39;49;00m idata.log_likelihood[\u001b[33m\"\u001b[39;49;00m\u001b[33my\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m].shape == (\u001b[94m2\u001b[39;49;00m, \u001b[94m50\u001b[39;49;00m, \u001b[94m20\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       assert (2, 50, 1) == (2, 50, 20)\u001b[0m\n\u001b[1m\u001b[31mE         \u001b[0m\n\u001b[1m\u001b[31mE         At index 2 diff: \u001b[0m\u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m != \u001b[0m\u001b[94m20\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\u001b[0m\n\u001b[1m\u001b[31mE         Use -v to get more diff\u001b[0m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:623: AssertionError\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     150     0         0.179     3         556.34    0:00:00   0:00:00   \n                                                  draws/s                       \n     150     0         0.118     3         540.91    0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \n----------------------------- Captured stderr call -----------------------------\nOnly 50 samples per chain. Reliable r-hat and ESS diagnostics require longer chains for accurate estimate.\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [p]\nSampling 2 chains for 100 tune and 50 draw iterations (200 + 100 draws total) took 0 seconds.\nThe number of samples is too small to check convergence reliably.\n------------------------------ Captured log call -------------------------------\n\u001b[33mWARNING \u001b[0m pymc.sampling.mcmc:mcmc.py:780 Only 50 samples per chain. Reliable r-hat and ESS diagnostics require longer chains for accurate estimate.\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [p]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 100 tune and 50 draw iterations (200 + 100 draws total) took 0 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 The number of samples is too small to check convergence reliably.\n\u001b[31m\u001b[1m______________________ TestDataPyMC.test_single_chain[2] _______________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     2000    0         1.682     1         2695.88   0:00:00   0:00:00   \n                                                  draws/s                       \n     2000    0         2.072     3         2547.39   0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \n----------------------------- Captured stderr call -----------------------------\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [x]\nSampling 2 chains for 1_000 tune and 1_000 draw iterations (2_000 + 2_000 draws total) took 1 seconds.\nWe recommend running at least 4 chains for robust computation of convergence diagnostics\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [x]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 1_000 tune and 1_000 draw iterations (2_000 + 2_000 draws total) took 1 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 We recommend running at least 4 chains for robust computation of convergence diagnostics\n\u001b[31m\u001b[1m____________ TestPyMCWarmupHandling.test_save_warmup[0-50-1-False] _____________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestPyMCWarmupHandling object at 0x7f6605e72590>\nsave_warmup = False, chains = 1, tune = 0, draws = 50\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mFalse\u001b[39;49;00m, \u001b[94mTrue\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mtune,draws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m0\u001b[39;49;00m, \u001b[94m50\u001b[39;49;00m), (\u001b[94m10\u001b[39;49;00m, \u001b[94m40\u001b[39;49;00m), (\u001b[94m30\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_save_warmup\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, save_warmup, chains, tune, draws):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33mu1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mn1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.*number of samples.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mMore chains .* than draws.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                idata = pm.sample(\u001b[90m\u001b[39;49;00m\n                    tune=tune,\u001b[90m\u001b[39;49;00m\n                    draws=draws,\u001b[90m\u001b[39;49;00m\n                    chains=chains,\u001b[90m\u001b[39;49;00m\n                    cores=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>                   step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                    discard_tuned_samples=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: save_warmup},\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:742: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:261: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.delta_logp = delta_logp(initial_point, model.logp(), \u001b[96mvars\u001b[39;49;00m, shared, compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:1272: in delta_logp\n    \u001b[0mf = \u001b[96mcompile\u001b[39;49;00m([inarray1, inarray0], logp1 - logp0, **compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/pytensorf.py\u001b[0m:942: in compile\n    \u001b[0mpytensor_function = pytensor.function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1822: in orig_function\n    \u001b[0mm = Maker(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1583: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.prepare_fgraph(inputs, outputs, found_updates, fgraph, mode, profile)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1470: in prepare_fgraph\n    \u001b[0mrewriter_profile = rewriter(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:124: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.rewrite(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:120: in rewrite\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.apply(fgraph, *args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:303: in apply\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(e, \u001b[96mself\u001b[39;49;00m, rewriter)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:237: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:292: in apply\n    \u001b[0msub_prof = rewriter.apply(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:2438: in apply\n    \u001b[0mnode_rewriter_change = \u001b[96mself\u001b[39;49;00m.process_node(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1936: in process_node\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1791: in warn_inplace\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m.warn(exc, nav, repl_pairs, node_rewriter, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1779: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1933: in process_node\n    \u001b[0mreplacements = node_rewriter.transform(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1643: in transform\n    \u001b[0ms = unify(\u001b[96mself\u001b[39;49;00m.in_pattern, node.out)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:254: in unify_NoMap\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m unify(u, v, {})\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:249: in unify\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m stream_eval(_unify(u, v, s))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:45: in stream_eval\n    \u001b[0mz_out = z.send(z_args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\u001b[0m:245: in _unify_ConstrainedVar_object\n    \u001b[0m\u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m v_w.constraint(eval_if_etuple(u_w))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\u001b[0m:918: in <lambda>\n    \u001b[0m\u001b[96mall\u001b[39;49;00m(s == \u001b[94m1\u001b[39;49;00m \u001b[94mfor\u001b[39;49;00m s \u001b[95min\u001b[39;49;00m expr.type.shape) \u001b[95mand\u001b[39;49;00m config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n----------------------------- Captured stderr call -----------------------------\nERROR (pytensor.graph.rewriting.basic): Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\nERROR (pytensor.graph.rewriting.basic): node: Sub(Mul.0, Mul.0)\nERROR (pytensor.graph.rewriting.basic): TRACEBACK:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\nERROR (pytensor.graph.rewriting.basic): SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f6634e6cf10>\nERROR (pytensor.graph.rewriting.basic): Traceback:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n------------------------------ Captured log call -------------------------------\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1768 Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1769 node: Sub(Mul.0, Mul.0)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1770 TRACEBACK:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1771 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:233 SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f6634e6cf10>\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:234 Traceback:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:235 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\u001b[31m\u001b[1m_____________ TestPyMCWarmupHandling.test_save_warmup[0-50-1-True] _____________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestPyMCWarmupHandling object at 0x7f6605e9c5b0>\nsave_warmup = True, chains = 1, tune = 0, draws = 50\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mFalse\u001b[39;49;00m, \u001b[94mTrue\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mtune,draws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m0\u001b[39;49;00m, \u001b[94m50\u001b[39;49;00m), (\u001b[94m10\u001b[39;49;00m, \u001b[94m40\u001b[39;49;00m), (\u001b[94m30\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_save_warmup\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, save_warmup, chains, tune, draws):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33mu1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mn1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.*number of samples.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mMore chains .* than draws.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                idata = pm.sample(\u001b[90m\u001b[39;49;00m\n                    tune=tune,\u001b[90m\u001b[39;49;00m\n                    draws=draws,\u001b[90m\u001b[39;49;00m\n                    chains=chains,\u001b[90m\u001b[39;49;00m\n                    cores=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>                   step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                    discard_tuned_samples=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: save_warmup},\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:742: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:261: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.delta_logp = delta_logp(initial_point, model.logp(), \u001b[96mvars\u001b[39;49;00m, shared, compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:1272: in delta_logp\n    \u001b[0mf = \u001b[96mcompile\u001b[39;49;00m([inarray1, inarray0], logp1 - logp0, **compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/pytensorf.py\u001b[0m:942: in compile\n    \u001b[0mpytensor_function = pytensor.function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1822: in orig_function\n    \u001b[0mm = Maker(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1583: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.prepare_fgraph(inputs, outputs, found_updates, fgraph, mode, profile)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1470: in prepare_fgraph\n    \u001b[0mrewriter_profile = rewriter(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:124: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.rewrite(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:120: in rewrite\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.apply(fgraph, *args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:303: in apply\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(e, \u001b[96mself\u001b[39;49;00m, rewriter)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:237: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:292: in apply\n    \u001b[0msub_prof = rewriter.apply(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:2438: in apply\n    \u001b[0mnode_rewriter_change = \u001b[96mself\u001b[39;49;00m.process_node(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1936: in process_node\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1791: in warn_inplace\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m.warn(exc, nav, repl_pairs, node_rewriter, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1779: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1933: in process_node\n    \u001b[0mreplacements = node_rewriter.transform(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1643: in transform\n    \u001b[0ms = unify(\u001b[96mself\u001b[39;49;00m.in_pattern, node.out)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:254: in unify_NoMap\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m unify(u, v, {})\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:249: in unify\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m stream_eval(_unify(u, v, s))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:45: in stream_eval\n    \u001b[0mz_out = z.send(z_args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\u001b[0m:245: in _unify_ConstrainedVar_object\n    \u001b[0m\u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m v_w.constraint(eval_if_etuple(u_w))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\u001b[0m:918: in <lambda>\n    \u001b[0m\u001b[96mall\u001b[39;49;00m(s == \u001b[94m1\u001b[39;49;00m \u001b[94mfor\u001b[39;49;00m s \u001b[95min\u001b[39;49;00m expr.type.shape) \u001b[95mand\u001b[39;49;00m config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n----------------------------- Captured stderr call -----------------------------\nERROR (pytensor.graph.rewriting.basic): Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\nERROR (pytensor.graph.rewriting.basic): node: Sub(Mul.0, Mul.0)\nERROR (pytensor.graph.rewriting.basic): TRACEBACK:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\nERROR (pytensor.graph.rewriting.basic): SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f6634949f90>\nERROR (pytensor.graph.rewriting.basic): Traceback:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n------------------------------ Captured log call -------------------------------\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1768 Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1769 node: Sub(Mul.0, Mul.0)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1770 TRACEBACK:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1771 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:233 SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f6634949f90>\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:234 Traceback:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:235 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\u001b[31m\u001b[1m____________ TestPyMCWarmupHandling.test_save_warmup[0-50-2-False] _____________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestPyMCWarmupHandling object at 0x7f6605e9c190>\nsave_warmup = False, chains = 2, tune = 0, draws = 50\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mFalse\u001b[39;49;00m, \u001b[94mTrue\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mtune,draws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m0\u001b[39;49;00m, \u001b[94m50\u001b[39;49;00m), (\u001b[94m10\u001b[39;49;00m, \u001b[94m40\u001b[39;49;00m), (\u001b[94m30\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_save_warmup\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, save_warmup, chains, tune, draws):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33mu1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mn1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.*number of samples.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mMore chains .* than draws.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                idata = pm.sample(\u001b[90m\u001b[39;49;00m\n                    tune=tune,\u001b[90m\u001b[39;49;00m\n                    draws=draws,\u001b[90m\u001b[39;49;00m\n                    chains=chains,\u001b[90m\u001b[39;49;00m\n                    cores=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>                   step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                    discard_tuned_samples=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: save_warmup},\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:742: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:261: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.delta_logp = delta_logp(initial_point, model.logp(), \u001b[96mvars\u001b[39;49;00m, shared, compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:1272: in delta_logp\n    \u001b[0mf = \u001b[96mcompile\u001b[39;49;00m([inarray1, inarray0], logp1 - logp0, **compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/pytensorf.py\u001b[0m:942: in compile\n    \u001b[0mpytensor_function = pytensor.function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1822: in orig_function\n    \u001b[0mm = Maker(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1583: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.prepare_fgraph(inputs, outputs, found_updates, fgraph, mode, profile)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1470: in prepare_fgraph\n    \u001b[0mrewriter_profile = rewriter(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:124: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.rewrite(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:120: in rewrite\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.apply(fgraph, *args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:303: in apply\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(e, \u001b[96mself\u001b[39;49;00m, rewriter)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:237: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:292: in apply\n    \u001b[0msub_prof = rewriter.apply(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:2438: in apply\n    \u001b[0mnode_rewriter_change = \u001b[96mself\u001b[39;49;00m.process_node(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1936: in process_node\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1791: in warn_inplace\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m.warn(exc, nav, repl_pairs, node_rewriter, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1779: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1933: in process_node\n    \u001b[0mreplacements = node_rewriter.transform(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1643: in transform\n    \u001b[0ms = unify(\u001b[96mself\u001b[39;49;00m.in_pattern, node.out)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:254: in unify_NoMap\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m unify(u, v, {})\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:249: in unify\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m stream_eval(_unify(u, v, s))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:45: in stream_eval\n    \u001b[0mz_out = z.send(z_args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\u001b[0m:245: in _unify_ConstrainedVar_object\n    \u001b[0m\u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m v_w.constraint(eval_if_etuple(u_w))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\u001b[0m:918: in <lambda>\n    \u001b[0m\u001b[96mall\u001b[39;49;00m(s == \u001b[94m1\u001b[39;49;00m \u001b[94mfor\u001b[39;49;00m s \u001b[95min\u001b[39;49;00m expr.type.shape) \u001b[95mand\u001b[39;49;00m config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n----------------------------- Captured stderr call -----------------------------\nERROR (pytensor.graph.rewriting.basic): Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\nERROR (pytensor.graph.rewriting.basic): node: Sub(Mul.0, Mul.0)\nERROR (pytensor.graph.rewriting.basic): TRACEBACK:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\nERROR (pytensor.graph.rewriting.basic): SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f659872b4f0>\nERROR (pytensor.graph.rewriting.basic): Traceback:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n------------------------------ Captured log call -------------------------------\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1768 Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1769 node: Sub(Mul.0, Mul.0)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1770 TRACEBACK:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1771 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:233 SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f659872b4f0>\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:234 Traceback:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:235 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\u001b[31m\u001b[1m_____________ TestPyMCWarmupHandling.test_save_warmup[0-50-2-True] _____________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestPyMCWarmupHandling object at 0x7f6605e9c4f0>\nsave_warmup = True, chains = 2, tune = 0, draws = 50\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mFalse\u001b[39;49;00m, \u001b[94mTrue\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mtune,draws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m0\u001b[39;49;00m, \u001b[94m50\u001b[39;49;00m), (\u001b[94m10\u001b[39;49;00m, \u001b[94m40\u001b[39;49;00m), (\u001b[94m30\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_save_warmup\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, save_warmup, chains, tune, draws):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33mu1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mn1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.*number of samples.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mMore chains .* than draws.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                idata = pm.sample(\u001b[90m\u001b[39;49;00m\n                    tune=tune,\u001b[90m\u001b[39;49;00m\n                    draws=draws,\u001b[90m\u001b[39;49;00m\n                    chains=chains,\u001b[90m\u001b[39;49;00m\n                    cores=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>                   step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                    discard_tuned_samples=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: save_warmup},\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:742: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:261: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.delta_logp = delta_logp(initial_point, model.logp(), \u001b[96mvars\u001b[39;49;00m, shared, compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:1272: in delta_logp\n    \u001b[0mf = \u001b[96mcompile\u001b[39;49;00m([inarray1, inarray0], logp1 - logp0, **compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/pytensorf.py\u001b[0m:942: in compile\n    \u001b[0mpytensor_function = pytensor.function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1822: in orig_function\n    \u001b[0mm = Maker(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1583: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.prepare_fgraph(inputs, outputs, found_updates, fgraph, mode, profile)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1470: in prepare_fgraph\n    \u001b[0mrewriter_profile = rewriter(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:124: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.rewrite(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:120: in rewrite\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.apply(fgraph, *args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:303: in apply\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(e, \u001b[96mself\u001b[39;49;00m, rewriter)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:237: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:292: in apply\n    \u001b[0msub_prof = rewriter.apply(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:2438: in apply\n    \u001b[0mnode_rewriter_change = \u001b[96mself\u001b[39;49;00m.process_node(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1936: in process_node\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1791: in warn_inplace\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m.warn(exc, nav, repl_pairs, node_rewriter, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1779: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1933: in process_node\n    \u001b[0mreplacements = node_rewriter.transform(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1643: in transform\n    \u001b[0ms = unify(\u001b[96mself\u001b[39;49;00m.in_pattern, node.out)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:254: in unify_NoMap\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m unify(u, v, {})\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:249: in unify\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m stream_eval(_unify(u, v, s))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:45: in stream_eval\n    \u001b[0mz_out = z.send(z_args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\u001b[0m:245: in _unify_ConstrainedVar_object\n    \u001b[0m\u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m v_w.constraint(eval_if_etuple(u_w))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\u001b[0m:918: in <lambda>\n    \u001b[0m\u001b[96mall\u001b[39;49;00m(s == \u001b[94m1\u001b[39;49;00m \u001b[94mfor\u001b[39;49;00m s \u001b[95min\u001b[39;49;00m expr.type.shape) \u001b[95mand\u001b[39;49;00m config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n----------------------------- Captured stderr call -----------------------------\nERROR (pytensor.graph.rewriting.basic): Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\nERROR (pytensor.graph.rewriting.basic): node: Sub(Mul.0, Mul.0)\nERROR (pytensor.graph.rewriting.basic): TRACEBACK:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\nERROR (pytensor.graph.rewriting.basic): SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f663499e710>\nERROR (pytensor.graph.rewriting.basic): Traceback:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n------------------------------ Captured log call -------------------------------\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1768 Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1769 node: Sub(Mul.0, Mul.0)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1770 TRACEBACK:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1771 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:233 SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f663499e710>\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:234 Traceback:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:235 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\u001b[31m\u001b[1m____________ TestPyMCWarmupHandling.test_save_warmup[10-40-1-False] ____________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestPyMCWarmupHandling object at 0x7f6605e9c9d0>\nsave_warmup = False, chains = 1, tune = 10, draws = 40\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mFalse\u001b[39;49;00m, \u001b[94mTrue\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mtune,draws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m0\u001b[39;49;00m, \u001b[94m50\u001b[39;49;00m), (\u001b[94m10\u001b[39;49;00m, \u001b[94m40\u001b[39;49;00m), (\u001b[94m30\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_save_warmup\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, save_warmup, chains, tune, draws):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33mu1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mn1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.*number of samples.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mMore chains .* than draws.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                idata = pm.sample(\u001b[90m\u001b[39;49;00m\n                    tune=tune,\u001b[90m\u001b[39;49;00m\n                    draws=draws,\u001b[90m\u001b[39;49;00m\n                    chains=chains,\u001b[90m\u001b[39;49;00m\n                    cores=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>                   step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                    discard_tuned_samples=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: save_warmup},\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:742: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:261: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.delta_logp = delta_logp(initial_point, model.logp(), \u001b[96mvars\u001b[39;49;00m, shared, compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:1272: in delta_logp\n    \u001b[0mf = \u001b[96mcompile\u001b[39;49;00m([inarray1, inarray0], logp1 - logp0, **compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/pytensorf.py\u001b[0m:942: in compile\n    \u001b[0mpytensor_function = pytensor.function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1822: in orig_function\n    \u001b[0mm = Maker(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1583: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.prepare_fgraph(inputs, outputs, found_updates, fgraph, mode, profile)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1470: in prepare_fgraph\n    \u001b[0mrewriter_profile = rewriter(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:124: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.rewrite(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:120: in rewrite\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.apply(fgraph, *args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:303: in apply\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(e, \u001b[96mself\u001b[39;49;00m, rewriter)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:237: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:292: in apply\n    \u001b[0msub_prof = rewriter.apply(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:2438: in apply\n    \u001b[0mnode_rewriter_change = \u001b[96mself\u001b[39;49;00m.process_node(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1936: in process_node\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1791: in warn_inplace\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m.warn(exc, nav, repl_pairs, node_rewriter, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1779: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1933: in process_node\n    \u001b[0mreplacements = node_rewriter.transform(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1643: in transform\n    \u001b[0ms = unify(\u001b[96mself\u001b[39;49;00m.in_pattern, node.out)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:254: in unify_NoMap\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m unify(u, v, {})\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:249: in unify\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m stream_eval(_unify(u, v, s))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:45: in stream_eval\n    \u001b[0mz_out = z.send(z_args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\u001b[0m:245: in _unify_ConstrainedVar_object\n    \u001b[0m\u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m v_w.constraint(eval_if_etuple(u_w))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\u001b[0m:918: in <lambda>\n    \u001b[0m\u001b[96mall\u001b[39;49;00m(s == \u001b[94m1\u001b[39;49;00m \u001b[94mfor\u001b[39;49;00m s \u001b[95min\u001b[39;49;00m expr.type.shape) \u001b[95mand\u001b[39;49;00m config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n----------------------------- Captured stderr call -----------------------------\nERROR (pytensor.graph.rewriting.basic): Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\nERROR (pytensor.graph.rewriting.basic): node: Sub(Mul.0, Mul.0)\nERROR (pytensor.graph.rewriting.basic): TRACEBACK:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\nERROR (pytensor.graph.rewriting.basic): SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f6633ee1870>\nERROR (pytensor.graph.rewriting.basic): Traceback:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n------------------------------ Captured log call -------------------------------\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1768 Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1769 node: Sub(Mul.0, Mul.0)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1770 TRACEBACK:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1771 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:233 SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f6633ee1870>\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:234 Traceback:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:235 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\u001b[31m\u001b[1m____________ TestPyMCWarmupHandling.test_save_warmup[10-40-1-True] _____________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestPyMCWarmupHandling object at 0x7f6605e9ca90>\nsave_warmup = True, chains = 1, tune = 10, draws = 40\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mFalse\u001b[39;49;00m, \u001b[94mTrue\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mtune,draws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m0\u001b[39;49;00m, \u001b[94m50\u001b[39;49;00m), (\u001b[94m10\u001b[39;49;00m, \u001b[94m40\u001b[39;49;00m), (\u001b[94m30\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_save_warmup\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, save_warmup, chains, tune, draws):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33mu1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mn1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.*number of samples.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mMore chains .* than draws.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                idata = pm.sample(\u001b[90m\u001b[39;49;00m\n                    tune=tune,\u001b[90m\u001b[39;49;00m\n                    draws=draws,\u001b[90m\u001b[39;49;00m\n                    chains=chains,\u001b[90m\u001b[39;49;00m\n                    cores=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>                   step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                    discard_tuned_samples=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: save_warmup},\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:742: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:261: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.delta_logp = delta_logp(initial_point, model.logp(), \u001b[96mvars\u001b[39;49;00m, shared, compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:1272: in delta_logp\n    \u001b[0mf = \u001b[96mcompile\u001b[39;49;00m([inarray1, inarray0], logp1 - logp0, **compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/pytensorf.py\u001b[0m:942: in compile\n    \u001b[0mpytensor_function = pytensor.function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1822: in orig_function\n    \u001b[0mm = Maker(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1583: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.prepare_fgraph(inputs, outputs, found_updates, fgraph, mode, profile)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1470: in prepare_fgraph\n    \u001b[0mrewriter_profile = rewriter(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:124: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.rewrite(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:120: in rewrite\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.apply(fgraph, *args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:303: in apply\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(e, \u001b[96mself\u001b[39;49;00m, rewriter)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:237: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:292: in apply\n    \u001b[0msub_prof = rewriter.apply(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:2438: in apply\n    \u001b[0mnode_rewriter_change = \u001b[96mself\u001b[39;49;00m.process_node(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1936: in process_node\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1791: in warn_inplace\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m.warn(exc, nav, repl_pairs, node_rewriter, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1779: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1933: in process_node\n    \u001b[0mreplacements = node_rewriter.transform(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1643: in transform\n    \u001b[0ms = unify(\u001b[96mself\u001b[39;49;00m.in_pattern, node.out)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:254: in unify_NoMap\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m unify(u, v, {})\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:249: in unify\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m stream_eval(_unify(u, v, s))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:45: in stream_eval\n    \u001b[0mz_out = z.send(z_args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\u001b[0m:245: in _unify_ConstrainedVar_object\n    \u001b[0m\u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m v_w.constraint(eval_if_etuple(u_w))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\u001b[0m:918: in <lambda>\n    \u001b[0m\u001b[96mall\u001b[39;49;00m(s == \u001b[94m1\u001b[39;49;00m \u001b[94mfor\u001b[39;49;00m s \u001b[95min\u001b[39;49;00m expr.type.shape) \u001b[95mand\u001b[39;49;00m config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n----------------------------- Captured stderr call -----------------------------\nERROR (pytensor.graph.rewriting.basic): Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\nERROR (pytensor.graph.rewriting.basic): node: Sub(Mul.0, Mul.0)\nERROR (pytensor.graph.rewriting.basic): TRACEBACK:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\nERROR (pytensor.graph.rewriting.basic): SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f66350eedd0>\nERROR (pytensor.graph.rewriting.basic): Traceback:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n------------------------------ Captured log call -------------------------------\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1768 Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1769 node: Sub(Mul.0, Mul.0)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1770 TRACEBACK:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1771 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:233 SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f66350eedd0>\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:234 Traceback:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:235 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\u001b[31m\u001b[1m____________ TestPyMCWarmupHandling.test_save_warmup[10-40-2-False] ____________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestPyMCWarmupHandling object at 0x7f6605e9cb50>\nsave_warmup = False, chains = 2, tune = 10, draws = 40\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mFalse\u001b[39;49;00m, \u001b[94mTrue\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mtune,draws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m0\u001b[39;49;00m, \u001b[94m50\u001b[39;49;00m), (\u001b[94m10\u001b[39;49;00m, \u001b[94m40\u001b[39;49;00m), (\u001b[94m30\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_save_warmup\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, save_warmup, chains, tune, draws):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33mu1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mn1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.*number of samples.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mMore chains .* than draws.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                idata = pm.sample(\u001b[90m\u001b[39;49;00m\n                    tune=tune,\u001b[90m\u001b[39;49;00m\n                    draws=draws,\u001b[90m\u001b[39;49;00m\n                    chains=chains,\u001b[90m\u001b[39;49;00m\n                    cores=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>                   step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                    discard_tuned_samples=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: save_warmup},\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:742: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:261: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.delta_logp = delta_logp(initial_point, model.logp(), \u001b[96mvars\u001b[39;49;00m, shared, compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:1272: in delta_logp\n    \u001b[0mf = \u001b[96mcompile\u001b[39;49;00m([inarray1, inarray0], logp1 - logp0, **compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/pytensorf.py\u001b[0m:942: in compile\n    \u001b[0mpytensor_function = pytensor.function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1822: in orig_function\n    \u001b[0mm = Maker(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1583: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.prepare_fgraph(inputs, outputs, found_updates, fgraph, mode, profile)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1470: in prepare_fgraph\n    \u001b[0mrewriter_profile = rewriter(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:124: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.rewrite(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:120: in rewrite\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.apply(fgraph, *args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:303: in apply\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(e, \u001b[96mself\u001b[39;49;00m, rewriter)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:237: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:292: in apply\n    \u001b[0msub_prof = rewriter.apply(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:2438: in apply\n    \u001b[0mnode_rewriter_change = \u001b[96mself\u001b[39;49;00m.process_node(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1936: in process_node\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1791: in warn_inplace\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m.warn(exc, nav, repl_pairs, node_rewriter, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1779: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1933: in process_node\n    \u001b[0mreplacements = node_rewriter.transform(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1643: in transform\n    \u001b[0ms = unify(\u001b[96mself\u001b[39;49;00m.in_pattern, node.out)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:254: in unify_NoMap\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m unify(u, v, {})\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:249: in unify\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m stream_eval(_unify(u, v, s))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:45: in stream_eval\n    \u001b[0mz_out = z.send(z_args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\u001b[0m:245: in _unify_ConstrainedVar_object\n    \u001b[0m\u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m v_w.constraint(eval_if_etuple(u_w))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\u001b[0m:918: in <lambda>\n    \u001b[0m\u001b[96mall\u001b[39;49;00m(s == \u001b[94m1\u001b[39;49;00m \u001b[94mfor\u001b[39;49;00m s \u001b[95min\u001b[39;49;00m expr.type.shape) \u001b[95mand\u001b[39;49;00m config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n----------------------------- Captured stderr call -----------------------------\nERROR (pytensor.graph.rewriting.basic): Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\nERROR (pytensor.graph.rewriting.basic): node: Sub(Mul.0, Mul.0)\nERROR (pytensor.graph.rewriting.basic): TRACEBACK:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\nERROR (pytensor.graph.rewriting.basic): SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f6634855f00>\nERROR (pytensor.graph.rewriting.basic): Traceback:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n------------------------------ Captured log call -------------------------------\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1768 Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1769 node: Sub(Mul.0, Mul.0)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1770 TRACEBACK:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1771 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:233 SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f6634855f00>\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:234 Traceback:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:235 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\u001b[31m\u001b[1m____________ TestPyMCWarmupHandling.test_save_warmup[10-40-2-True] _____________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestPyMCWarmupHandling object at 0x7f6605e9cc10>\nsave_warmup = True, chains = 2, tune = 10, draws = 40\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mFalse\u001b[39;49;00m, \u001b[94mTrue\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mtune,draws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m0\u001b[39;49;00m, \u001b[94m50\u001b[39;49;00m), (\u001b[94m10\u001b[39;49;00m, \u001b[94m40\u001b[39;49;00m), (\u001b[94m30\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_save_warmup\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, save_warmup, chains, tune, draws):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33mu1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mn1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.*number of samples.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mMore chains .* than draws.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                idata = pm.sample(\u001b[90m\u001b[39;49;00m\n                    tune=tune,\u001b[90m\u001b[39;49;00m\n                    draws=draws,\u001b[90m\u001b[39;49;00m\n                    chains=chains,\u001b[90m\u001b[39;49;00m\n                    cores=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>                   step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                    discard_tuned_samples=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: save_warmup},\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:742: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:261: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.delta_logp = delta_logp(initial_point, model.logp(), \u001b[96mvars\u001b[39;49;00m, shared, compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:1272: in delta_logp\n    \u001b[0mf = \u001b[96mcompile\u001b[39;49;00m([inarray1, inarray0], logp1 - logp0, **compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/pytensorf.py\u001b[0m:942: in compile\n    \u001b[0mpytensor_function = pytensor.function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1822: in orig_function\n    \u001b[0mm = Maker(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1583: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.prepare_fgraph(inputs, outputs, found_updates, fgraph, mode, profile)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1470: in prepare_fgraph\n    \u001b[0mrewriter_profile = rewriter(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:124: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.rewrite(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:120: in rewrite\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.apply(fgraph, *args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:303: in apply\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(e, \u001b[96mself\u001b[39;49;00m, rewriter)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:237: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:292: in apply\n    \u001b[0msub_prof = rewriter.apply(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:2438: in apply\n    \u001b[0mnode_rewriter_change = \u001b[96mself\u001b[39;49;00m.process_node(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1936: in process_node\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1791: in warn_inplace\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m.warn(exc, nav, repl_pairs, node_rewriter, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1779: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1933: in process_node\n    \u001b[0mreplacements = node_rewriter.transform(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1643: in transform\n    \u001b[0ms = unify(\u001b[96mself\u001b[39;49;00m.in_pattern, node.out)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:254: in unify_NoMap\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m unify(u, v, {})\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:249: in unify\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m stream_eval(_unify(u, v, s))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:45: in stream_eval\n    \u001b[0mz_out = z.send(z_args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\u001b[0m:245: in _unify_ConstrainedVar_object\n    \u001b[0m\u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m v_w.constraint(eval_if_etuple(u_w))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\u001b[0m:918: in <lambda>\n    \u001b[0m\u001b[96mall\u001b[39;49;00m(s == \u001b[94m1\u001b[39;49;00m \u001b[94mfor\u001b[39;49;00m s \u001b[95min\u001b[39;49;00m expr.type.shape) \u001b[95mand\u001b[39;49;00m config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n----------------------------- Captured stderr call -----------------------------\nERROR (pytensor.graph.rewriting.basic): Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\nERROR (pytensor.graph.rewriting.basic): node: Sub(Mul.0, Mul.0)\nERROR (pytensor.graph.rewriting.basic): TRACEBACK:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\nERROR (pytensor.graph.rewriting.basic): SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f66346d1840>\nERROR (pytensor.graph.rewriting.basic): Traceback:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n------------------------------ Captured log call -------------------------------\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1768 Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1769 node: Sub(Mul.0, Mul.0)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1770 TRACEBACK:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1771 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:233 SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f66346d1840>\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:234 Traceback:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:235 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\u001b[31m\u001b[1m____________ TestPyMCWarmupHandling.test_save_warmup[30-0-1-False] _____________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestPyMCWarmupHandling object at 0x7f6605e9ccd0>\nsave_warmup = False, chains = 1, tune = 30, draws = 0\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mFalse\u001b[39;49;00m, \u001b[94mTrue\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mtune,draws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m0\u001b[39;49;00m, \u001b[94m50\u001b[39;49;00m), (\u001b[94m10\u001b[39;49;00m, \u001b[94m40\u001b[39;49;00m), (\u001b[94m30\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_save_warmup\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, save_warmup, chains, tune, draws):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33mu1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mn1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.*number of samples.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mMore chains .* than draws.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                idata = pm.sample(\u001b[90m\u001b[39;49;00m\n                    tune=tune,\u001b[90m\u001b[39;49;00m\n                    draws=draws,\u001b[90m\u001b[39;49;00m\n                    chains=chains,\u001b[90m\u001b[39;49;00m\n                    cores=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>                   step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                    discard_tuned_samples=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: save_warmup},\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:742: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:261: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.delta_logp = delta_logp(initial_point, model.logp(), \u001b[96mvars\u001b[39;49;00m, shared, compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:1272: in delta_logp\n    \u001b[0mf = \u001b[96mcompile\u001b[39;49;00m([inarray1, inarray0], logp1 - logp0, **compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/pytensorf.py\u001b[0m:942: in compile\n    \u001b[0mpytensor_function = pytensor.function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1822: in orig_function\n    \u001b[0mm = Maker(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1583: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.prepare_fgraph(inputs, outputs, found_updates, fgraph, mode, profile)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1470: in prepare_fgraph\n    \u001b[0mrewriter_profile = rewriter(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:124: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.rewrite(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:120: in rewrite\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.apply(fgraph, *args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:303: in apply\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(e, \u001b[96mself\u001b[39;49;00m, rewriter)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:237: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:292: in apply\n    \u001b[0msub_prof = rewriter.apply(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:2438: in apply\n    \u001b[0mnode_rewriter_change = \u001b[96mself\u001b[39;49;00m.process_node(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1936: in process_node\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1791: in warn_inplace\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m.warn(exc, nav, repl_pairs, node_rewriter, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1779: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1933: in process_node\n    \u001b[0mreplacements = node_rewriter.transform(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1643: in transform\n    \u001b[0ms = unify(\u001b[96mself\u001b[39;49;00m.in_pattern, node.out)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:254: in unify_NoMap\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m unify(u, v, {})\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:249: in unify\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m stream_eval(_unify(u, v, s))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:45: in stream_eval\n    \u001b[0mz_out = z.send(z_args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\u001b[0m:245: in _unify_ConstrainedVar_object\n    \u001b[0m\u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m v_w.constraint(eval_if_etuple(u_w))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\u001b[0m:918: in <lambda>\n    \u001b[0m\u001b[96mall\u001b[39;49;00m(s == \u001b[94m1\u001b[39;49;00m \u001b[94mfor\u001b[39;49;00m s \u001b[95min\u001b[39;49;00m expr.type.shape) \u001b[95mand\u001b[39;49;00m config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n----------------------------- Captured stderr call -----------------------------\nERROR (pytensor.graph.rewriting.basic): Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\nERROR (pytensor.graph.rewriting.basic): node: Sub(Mul.0, Mul.0)\nERROR (pytensor.graph.rewriting.basic): TRACEBACK:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\nERROR (pytensor.graph.rewriting.basic): SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f659879b280>\nERROR (pytensor.graph.rewriting.basic): Traceback:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n------------------------------ Captured log call -------------------------------\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1768 Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1769 node: Sub(Mul.0, Mul.0)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1770 TRACEBACK:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1771 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:233 SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f659879b280>\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:234 Traceback:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:235 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\u001b[31m\u001b[1m_____________ TestPyMCWarmupHandling.test_save_warmup[30-0-1-True] _____________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestPyMCWarmupHandling object at 0x7f6605e9cd90>\nsave_warmup = True, chains = 1, tune = 30, draws = 0\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mFalse\u001b[39;49;00m, \u001b[94mTrue\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mtune,draws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m0\u001b[39;49;00m, \u001b[94m50\u001b[39;49;00m), (\u001b[94m10\u001b[39;49;00m, \u001b[94m40\u001b[39;49;00m), (\u001b[94m30\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_save_warmup\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, save_warmup, chains, tune, draws):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33mu1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mn1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.*number of samples.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mMore chains .* than draws.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                idata = pm.sample(\u001b[90m\u001b[39;49;00m\n                    tune=tune,\u001b[90m\u001b[39;49;00m\n                    draws=draws,\u001b[90m\u001b[39;49;00m\n                    chains=chains,\u001b[90m\u001b[39;49;00m\n                    cores=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>                   step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                    discard_tuned_samples=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: save_warmup},\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:742: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:261: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.delta_logp = delta_logp(initial_point, model.logp(), \u001b[96mvars\u001b[39;49;00m, shared, compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:1272: in delta_logp\n    \u001b[0mf = \u001b[96mcompile\u001b[39;49;00m([inarray1, inarray0], logp1 - logp0, **compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/pytensorf.py\u001b[0m:942: in compile\n    \u001b[0mpytensor_function = pytensor.function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1822: in orig_function\n    \u001b[0mm = Maker(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1583: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.prepare_fgraph(inputs, outputs, found_updates, fgraph, mode, profile)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1470: in prepare_fgraph\n    \u001b[0mrewriter_profile = rewriter(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:124: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.rewrite(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:120: in rewrite\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.apply(fgraph, *args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:303: in apply\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(e, \u001b[96mself\u001b[39;49;00m, rewriter)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:237: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:292: in apply\n    \u001b[0msub_prof = rewriter.apply(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:2438: in apply\n    \u001b[0mnode_rewriter_change = \u001b[96mself\u001b[39;49;00m.process_node(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1936: in process_node\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1791: in warn_inplace\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m.warn(exc, nav, repl_pairs, node_rewriter, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1779: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1933: in process_node\n    \u001b[0mreplacements = node_rewriter.transform(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1643: in transform\n    \u001b[0ms = unify(\u001b[96mself\u001b[39;49;00m.in_pattern, node.out)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:254: in unify_NoMap\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m unify(u, v, {})\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:249: in unify\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m stream_eval(_unify(u, v, s))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:45: in stream_eval\n    \u001b[0mz_out = z.send(z_args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\u001b[0m:245: in _unify_ConstrainedVar_object\n    \u001b[0m\u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m v_w.constraint(eval_if_etuple(u_w))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\u001b[0m:918: in <lambda>\n    \u001b[0m\u001b[96mall\u001b[39;49;00m(s == \u001b[94m1\u001b[39;49;00m \u001b[94mfor\u001b[39;49;00m s \u001b[95min\u001b[39;49;00m expr.type.shape) \u001b[95mand\u001b[39;49;00m config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n----------------------------- Captured stderr call -----------------------------\nERROR (pytensor.graph.rewriting.basic): Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\nERROR (pytensor.graph.rewriting.basic): node: Sub(Mul.0, Mul.0)\nERROR (pytensor.graph.rewriting.basic): TRACEBACK:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\nERROR (pytensor.graph.rewriting.basic): SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f66344971f0>\nERROR (pytensor.graph.rewriting.basic): Traceback:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n------------------------------ Captured log call -------------------------------\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1768 Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1769 node: Sub(Mul.0, Mul.0)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1770 TRACEBACK:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1771 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:233 SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f66344971f0>\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:234 Traceback:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:235 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\u001b[31m\u001b[1m____________ TestPyMCWarmupHandling.test_save_warmup[30-0-2-False] _____________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestPyMCWarmupHandling object at 0x7f6605e9ce50>\nsave_warmup = False, chains = 2, tune = 30, draws = 0\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mFalse\u001b[39;49;00m, \u001b[94mTrue\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mtune,draws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m0\u001b[39;49;00m, \u001b[94m50\u001b[39;49;00m), (\u001b[94m10\u001b[39;49;00m, \u001b[94m40\u001b[39;49;00m), (\u001b[94m30\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_save_warmup\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, save_warmup, chains, tune, draws):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33mu1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mn1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.*number of samples.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mMore chains .* than draws.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                idata = pm.sample(\u001b[90m\u001b[39;49;00m\n                    tune=tune,\u001b[90m\u001b[39;49;00m\n                    draws=draws,\u001b[90m\u001b[39;49;00m\n                    chains=chains,\u001b[90m\u001b[39;49;00m\n                    cores=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>                   step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                    discard_tuned_samples=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: save_warmup},\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:742: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:261: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.delta_logp = delta_logp(initial_point, model.logp(), \u001b[96mvars\u001b[39;49;00m, shared, compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:1272: in delta_logp\n    \u001b[0mf = \u001b[96mcompile\u001b[39;49;00m([inarray1, inarray0], logp1 - logp0, **compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/pytensorf.py\u001b[0m:942: in compile\n    \u001b[0mpytensor_function = pytensor.function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1822: in orig_function\n    \u001b[0mm = Maker(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1583: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.prepare_fgraph(inputs, outputs, found_updates, fgraph, mode, profile)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1470: in prepare_fgraph\n    \u001b[0mrewriter_profile = rewriter(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:124: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.rewrite(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:120: in rewrite\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.apply(fgraph, *args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:303: in apply\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(e, \u001b[96mself\u001b[39;49;00m, rewriter)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:237: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:292: in apply\n    \u001b[0msub_prof = rewriter.apply(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:2438: in apply\n    \u001b[0mnode_rewriter_change = \u001b[96mself\u001b[39;49;00m.process_node(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1936: in process_node\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1791: in warn_inplace\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m.warn(exc, nav, repl_pairs, node_rewriter, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1779: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1933: in process_node\n    \u001b[0mreplacements = node_rewriter.transform(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1643: in transform\n    \u001b[0ms = unify(\u001b[96mself\u001b[39;49;00m.in_pattern, node.out)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:254: in unify_NoMap\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m unify(u, v, {})\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:249: in unify\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m stream_eval(_unify(u, v, s))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:45: in stream_eval\n    \u001b[0mz_out = z.send(z_args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\u001b[0m:245: in _unify_ConstrainedVar_object\n    \u001b[0m\u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m v_w.constraint(eval_if_etuple(u_w))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\u001b[0m:918: in <lambda>\n    \u001b[0m\u001b[96mall\u001b[39;49;00m(s == \u001b[94m1\u001b[39;49;00m \u001b[94mfor\u001b[39;49;00m s \u001b[95min\u001b[39;49;00m expr.type.shape) \u001b[95mand\u001b[39;49;00m config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n----------------------------- Captured stderr call -----------------------------\nERROR (pytensor.graph.rewriting.basic): Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\nERROR (pytensor.graph.rewriting.basic): node: Sub(Mul.0, Mul.0)\nERROR (pytensor.graph.rewriting.basic): TRACEBACK:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\nERROR (pytensor.graph.rewriting.basic): SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f663490ba90>\nERROR (pytensor.graph.rewriting.basic): Traceback:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n------------------------------ Captured log call -------------------------------\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1768 Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1769 node: Sub(Mul.0, Mul.0)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1770 TRACEBACK:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1771 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:233 SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f663490ba90>\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:234 Traceback:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:235 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\u001b[31m\u001b[1m_____________ TestPyMCWarmupHandling.test_save_warmup[30-0-2-True] _____________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestPyMCWarmupHandling object at 0x7f6605e9cf10>\nsave_warmup = True, chains = 2, tune = 30, draws = 0\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mFalse\u001b[39;49;00m, \u001b[94mTrue\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mtune,draws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m0\u001b[39;49;00m, \u001b[94m50\u001b[39;49;00m), (\u001b[94m10\u001b[39;49;00m, \u001b[94m40\u001b[39;49;00m), (\u001b[94m30\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_save_warmup\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, save_warmup, chains, tune, draws):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33mu1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mn1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.*number of samples.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mMore chains .* than draws.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                idata = pm.sample(\u001b[90m\u001b[39;49;00m\n                    tune=tune,\u001b[90m\u001b[39;49;00m\n                    draws=draws,\u001b[90m\u001b[39;49;00m\n                    chains=chains,\u001b[90m\u001b[39;49;00m\n                    cores=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>                   step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                    discard_tuned_samples=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    idata_kwargs={\u001b[33m\"\u001b[39;49;00m\u001b[33msave_warmup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: save_warmup},\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:742: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:261: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.delta_logp = delta_logp(initial_point, model.logp(), \u001b[96mvars\u001b[39;49;00m, shared, compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:1272: in delta_logp\n    \u001b[0mf = \u001b[96mcompile\u001b[39;49;00m([inarray1, inarray0], logp1 - logp0, **compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/pytensorf.py\u001b[0m:942: in compile\n    \u001b[0mpytensor_function = pytensor.function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1822: in orig_function\n    \u001b[0mm = Maker(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1583: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.prepare_fgraph(inputs, outputs, found_updates, fgraph, mode, profile)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1470: in prepare_fgraph\n    \u001b[0mrewriter_profile = rewriter(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:124: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.rewrite(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:120: in rewrite\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.apply(fgraph, *args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:303: in apply\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(e, \u001b[96mself\u001b[39;49;00m, rewriter)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:237: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:292: in apply\n    \u001b[0msub_prof = rewriter.apply(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:2438: in apply\n    \u001b[0mnode_rewriter_change = \u001b[96mself\u001b[39;49;00m.process_node(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1936: in process_node\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1791: in warn_inplace\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m.warn(exc, nav, repl_pairs, node_rewriter, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1779: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1933: in process_node\n    \u001b[0mreplacements = node_rewriter.transform(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1643: in transform\n    \u001b[0ms = unify(\u001b[96mself\u001b[39;49;00m.in_pattern, node.out)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:254: in unify_NoMap\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m unify(u, v, {})\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:249: in unify\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m stream_eval(_unify(u, v, s))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:45: in stream_eval\n    \u001b[0mz_out = z.send(z_args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\u001b[0m:245: in _unify_ConstrainedVar_object\n    \u001b[0m\u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m v_w.constraint(eval_if_etuple(u_w))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\u001b[0m:918: in <lambda>\n    \u001b[0m\u001b[96mall\u001b[39;49;00m(s == \u001b[94m1\u001b[39;49;00m \u001b[94mfor\u001b[39;49;00m s \u001b[95min\u001b[39;49;00m expr.type.shape) \u001b[95mand\u001b[39;49;00m config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n----------------------------- Captured stderr call -----------------------------\nERROR (pytensor.graph.rewriting.basic): Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\nERROR (pytensor.graph.rewriting.basic): node: Sub(Mul.0, Mul.0)\nERROR (pytensor.graph.rewriting.basic): TRACEBACK:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\nERROR (pytensor.graph.rewriting.basic): SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f6634a0af20>\nERROR (pytensor.graph.rewriting.basic): Traceback:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n------------------------------ Captured log call -------------------------------\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1768 Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1769 node: Sub(Mul.0, Mul.0)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1770 TRACEBACK:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1771 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:233 SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f6634a0af20>\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:234 Traceback:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:235 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\u001b[31m\u001b[1m_________ TestPyMCWarmupHandling.test_save_warmup_issue_1208_after_3_9 _________\u001b[0m\n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:300: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:783: in get\n    \u001b[0md = \u001b[96mself\u001b[39;49;00m._unify_values(section, \u001b[96mvars\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x7f662fde4c70>, section = 'blas'\nvars = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_unify_values\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, section, \u001b[96mvars\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Create a sequence of lookups with 'vars' taking priority over\u001b[39;49;00m\n    \u001b[33m    the 'section' which takes priority over the DEFAULTSECT.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        sectiondict = {}\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sectiondict = \u001b[96mself\u001b[39;49;00m._sections[section]\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m section != \u001b[96mself\u001b[39;49;00m.default_section:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m NoSectionError(section) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               configparser.NoSectionError: No section: 'blas'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/lib/python3.10/configparser.py\u001b[0m:1154: NoSectionError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <pytensor.configparser.StrParam object at 0x7f662fbd48b0>\ncls = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\ntype_ = <class 'pytensor.configparser.PyTensorConfigParser'>, delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__get__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[96mcls\u001b[39;49;00m, type_, delete_key=\u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name \u001b[95mnot\u001b[39;49;00m \u001b[95min\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m._config_var_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m ConfigAccessViolation(\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mThe config parameter \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.name\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m was registered on a different instance of the PyTensorConfigParser.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m It is not accessible through the instance with id \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mid\u001b[39;49;00m(\u001b[96mcls\u001b[39;49;00m)\u001b[33m}\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m because of safeguarding.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mval\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               val_str = \u001b[96mcls\u001b[39;49;00m.fetch_val_for_key(\u001b[96mself\u001b[39;49;00m.name, delete_key=delete_key)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.configparser.PyTensorConfigParser object at 0x7f662fde5c60>\nkey = 'blas__ldflags', delete_key = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mfetch_val_for_key\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, key, delete_key: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Return the overriding config value for a key.\u001b[39;49;00m\n    \u001b[33m    A successful search returns a string value.\u001b[39;49;00m\n    \u001b[33m    An unsuccessful search raises a KeyError\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    The (decreasing) priority order is:\u001b[39;49;00m\n    \u001b[33m    - PYTENSOR_FLAGS\u001b[39;49;00m\n    \u001b[33m    - ~/.pytensorrc\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# first try to find it in the FLAGS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict:\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m delete_key:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict.pop(key)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._flags_dict[key]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# next try to find it in the config file\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# config file keys can be of form option, or section__option\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        key_tokens = key.rsplit(\u001b[33m\"\u001b[39;49;00m\u001b[33m__\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) > \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(key_tokens) == \u001b[94m2\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = key_tokens\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            section, option = \u001b[33m\"\u001b[39;49;00m\u001b[33mglobal\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, key\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m InterpolationError:\u001b[90m\u001b[39;49;00m\n                \u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._pytensor_raw_cfg.get(section, option)\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m (NoOptionError, NoSectionError):\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mKeyError\u001b[39;49;00m(key)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           KeyError: 'blas__ldflags'\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:304: KeyError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.backends.test_arviz.TestPyMCWarmupHandling object at 0x7f6605e9d0c0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_save_warmup_issue_1208_after_3_9\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33mu1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mn1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n                warnings.filterwarnings(\u001b[33m\"\u001b[39;49;00m\u001b[33mignore\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mTuning samples will be included.*\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mUserWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n                trace = pm.sample(\u001b[90m\u001b[39;49;00m\n                    tune=\u001b[94m100\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    draws=\u001b[94m200\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    chains=\u001b[94m2\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    cores=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n>                   step=pm.Metropolis(),\u001b[90m\u001b[39;49;00m\n                    discard_tuned_samples=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    return_inferencedata=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/backends/test_arviz.py\u001b[0m:777: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/step_methods/compound.py\u001b[0m:170: in __new__\n    \u001b[0mstep.\u001b[92m__init__\u001b[39;49;00m([var], *args, **_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:261: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.delta_logp = delta_logp(initial_point, model.logp(), \u001b[96mvars\u001b[39;49;00m, shared, compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/step_methods/metropolis.py\u001b[0m:1272: in delta_logp\n    \u001b[0mf = \u001b[96mcompile\u001b[39;49;00m([inarray1, inarray0], logp1 - logp0, **compile_kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/pytensorf.py\u001b[0m:942: in compile\n    \u001b[0mpytensor_function = pytensor.function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/__init__.py\u001b[0m:332: in function\n    \u001b[0mfn = pfunc(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/pfunc.py\u001b[0m:466: in pfunc\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m orig_function(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1822: in orig_function\n    \u001b[0mm = Maker(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1583: in __init__\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.prepare_fgraph(inputs, outputs, found_updates, fgraph, mode, profile)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1470: in prepare_fgraph\n    \u001b[0mrewriter_profile = rewriter(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:124: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.rewrite(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:120: in rewrite\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.apply(fgraph, *args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:303: in apply\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(e, \u001b[96mself\u001b[39;49;00m, rewriter)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:237: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:292: in apply\n    \u001b[0msub_prof = rewriter.apply(fgraph)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:2438: in apply\n    \u001b[0mnode_rewriter_change = \u001b[96mself\u001b[39;49;00m.process_node(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1936: in process_node\n    \u001b[0m\u001b[96mself\u001b[39;49;00m.failure_callback(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1791: in warn_inplace\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcls\u001b[39;49;00m.warn(exc, nav, repl_pairs, node_rewriter, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1779: in warn\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1933: in process_node\n    \u001b[0mreplacements = node_rewriter.transform(fgraph, node)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\u001b[0m:1643: in transform\n    \u001b[0ms = unify(\u001b[96mself\u001b[39;49;00m.in_pattern, node.out)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:254: in unify_NoMap\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m unify(u, v, {})\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\u001b[0m:279: in __call__\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m func(*args, **kwargs)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:249: in unify\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m stream_eval(_unify(u, v, s))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/unification/core.py\u001b[0m:45: in stream_eval\n    \u001b[0mz_out = z.send(z_args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\u001b[0m:245: in _unify_ConstrainedVar_object\n    \u001b[0m\u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m v_w.constraint(eval_if_etuple(u_w))\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\u001b[0m:918: in <lambda>\n    \u001b[0m\u001b[96mall\u001b[39;49;00m(s == \u001b[94m1\u001b[39;49;00m \u001b[94mfor\u001b[39;49;00m s \u001b[95min\u001b[39;49;00m expr.type.shape) \u001b[95mand\u001b[39;49;00m config.blas__ldflags\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\u001b[0m:419: in __get__\n    \u001b[0mval_str = \u001b[96mself\u001b[39;49;00m.default()\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mdefault_blas_ldflags\u001b[39;49;00m() -> \u001b[96mstr\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Look for an available BLAS implementation in the system.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    This function tries to compile a simple C code that uses the BLAS\u001b[39;49;00m\n    \u001b[33m    if the required files are found in the system.\u001b[39;49;00m\n    \u001b[33m    It sequentially tries to link to the following implementations, until one is found:\u001b[39;49;00m\n    \u001b[33m    1. Intel MKL with Intel OpenMP threading\u001b[39;49;00m\n    \u001b[33m    2. Intel MKL with GNU OpenMP threading\u001b[39;49;00m\n    \u001b[33m    3. Lapack + BLAS\u001b[39;49;00m\n    \u001b[33m    4. BLAS alone\u001b[39;49;00m\n    \u001b[33m    5. OpenBLAS\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    blas flags: str\u001b[39;49;00m\n    \u001b[33m        Blas flags needed to link to the BLAS implementation found in the system.\u001b[39;49;00m\n    \u001b[33m        If no BLAS implementation is found, an empty string is returned.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Notes\u001b[39;49;00m\n    \u001b[33m    -----\u001b[39;49;00m\n    \u001b[33m    This function is triggered when `pytensor.config.blas__ldflags` is not given a user\u001b[39;49;00m\n    \u001b[33m    default, and it is first accessed at runtime. It can be rather slow, so it is advised\u001b[39;49;00m\n    \u001b[33m    to cache the results of this function in PYTENSORRC configuration file or\u001b[39;49;00m\n    \u001b[33m    PyTensor environment flags.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# If no compiler is available we default to empty ldflags\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m config.cxx:\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        _std_lib_dirs = std_lib_dirs()\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(_std_lib_dirs) > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = _std_lib_dirs[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rpath = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        cxx_library_dirs = _get_cxx_library_dirs()\u001b[90m\u001b[39;49;00m\n        searched_library_dirs = cxx_library_dirs + _std_lib_dirs\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sys.platform == \u001b[33m\"\u001b[39;49;00m\u001b[33mwin32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Conda on Windows saves MKL libraries under CONDA_PREFIX\\Library\\bin\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# From the conda manual (https://docs.conda.io/projects/conda-build/en/stable/user-guide/environment-variables.html)\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# it seems like conda could also save some libraries into the CONDA_PREFIX\\Library\\lib\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# directory. We will include both in our searched library dirs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mbin\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            searched_library_dirs.append(os.path.join(sys.prefix, \u001b[33m\"\u001b[39;49;00m\u001b[33mLibrary\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mlib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        search_dirs = \u001b[33m\"\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m.join(searched_library_dirs)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mWill search for BLAS libraries in the following directories:\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m%s\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            search_dirs,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        all_libs = [\u001b[90m\u001b[39;49;00m\n            l\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m path \u001b[95min\u001b[39;49;00m [\u001b[90m\u001b[39;49;00m\n                Path(library_dir)\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m library_dir \u001b[95min\u001b[39;49;00m searched_library_dirs\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m Path(library_dir).exists()\u001b[90m\u001b[39;49;00m\n            ]\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m l \u001b[95min\u001b[39;49;00m path.iterdir()\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m l.suffix \u001b[95min\u001b[39;49;00m {\u001b[33m\"\u001b[39;49;00m\u001b[33m.so\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dll\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33m.dylib\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        ]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            maybe_add_to_os_environ_pathlist(\u001b[33m\"\u001b[39;49;00m\u001b[33mPATH\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, rpath)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 1. Try to use MKL with INTEL OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with intel threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_intel_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33miomp5\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                ],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 2. Try to use MKL with GNU OpenMP threading\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking MKL flags with GNU OpenMP threading\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_core\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_rt\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mmkl_gnu_thread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mpthread\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 3. Mac Accelerate framework\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Accelerate framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            flags = [\u001b[33m\"\u001b[39;49;00m\u001b[33m-framework\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m rpath:\u001b[90m\u001b[39;49;00m\n                flags = [*flags, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n            validated_flags = try_blas_flag(flags)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m validated_flags == \u001b[33m\"\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mAccelerate framework flag failed \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m validated_flags\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking Lapack + blas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 4. Try to use LAPACK + BLAS\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mlapack\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 5. Try to use BLAS alone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking blas alone\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m [],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# 6. Try to use openblas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mChecking openblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m _check_libs(\u001b[90m\u001b[39;49;00m\n                all_libs,\u001b[90m\u001b[39;49;00m\n                required_libs=[\u001b[33m\"\u001b[39;49;00m\u001b[33mopenblas\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgfortran\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mgomp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mm\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                extra_compile_flags=[\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m-Wl,-rpath,\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mrpath\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m rpath \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m [\u001b[33m\"\u001b[39;49;00m\u001b[33m-fopenmp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                cxx_library_dirs=cxx_library_dirs,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n            _logger.debug(e)\u001b[90m\u001b[39;49;00m\n        _logger.debug(\u001b[33m\"\u001b[39;49;00m\u001b[33mFailed to identify blas ldflags. Will leave them empty.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       warnings.warn(\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mPyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mby setting `pytensor.config.mode == \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` or passing `mode=\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mNUMBA\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33m` when compiling a PyTensor function.\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[96mUserWarning\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\u001b[0m\n\u001b[1m\u001b[31mE       This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\u001b[0m\n\u001b[1m\u001b[31mE       Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\u001b[0m\n\u001b[1m\u001b[31mE       For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\u001b[0m:2968: UserWarning\n----------------------------- Captured stderr call -----------------------------\nERROR (pytensor.graph.rewriting.basic): Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\nERROR (pytensor.graph.rewriting.basic): node: Sub(Mul.0, Mul.0)\nERROR (pytensor.graph.rewriting.basic): TRACEBACK:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\nERROR (pytensor.graph.rewriting.basic): SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f6634a67cd0>\nERROR (pytensor.graph.rewriting.basic): Traceback:\nERROR (pytensor.graph.rewriting.basic): Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n------------------------------ Captured log call -------------------------------\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1768 Rewrite failure due to: e(Sub, ~z, e(Mul, ~alpha [<function <lambda> at 0x7f660e05f2e0>], e(SparseDot, ~x, ~y))) -> e(Usmm{no_inplace}, e(Neg, ~alpha [<function <lambda> at 0x7f660e05f2e0>]), ~x, ~y, ~z)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1769 node: Sub(Mul.0, Mul.0)\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1770 TRACEBACK:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:1771 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:233 SequentialGraphRewriter apply <pytensor.graph.rewriting.basic.EquilibriumGraphRewriter object at 0x7f6634a67cd0>\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:234 Traceback:\n\u001b[1m\u001b[31mERROR   \u001b[0m pytensor.graph.rewriting.basic:basic.py:235 Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 300, in fetch_val_for_key\n    return self._pytensor_cfg.get(section, option)\n  File \"/usr/lib/python3.10/configparser.py\", line 783, in get\n    d = self._unify_values(section, vars)\n  File \"/usr/lib/python3.10/configparser.py\", line 1154, in _unify_values\n    raise NoSectionError(section) from None\nconfigparser.NoSectionError: No section: 'blas'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 415, in __get__\n    val_str = cls.fetch_val_for_key(self.name, delete_key=delete_key)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 304, in fetch_val_for_key\n    raise KeyError(key)\nKeyError: 'blas__ldflags'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 292, in apply\n    sub_prof = rewriter.apply(fgraph)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 2438, in apply\n    node_rewriter_change = self.process_node(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1936, in process_node\n    self.failure_callback(\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1791, in warn_inplace\n    return cls.warn(exc, nav, repl_pairs, node_rewriter, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1779, in warn\n    raise exc\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1933, in process_node\n    replacements = node_rewriter.transform(fgraph, node)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/basic.py\", line 1643, in transform\n    s = unify(self.in_pattern, node.out)\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 254, in unify_NoMap\n    return unify(u, v, {})\n  File \"/usr/local/lib/python3.10/dist-packages/multipledispatch/dispatcher.py\", line 279, in __call__\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 249, in unify\n    return stream_eval(_unify(u, v, s))\n  File \"/usr/local/lib/python3.10/dist-packages/unification/core.py\", line 45, in stream_eval\n    z_out = z.send(z_args)\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/rewriting/unify.py\", line 245, in _unify_ConstrainedVar_object\n    and not v_w.constraint(eval_if_etuple(u_w))\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/sparse/rewriting.py\", line 918, in <lambda>\n    all(s == 1 for s in expr.type.shape) and config.blas__ldflags\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/configparser.py\", line 419, in __get__\n    val_str = self.default()\n  File \"/usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py\", line 2968, in default_blas_ldflags\n    warnings.warn(\nUserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\nThis usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\nAlternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\nFor more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n\u001b[31m\u001b[1m______________________________ test_simple_model _______________________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stderr call -----------------------------\nSampling: [sigma, x, y]\nOnly 50 samples per chain. Reliable r-hat and ESS diagnostics require longer chains for accurate estimate.\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [x, sigma]\nSampling 2 chains for 200 tune and 50 draw iterations (400 + 100 draws total) took 1 seconds.\nSampling: [y]\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.forward:forward.py:479 Sampling: [sigma, x, y]\n\u001b[33mWARNING \u001b[0m pymc.sampling.mcmc:mcmc.py:780 Only 50 samples per chain. Reliable r-hat and ESS diagnostics require longer chains for accurate estimate.\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [x, sigma]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 200 tune and 50 draw iterations (400 + 100 draws total) took 1 seconds.\n\u001b[32mINFO    \u001b[0m pymc.sampling.forward:forward.py:919 Sampling: [y]\n\u001b[31m\u001b[1m______________________________ test_complex_model ______________________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stderr call -----------------------------\nSampling: [beta_0, sigma, sigma_beta0, y_obs, z]\nOnly 50 samples per chain. Reliable r-hat and ESS diagnostics require longer chains for accurate estimate.\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [sigma, sigma_beta0, beta_0, z]\nSampling 2 chains for 200 tune and 50 draw iterations (400 + 100 draws total) took 5 seconds.\nSampling: [y_obs]\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.forward:forward.py:479 Sampling: [beta_0, sigma, sigma_beta0, y_obs, z]\n\u001b[33mWARNING \u001b[0m pymc.sampling.mcmc:mcmc.py:780 Only 50 samples per chain. Reliable r-hat and ESS diagnostics require longer chains for accurate estimate.\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [sigma, sigma_beta0, beta_0, z]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 200 tune and 50 draw iterations (400 + 100 draws total) took 5 seconds.\n\u001b[32mINFO    \u001b[0m pymc.sampling.forward:forward.py:919 Sampling: [y_obs]\n\u001b[31m\u001b[1m_____________ TestMixtureSameFamily.test_with_multinomial[(3, 4)] ______________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f66327dfcd0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f654060ddf0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_mixture.TestMixtureSameFamily object at 0x7f6604c7b2b0>\nseeded_test = None, batch_shape = (3, 4)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mbatch_shape\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m3\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m), (\u001b[94m20\u001b[39;49;00m,)], ids=\u001b[96mstr\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_with_multinomial\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, seeded_test, batch_shape):\u001b[90m\u001b[39;49;00m\n        p = np.random.uniform(size=(*batch_shape, \u001b[96mself\u001b[39;49;00m.mixture_comps, \u001b[94m3\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        n = \u001b[94m100\u001b[39;49;00m * np.ones((*batch_shape, \u001b[94m1\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        w = np.ones(\u001b[96mself\u001b[39;49;00m.mixture_comps) / \u001b[96mself\u001b[39;49;00m.mixture_comps\u001b[90m\u001b[39;49;00m\n        mixture_axis = \u001b[96mlen\u001b[39;49;00m(batch_shape)\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            comp_dists = Multinomial.dist(p=p, n=n, shape=(*batch_shape, \u001b[96mself\u001b[39;49;00m.mixture_comps, \u001b[94m3\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            mixture = Mixture(\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mmixture\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                w=w,\u001b[90m\u001b[39;49;00m\n                comp_dists=comp_dists,\u001b[90m\u001b[39;49;00m\n                shape=(*batch_shape, \u001b[94m3\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n            prior = sample_prior_predictive(draws=\u001b[96mself\u001b[39;49;00m.n_samples, return_inferencedata=\u001b[94mFalse\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94massert\u001b[39;49;00m prior[\u001b[33m\"\u001b[39;49;00m\u001b[33mmixture\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m].shape == (\u001b[96mself\u001b[39;49;00m.n_samples, *batch_shape, \u001b[94m3\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94massert\u001b[39;49;00m draw(mixture, draws=\u001b[96mself\u001b[39;49;00m.size).shape == (\u001b[96mself\u001b[39;49;00m.size, *batch_shape, \u001b[94m3\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m pytensor.config.floatX == \u001b[33m\"\u001b[39;49;00m\u001b[33mfloat32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rtol = \u001b[94m1e-4\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rtol = \u001b[94m1e-7\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        initial_point = model.initial_point()\u001b[90m\u001b[39;49;00m\n        comp_logp = logp(comp_dists, initial_point[\u001b[33m\"\u001b[39;49;00m\u001b[33mmixture\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m].reshape(*batch_shape, \u001b[94m1\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        log_sum_exp = logsumexp(\u001b[90m\u001b[39;49;00m\n>           comp_logp.eval() + np.log(w), axis=mixture_axis, keepdims=\u001b[94mTrue\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        ).sum()\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_mixture.py\u001b[0m:1051: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f66327dfcd0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f654060ddf0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[-17642. ... 4381612]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(3, 4, 1)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(3, 4, 1), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(32, 8, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: ['not shown', np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor3(float64, shape=(3, 4, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[-17642. ... 4381612]]] [id B] <Tensor3(float64, shape=(3, 4, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[-17642. ... 4381612]]], Shape: (3, 4, 1), ElemSize: 8 Byte(s), TotalSize: 96 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 97.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 97.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n----------------------------- Captured stderr call -----------------------------\nSampling: [mixture]\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.forward:forward.py:479 Sampling: [mixture]\n\u001b[31m\u001b[1m______________ TestMixtureSameFamily.test_with_multinomial[(20,)] ______________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f64fc634e80>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f65645115a0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_mixture.TestMixtureSameFamily object at 0x7f6604c78fa0>\nseeded_test = None, batch_shape = (20,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mbatch_shape\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m3\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m), (\u001b[94m20\u001b[39;49;00m,)], ids=\u001b[96mstr\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_with_multinomial\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, seeded_test, batch_shape):\u001b[90m\u001b[39;49;00m\n        p = np.random.uniform(size=(*batch_shape, \u001b[96mself\u001b[39;49;00m.mixture_comps, \u001b[94m3\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        n = \u001b[94m100\u001b[39;49;00m * np.ones((*batch_shape, \u001b[94m1\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        w = np.ones(\u001b[96mself\u001b[39;49;00m.mixture_comps) / \u001b[96mself\u001b[39;49;00m.mixture_comps\u001b[90m\u001b[39;49;00m\n        mixture_axis = \u001b[96mlen\u001b[39;49;00m(batch_shape)\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            comp_dists = Multinomial.dist(p=p, n=n, shape=(*batch_shape, \u001b[96mself\u001b[39;49;00m.mixture_comps, \u001b[94m3\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n            mixture = Mixture(\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mmixture\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                w=w,\u001b[90m\u001b[39;49;00m\n                comp_dists=comp_dists,\u001b[90m\u001b[39;49;00m\n                shape=(*batch_shape, \u001b[94m3\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n            prior = sample_prior_predictive(draws=\u001b[96mself\u001b[39;49;00m.n_samples, return_inferencedata=\u001b[94mFalse\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94massert\u001b[39;49;00m prior[\u001b[33m\"\u001b[39;49;00m\u001b[33mmixture\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m].shape == (\u001b[96mself\u001b[39;49;00m.n_samples, *batch_shape, \u001b[94m3\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94massert\u001b[39;49;00m draw(mixture, draws=\u001b[96mself\u001b[39;49;00m.size).shape == (\u001b[96mself\u001b[39;49;00m.size, *batch_shape, \u001b[94m3\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m pytensor.config.floatX == \u001b[33m\"\u001b[39;49;00m\u001b[33mfloat32\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rtol = \u001b[94m1e-4\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            rtol = \u001b[94m1e-7\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        initial_point = model.initial_point()\u001b[90m\u001b[39;49;00m\n        comp_logp = logp(comp_dists, initial_point[\u001b[33m\"\u001b[39;49;00m\u001b[33mmixture\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m].reshape(*batch_shape, \u001b[94m1\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n        log_sum_exp = logsumexp(\u001b[90m\u001b[39;49;00m\n>           comp_logp.eval() + np.log(w), axis=mixture_axis, keepdims=\u001b[94mTrue\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        ).sum()\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_mixture.py\u001b[0m:1051: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f64fc634e80>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f65645115a0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[-30495.1 ... 11099217]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(20, 1)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(20, 1), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(8, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: ['not shown', np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Matrix(float64, shape=(20, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             [[-30495.1 ... 11099217]] [id B] <Matrix(float64, shape=(20, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[-30495.1 ... 11099217]], Shape: (20, 1), ElemSize: 8 Byte(s), TotalSize: 160 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 161.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 161.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n----------------------------- Captured stderr call -----------------------------\nSampling: [mixture]\n------------------------------ Captured log call -------------------------------\n\u001b[32mINFO    \u001b[0m pymc.sampling.forward:forward.py:479 Sampling: [mixture]\n\u001b[31m\u001b[1m_____________________ TestMatchesScipy.test_multinomial[2] _____________________\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ac9570>\nn = 2\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n):\u001b[90m\u001b[39;49;00m\n>       check_logp(\u001b[90m\u001b[39;49;00m\n            pm.Multinomial,\u001b[90m\u001b[39;49;00m\n            Vector(Nat, n),\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: Simplex(n), \u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: Nat},\u001b[90m\u001b[39;49;00m\n            \u001b[94mlambda\u001b[39;49;00m value, n, p: st.multinomial.logpmf(value, n, p),\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npymc_dist = <class 'pymc.distributions.multivariate.Multinomial'>\ndomain = <pymc.testing.ProductDomain object at 0x7f6403d2bdf0>\nparamdomains = {'n': <pymc.testing.Domain object at 0x7f6605d748e0>, 'p': <pymc.testing.Domain object at 0x7f64bc4657b0>}\nscipy_logp = <function TestMatchesScipy.test_multinomial.<locals>.<lambda> at 0x7f6633c2c670>\ndecimal = 6, n_samples = 100, extra_args = None, scipy_args = {}\nskip_paramdomain_outside_edge_test = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mcheck_logp\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        pymc_dist: Distribution,\u001b[90m\u001b[39;49;00m\n        domain: Domain,\u001b[90m\u001b[39;49;00m\n        paramdomains: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Domain],\u001b[90m\u001b[39;49;00m\n        scipy_logp: Callable,\u001b[90m\u001b[39;49;00m\n        decimal: \u001b[96mint\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        n_samples: \u001b[96mint\u001b[39;49;00m = \u001b[94m100\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        extra_args: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        scipy_args: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        skip_paramdomain_outside_edge_test: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Test PyMC logp and equivalent scipy logpmf/logpdf methods give similar results for valid values and parameters inside the supported edges.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Edges are excluded by default, but can be artificially included by\u001b[39;49;00m\n    \u001b[33m    creating a domain with repeated values (e.g., `Domain([0, 0, .5, 1, 1]`)\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    pymc_dist: PyMC distribution\u001b[39;49;00m\n    \u001b[33m    domain : Domain\u001b[39;49;00m\n    \u001b[33m        Supported domain of distribution values\u001b[39;49;00m\n    \u001b[33m    paramdomains : Dictionary of Parameter : Domain pairs\u001b[39;49;00m\n    \u001b[33m        Supported domains of distribution parameters\u001b[39;49;00m\n    \u001b[33m    scipy_logp : Scipy logpmf/logpdf method\u001b[39;49;00m\n    \u001b[33m        Scipy logp method of equivalent pymc_dist distribution\u001b[39;49;00m\n    \u001b[33m    decimal : Int\u001b[39;49;00m\n    \u001b[33m        Level of precision with which pymc_dist and scipy logp are compared.\u001b[39;49;00m\n    \u001b[33m        Defaults to 6 for float64 and 3 for float32\u001b[39;49;00m\n    \u001b[33m    n_samples : Int\u001b[39;49;00m\n    \u001b[33m        Upper limit on the number of valid domain and value combinations that\u001b[39;49;00m\n    \u001b[33m        are compared between pymc and scipy methods. If n_samples is below the\u001b[39;49;00m\n    \u001b[33m        total number of combinations, a random subset is evaluated. Setting\u001b[39;49;00m\n    \u001b[33m        n_samples = -1, will return all possible combinations. Defaults to 100\u001b[39;49;00m\n    \u001b[33m    extra_args : Dictionary with extra arguments needed to build pymc model\u001b[39;49;00m\n    \u001b[33m        Dictionary is passed to helper function `build_model` from which\u001b[39;49;00m\n    \u001b[33m        the pymc distribution logp is calculated\u001b[39;49;00m\n    \u001b[33m    scipy_args : Dictionary with extra arguments needed to call scipy logp method\u001b[39;49;00m\n    \u001b[33m        Usually the same as extra_args\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mpytest\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m decimal \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            decimal = select_by_precision(float64=\u001b[94m6\u001b[39;49;00m, float32=\u001b[94m3\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m scipy_args \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            scipy_args = {}\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mscipy_logp_with_scipy_args\u001b[39;49;00m(**args):\u001b[90m\u001b[39;49;00m\n            args.update(scipy_args)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m scipy_logp(**args)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        dist = create_dist_from_paramdomains(pymc_dist, paramdomains, extra_args)\u001b[90m\u001b[39;49;00m\n        value = dist.type()\u001b[90m\u001b[39;49;00m\n        value.name = \u001b[33m\"\u001b[39;49;00m\u001b[33mvalue\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        pymc_dist_logp = logp(dist, value).sum()\u001b[90m\u001b[39;49;00m\n        pymc_logp = pytensor.function(\u001b[96mlist\u001b[39;49;00m(inputvars(pymc_dist_logp)), pymc_dist_logp)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Test supported value and parameters domain matches Scipy\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        domains = paramdomains.copy()\u001b[90m\u001b[39;49;00m\n        domains[\u001b[33m\"\u001b[39;49;00m\u001b[33mvalue\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] = domain\u001b[90m\u001b[39;49;00m\n        \u001b[94mfor\u001b[39;49;00m point \u001b[95min\u001b[39;49;00m product(domains, n_samples=n_samples):\u001b[90m\u001b[39;49;00m\n            point = \u001b[96mdict\u001b[39;49;00m(point)\u001b[90m\u001b[39;49;00m\n>           npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n                pymc_logp(**point),\u001b[90m\u001b[39;49;00m\n                scipy_logp_with_scipy_args(**point),\u001b[90m\u001b[39;49;00m\n                decimal=decimal,\u001b[90m\u001b[39;49;00m\n                err_msg=\u001b[96mstr\u001b[39;49;00m(point),\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           AssertionError: \u001b[0m\n\u001b[1m\u001b[31mE           Arrays are not almost equal to 6 decimals\u001b[0m\n\u001b[1m\u001b[31mE           {'p': array([0.5, 0.5]), 'n': array(1), 'value': (array(3), array(2))}\u001b[0m\n\u001b[1m\u001b[31mE           -inf location mismatch:\u001b[0m\n\u001b[1m\u001b[31mE            ACTUAL: array(-5.950643)\u001b[0m\n\u001b[1m\u001b[31mE            DESIRED: array(-inf)\u001b[0m\n\n\u001b[1m\u001b[31mpymc/testing.py\u001b[0m:369: AssertionError\n\u001b[31m\u001b[1m_____________________ TestMatchesScipy.test_multinomial[3] _____________________\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604acbb80>\nn = 3\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n):\u001b[90m\u001b[39;49;00m\n>       check_logp(\u001b[90m\u001b[39;49;00m\n            pm.Multinomial,\u001b[90m\u001b[39;49;00m\n            Vector(Nat, n),\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: Simplex(n), \u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: Nat},\u001b[90m\u001b[39;49;00m\n            \u001b[94mlambda\u001b[39;49;00m value, n, p: st.multinomial.logpmf(value, n, p),\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npymc_dist = <class 'pymc.distributions.multivariate.Multinomial'>\ndomain = <pymc.testing.ProductDomain object at 0x7f6633c63730>\nparamdomains = {'n': <pymc.testing.Domain object at 0x7f6605d748e0>, 'p': <pymc.testing.Domain object at 0x7f6633c61240>}\nscipy_logp = <function TestMatchesScipy.test_multinomial.<locals>.<lambda> at 0x7f65406d3eb0>\ndecimal = 6, n_samples = 100, extra_args = None, scipy_args = {}\nskip_paramdomain_outside_edge_test = False\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mcheck_logp\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        pymc_dist: Distribution,\u001b[90m\u001b[39;49;00m\n        domain: Domain,\u001b[90m\u001b[39;49;00m\n        paramdomains: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Domain],\u001b[90m\u001b[39;49;00m\n        scipy_logp: Callable,\u001b[90m\u001b[39;49;00m\n        decimal: \u001b[96mint\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        n_samples: \u001b[96mint\u001b[39;49;00m = \u001b[94m100\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        extra_args: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        scipy_args: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        skip_paramdomain_outside_edge_test: \u001b[96mbool\u001b[39;49;00m = \u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Test PyMC logp and equivalent scipy logpmf/logpdf methods give similar results for valid values and parameters inside the supported edges.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Edges are excluded by default, but can be artificially included by\u001b[39;49;00m\n    \u001b[33m    creating a domain with repeated values (e.g., `Domain([0, 0, .5, 1, 1]`)\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    pymc_dist: PyMC distribution\u001b[39;49;00m\n    \u001b[33m    domain : Domain\u001b[39;49;00m\n    \u001b[33m        Supported domain of distribution values\u001b[39;49;00m\n    \u001b[33m    paramdomains : Dictionary of Parameter : Domain pairs\u001b[39;49;00m\n    \u001b[33m        Supported domains of distribution parameters\u001b[39;49;00m\n    \u001b[33m    scipy_logp : Scipy logpmf/logpdf method\u001b[39;49;00m\n    \u001b[33m        Scipy logp method of equivalent pymc_dist distribution\u001b[39;49;00m\n    \u001b[33m    decimal : Int\u001b[39;49;00m\n    \u001b[33m        Level of precision with which pymc_dist and scipy logp are compared.\u001b[39;49;00m\n    \u001b[33m        Defaults to 6 for float64 and 3 for float32\u001b[39;49;00m\n    \u001b[33m    n_samples : Int\u001b[39;49;00m\n    \u001b[33m        Upper limit on the number of valid domain and value combinations that\u001b[39;49;00m\n    \u001b[33m        are compared between pymc and scipy methods. If n_samples is below the\u001b[39;49;00m\n    \u001b[33m        total number of combinations, a random subset is evaluated. Setting\u001b[39;49;00m\n    \u001b[33m        n_samples = -1, will return all possible combinations. Defaults to 100\u001b[39;49;00m\n    \u001b[33m    extra_args : Dictionary with extra arguments needed to build pymc model\u001b[39;49;00m\n    \u001b[33m        Dictionary is passed to helper function `build_model` from which\u001b[39;49;00m\n    \u001b[33m        the pymc distribution logp is calculated\u001b[39;49;00m\n    \u001b[33m    scipy_args : Dictionary with extra arguments needed to call scipy logp method\u001b[39;49;00m\n    \u001b[33m        Usually the same as extra_args\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mpytest\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m decimal \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            decimal = select_by_precision(float64=\u001b[94m6\u001b[39;49;00m, float32=\u001b[94m3\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m scipy_args \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            scipy_args = {}\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mscipy_logp_with_scipy_args\u001b[39;49;00m(**args):\u001b[90m\u001b[39;49;00m\n            args.update(scipy_args)\u001b[90m\u001b[39;49;00m\n            \u001b[94mreturn\u001b[39;49;00m scipy_logp(**args)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        dist = create_dist_from_paramdomains(pymc_dist, paramdomains, extra_args)\u001b[90m\u001b[39;49;00m\n        value = dist.type()\u001b[90m\u001b[39;49;00m\n        value.name = \u001b[33m\"\u001b[39;49;00m\u001b[33mvalue\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        pymc_dist_logp = logp(dist, value).sum()\u001b[90m\u001b[39;49;00m\n        pymc_logp = pytensor.function(\u001b[96mlist\u001b[39;49;00m(inputvars(pymc_dist_logp)), pymc_dist_logp)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Test supported value and parameters domain matches Scipy\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        domains = paramdomains.copy()\u001b[90m\u001b[39;49;00m\n        domains[\u001b[33m\"\u001b[39;49;00m\u001b[33mvalue\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m] = domain\u001b[90m\u001b[39;49;00m\n        \u001b[94mfor\u001b[39;49;00m point \u001b[95min\u001b[39;49;00m product(domains, n_samples=n_samples):\u001b[90m\u001b[39;49;00m\n            point = \u001b[96mdict\u001b[39;49;00m(point)\u001b[90m\u001b[39;49;00m\n>           npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n                pymc_logp(**point),\u001b[90m\u001b[39;49;00m\n                scipy_logp_with_scipy_args(**point),\u001b[90m\u001b[39;49;00m\n                decimal=decimal,\u001b[90m\u001b[39;49;00m\n                err_msg=\u001b[96mstr\u001b[39;49;00m(point),\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           AssertionError: \u001b[0m\n\u001b[1m\u001b[31mE           Arrays are not almost equal to 6 decimals\u001b[0m\n\u001b[1m\u001b[31mE           {'p': array([0.5  , 0.375, 0.125]), 'n': array(3), 'value': (array(2), array(3), array(1))}\u001b[0m\n\u001b[1m\u001b[31mE           -inf location mismatch:\u001b[0m\n\u001b[1m\u001b[31mE            ACTUAL: array(-7.101371)\u001b[0m\n\u001b[1m\u001b[31mE            DESIRED: array(-inf)\u001b[0m\n\n\u001b[1m\u001b[31mpymc/testing.py\u001b[0m:369: AssertionError\n\u001b[31m\u001b[1m_______________ TestMatchesScipy.test_multinomial_invalid_value ________________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f6564394b80>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6632e435b0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ac9d50>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_invalid_value\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[90m# Test passing non-scalar invalid parameters/values to an otherwise valid Multinomial,\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[90m# evaluates to -inf\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        value = np.array([[\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m], [\u001b[94m3\u001b[39;49;00m, -\u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m]])\u001b[90m\u001b[39;49;00m\n        valid_dist = pm.Multinomial.dist(n=\u001b[94m5\u001b[39;49;00m, p=np.ones(\u001b[94m3\u001b[39;49;00m) / \u001b[94m3\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>       \u001b[94massert\u001b[39;49;00m np.all(np.isfinite(pm.logp(valid_dist, value).eval()) == np.array([\u001b[94mTrue\u001b[39;49;00m, \u001b[94mFalse\u001b[39;49;00m]))\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:631: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f6564394b80>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6632e435b0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}(-inf, False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=()), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array(-inf), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Scalar(float64, shape=())>\u001b[0m\n\u001b[1m\u001b[31mE             -inf [id B] <Scalar(float64, shape=())>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - -inf, Shape: (), ElemSize: 8 Byte(s), TotalSize: 8.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 9.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 9.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size0-p0-n1] ________\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604acbee0>\nn = array([10, 11]), p = array([0.2, 0.3, 0.5]), extra_size = (1,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n            pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       AssertionError: \u001b[0m\n\u001b[1m\u001b[31mE       Arrays are not almost equal to 4 decimals\u001b[0m\n\u001b[1m\u001b[31mE       vals=[[[0 2 8]\u001b[0m\n\u001b[1m\u001b[31mE         [3 3 5]]]\u001b[0m\n\u001b[1m\u001b[31mE       Mismatched elements: 2 / 2 (100%)\u001b[0m\n\u001b[1m\u001b[31mE       Max absolute difference among violations: 20.27697873\u001b[0m\n\u001b[1m\u001b[31mE       Max relative difference among violations: 0.87402486\u001b[0m\n\u001b[1m\u001b[31mE        ACTUAL: array([[-4.1465, -2.7747]])\u001b[0m\n\u001b[1m\u001b[31mE        DESIRED: array([[-24.4234, -22.0255]])\u001b[0m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:690: AssertionError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size0-p0-n2] ________\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ac90f0>\nn = array([[ 5,  6],\n       [10, 11]]), p = array([0.2, 0.3, 0.5])\nextra_size = (1,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n            pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       AssertionError: \u001b[0m\n\u001b[1m\u001b[31mE       Arrays are not almost equal to 4 decimals\u001b[0m\n\u001b[1m\u001b[31mE       vals=[[[[0 3 2]\u001b[0m\n\u001b[1m\u001b[31mE          [1 2 3]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE         [[1 1 8]\u001b[0m\n\u001b[1m\u001b[31mE          [1 2 8]]]]\u001b[0m\n\u001b[1m\u001b[31mE       Mismatched elements: 4 / 4 (100%)\u001b[0m\n\u001b[1m\u001b[31mE       Max absolute difference among violations: 48.40523383\u001b[0m\n\u001b[1m\u001b[31mE       Max relative difference among violations: 0.95938923\u001b[0m\n\u001b[1m\u001b[31mE        ACTUAL: array([[[-2.6956, -2.0025],\u001b[0m\n\u001b[1m\u001b[31mE               [-3.8588, -3.358 ]]])\u001b[0m\n\u001b[1m\u001b[31mE        DESIRED: array([[[-51.1009, -49.3091],\u001b[0m\n\u001b[1m\u001b[31mE               [-40.7839, -38.386 ]]])\u001b[0m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:690: AssertionError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size0-p1-10] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f65805664d0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6520381470>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604acbbb0>\nn = array(10), p = array([[0.2 , 0.3 , 0.5 ],\n       [0.9 , 0.09, 0.01]])\nextra_size = (1,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f65805664d0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6520381470>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[-19.72114598]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 1)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 1), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(8, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[-19.72114598]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Matrix(float64, shape=(1, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             [[-19.72114598]] [id B] <Matrix(float64, shape=(1, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[-19.72114598]], Shape: (1, 1), ElemSize: 8 Byte(s), TotalSize: 8 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 9.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 9.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size0-p1-n1] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f66331385b0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f66326c0c20>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae3d30>\nn = array([10, 11]), p = array([[0.2 , 0.3 , 0.5 ],\n       [0.9 , 0.09, 0.01]])\nextra_size = (1,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f66331385b0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f66326c0c20>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[-21.6445 ... 246688  ]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 2)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 2), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(16, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[-21.64458327, -19.246688  ]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Matrix(float64, shape=(1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[-21.6445 ... 246688  ]] [id B] <Matrix(float64, shape=(1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[-21.6445 ... 246688  ]], Shape: (1, 2), ElemSize: 8 Byte(s), TotalSize: 16 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 17.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 17.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size0-p1-n2] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f6634cb1000>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f658016ce80>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae33d0>\nn = array([[ 5,  6],\n       [10, 11]])\np = array([[0.2 , 0.3 , 0.5 ],\n       [0.9 , 0.09, 0.01]]), extra_size = (1,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f6634cb1000>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f658016ce80>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[-48.303 ... 8888085]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 2, 2)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 2, 2), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(32, 16, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[-48.30369696, -46.51193749],\u001b[0m\n\u001b[1m\u001b[31mE                   [-37.98677613, -35.58888085]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[-48.303 ... 8888085]]] [id B] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[-48.303 ... 8888085]]], Shape: (1, 2, 2), ElemSize: 8 Byte(s), TotalSize: 32 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 33.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 33.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size0-p2-10] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f6631f2c0d0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6633a38e80>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae17b0>\nn = array(10)\np = array([[[0.19186492, 0.09946628, 0.37137476, 0.33729404],\n        [0.54046751, 0.22363022, 0.05438684, 0.18151543]],\n\n       [[0.28357409, 0.38940079, 0.25882277, 0.06820235],\n        [0.14092158, 0.14108808, 0.58976162, 0.12822872]]])\nextra_size = (1,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f6631f2c0d0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6633a38e80>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[-63.12164621]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 1, 1)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 1, 1), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(8, 8, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[-63.12164621]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor3(float64, shape=(1, 1, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[-63.12164621]]] [id B] <Tensor3(float64, shape=(1, 1, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[-63.12164621]]], Shape: (1, 1, 1), ElemSize: 8 Byte(s), TotalSize: 8 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 9.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 9.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size0-p2-n1] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f6604cbeec0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6540459a60>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae15d0>\nn = array([10, 11])\np = array([[[0.19186492, 0.09946628, 0.37137476, 0.33729404],\n        [0.54046751, 0.22363022, 0.05438684, 0.18151543]],\n\n       [[0.28357409, 0.38940079, 0.25882277, 0.06820235],\n        [0.14092158, 0.14108808, 0.58976162, 0.12822872]]])\nextra_size = (1,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f6604cbeec0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6540459a60>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[-71.950 ... 5218803]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 1, 2)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 1, 2), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(16, 16, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[-71.9500833 , -69.55218803]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor3(float64, shape=(1, 1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[-71.950 ... 5218803]]] [id B] <Tensor3(float64, shape=(1, 1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[-71.950 ... 5218803]]], Shape: (1, 1, 2), ElemSize: 8 Byte(s), TotalSize: 16 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 17.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 17.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size0-p2-n2] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f65643b9060>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f66345eeb00>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae2260>\nn = array([[ 5,  6],\n       [10, 11]])\np = array([[[0.19186492, 0.09946628, 0.37137476, 0.33729404],\n        [0.54046751, 0.22363022, 0.05438684, 0.18151543]],\n\n       [[0.28357409, 0.38940079, 0.25882277, 0.06820235],\n        [0.14092158, 0.14108808, 0.58976162, 0.12822872]]])\nextra_size = (1,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f65643b9060>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f66345eeb00>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[-54.974 ... 6008657]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 2, 2)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 2, 2), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(32, 16, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[-54.97490267, -53.1831432 ],\u001b[0m\n\u001b[1m\u001b[31mE                   [-44.65798184, -42.26008657]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[-54.974 ... 6008657]]] [id B] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[-54.974 ... 6008657]]], Shape: (1, 2, 2), ElemSize: 8 Byte(s), TotalSize: 32 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 33.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 33.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size1-p0-10] ________\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae1cc0>\nn = array(10), p = array([0.2, 0.3, 0.5]), extra_size = (2,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n            pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       AssertionError: \u001b[0m\n\u001b[1m\u001b[31mE       Arrays are not almost equal to 4 decimals\u001b[0m\n\u001b[1m\u001b[31mE       vals=[[3 1 6]\u001b[0m\n\u001b[1m\u001b[31mE        [1 2 7]]\u001b[0m\n\u001b[1m\u001b[31mE       (shapes (2,), (1,) mismatch)\u001b[0m\n\u001b[1m\u001b[31mE        ACTUAL: array([-3.4578, -2.9833])\u001b[0m\n\u001b[1m\u001b[31mE        DESIRED: array([-21.5455])\u001b[0m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:690: AssertionError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size1-p0-n1] ________\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae0520>\nn = array([10, 11]), p = array([0.2, 0.3, 0.5]), extra_size = (2,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n            pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       AssertionError: \u001b[0m\n\u001b[1m\u001b[31mE       Arrays are not almost equal to 4 decimals\u001b[0m\n\u001b[1m\u001b[31mE       vals=[[[2 3 5]\u001b[0m\n\u001b[1m\u001b[31mE         [1 5 5]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE        [[5 0 5]\u001b[0m\n\u001b[1m\u001b[31mE         [1 5 5]]]\u001b[0m\n\u001b[1m\u001b[31mE       (shapes (2, 2), (1, 2) mismatch)\u001b[0m\n\u001b[1m\u001b[31mE        ACTUAL: array([[-2.4645, -3.1677],\u001b[0m\n\u001b[1m\u001b[31mE              [-5.9835, -3.1677]])\u001b[0m\n\u001b[1m\u001b[31mE        DESIRED: array([[-64.8925, -62.4946]])\u001b[0m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:690: AssertionError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size1-p0-n2] ________\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae1750>\nn = array([[ 5,  6],\n       [10, 11]]), p = array([0.2, 0.3, 0.5])\nextra_size = (2,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n            pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       AssertionError: \u001b[0m\n\u001b[1m\u001b[31mE       Arrays are not almost equal to 4 decimals\u001b[0m\n\u001b[1m\u001b[31mE       vals=[[[[1 2 2]\u001b[0m\n\u001b[1m\u001b[31mE          [2 2 2]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE         [[3 2 5]\u001b[0m\n\u001b[1m\u001b[31mE          [1 4 6]]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE        [[[1 1 3]\u001b[0m\n\u001b[1m\u001b[31mE          [2 2 2]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE         [[1 3 6]\u001b[0m\n\u001b[1m\u001b[31mE          [4 3 4]]]]\u001b[0m\n\u001b[1m\u001b[31mE       (shapes (2, 2, 2), (1, 2, 2) mismatch)\u001b[0m\n\u001b[1m\u001b[31mE        ACTUAL: array([[[-2.0025, -2.5133],\u001b[0m\n\u001b[1m\u001b[31mE               [-2.87  , -2.8392]],\u001b[0m\n\u001b[1m\u001b[31mE       ...\u001b[0m\n\u001b[1m\u001b[31mE        DESIRED: array([[[-103.9095, -102.1177],\u001b[0m\n\u001b[1m\u001b[31mE               [ -93.5926,  -91.1947]]])\u001b[0m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:690: AssertionError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size1-p1-10] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f65402f1ff0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6634d86fc0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae09a0>\nn = array(10), p = array([[0.2 , 0.3 , 0.5 ],\n       [0.9 , 0.09, 0.01]])\nextra_size = (2,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f65402f1ff0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6634d86fc0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[-53.6304138]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 1)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 1), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(8, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[-53.6304138]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Matrix(float64, shape=(1, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             [[-53.6304138]] [id B] <Matrix(float64, shape=(1, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[-53.6304138]], Shape: (1, 1), ElemSize: 8 Byte(s), TotalSize: 8 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 9.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 9.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size1-p1-n1] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f64fc5ac2e0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f66323edcc0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae1210>\nn = array([10, 11]), p = array([[0.2 , 0.3 , 0.5 ],\n       [0.9 , 0.09, 0.01]])\nextra_size = (2,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f64fc5ac2e0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f66323edcc0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[-59.3401 ... 94222762]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 2)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 2), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(16, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[-59.34012289, -56.94222762]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Matrix(float64, shape=(1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[-59.3401 ... 94222762]] [id B] <Matrix(float64, shape=(1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[-59.3401 ... 94222762]], Shape: (1, 2), ElemSize: 8 Byte(s), TotalSize: 16 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 17.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 17.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size1-p1-n2] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f65207717e0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f66301ad6d0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae13f0>\nn = array([[ 5,  6],\n       [10, 11]])\np = array([[0.2 , 0.3 , 0.5 ],\n       [0.9 , 0.09, 0.01]]), extra_size = (2,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f65207717e0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f66301ad6d0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[-104.89 ... 8330161]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 2, 2)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 2, 2), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(32, 16, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[-104.89811772, -103.10635825],\u001b[0m\n\u001b[1m\u001b[31mE                   [ -94.58119689,  -92.18330161]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[-104.89 ... 8330161]]] [id B] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[-104.89 ... 8330161]]], Shape: (1, 2, 2), ElemSize: 8 Byte(s), TotalSize: 32 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 33.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 33.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size1-p2-10] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f64e0512ad0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6634d84890>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae22c0>\nn = array(10)\np = array([[[0.19186492, 0.09946628, 0.37137476, 0.33729404],\n        [0.54046751, 0.22363022, 0.05438684, 0.18151543]],\n\n       [[0.28357409, 0.38940079, 0.25882277, 0.06820235],\n        [0.14092158, 0.14108808, 0.58976162, 0.12822872]]])\nextra_size = (2,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f64e0512ad0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6634d84890>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[-140.0384852]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 1, 1)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 1, 1), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(8, 8, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[-140.0384852]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor3(float64, shape=(1, 1, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[-140.0384852]]] [id B] <Tensor3(float64, shape=(1, 1, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[-140.0384852]]], Shape: (1, 1, 1), ElemSize: 8 Byte(s), TotalSize: 8 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 9.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 9.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size1-p2-n1] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f6632e97100>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f65645f69d0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae0850>\nn = array([10, 11])\np = array([[[0.19186492, 0.09946628, 0.37137476, 0.33729404],\n        [0.54046751, 0.22363022, 0.05438684, 0.18151543]],\n\n       [[0.28357409, 0.38940079, 0.25882277, 0.06820235],\n        [0.14092158, 0.14108808, 0.58976162, 0.12822872]]])\nextra_size = (2,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f6632e97100>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f65645f69d0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[-147.44 ... 4880752]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 1, 2)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 1, 2), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(16, 16, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[-147.4467028 , -145.04880752]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor3(float64, shape=(1, 1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[-147.44 ... 4880752]]] [id B] <Tensor3(float64, shape=(1, 1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[-147.44 ... 4880752]]], Shape: (1, 1, 2), ElemSize: 8 Byte(s), TotalSize: 16 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 17.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 17.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size1-p2-n2] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f6631e5dcc0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f654072cfb0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae0940>\nn = array([[ 5,  6],\n       [10, 11]])\np = array([[[0.19186492, 0.09946628, 0.37137476, 0.33729404],\n        [0.54046751, 0.22363022, 0.05438684, 0.18151543]],\n\n       [[0.28357409, 0.38940079, 0.25882277, 0.06820235],\n        [0.14092158, 0.14108808, 0.58976162, 0.12822872]]])\nextra_size = (2,)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f6631e5dcc0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f654072cfb0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[-110.82 ... 1177395]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 2, 2)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 2, 2), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(32, 16, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[-110.82659005, -109.03483058],\u001b[0m\n\u001b[1m\u001b[31mE                   [-100.50966922,  -98.11177395]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[-110.82 ... 1177395]]] [id B] <Tensor3(float64, shape=(1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[-110.82 ... 1177395]]], Shape: (1, 2, 2), ElemSize: 8 Byte(s), TotalSize: 32 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 33.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 33.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size2-p0-10] ________\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae0160>\nn = array(10), p = array([0.2, 0.3, 0.5]), extra_size = (2, 3)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n            pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       AssertionError: \u001b[0m\n\u001b[1m\u001b[31mE       Arrays are not almost equal to 4 decimals\u001b[0m\n\u001b[1m\u001b[31mE       vals=[[[2 1 7]\u001b[0m\n\u001b[1m\u001b[31mE         [0 3 7]\u001b[0m\n\u001b[1m\u001b[31mE         [2 5 3]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE        [[2 5 3]\u001b[0m\n\u001b[1m\u001b[31mE         [4 3 3]\u001b[0m\n\u001b[1m\u001b[31mE         [2 2 6]]]\u001b[0m\n\u001b[1m\u001b[31mE       (shapes (2, 3), (1, 1) mismatch)\u001b[0m\n\u001b[1m\u001b[31mE        ACTUAL: array([[-3.3888, -3.6765, -3.4862],\u001b[0m\n\u001b[1m\u001b[31mE              [-3.4862, -3.7863, -2.6468]])\u001b[0m\n\u001b[1m\u001b[31mE        DESIRED: array([[-95.9927]])\u001b[0m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:690: AssertionError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size2-p0-n1] ________\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae2800>\nn = array([10, 11]), p = array([0.2, 0.3, 0.5]), extra_size = (2, 3)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n            pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       AssertionError: \u001b[0m\n\u001b[1m\u001b[31mE       Arrays are not almost equal to 4 decimals\u001b[0m\n\u001b[1m\u001b[31mE       vals=[[[[2 3 5]\u001b[0m\n\u001b[1m\u001b[31mE          [3 4 4]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE         [[2 3 5]\u001b[0m\n\u001b[1m\u001b[31mE          [4 1 6]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE         [[2 3 5]\u001b[0m\n\u001b[1m\u001b[31mE          [2 1 8]]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE        [[[1 3 6]\u001b[0m\n\u001b[1m\u001b[31mE          [2 3 6]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE         [[2 2 6]\u001b[0m\n\u001b[1m\u001b[31mE          [2 4 5]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE         [[2 7 1]\u001b[0m\n\u001b[1m\u001b[31mE          [1 4 6]]]]\u001b[0m\n\u001b[1m\u001b[31mE       (shapes (2, 3, 2), (1, 1, 2) mismatch)\u001b[0m\n\u001b[1m\u001b[31mE        ACTUAL: array([[[-2.4645, -3.0624],\u001b[0m\n\u001b[1m\u001b[31mE               [-2.4645, -4.0556],\u001b[0m\n\u001b[1m\u001b[31mE               [-2.4645, -3.7635]],...\u001b[0m\n\u001b[1m\u001b[31mE        DESIRED: array([[[-218.6059, -216.208 ]]])\u001b[0m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:690: AssertionError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size2-p0-n2] ________\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae24d0>\nn = array([[ 5,  6],\n       [10, 11]]), p = array([0.2, 0.3, 0.5])\nextra_size = (2, 3)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n            pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       AssertionError: \u001b[0m\n\u001b[1m\u001b[31mE       Arrays are not almost equal to 4 decimals\u001b[0m\n\u001b[1m\u001b[31mE       vals=[[[[[ 1  1  3]\u001b[0m\n\u001b[1m\u001b[31mE           [ 1  3  2]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE          [[ 3  4  3]\u001b[0m\n\u001b[1m\u001b[31mE           [ 0  8  3]]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE         [[[ 2  3  0]\u001b[0m\n\u001b[1m\u001b[31mE           [ 1  1  4]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE          [[ 1  3  6]\u001b[0m\n\u001b[1m\u001b[31mE           [ 4  3  4]]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE         [[[ 0  2  3]\u001b[0m\n\u001b[1m\u001b[31mE           [ 2  0  4]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE          [[ 3  3  4]\u001b[0m\n\u001b[1m\u001b[31mE           [ 2  5  4]]]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE        [[[[ 1  1  3]\u001b[0m\n\u001b[1m\u001b[31mE           [ 1  1  4]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE          [[ 2  2  6]\u001b[0m\n\u001b[1m\u001b[31mE           [ 0  1 10]]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE         [[[ 3  2  0]\u001b[0m\n\u001b[1m\u001b[31mE           [ 0  2  4]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE          [[ 6  2  2]\u001b[0m\n\u001b[1m\u001b[31mE           [ 4  3  4]]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE         [[[ 3  1  1]\u001b[0m\n\u001b[1m\u001b[31mE           [ 2  1  3]]\u001b[0m\n\u001b[1m\u001b[31mE       \u001b[0m\n\u001b[1m\u001b[31mE          [[ 2  1  7]\u001b[0m\n\u001b[1m\u001b[31mE           [ 1  2  8]]]]]\u001b[0m\n\u001b[1m\u001b[31mE       (shapes (2, 3, 2, 2), (1, 1, 2, 2) mismatch)\u001b[0m\n\u001b[1m\u001b[31mE        ACTUAL: array([[[[-1.8971, -2.5133],\u001b[0m\n\u001b[1m\u001b[31mE                [-3.3808, -6.6053]],\u001b[0m\n\u001b[1m\u001b[31mE       ...\u001b[0m\n\u001b[1m\u001b[31mE        DESIRED: array([[[[-340.3201, -338.5283],\u001b[0m\n\u001b[1m\u001b[31mE                [-330.0032, -327.6053]]]])\u001b[0m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:690: AssertionError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size2-p1-10] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f6403e63190>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6634bf7810>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae1390>\nn = array(10), p = array([[0.2 , 0.3 , 0.5 ],\n       [0.9 , 0.09, 0.01]])\nextra_size = (2, 3)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f6403e63190>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6634bf7810>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[-199.78383293]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 1, 1)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 1, 1), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(8, 8, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[-199.78383293]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor3(float64, shape=(1, 1, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[-199.78383293]]] [id B] <Tensor3(float64, shape=(1, 1, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[-199.78383293]]], Shape: (1, 1, 1), ElemSize: 8 Byte(s), TotalSize: 8 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 9.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 9.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size2-p1-n1] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f6404083d90>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f66326c1cc0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae29b0>\nn = array([10, 11]), p = array([[0.2 , 0.3 , 0.5 ],\n       [0.9 , 0.09, 0.01]])\nextra_size = (2, 3)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f6404083d90>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f66326c1cc0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[-206.84 ... 4467355]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 1, 2)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 1, 2), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(16, 16, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[-206.84256883, -204.44467355]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor3(float64, shape=(1, 1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[-206.84 ... 4467355]]] [id B] <Tensor3(float64, shape=(1, 1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[-206.84 ... 4467355]]], Shape: (1, 1, 2), ElemSize: 8 Byte(s), TotalSize: 16 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 17.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 17.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size2-p1-n2] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f656416ab00>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f65803a56d0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae26e0>\nn = array([[ 5,  6],\n       [10, 11]])\np = array([[0.2 , 0.3 , 0.5 ],\n       [0.9 , 0.09, 0.01]]), extra_size = (2, 3)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f656416ab00>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f65803a56d0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[[-307.6 ... 519885]]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 1, 2, 2)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 1, 2, 2), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(32, 32, 16, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[[-307.61001495, -305.81825548],\u001b[0m\n\u001b[1m\u001b[31mE                    [-297.29309412, -294.89519885]]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor4(float64, shape=(1, 1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[[-307.6 ... 519885]]]] [id B] <Tensor4(float64, shape=(1, 1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[[-307.6 ... 519885]]]], Shape: (1, 1, 2, 2), ElemSize: 8 Byte(s), TotalSize: 32 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 33.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 33.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size2-p2-10] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f6403e62620>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f65404968a0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae2500>\nn = array(10)\np = array([[[0.19186492, 0.09946628, 0.37137476, 0.33729404],\n        [0.54046751, 0.22363022, 0.05438684, 0.18151543]],\n\n       [[0.28357409, 0.38940079, 0.25882277, 0.06820235],\n        [0.14092158, 0.14108808, 0.58976162, 0.12822872]]])\nextra_size = (2, 3)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f6403e62620>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f65404968a0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[[-448.6 ... 222617]]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 1, 1, 1)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 1, 1, 1), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(8, 8, 8, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[[-448.68222617]]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor4(float64, shape=(1, 1, 1, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[[-448.6 ... 222617]]]] [id B] <Tensor4(float64, shape=(1, 1, 1, 1))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[[-448.6 ... 222617]]]], Shape: (1, 1, 1, 1), ElemSize: 8 Byte(s), TotalSize: 8 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 9.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 9.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size2-p2-n1] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f6632ea2500>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f659818bba0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae0190>\nn = array([10, 11])\np = array([[[0.19186492, 0.09946628, 0.37137476, 0.33729404],\n        [0.54046751, 0.22363022, 0.05438684, 0.18151543]],\n\n       [[0.28357409, 0.38940079, 0.25882277, 0.06820235],\n        [0.14092158, 0.14108808, 0.58976162, 0.12822872]]])\nextra_size = (2, 3)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f6632ea2500>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f659818bba0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[[-487.0 ... 026479]]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 1, 1, 2)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 1, 1, 2), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(16, 16, 16, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[[-487.08816007, -484.69026479]]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor4(float64, shape=(1, 1, 1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[[-487.0 ... 026479]]]] [id B] <Tensor4(float64, shape=(1, 1, 1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[[-487.0 ... 026479]]]], Shape: (1, 1, 1, 2), ElemSize: 8 Byte(s), TotalSize: 16 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 17.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 17.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMatchesScipy.test_multinomial_vectorized[extra_size2-p2-n2] ________\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f6540685ae0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6632663e00>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae1b70>\nn = array([[ 5,  6],\n       [10, 11]])\np = array([[[0.19186492, 0.09946628, 0.37137476, 0.33729404],\n        [0.54046751, 0.22363022, 0.05438684, 0.18151543]],\n\n       [[0.28357409, 0.38940079, 0.25882277, 0.06820235],\n        [0.14092158, 0.14108808, 0.58976162, 0.12822872]]])\nextra_size = (2, 3)\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mn\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m10\u001b[39;49;00m), ([\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]), ([[\u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m], [\u001b[94m10\u001b[39;49;00m, \u001b[94m11\u001b[39;49;00m]])])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            ([\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ([[\u001b[94m0.2\u001b[39;49;00m, \u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.5\u001b[39;49;00m], [\u001b[94m0.9\u001b[39;49;00m, \u001b[94m0.09\u001b[39;49;00m, \u001b[94m0.01\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            (np.abs(np.random.randn(\u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m))),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mextra_size\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [(\u001b[94m1\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m,), (\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m)])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_vectorized\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, n, p, extra_size):\u001b[90m\u001b[39;49;00m\n        n = np.array(n)\u001b[90m\u001b[39;49;00m\n        p = np.array(p)\u001b[90m\u001b[39;49;00m\n        p /= p.sum(axis=-\u001b[94m1\u001b[39;49;00m, keepdims=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        _, bcast_p = broadcast_params([n, p], ndims_params=[\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n        size = extra_size + bcast_p.shape[:-\u001b[94m1\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n        vals = mn.eval()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        npt.assert_almost_equal(\u001b[90m\u001b[39;49;00m\n            st.multinomial.logpmf(vals, n, p),\u001b[90m\u001b[39;49;00m\n>           pm.logp(mn, vals).eval(),\u001b[90m\u001b[39;49;00m\n            decimal=\u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            err_msg=\u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mvals=\u001b[39;49;00m\u001b[33m{\u001b[39;49;00mvals\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:692: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f6540685ae0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6632663e00>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[[[-350.3 ... 437176]]]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 1, 2, 2)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 1, 2, 2), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(32, 32, 16, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[[[-350.38918787, -348.5974284 ],\u001b[0m\n\u001b[1m\u001b[31mE                    [-340.07226704, -337.67437176]]]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[DeepCopyOp(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 194, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return _logprob_helper(rv, value, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/abstract.py\", line 70, in _logprob_helper\u001b[0m\n\u001b[1m\u001b[31mE               logprob = _logprob(rv.owner.op, values, *rv.owner.inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Tensor4(float64, shape=(1, 1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[[[-350.3 ... 437176]]]] [id B] <Tensor4(float64, shape=(1, 1, 2, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[[[-350.3 ... 437176]]]], Shape: (1, 1, 2, 2), ElemSize: 8 Byte(s), TotalSize: 32 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 33.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 33.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_________________ TestMatchesScipy.test_multinomial_zero_probs _________________\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMatchesScipy object at 0x7f6604ae0a60>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_zero_probs\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[90m# test multinomial accepts 0 probabilities / observations:\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        mn = pm.Multinomial.dist(n=\u001b[94m100\u001b[39;49;00m, p=[\u001b[94m0.0\u001b[39;49;00m, \u001b[94m0.0\u001b[39;49;00m, \u001b[94m1.0\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n>       \u001b[94massert\u001b[39;49;00m pm.logp(mn, np.array([\u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m100\u001b[39;49;00m])).eval() >= \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       assert array(nan) >= 0\u001b[0m\n\u001b[1m\u001b[31mE        +  where array(nan) = eval()\u001b[0m\n\u001b[1m\u001b[31mE        +    where eval = Check{}.0.eval\u001b[0m\n\u001b[1m\u001b[31mE        +      where Check{}.0 = <function logp at 0x7f6607adf0a0>(multinomial_rv{\"(),(p)->(p)\"}.out, array([  0,   0, 100]))\u001b[0m\n\u001b[1m\u001b[31mE        +        where <function logp at 0x7f6607adf0a0> = pm.logp\u001b[0m\n\u001b[1m\u001b[31mE        +        and   array([  0,   0, 100]) = <built-in function array>([0, 0, 100])\u001b[0m\n\u001b[1m\u001b[31mE        +          where <built-in function array> = np.array\u001b[0m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:700: AssertionError\n\u001b[31m\u001b[1m_______ TestMoments.test_multinomial_support_point[p3-10-None-expected3] _______\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f6580331510>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f654064d470>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMoments object at 0x7f6606a49b40>\np = array([[0.3 , 0.6 , 0.05, 0.05],\n       [0.25, 0.25, 0.25, 0.25]]), n = 10\nsize = None, expected = array([[3, 7, 0, 0],\n       [4, 2, 2, 2]])\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp, n, size, expected\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            (np.array([\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m]), \u001b[94m1\u001b[39;49;00m, \u001b[94mNone\u001b[39;49;00m, np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\n            (np.array([\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m]), \u001b[94m2\u001b[39;49;00m, \u001b[94mNone\u001b[39;49;00m, np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\n            (np.array([\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m]), \u001b[94m10\u001b[39;49;00m, \u001b[94mNone\u001b[39;49;00m, np.array([\u001b[94m3\u001b[39;49;00m, \u001b[94m7\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m], [\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n                \u001b[94m10\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m3\u001b[39;49;00m, \u001b[94m7\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m4\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m2\u001b[39;49;00m, \u001b[94m10\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                (\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n                np.array([[[\u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m3\u001b[39;49;00m, \u001b[94m7\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m]]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m], [\u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.22\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m10\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m], [\u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.22\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m10\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                (\u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n                np.full((\u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m), [[\u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0.0\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                \u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0.1441\u001b[39;49;00m, \u001b[94m0.1363\u001b[39;49;00m, \u001b[94m0.1385\u001b[39;49;00m, \u001b[94m0.1348\u001b[39;49;00m, \u001b[94m0.1521\u001b[39;49;00m, \u001b[94m0.1500\u001b[39;49;00m, \u001b[94m0.1442\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                \u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                marks=pytest.mark.xfail(\u001b[90m\u001b[39;49;00m\n                    rises=\u001b[96mAssertionError\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mKnown failure in mode approximation \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                ),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_support_point\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, p, n, size, expected):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            pm.Multinomial(\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n>       assert_support_point_is_expected(model, expected)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:1065: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/testing.py\u001b[0m:693: in assert_support_point_is_expected\n    \u001b[0m.eval()\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f6580331510>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f654064d470>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([-21.52064456], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1,)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1,), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(8,), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([-21.52064456]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[Squeeze{axis=0}(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 575, in transformed_conditional_logp\u001b[0m\n\u001b[1m\u001b[31mE               temp_logp_terms = conditional_logp(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 505, in conditional_logp\u001b[0m\n\u001b[1m\u001b[31mE               node_logprobs = _logprob(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE             [-21.52064456] [id B] <Vector(float64, shape=(1,))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [-21.52064456], Shape: (1,), ElemSize: 8 Byte(s), TotalSize: 8 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 9.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 9.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMoments.test_multinomial_support_point[p5-n5-None-expected5] _______\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f64bc3e47f0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f660772f480>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMoments object at 0x7f6604bc20b0>\np = array([[0.25, 0.25, 0.25, 0.25],\n       [0.26, 0.26, 0.26, 0.22]])\nn = array([ 1, 10]), size = None\nexpected = array([[1, 0, 0, 0],\n       [2, 3, 3, 2]])\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp, n, size, expected\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            (np.array([\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m]), \u001b[94m1\u001b[39;49;00m, \u001b[94mNone\u001b[39;49;00m, np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\n            (np.array([\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m]), \u001b[94m2\u001b[39;49;00m, \u001b[94mNone\u001b[39;49;00m, np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\n            (np.array([\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m]), \u001b[94m10\u001b[39;49;00m, \u001b[94mNone\u001b[39;49;00m, np.array([\u001b[94m3\u001b[39;49;00m, \u001b[94m7\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m], [\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n                \u001b[94m10\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m3\u001b[39;49;00m, \u001b[94m7\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m4\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m2\u001b[39;49;00m, \u001b[94m10\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                (\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n                np.array([[[\u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m3\u001b[39;49;00m, \u001b[94m7\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m]]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m], [\u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.22\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m10\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m], [\u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.22\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m10\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                (\u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n                np.full((\u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m), [[\u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0.0\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                \u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0.1441\u001b[39;49;00m, \u001b[94m0.1363\u001b[39;49;00m, \u001b[94m0.1385\u001b[39;49;00m, \u001b[94m0.1348\u001b[39;49;00m, \u001b[94m0.1521\u001b[39;49;00m, \u001b[94m0.1500\u001b[39;49;00m, \u001b[94m0.1442\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                \u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                marks=pytest.mark.xfail(\u001b[90m\u001b[39;49;00m\n                    rises=\u001b[96mAssertionError\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mKnown failure in mode approximation \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                ),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_support_point\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, p, n, size, expected):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            pm.Multinomial(\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n>       assert_support_point_is_expected(model, expected)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:1065: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/testing.py\u001b[0m:693: in assert_support_point_is_expected\n    \u001b[0m.eval()\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f64bc3e47f0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f660772f480>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([-20.16095 ... .05653974], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(2,)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(2,), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(8,), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([-20.16095231,  -5.05653974]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[Sum{axes=None}(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 575, in transformed_conditional_logp\u001b[0m\n\u001b[1m\u001b[31mE               temp_logp_terms = conditional_logp(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 505, in conditional_logp\u001b[0m\n\u001b[1m\u001b[31mE               node_logprobs = _logprob(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Vector(float64, shape=(2,))>\u001b[0m\n\u001b[1m\u001b[31mE             [-20.16095 ... .05653974] [id B] <Vector(float64, shape=(2,))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [-20.16095 ... .05653974], Shape: (2,), ElemSize: 8 Byte(s), TotalSize: 16 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 17.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 17.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m______ TestMoments.test_multinomial_support_point[p6-n6-size6-expected6] _______\u001b[0m\n\nself = <pytensor.compile.function.types.Function object at 0x7f66075a13f0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6403b936e0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMoments object at 0x7f660593a080>\np = array([[0.25, 0.25, 0.25, 0.25],\n       [0.26, 0.26, 0.26, 0.22]])\nn = array([ 1, 10]), size = (3, 2)\nexpected = array([[[1, 0, 0, 0],\n        [2, 3, 3, 2]],\n\n       [[1, 0, 0, 0],\n        [2, 3, 3, 2]],\n\n       [[1, 0, 0, 0],\n        [2, 3, 3, 2]]])\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp, n, size, expected\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            (np.array([\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m]), \u001b[94m1\u001b[39;49;00m, \u001b[94mNone\u001b[39;49;00m, np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\n            (np.array([\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m]), \u001b[94m2\u001b[39;49;00m, \u001b[94mNone\u001b[39;49;00m, np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\n            (np.array([\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m]), \u001b[94m10\u001b[39;49;00m, \u001b[94mNone\u001b[39;49;00m, np.array([\u001b[94m3\u001b[39;49;00m, \u001b[94m7\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m], [\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n                \u001b[94m10\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m3\u001b[39;49;00m, \u001b[94m7\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m4\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m2\u001b[39;49;00m, \u001b[94m10\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                (\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n                np.array([[[\u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m3\u001b[39;49;00m, \u001b[94m7\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m]]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m], [\u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.22\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m10\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m], [\u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.22\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m10\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                (\u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n                np.full((\u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m), [[\u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0.0\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                \u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0.1441\u001b[39;49;00m, \u001b[94m0.1363\u001b[39;49;00m, \u001b[94m0.1385\u001b[39;49;00m, \u001b[94m0.1348\u001b[39;49;00m, \u001b[94m0.1521\u001b[39;49;00m, \u001b[94m0.1500\u001b[39;49;00m, \u001b[94m0.1442\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                \u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                marks=pytest.mark.xfail(\u001b[90m\u001b[39;49;00m\n                    rises=\u001b[96mAssertionError\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mKnown failure in mode approximation \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                ),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_support_point\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, p, n, size, expected):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            pm.Multinomial(\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n>       assert_support_point_is_expected(model, expected)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:1065: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/testing.py\u001b[0m:693: in assert_support_point_is_expected\n    \u001b[0m.eval()\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/graph/basic.py\u001b[0m:662: in eval\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m fn(*args)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1049: in __call__\n    \u001b[0mraise_with_op(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/link/utils.py\u001b[0m:526: in raise_with_op\n    \u001b[0m\u001b[94mraise\u001b[39;49;00m exc_value.with_traceback(exc_trace)\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytensor.compile.function.types.Function object at 0x7f66075a13f0>\noutput_subset = None, args = (), kwargs = {}, trust_input = False\nvm = <pytensor.link.c.cvm.CVM object at 0x7f6403b936e0>, profile = None\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m__call__\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, *args, output_subset=\u001b[94mNone\u001b[39;49;00m, **kwargs):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Evaluates value of a function on given arguments.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    args : list\u001b[39;49;00m\n    \u001b[33m        List of inputs to the function. All inputs are required, even when\u001b[39;49;00m\n    \u001b[33m        some of them are not necessary to calculate requested subset of\u001b[39;49;00m\n    \u001b[33m        outputs.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    kwargs : dict\u001b[39;49;00m\n    \u001b[33m        The function inputs can be passed as keyword argument. For this, use\u001b[39;49;00m\n    \u001b[33m        the name of the input or the input instance as the key.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m        Keyword argument ``output_subset`` is a list of either indices of the\u001b[39;49;00m\n    \u001b[33m        function's outputs or the keys belonging to the `output_keys` dict\u001b[39;49;00m\n    \u001b[33m        and represent outputs that are requested to be calculated. Regardless\u001b[39;49;00m\n    \u001b[33m        of the presence of ``output_subset``, the updates are always calculated\u001b[39;49;00m\n    \u001b[33m        and processed. To disable the updates, you should use the ``copy``\u001b[39;49;00m\n    \u001b[33m        method with ``delete_updates=True``.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    list\u001b[39;49;00m\n    \u001b[33m        List of outputs on indices/keys from ``output_subset`` or all of them,\u001b[39;49;00m\n    \u001b[33m        if ``output_subset`` is not passed.\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        trust_input = \u001b[96mself\u001b[39;49;00m.trust_input\u001b[90m\u001b[39;49;00m\n        input_storage = \u001b[96mself\u001b[39;49;00m.input_storage\u001b[90m\u001b[39;49;00m\n        vm = \u001b[96mself\u001b[39;49;00m.vm\u001b[90m\u001b[39;49;00m\n        profile = \u001b[96mself\u001b[39;49;00m.profile\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0 = time.perf_counter()\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            warnings.warn(\u001b[33m\"\u001b[39;49;00m\u001b[33moutput_subset is deprecated.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[96mFutureWarning\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.output_keys \u001b[95mis\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                output_subset = [\u001b[96mself\u001b[39;49;00m.output_keys.index(key) \u001b[94mfor\u001b[39;49;00m key \u001b[95min\u001b[39;49;00m output_subset]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Reinitialize each container's 'provided' counter\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                arg_container.provided = \u001b[94m0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(args) + \u001b[96mlen\u001b[39;49;00m(kwargs) > \u001b[96mlen\u001b[39;49;00m(input_storage):\u001b[90m\u001b[39;49;00m\n                \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mToo many parameter passed to pytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Set positional arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# zip strict not specified because we are in a hot loop\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container, arg \u001b[95min\u001b[39;49;00m \u001b[96mzip\u001b[39;49;00m(input_storage, args):\u001b[90m\u001b[39;49;00m\n                \u001b[90m# See discussion about None as input\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[90m# https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg\u001b[90m\u001b[39;49;00m\n                \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        arg_container.storage[\u001b[94m0\u001b[39;49;00m] = arg_container.type.filter(\u001b[90m\u001b[39;49;00m\n                            arg,\u001b[90m\u001b[39;49;00m\n                            strict=arg_container.strict,\u001b[90m\u001b[39;49;00m\n                            allow_downcast=arg_container.allow_downcast,\u001b[90m\u001b[39;49;00m\n                        )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[94mexcept\u001b[39;49;00m \u001b[96mException\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m e:\u001b[90m\u001b[39;49;00m\n                        i = input_storage.index(arg_container)\u001b[90m\u001b[39;49;00m\n                        function_name = \u001b[33m\"\u001b[39;49;00m\u001b[33mpytensor function\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        argument_name = \u001b[33m\"\u001b[39;49;00m\u001b[33margument\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m.name:\u001b[90m\u001b[39;49;00m\n                            function_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + \u001b[96mself\u001b[39;49;00m.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mhasattr\u001b[39;49;00m(arg, \u001b[33m\"\u001b[39;49;00m\u001b[33mname\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m) \u001b[95mand\u001b[39;49;00m arg.name:\u001b[90m\u001b[39;49;00m\n                            argument_name += \u001b[33m'\u001b[39;49;00m\u001b[33m with name \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m + arg.name + \u001b[33m'\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        where = get_variable_trace_string(\u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable)\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(e.args) == \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + e.args[\u001b[94m0\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n                        \u001b[94melse\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                            e.args = (\u001b[90m\u001b[39;49;00m\n                                \u001b[33m\"\u001b[39;49;00m\u001b[33mBad input \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + argument_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33m\"\u001b[39;49;00m\u001b[33m to \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                                + function_name\u001b[90m\u001b[39;49;00m\n                                + \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33m at index \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mint\u001b[39;49;00m(i)\u001b[33m}\u001b[39;49;00m\u001b[33m (0-based). \u001b[39;49;00m\u001b[33m{\u001b[39;49;00mwhere\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                            ) + e.args\u001b[90m\u001b[39;49;00m\n                        \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                        \u001b[94mraise\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                arg_container.provided += \u001b[94m1\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Set keyword arguments\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m kwargs:  \u001b[90m# for speed, skip the items for empty kwargs\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m k, arg \u001b[95min\u001b[39;49;00m kwargs.items():\u001b[90m\u001b[39;49;00m\n                \u001b[96mself\u001b[39;49;00m[k] = arg\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m trust_input:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Collect aliased inputs among the storage space\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m potential_group \u001b[95min\u001b[39;49;00m \u001b[96mself\u001b[39;49;00m._potential_aliased_input_groups:\u001b[90m\u001b[39;49;00m\n                args_share_memory: \u001b[96mlist\u001b[39;49;00m[\u001b[96mlist\u001b[39;49;00m[\u001b[96mint\u001b[39;49;00m]] = []\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m potential_group:\u001b[90m\u001b[39;49;00m\n                    i_type = \u001b[96mself\u001b[39;49;00m.maker.inputs[i].variable.type\u001b[90m\u001b[39;49;00m\n                    i_val = input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                    \u001b[90m# Check if value is aliased with any of the values in one of the groups\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94mfor\u001b[39;49;00m j_group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                        \u001b[94mif\u001b[39;49;00m \u001b[96many\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                            i_type.may_share_memory(input_storage[j].storage[\u001b[94m0\u001b[39;49;00m], i_val)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mfor\u001b[39;49;00m j \u001b[95min\u001b[39;49;00m j_group\u001b[90m\u001b[39;49;00m\n                        ):\u001b[90m\u001b[39;49;00m\n                            j_group.append(i)\u001b[90m\u001b[39;49;00m\n                            \u001b[94mbreak\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    \u001b[94melse\u001b[39;49;00m:  \u001b[90m# no break\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# Create a new group\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        args_share_memory.append([i])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n                \u001b[90m# Check for groups of more than one argument that share memory\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[94mfor\u001b[39;49;00m group \u001b[95min\u001b[39;49;00m args_share_memory:\u001b[90m\u001b[39;49;00m\n                    \u001b[94mif\u001b[39;49;00m \u001b[96mlen\u001b[39;49;00m(group) > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                        \u001b[90m# copy all but the first\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                        \u001b[94mfor\u001b[39;49;00m i \u001b[95min\u001b[39;49;00m group[\u001b[94m1\u001b[39;49;00m:]:\u001b[90m\u001b[39;49;00m\n                            input_storage[i].storage[\u001b[94m0\u001b[39;49;00m] = copy.copy(\u001b[90m\u001b[39;49;00m\n                                input_storage[i].storage[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                            )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[90m# Check if inputs are missing, or if inputs were set more than once, or\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[90m# if we tried to provide inputs that are supposed to be implicit.\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mfor\u001b[39;49;00m arg_container \u001b[95min\u001b[39;49;00m input_storage:\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.required \u001b[95mand\u001b[39;49;00m \u001b[95mnot\u001b[39;49;00m arg_container.provided:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMissing required input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.provided > \u001b[94m1\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mMultiple values for input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n                \u001b[94mif\u001b[39;49;00m arg_container.implicit \u001b[95mand\u001b[39;49;00m arg_container.provided > \u001b[94m0\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                    \u001b[96mself\u001b[39;49;00m._restore_defaults()\u001b[90m\u001b[39;49;00m\n                    \u001b[94mraise\u001b[39;49;00m \u001b[96mTypeError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                        \u001b[33mf\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[33mTried to provide value for implicit input: \u001b[39;49;00m\u001b[33m{\u001b[39;49;00m\u001b[96mgetattr\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container],\u001b[90m \u001b[39;49;00m\u001b[33m'\u001b[39;49;00m\u001b[33mvariable\u001b[39;49;00m\u001b[33m'\u001b[39;49;00m,\u001b[90m \u001b[39;49;00m\u001b[96mself\u001b[39;49;00m.inv_finder[arg_container])\u001b[33m}\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                    )\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Do the actual work\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m profile:\u001b[90m\u001b[39;49;00m\n            t0_fn = time.perf_counter()\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           outputs = vm() \u001b[94mif\u001b[39;49;00m output_subset \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m \u001b[94melse\u001b[39;49;00m vm(output_subset=output_subset)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           pymc.logprob.utils.ParameterValueError: \u001b[0m\n\u001b[1m\u001b[31mE           Apply node that caused the error: Check{}([[-60.4828 ... 37844436]], False)\u001b[0m\n\u001b[1m\u001b[31mE           Toposort index: 0\u001b[0m\n\u001b[1m\u001b[31mE           Inputs types: [TensorType(float64, shape=(1, 2)), ScalarType(bool)]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs shapes: [(1, 2), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs strides: [(16, 8), ()]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs values: [array([[-60.48285693, -45.37844436]]), np.False_]\u001b[0m\n\u001b[1m\u001b[31mE           Inputs type_num: [12, 0]\u001b[0m\n\u001b[1m\u001b[31mE           Outputs clients: [[Sum{axes=None}(Check{}.0)]]\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Backtrace when the node is created (use PyTensor flag traceback__limit=N to make it longer):\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 575, in transformed_conditional_logp\u001b[0m\n\u001b[1m\u001b[31mE               temp_logp_terms = conditional_logp(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/logprob/basic.py\", line 505, in conditional_logp\u001b[0m\n\u001b[1m\u001b[31mE               node_logprobs = _logprob(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/lib/python3.10/functools.py\", line 889, in wrapper\u001b[0m\n\u001b[1m\u001b[31mE               return dispatch(args[0].__class__)(*args, **kw)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/distribution.py\", line 140, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return class_logp(value, *dist_params)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/tests/distributions/test_dist_math.py\", line 96, in logp\u001b[0m\n\u001b[1m\u001b[31mE               return check_parameters(\u001b[0m\n\u001b[1m\u001b[31mE             File \"/app/repo_to_process/pymc/distributions/dist_math.py\", line 72, in check_parameters\u001b[0m\n\u001b[1m\u001b[31mE               return CheckParameterValue(msg, can_be_replaced_by_ninf)(expr, all_true_scalar)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/graph/op.py\", line 293, in __call__\u001b[0m\n\u001b[1m\u001b[31mE               node = self.make_node(*inputs, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mE             File \"/usr/local/lib/python3.10/dist-packages/pytensor/raise_op.py\", line 81, in make_node\u001b[0m\n\u001b[1m\u001b[31mE               [value.type()],\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Debug print of the apply node: \u001b[0m\n\u001b[1m\u001b[31mE           Check{} [id A] <Matrix(float64, shape=(1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             [[-60.4828 ... 37844436]] [id B] <Matrix(float64, shape=(1, 2))>\u001b[0m\n\u001b[1m\u001b[31mE             False [id C] <bool>\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           Storage map footprint:\u001b[0m\n\u001b[1m\u001b[31mE            - [[-60.4828 ... 37844436]], Shape: (1, 2), ElemSize: 8 Byte(s), TotalSize: 16 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            - False, Shape: (), ElemSize: 1 Byte(s), TotalSize: 1.0 Byte(s)\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize: 17.0 Byte(s) 0.000 GB\u001b[0m\n\u001b[1m\u001b[31mE            TotalSize inputs: 17.0 Byte(s) 0.000 GB\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/dist-packages/pytensor/compile/function/types.py\u001b[0m:1039: ParameterValueError\n\u001b[31m\u001b[1m_______ TestMoments.test_multinomial_support_point[p7-1-None-expected7] ________\u001b[0m\n\nself = <tests.distributions.test_multivariate.TestMoments object at 0x7f6604caabc0>\np = array([0.  , 0.25, 0.25, 0.25, 0.25]), n = 1, size = None\nexpected = array([0, 1, 0, 0, 0])\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mp, n, size, expected\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            (np.array([\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m]), \u001b[94m1\u001b[39;49;00m, \u001b[94mNone\u001b[39;49;00m, np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\n            (np.array([\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m]), \u001b[94m2\u001b[39;49;00m, \u001b[94mNone\u001b[39;49;00m, np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\n            (np.array([\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m]), \u001b[94m10\u001b[39;49;00m, \u001b[94mNone\u001b[39;49;00m, np.array([\u001b[94m3\u001b[39;49;00m, \u001b[94m7\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m], [\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n                \u001b[94m10\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m3\u001b[39;49;00m, \u001b[94m7\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m4\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0.3\u001b[39;49;00m, \u001b[94m0.6\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m, \u001b[94m0.05\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m2\u001b[39;49;00m, \u001b[94m10\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                (\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n                np.array([[[\u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m3\u001b[39;49;00m, \u001b[94m7\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m]]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m], [\u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.22\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m10\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([[\u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m], [\u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.26\u001b[39;49;00m, \u001b[94m0.22\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m10\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                (\u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n                np.full((\u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m4\u001b[39;49;00m), [[\u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m], [\u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m]]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            (\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0.0\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m, \u001b[94m0.25\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                \u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m0.1441\u001b[39;49;00m, \u001b[94m0.1363\u001b[39;49;00m, \u001b[94m0.1385\u001b[39;49;00m, \u001b[94m0.1348\u001b[39;49;00m, \u001b[94m0.1521\u001b[39;49;00m, \u001b[94m0.1500\u001b[39;49;00m, \u001b[94m0.1442\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                \u001b[94m4\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                np.array([\u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m1\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m, \u001b[94m0\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\n                marks=pytest.mark.xfail(\u001b[90m\u001b[39;49;00m\n                    rises=\u001b[96mAssertionError\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mKnown failure in mode approximation \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                ),\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_multinomial_support_point\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m, p, n, size, expected):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            pm.Multinomial(\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, n=n, p=p, size=size)\u001b[90m\u001b[39;49;00m\n>       assert_support_point_is_expected(model, expected)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/distributions/test_multivariate.py\u001b[0m:1065: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f6632c520e0>\nexpected = array([0, 1, 0, 0, 0]), check_finite_logp = True\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92massert_support_point_is_expected\u001b[39;49;00m(model, expected, check_finite_logp=\u001b[94mTrue\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        fn = make_initial_point_fn(\u001b[90m\u001b[39;49;00m\n            model=model,\u001b[90m\u001b[39;49;00m\n            return_transformed=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            default_strategy=\u001b[33m\"\u001b[39;49;00m\u001b[33msupport_point\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        )\u001b[90m\u001b[39;49;00m\n        support_point = fn(\u001b[94m0\u001b[39;49;00m)[\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n        expected = np.asarray(expected)\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            random_draw = model[\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m].eval()\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mNotImplementedError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            random_draw = support_point\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94massert\u001b[39;49;00m support_point.shape == expected.shape\u001b[90m\u001b[39;49;00m\n        \u001b[94massert\u001b[39;49;00m expected.shape == random_draw.shape\u001b[90m\u001b[39;49;00m\n        \u001b[94massert\u001b[39;49;00m np.allclose(support_point, expected)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m check_finite_logp:\u001b[90m\u001b[39;49;00m\n            logp_support_point = (\u001b[90m\u001b[39;49;00m\n                transformed_conditional_logp(\u001b[90m\u001b[39;49;00m\n                    (model[\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],),\u001b[90m\u001b[39;49;00m\n                    rvs_to_values={model[\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]: pt.constant(support_point)},\u001b[90m\u001b[39;49;00m\n                    rvs_to_transforms={},\u001b[90m\u001b[39;49;00m\n                )[\u001b[94m0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\n                .sum()\u001b[90m\u001b[39;49;00m\n                .eval()\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n>           \u001b[94massert\u001b[39;49;00m np.isfinite(logp_support_point)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           AssertionError\u001b[0m\n\n\u001b[1m\u001b[31mpymc/testing.py\u001b[0m:695: AssertionError\n\u001b[31m\u001b[1m____________________________ test_docstring_example ____________________________\u001b[0m\n  + Exception Group Traceback (most recent call last):\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 344, in from_call\n  |     result: TResult | None = func()\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/runner.py\", line 246, in <lambda>\n  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_hooks.py\", line 512, in __call__\n  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_manager.py\", line 120, in _hookexec\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 167, in _multicall\n  |     raise exception\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/logging.py\", line 850, in pytest_runtest_call\n  |     yield\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/capture.py\", line 900, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 139, in _multicall\n  |     teardown.throw(exception)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/skipping.py\", line 263, in pytest_runtest_call\n  |     return (yield)\n  |   File \"/usr/local/lib/python3.10/dist-packages/pluggy/_callers.py\", line 121, in _multicall\n  |     res = hook_impl.function(*args)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 158, in pytest_runtest_call\n  |     collect_unraisable(item.config)\n  |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 81, in collect_unraisable\n  |     raise ExceptionGroup(\"multiple unraisable exception warnings\", errors)\n  | exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/jax/_src/xla_bridge.py\", line 120, in _at_fork\n    |     warnings.warn(\n    | RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    | \n    | The above exception was the direct cause of the following exception:\n    | \n    | Traceback (most recent call last):\n    |   File \"/usr/local/lib/python3.10/dist-packages/_pytest/unraisableexception.py\", line 67, in collect_unraisable\n    |     warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))\n    | pytest.PytestUnraisableExceptionWarning: Exception ignored in: <function _at_fork at 0x7f65f47215a0>\n    | Enable tracemalloc to get traceback where the object was allocated.\n    | See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n    +------------------------------------\n----------------------------- Captured stdout call -----------------------------\n                                                                                \n                              Step      Grad      Sampli                       \n  Progre   Draws   Diverg   size      evals     Speed     Elapsed   Remaini  \n  \n     10      0         1.403     3         547.43    0:00:00   0:00:00   \n                                                  draws/s                       \n     10      0         0.802     7         67.31     0:00:00   0:00:00   \n                                                  draws/s                       \n                                                                                \nComputing ...  100% 0:00:00\n----------------------------- Captured stderr call -----------------------------\nOnly 5 samples per chain. Reliable r-hat and ESS diagnostics require longer chains for accurate estimate.\nInitializing NUTS using jitter+adapt_diag...\nMultiprocess sampling (2 chains in 2 jobs)\nNUTS: [mu_raw]\nSampling 2 chains for 5 tune and 5 draw iterations (10 + 10 draws total) took 0 seconds.\nThe number of samples is too small to check convergence reliably.\n------------------------------ Captured log call -------------------------------\n\u001b[33mWARNING \u001b[0m pymc.sampling.mcmc:mcmc.py:780 Only 5 samples per chain. Reliable r-hat and ESS diagnostics require longer chains for accurate estimate.\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1582 Initializing NUTS using jitter+adapt_diag...\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:925 Multiprocess sampling (2 chains in 2 jobs)\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:282 NUTS: [mu_raw]\n\u001b[32mINFO    \u001b[0m pymc.sampling.mcmc:mcmc.py:1068 Sampling 2 chains for 5 tune and 5 draw iterations (10 + 10 draws total) took 0 seconds.\n\u001b[32mINFO    \u001b[0m pymc.stats.convergence:convergence.py:187 The number of samples is too small to check convergence reliably.\n\u001b[31m\u001b[1m_________________ test_transform_samples[scan-1-None-sampler0] _________________\u001b[0m\n\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\npostprocessing_backend = None, chains = 1, postprocessing_vectorize = 'scan'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[94m1\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                \u001b[94m2\u001b[39;49;00m, marks=pytest.mark.skipif(\u001b[96mlen\u001b[39;49;00m(jax.devices()) < \u001b[94m2\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mnot enough devices\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_vectorize\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[33m\"\u001b[39;49;00m\u001b[33mscan\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvmap\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_transform_samples\u001b[39;49;00m(sampler, postprocessing_backend, chains, postprocessing_vectorize):\u001b[90m\u001b[39;49;00m\n        pytensor.config.on_opt_error = \u001b[33m\"\u001b[39;49;00m\u001b[33mraise\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        np.random.seed(\u001b[94m13244\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        obs = np.random.normal(\u001b[94m10\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        obs_at = pytensor.shared(obs, borrow=\u001b[94mTrue\u001b[39;49;00m, name=\u001b[33m\"\u001b[39;49;00m\u001b[33mobs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            a = pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33ma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, -\u001b[94m20\u001b[39;49;00m, \u001b[94m20\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            sigma = pm.HalfNormal(\u001b[33m\"\u001b[39;49;00m\u001b[33msigma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, shape=(\u001b[94m2\u001b[39;49;00m,))\u001b[90m\u001b[39;49;00m\n            b = pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mb\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, a, sigma=sigma.mean(), observed=obs_at)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>           trace = sampler(\u001b[90m\u001b[39;49;00m\n                chains=chains,\u001b[90m\u001b[39;49;00m\n                random_seed=\u001b[94m1322\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                keep_untransformed=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n                postprocessing_vectorize=postprocessing_vectorize,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:97: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f63f624c370>, target_accept = 0.8\ntune = 1000, draws = 1000, chains = 1, chain_method = 'parallel'\nprogressbar = True, random_seed = 1322\ninitial_points = [array(-0.30226902), array([-0.09759751, -0.98476903])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6610b57be0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m_________________ test_transform_samples[scan-1-cpu-sampler0] __________________\u001b[0m\n\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\npostprocessing_backend = 'cpu', chains = 1, postprocessing_vectorize = 'scan'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[94m1\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                \u001b[94m2\u001b[39;49;00m, marks=pytest.mark.skipif(\u001b[96mlen\u001b[39;49;00m(jax.devices()) < \u001b[94m2\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mnot enough devices\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_vectorize\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[33m\"\u001b[39;49;00m\u001b[33mscan\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvmap\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_transform_samples\u001b[39;49;00m(sampler, postprocessing_backend, chains, postprocessing_vectorize):\u001b[90m\u001b[39;49;00m\n        pytensor.config.on_opt_error = \u001b[33m\"\u001b[39;49;00m\u001b[33mraise\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        np.random.seed(\u001b[94m13244\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        obs = np.random.normal(\u001b[94m10\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        obs_at = pytensor.shared(obs, borrow=\u001b[94mTrue\u001b[39;49;00m, name=\u001b[33m\"\u001b[39;49;00m\u001b[33mobs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            a = pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33ma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, -\u001b[94m20\u001b[39;49;00m, \u001b[94m20\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            sigma = pm.HalfNormal(\u001b[33m\"\u001b[39;49;00m\u001b[33msigma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, shape=(\u001b[94m2\u001b[39;49;00m,))\u001b[90m\u001b[39;49;00m\n            b = pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mb\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, a, sigma=sigma.mean(), observed=obs_at)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>           trace = sampler(\u001b[90m\u001b[39;49;00m\n                chains=chains,\u001b[90m\u001b[39;49;00m\n                random_seed=\u001b[94m1322\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                keep_untransformed=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n                postprocessing_vectorize=postprocessing_vectorize,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:97: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f64e06c1d50>, target_accept = 0.8\ntune = 1000, draws = 1000, chains = 1, chain_method = 'parallel'\nprogressbar = True, random_seed = 1322\ninitial_points = [array(-0.30226902), array([-0.09759751, -0.98476903])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f649858feb0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m_________________ test_transform_samples[scan-2-None-sampler0] _________________\u001b[0m\n\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\npostprocessing_backend = None, chains = 2, postprocessing_vectorize = 'scan'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[94m1\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                \u001b[94m2\u001b[39;49;00m, marks=pytest.mark.skipif(\u001b[96mlen\u001b[39;49;00m(jax.devices()) < \u001b[94m2\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mnot enough devices\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_vectorize\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[33m\"\u001b[39;49;00m\u001b[33mscan\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvmap\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_transform_samples\u001b[39;49;00m(sampler, postprocessing_backend, chains, postprocessing_vectorize):\u001b[90m\u001b[39;49;00m\n        pytensor.config.on_opt_error = \u001b[33m\"\u001b[39;49;00m\u001b[33mraise\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        np.random.seed(\u001b[94m13244\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        obs = np.random.normal(\u001b[94m10\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        obs_at = pytensor.shared(obs, borrow=\u001b[94mTrue\u001b[39;49;00m, name=\u001b[33m\"\u001b[39;49;00m\u001b[33mobs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            a = pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33ma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, -\u001b[94m20\u001b[39;49;00m, \u001b[94m20\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            sigma = pm.HalfNormal(\u001b[33m\"\u001b[39;49;00m\u001b[33msigma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, shape=(\u001b[94m2\u001b[39;49;00m,))\u001b[90m\u001b[39;49;00m\n            b = pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mb\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, a, sigma=sigma.mean(), observed=obs_at)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>           trace = sampler(\u001b[90m\u001b[39;49;00m\n                chains=chains,\u001b[90m\u001b[39;49;00m\n                random_seed=\u001b[94m1322\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                keep_untransformed=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n                postprocessing_vectorize=postprocessing_vectorize,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:97: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f663253bf40>, target_accept = 0.8\ntune = 1000, draws = 1000, chains = 2, chain_method = 'parallel'\nprogressbar = True, random_seed = 1322\ninitial_points = [array([0.56284093, 0.4068034 ]), array([[ 0.47840234,  0.27787312],\n       [-0.8280904 ,  0.60854149]])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f64e0525b40>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m_________________ test_transform_samples[scan-2-cpu-sampler0] __________________\u001b[0m\n\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\npostprocessing_backend = 'cpu', chains = 2, postprocessing_vectorize = 'scan'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[94m1\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                \u001b[94m2\u001b[39;49;00m, marks=pytest.mark.skipif(\u001b[96mlen\u001b[39;49;00m(jax.devices()) < \u001b[94m2\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mnot enough devices\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_vectorize\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[33m\"\u001b[39;49;00m\u001b[33mscan\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvmap\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_transform_samples\u001b[39;49;00m(sampler, postprocessing_backend, chains, postprocessing_vectorize):\u001b[90m\u001b[39;49;00m\n        pytensor.config.on_opt_error = \u001b[33m\"\u001b[39;49;00m\u001b[33mraise\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        np.random.seed(\u001b[94m13244\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        obs = np.random.normal(\u001b[94m10\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        obs_at = pytensor.shared(obs, borrow=\u001b[94mTrue\u001b[39;49;00m, name=\u001b[33m\"\u001b[39;49;00m\u001b[33mobs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            a = pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33ma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, -\u001b[94m20\u001b[39;49;00m, \u001b[94m20\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            sigma = pm.HalfNormal(\u001b[33m\"\u001b[39;49;00m\u001b[33msigma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, shape=(\u001b[94m2\u001b[39;49;00m,))\u001b[90m\u001b[39;49;00m\n            b = pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mb\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, a, sigma=sigma.mean(), observed=obs_at)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>           trace = sampler(\u001b[90m\u001b[39;49;00m\n                chains=chains,\u001b[90m\u001b[39;49;00m\n                random_seed=\u001b[94m1322\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                keep_untransformed=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n                postprocessing_vectorize=postprocessing_vectorize,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:97: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f63f6afa470>, target_accept = 0.8\ntune = 1000, draws = 1000, chains = 2, chain_method = 'parallel'\nprogressbar = True, random_seed = 1322\ninitial_points = [array([0.56284093, 0.4068034 ]), array([[ 0.47840234,  0.27787312],\n       [-0.8280904 ,  0.60854149]])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6610ac4b80>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m_________________ test_transform_samples[vmap-1-None-sampler0] _________________\u001b[0m\n\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\npostprocessing_backend = None, chains = 1, postprocessing_vectorize = 'vmap'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[94m1\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                \u001b[94m2\u001b[39;49;00m, marks=pytest.mark.skipif(\u001b[96mlen\u001b[39;49;00m(jax.devices()) < \u001b[94m2\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mnot enough devices\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_vectorize\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[33m\"\u001b[39;49;00m\u001b[33mscan\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvmap\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_transform_samples\u001b[39;49;00m(sampler, postprocessing_backend, chains, postprocessing_vectorize):\u001b[90m\u001b[39;49;00m\n        pytensor.config.on_opt_error = \u001b[33m\"\u001b[39;49;00m\u001b[33mraise\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        np.random.seed(\u001b[94m13244\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        obs = np.random.normal(\u001b[94m10\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        obs_at = pytensor.shared(obs, borrow=\u001b[94mTrue\u001b[39;49;00m, name=\u001b[33m\"\u001b[39;49;00m\u001b[33mobs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            a = pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33ma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, -\u001b[94m20\u001b[39;49;00m, \u001b[94m20\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            sigma = pm.HalfNormal(\u001b[33m\"\u001b[39;49;00m\u001b[33msigma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, shape=(\u001b[94m2\u001b[39;49;00m,))\u001b[90m\u001b[39;49;00m\n            b = pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mb\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, a, sigma=sigma.mean(), observed=obs_at)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>           trace = sampler(\u001b[90m\u001b[39;49;00m\n                chains=chains,\u001b[90m\u001b[39;49;00m\n                random_seed=\u001b[94m1322\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                keep_untransformed=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n                postprocessing_vectorize=postprocessing_vectorize,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:97: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f63f63c0820>, target_accept = 0.8\ntune = 1000, draws = 1000, chains = 1, chain_method = 'parallel'\nprogressbar = True, random_seed = 1322\ninitial_points = [array(-0.30226902), array([-0.09759751, -0.98476903])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f658058d750>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m_________________ test_transform_samples[vmap-1-cpu-sampler0] __________________\u001b[0m\n\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\npostprocessing_backend = 'cpu', chains = 1, postprocessing_vectorize = 'vmap'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[94m1\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                \u001b[94m2\u001b[39;49;00m, marks=pytest.mark.skipif(\u001b[96mlen\u001b[39;49;00m(jax.devices()) < \u001b[94m2\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mnot enough devices\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_vectorize\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[33m\"\u001b[39;49;00m\u001b[33mscan\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvmap\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_transform_samples\u001b[39;49;00m(sampler, postprocessing_backend, chains, postprocessing_vectorize):\u001b[90m\u001b[39;49;00m\n        pytensor.config.on_opt_error = \u001b[33m\"\u001b[39;49;00m\u001b[33mraise\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        np.random.seed(\u001b[94m13244\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        obs = np.random.normal(\u001b[94m10\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        obs_at = pytensor.shared(obs, borrow=\u001b[94mTrue\u001b[39;49;00m, name=\u001b[33m\"\u001b[39;49;00m\u001b[33mobs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            a = pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33ma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, -\u001b[94m20\u001b[39;49;00m, \u001b[94m20\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            sigma = pm.HalfNormal(\u001b[33m\"\u001b[39;49;00m\u001b[33msigma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, shape=(\u001b[94m2\u001b[39;49;00m,))\u001b[90m\u001b[39;49;00m\n            b = pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mb\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, a, sigma=sigma.mean(), observed=obs_at)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>           trace = sampler(\u001b[90m\u001b[39;49;00m\n                chains=chains,\u001b[90m\u001b[39;49;00m\n                random_seed=\u001b[94m1322\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                keep_untransformed=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n                postprocessing_vectorize=postprocessing_vectorize,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:97: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f6630d11240>, target_accept = 0.8\ntune = 1000, draws = 1000, chains = 1, chain_method = 'parallel'\nprogressbar = True, random_seed = 1322\ninitial_points = [array(-0.30226902), array([-0.09759751, -0.98476903])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f66310b91b0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m_________________ test_transform_samples[vmap-2-None-sampler0] _________________\u001b[0m\n\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\npostprocessing_backend = None, chains = 2, postprocessing_vectorize = 'vmap'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[94m1\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                \u001b[94m2\u001b[39;49;00m, marks=pytest.mark.skipif(\u001b[96mlen\u001b[39;49;00m(jax.devices()) < \u001b[94m2\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mnot enough devices\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_vectorize\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[33m\"\u001b[39;49;00m\u001b[33mscan\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvmap\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_transform_samples\u001b[39;49;00m(sampler, postprocessing_backend, chains, postprocessing_vectorize):\u001b[90m\u001b[39;49;00m\n        pytensor.config.on_opt_error = \u001b[33m\"\u001b[39;49;00m\u001b[33mraise\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        np.random.seed(\u001b[94m13244\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        obs = np.random.normal(\u001b[94m10\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        obs_at = pytensor.shared(obs, borrow=\u001b[94mTrue\u001b[39;49;00m, name=\u001b[33m\"\u001b[39;49;00m\u001b[33mobs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            a = pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33ma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, -\u001b[94m20\u001b[39;49;00m, \u001b[94m20\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            sigma = pm.HalfNormal(\u001b[33m\"\u001b[39;49;00m\u001b[33msigma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, shape=(\u001b[94m2\u001b[39;49;00m,))\u001b[90m\u001b[39;49;00m\n            b = pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mb\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, a, sigma=sigma.mean(), observed=obs_at)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>           trace = sampler(\u001b[90m\u001b[39;49;00m\n                chains=chains,\u001b[90m\u001b[39;49;00m\n                random_seed=\u001b[94m1322\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                keep_untransformed=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n                postprocessing_vectorize=postprocessing_vectorize,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:97: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f654055a140>, target_accept = 0.8\ntune = 1000, draws = 1000, chains = 2, chain_method = 'parallel'\nprogressbar = True, random_seed = 1322\ninitial_points = [array([0.56284093, 0.4068034 ]), array([[ 0.47840234,  0.27787312],\n       [-0.8280904 ,  0.60854149]])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6403befeb0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m_________________ test_transform_samples[vmap-2-cpu-sampler0] __________________\u001b[0m\n\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\npostprocessing_backend = 'cpu', chains = 2, postprocessing_vectorize = 'vmap'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[94m1\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                \u001b[94m2\u001b[39;49;00m, marks=pytest.mark.skipif(\u001b[96mlen\u001b[39;49;00m(jax.devices()) < \u001b[94m2\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mnot enough devices\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_vectorize\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[33m\"\u001b[39;49;00m\u001b[33mscan\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvmap\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_transform_samples\u001b[39;49;00m(sampler, postprocessing_backend, chains, postprocessing_vectorize):\u001b[90m\u001b[39;49;00m\n        pytensor.config.on_opt_error = \u001b[33m\"\u001b[39;49;00m\u001b[33mraise\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        np.random.seed(\u001b[94m13244\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        obs = np.random.normal(\u001b[94m10\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        obs_at = pytensor.shared(obs, borrow=\u001b[94mTrue\u001b[39;49;00m, name=\u001b[33m\"\u001b[39;49;00m\u001b[33mobs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            a = pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33ma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, -\u001b[94m20\u001b[39;49;00m, \u001b[94m20\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            sigma = pm.HalfNormal(\u001b[33m\"\u001b[39;49;00m\u001b[33msigma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, shape=(\u001b[94m2\u001b[39;49;00m,))\u001b[90m\u001b[39;49;00m\n            b = pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mb\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, a, sigma=sigma.mean(), observed=obs_at)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>           trace = sampler(\u001b[90m\u001b[39;49;00m\n                chains=chains,\u001b[90m\u001b[39;49;00m\n                random_seed=\u001b[94m1322\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                keep_untransformed=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n                postprocessing_vectorize=postprocessing_vectorize,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:97: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f6616027c40>, target_accept = 0.8\ntune = 1000, draws = 1000, chains = 2, chain_method = 'parallel'\nprogressbar = True, random_seed = 1322\ninitial_points = [array([0.56284093, 0.4068034 ]), array([[ 0.47840234,  0.27787312],\n       [-0.8280904 ,  0.60854149]])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6615848160>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m_____________________ test_deterministic_samples[sampler0] _____________________\u001b[0m\n\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.skipif(\u001b[96mlen\u001b[39;49;00m(jax.devices()) < \u001b[94m2\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mnot enough devices\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_deterministic_samples\u001b[39;49;00m(sampler):\u001b[90m\u001b[39;49;00m\n        pytensor.config.on_opt_error = \u001b[33m\"\u001b[39;49;00m\u001b[33mraise\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        np.random.seed(\u001b[94m13244\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        obs = np.random.normal(\u001b[94m10\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        obs_at = pytensor.shared(obs, borrow=\u001b[94mTrue\u001b[39;49;00m, name=\u001b[33m\"\u001b[39;49;00m\u001b[33mobs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            a = pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33ma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, -\u001b[94m20\u001b[39;49;00m, \u001b[94m20\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            b = pm.Deterministic(\u001b[33m\"\u001b[39;49;00m\u001b[33mb\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, a / \u001b[94m2.0\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            c = pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mc\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, a, sigma=\u001b[94m1.0\u001b[39;49;00m, observed=obs_at)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>           trace = sampler(chains=\u001b[94m2\u001b[39;49;00m, random_seed=\u001b[94m1322\u001b[39;49;00m, keep_untransformed=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:145: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f66150af820>, target_accept = 0.8\ntune = 1000, draws = 1000, chains = 2, chain_method = 'parallel'\nprogressbar = True, random_seed = 1322\ninitial_points = [array([ 0.47840234, -0.8280904 ])], nuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6614ea2d40>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m____________________ test_initvals_without_jitter[sampler0] ____________________\u001b[0m\n\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_initvals_without_jitter\u001b[39;49;00m(sampler):\u001b[90m\u001b[39;49;00m\n        pytensor.config.on_opt_error = \u001b[33m\"\u001b[39;49;00m\u001b[33mraise\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        np.random.seed(\u001b[94m13244\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        obs = np.random.normal(\u001b[94m10\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        obs_at = pytensor.shared(obs, borrow=\u001b[94mTrue\u001b[39;49;00m, name=\u001b[33m\"\u001b[39;49;00m\u001b[33mobs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        initvals = {\u001b[33m\"\u001b[39;49;00m\u001b[33ma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: -\u001b[94m3\u001b[39;49;00m}\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            a = pm.Uniform(\u001b[33m\"\u001b[39;49;00m\u001b[33ma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, -\u001b[94m20\u001b[39;49;00m, \u001b[94m20\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            b = pm.Deterministic(\u001b[33m\"\u001b[39;49;00m\u001b[33mb\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, a / \u001b[94m2.0\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            c = pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mc\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, a, sigma=\u001b[94m1.0\u001b[39;49;00m, observed=obs_at)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>           trace1 = sampler(\u001b[90m\u001b[39;49;00m\n                chains=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                tune=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                draws=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                random_seed=\u001b[94m1322\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                initvals=initvals,\u001b[90m\u001b[39;49;00m\n                jitter=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                keep_untransformed=\u001b[94mTrue\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:170: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f6458264ee0>, target_accept = 0.8\ntune = 1, draws = 1, chains = 1, chain_method = 'parallel', progressbar = True\nrandom_seed = 1322, initial_points = [array(-0.30228087)], nuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6613bec160>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m________________ test_idata_kwargs[None-idata_kwargs0-sampler0] ________________\u001b[0m\n\nmodel_test_idata_kwargs = <pymc.model.core.Model object at 0x7f66150851e0>\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\nidata_kwargs = {}, postprocessing_backend = None\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33midata_kwargs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            {},\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mlog_likelihood\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mTrue\u001b[39;49;00m},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite models coords\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mx2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite dims from dist specification in model\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite both coords and dims\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mA\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mB\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}, \u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_idata_kwargs\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model_test_idata_kwargs: pm.Model,\u001b[90m\u001b[39;49;00m\n        sampler: Callable[..., az.InferenceData],\u001b[90m\u001b[39;49;00m\n        idata_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        postprocessing_backend: \u001b[96mstr\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n        idata: az.InferenceData | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m model_test_idata_kwargs:\u001b[90m\u001b[39;49;00m\n>           idata = sampler(\u001b[90m\u001b[39;49;00m\n                tune=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                draws=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                chains=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                idata_kwargs=idata_kwargs,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:298: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f66150851e0>, target_accept = 0.8\ntune = 50, draws = 50, chains = 1, chain_method = 'parallel', progressbar = True\nrandom_seed = 924231661\ninitial_points = [array([0.53428155, 0.81956672]), array([0.26682213, 0.28014625, 0.68023699])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6610b54ee0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m________________ test_idata_kwargs[None-idata_kwargs1-sampler0] ________________\u001b[0m\n\nmodel_test_idata_kwargs = <pymc.model.core.Model object at 0x7f66150851e0>\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\nidata_kwargs = {'log_likelihood': True}, postprocessing_backend = None\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33midata_kwargs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            {},\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mlog_likelihood\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mTrue\u001b[39;49;00m},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite models coords\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mx2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite dims from dist specification in model\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite both coords and dims\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mA\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mB\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}, \u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_idata_kwargs\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model_test_idata_kwargs: pm.Model,\u001b[90m\u001b[39;49;00m\n        sampler: Callable[..., az.InferenceData],\u001b[90m\u001b[39;49;00m\n        idata_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        postprocessing_backend: \u001b[96mstr\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n        idata: az.InferenceData | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m model_test_idata_kwargs:\u001b[90m\u001b[39;49;00m\n>           idata = sampler(\u001b[90m\u001b[39;49;00m\n                tune=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                draws=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                chains=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                idata_kwargs=idata_kwargs,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:298: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f66150851e0>, target_accept = 0.8\ntune = 50, draws = 50, chains = 1, chain_method = 'parallel', progressbar = True\nrandom_seed = 80515028\ninitial_points = [array([-0.83370473, -0.27633715]), array([-0.22207774, -0.60252528, -0.71232414])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f647862d000>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m________________ test_idata_kwargs[None-idata_kwargs2-sampler0] ________________\u001b[0m\n\nmodel_test_idata_kwargs = <pymc.model.core.Model object at 0x7f66150851e0>\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\nidata_kwargs = {'coords': {'x_coord': ['x1', 'x2']}}\npostprocessing_backend = None\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33midata_kwargs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            {},\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mlog_likelihood\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mTrue\u001b[39;49;00m},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite models coords\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mx2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite dims from dist specification in model\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite both coords and dims\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mA\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mB\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}, \u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_idata_kwargs\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model_test_idata_kwargs: pm.Model,\u001b[90m\u001b[39;49;00m\n        sampler: Callable[..., az.InferenceData],\u001b[90m\u001b[39;49;00m\n        idata_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        postprocessing_backend: \u001b[96mstr\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n        idata: az.InferenceData | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m model_test_idata_kwargs:\u001b[90m\u001b[39;49;00m\n>           idata = sampler(\u001b[90m\u001b[39;49;00m\n                tune=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                draws=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                chains=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                idata_kwargs=idata_kwargs,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:298: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f66150851e0>, target_accept = 0.8\ntune = 50, draws = 50, chains = 1, chain_method = 'parallel', progressbar = True\nrandom_seed = 309901739\ninitial_points = [array([0.08620367, 0.64048743]), array([0.9285221 , 0.557161  , 0.37421947])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f644012d480>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m________________ test_idata_kwargs[None-idata_kwargs3-sampler0] ________________\u001b[0m\n\nmodel_test_idata_kwargs = <pymc.model.core.Model object at 0x7f66150851e0>\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\nidata_kwargs = {'dims': {'x': ['x_coord2']}}, postprocessing_backend = None\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33midata_kwargs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            {},\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mlog_likelihood\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mTrue\u001b[39;49;00m},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite models coords\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mx2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite dims from dist specification in model\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite both coords and dims\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mA\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mB\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}, \u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_idata_kwargs\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model_test_idata_kwargs: pm.Model,\u001b[90m\u001b[39;49;00m\n        sampler: Callable[..., az.InferenceData],\u001b[90m\u001b[39;49;00m\n        idata_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        postprocessing_backend: \u001b[96mstr\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n        idata: az.InferenceData | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m model_test_idata_kwargs:\u001b[90m\u001b[39;49;00m\n>           idata = sampler(\u001b[90m\u001b[39;49;00m\n                tune=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                draws=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                chains=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                idata_kwargs=idata_kwargs,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:298: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f66150851e0>, target_accept = 0.8\ntune = 50, draws = 50, chains = 1, chain_method = 'parallel', progressbar = True\nrandom_seed = 625738061\ninitial_points = [array([-0.98046743,  0.27946198]), array([-0.74831516,  0.20871984,  0.46920888])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f63e825c430>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m________________ test_idata_kwargs[None-idata_kwargs4-sampler0] ________________\u001b[0m\n\nmodel_test_idata_kwargs = <pymc.model.core.Model object at 0x7f66150851e0>\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\nidata_kwargs = {'coords': {'x_coord3': ['A', 'B']}, 'dims': {'x': ['x_coord3']}}\npostprocessing_backend = None\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33midata_kwargs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            {},\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mlog_likelihood\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mTrue\u001b[39;49;00m},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite models coords\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mx2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite dims from dist specification in model\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite both coords and dims\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mA\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mB\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}, \u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_idata_kwargs\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model_test_idata_kwargs: pm.Model,\u001b[90m\u001b[39;49;00m\n        sampler: Callable[..., az.InferenceData],\u001b[90m\u001b[39;49;00m\n        idata_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        postprocessing_backend: \u001b[96mstr\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n        idata: az.InferenceData | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m model_test_idata_kwargs:\u001b[90m\u001b[39;49;00m\n>           idata = sampler(\u001b[90m\u001b[39;49;00m\n                tune=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                draws=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                chains=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                idata_kwargs=idata_kwargs,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:298: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f66150851e0>, target_accept = 0.8\ntune = 50, draws = 50, chains = 1, chain_method = 'parallel', progressbar = True\nrandom_seed = 303553620\ninitial_points = [array([-0.31913086, -0.18832141]), array([ 0.50907217, -0.3841544 ,  0.62592554])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6630d87eb0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m________________ test_idata_kwargs[cpu-idata_kwargs0-sampler0] _________________\u001b[0m\n\nmodel_test_idata_kwargs = <pymc.model.core.Model object at 0x7f66150851e0>\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\nidata_kwargs = {}, postprocessing_backend = 'cpu'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33midata_kwargs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            {},\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mlog_likelihood\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mTrue\u001b[39;49;00m},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite models coords\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mx2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite dims from dist specification in model\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite both coords and dims\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mA\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mB\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}, \u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_idata_kwargs\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model_test_idata_kwargs: pm.Model,\u001b[90m\u001b[39;49;00m\n        sampler: Callable[..., az.InferenceData],\u001b[90m\u001b[39;49;00m\n        idata_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        postprocessing_backend: \u001b[96mstr\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n        idata: az.InferenceData | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m model_test_idata_kwargs:\u001b[90m\u001b[39;49;00m\n>           idata = sampler(\u001b[90m\u001b[39;49;00m\n                tune=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                draws=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                chains=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                idata_kwargs=idata_kwargs,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:298: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f66150851e0>, target_accept = 0.8\ntune = 50, draws = 50, chains = 1, chain_method = 'parallel', progressbar = True\nrandom_seed = 351346894\ninitial_points = [array([0.33805957, 0.15081531]), array([-0.23144363,  0.52380503, -0.20879436])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f661393d7e0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m________________ test_idata_kwargs[cpu-idata_kwargs1-sampler0] _________________\u001b[0m\n\nmodel_test_idata_kwargs = <pymc.model.core.Model object at 0x7f66150851e0>\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\nidata_kwargs = {'log_likelihood': True}, postprocessing_backend = 'cpu'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33midata_kwargs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            {},\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mlog_likelihood\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mTrue\u001b[39;49;00m},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite models coords\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mx2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite dims from dist specification in model\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite both coords and dims\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mA\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mB\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}, \u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_idata_kwargs\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model_test_idata_kwargs: pm.Model,\u001b[90m\u001b[39;49;00m\n        sampler: Callable[..., az.InferenceData],\u001b[90m\u001b[39;49;00m\n        idata_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        postprocessing_backend: \u001b[96mstr\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n        idata: az.InferenceData | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m model_test_idata_kwargs:\u001b[90m\u001b[39;49;00m\n>           idata = sampler(\u001b[90m\u001b[39;49;00m\n                tune=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                draws=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                chains=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                idata_kwargs=idata_kwargs,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:298: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f66150851e0>, target_accept = 0.8\ntune = 50, draws = 50, chains = 1, chain_method = 'parallel', progressbar = True\nrandom_seed = 368405633\ninitial_points = [array([-0.81172252,  0.95388078]), array([ 0.79358532, -0.3216138 , -0.02008213])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6613966dd0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m________________ test_idata_kwargs[cpu-idata_kwargs2-sampler0] _________________\u001b[0m\n\nmodel_test_idata_kwargs = <pymc.model.core.Model object at 0x7f66150851e0>\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\nidata_kwargs = {'coords': {'x_coord': ['x1', 'x2']}}\npostprocessing_backend = 'cpu'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33midata_kwargs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            {},\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mlog_likelihood\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mTrue\u001b[39;49;00m},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite models coords\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mx2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite dims from dist specification in model\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite both coords and dims\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mA\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mB\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}, \u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_idata_kwargs\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model_test_idata_kwargs: pm.Model,\u001b[90m\u001b[39;49;00m\n        sampler: Callable[..., az.InferenceData],\u001b[90m\u001b[39;49;00m\n        idata_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        postprocessing_backend: \u001b[96mstr\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n        idata: az.InferenceData | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m model_test_idata_kwargs:\u001b[90m\u001b[39;49;00m\n>           idata = sampler(\u001b[90m\u001b[39;49;00m\n                tune=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                draws=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                chains=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                idata_kwargs=idata_kwargs,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:298: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f66150851e0>, target_accept = 0.8\ntune = 50, draws = 50, chains = 1, chain_method = 'parallel', progressbar = True\nrandom_seed = 224051634\ninitial_points = [array([0.4470838 , 0.17321975]), array([-0.97335907, -0.5326334 , -0.77147898])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f66130af7f0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m________________ test_idata_kwargs[cpu-idata_kwargs3-sampler0] _________________\u001b[0m\n\nmodel_test_idata_kwargs = <pymc.model.core.Model object at 0x7f66150851e0>\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\nidata_kwargs = {'dims': {'x': ['x_coord2']}}, postprocessing_backend = 'cpu'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33midata_kwargs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            {},\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mlog_likelihood\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mTrue\u001b[39;49;00m},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite models coords\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mx2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite dims from dist specification in model\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite both coords and dims\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mA\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mB\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}, \u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_idata_kwargs\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model_test_idata_kwargs: pm.Model,\u001b[90m\u001b[39;49;00m\n        sampler: Callable[..., az.InferenceData],\u001b[90m\u001b[39;49;00m\n        idata_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        postprocessing_backend: \u001b[96mstr\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n        idata: az.InferenceData | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m model_test_idata_kwargs:\u001b[90m\u001b[39;49;00m\n>           idata = sampler(\u001b[90m\u001b[39;49;00m\n                tune=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                draws=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                chains=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                idata_kwargs=idata_kwargs,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:298: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f66150851e0>, target_accept = 0.8\ntune = 50, draws = 50, chains = 1, chain_method = 'parallel', progressbar = True\nrandom_seed = 962581644\ninitial_points = [array([ 0.08217045, -0.47496895]), array([-0.65814561, -0.69611231, -0.89279889])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f66130e6170>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m________________ test_idata_kwargs[cpu-idata_kwargs4-sampler0] _________________\u001b[0m\n\nmodel_test_idata_kwargs = <pymc.model.core.Model object at 0x7f66150851e0>\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\nidata_kwargs = {'coords': {'x_coord3': ['A', 'B']}, 'dims': {'x': ['x_coord3']}}\npostprocessing_backend = 'cpu'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33midata_kwargs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            {},\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mlog_likelihood\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mTrue\u001b[39;49;00m},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite models coords\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx1\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mx2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite dims from dist specification in model\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord2\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Overwrite both coords and dims\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            {\u001b[33m\"\u001b[39;49;00m\u001b[33mcoords\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mA\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mB\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}, \u001b[33m\"\u001b[39;49;00m\u001b[33mdims\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: {\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: [\u001b[33m\"\u001b[39;49;00m\u001b[33mx_coord3\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m]}},\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mpostprocessing_backend\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[94mNone\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_idata_kwargs\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model_test_idata_kwargs: pm.Model,\u001b[90m\u001b[39;49;00m\n        sampler: Callable[..., az.InferenceData],\u001b[90m\u001b[39;49;00m\n        idata_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        postprocessing_backend: \u001b[96mstr\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n        idata: az.InferenceData | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m model_test_idata_kwargs:\u001b[90m\u001b[39;49;00m\n>           idata = sampler(\u001b[90m\u001b[39;49;00m\n                tune=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                draws=\u001b[94m50\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                chains=\u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n                idata_kwargs=idata_kwargs,\u001b[90m\u001b[39;49;00m\n                postprocessing_backend=postprocessing_backend,\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:298: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f66150851e0>, target_accept = 0.8\ntune = 50, draws = 50, chains = 1, chain_method = 'parallel', progressbar = True\nrandom_seed = 13444763\ninitial_points = [array([0.27693658, 0.62546453]), array([ 0.32059778, -0.16905004,  0.95974366])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f66155b2710>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m________________________ test_seeding[1-None-sampler0] _________________________\u001b[0m\n\nchains = 1, random_seed = None\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mrandom_seed\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, (\u001b[94mNone\u001b[39;49;00m, \u001b[94m123\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[94m1\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                \u001b[94m2\u001b[39;49;00m, marks=pytest.mark.skipif(\u001b[96mlen\u001b[39;49;00m(jax.devices()) < \u001b[94m2\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mnot enough devices\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_seeding\u001b[39;49;00m(chains, random_seed, sampler):\u001b[90m\u001b[39;49;00m\n        sample_kwargs = {\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mtune\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m100\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mdraws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m5\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: chains,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mrandom_seed\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: random_seed,\u001b[90m\u001b[39;49;00m\n        }\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m m:\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, mu=\u001b[94m0\u001b[39;49;00m, sigma=\u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>           result1 = sampler(**sample_kwargs)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:402: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f6611de7970>, target_accept = 0.8\ntune = 100, draws = 5, chains = 1, chain_method = 'parallel', progressbar = True\nrandom_seed = 219457143, initial_points = [array(0.99233904)], nuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6613059cf0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m_________________________ test_seeding[1-123-sampler0] _________________________\u001b[0m\n\nchains = 1, random_seed = 123\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mrandom_seed\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, (\u001b[94mNone\u001b[39;49;00m, \u001b[94m123\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[94m1\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                \u001b[94m2\u001b[39;49;00m, marks=pytest.mark.skipif(\u001b[96mlen\u001b[39;49;00m(jax.devices()) < \u001b[94m2\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mnot enough devices\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_seeding\u001b[39;49;00m(chains, random_seed, sampler):\u001b[90m\u001b[39;49;00m\n        sample_kwargs = {\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mtune\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m100\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mdraws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m5\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: chains,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mrandom_seed\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: random_seed,\u001b[90m\u001b[39;49;00m\n        }\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m m:\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, mu=\u001b[94m0\u001b[39;49;00m, sigma=\u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>           result1 = sampler(**sample_kwargs)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:402: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f6613880e80>, target_accept = 0.8\ntune = 100, draws = 5, chains = 1, chain_method = 'parallel', progressbar = True\nrandom_seed = 123, initial_points = [array(-0.61269833)], nuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6630d79900>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m________________________ test_seeding[2-None-sampler0] _________________________\u001b[0m\n\nchains = 2, random_seed = None\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mrandom_seed\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, (\u001b[94mNone\u001b[39;49;00m, \u001b[94m123\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[94m1\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                \u001b[94m2\u001b[39;49;00m, marks=pytest.mark.skipif(\u001b[96mlen\u001b[39;49;00m(jax.devices()) < \u001b[94m2\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mnot enough devices\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_seeding\u001b[39;49;00m(chains, random_seed, sampler):\u001b[90m\u001b[39;49;00m\n        sample_kwargs = {\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mtune\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m100\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mdraws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m5\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: chains,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mrandom_seed\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: random_seed,\u001b[90m\u001b[39;49;00m\n        }\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m m:\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, mu=\u001b[94m0\u001b[39;49;00m, sigma=\u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>           result1 = sampler(**sample_kwargs)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:402: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f663117a380>, target_accept = 0.8\ntune = 100, draws = 5, chains = 2, chain_method = 'parallel', progressbar = True\nrandom_seed = 847247196, initial_points = [array([ 0.63809346, -0.69962975])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6611d36b90>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m_________________________ test_seeding[2-123-sampler0] _________________________\u001b[0m\n\nchains = 2, random_seed = 123\nsampler = functools.partial(<function sample_jax_nuts at 0x7f65f3876f80>, nuts_sampler='blackjax')\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            sample_blackjax_nuts,\u001b[90m\u001b[39;49;00m\n            sample_numpyro_nuts,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mrandom_seed\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, (\u001b[94mNone\u001b[39;49;00m, \u001b[94m123\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[94m1\u001b[39;49;00m),\u001b[90m\u001b[39;49;00m\n            pytest.param(\u001b[90m\u001b[39;49;00m\n                \u001b[94m2\u001b[39;49;00m, marks=pytest.mark.skipif(\u001b[96mlen\u001b[39;49;00m(jax.devices()) < \u001b[94m2\u001b[39;49;00m, reason=\u001b[33m\"\u001b[39;49;00m\u001b[33mnot enough devices\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            ),\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_seeding\u001b[39;49;00m(chains, random_seed, sampler):\u001b[90m\u001b[39;49;00m\n        sample_kwargs = {\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mtune\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m100\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mdraws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m5\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: chains,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mrandom_seed\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: random_seed,\u001b[90m\u001b[39;49;00m\n        }\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m m:\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, mu=\u001b[94m0\u001b[39;49;00m, sigma=\u001b[94m1\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>           result1 = sampler(**sample_kwargs)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:402: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f6611dbf1f0>, target_accept = 0.8\ntune = 100, draws = 5, chains = 2, chain_method = 'parallel', progressbar = True\nrandom_seed = 123, initial_points = [array([-0.09092255, -0.74054331])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6611c65090>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m_______________ test_idata_contains_stats[sample_blackjax_nuts] ________________\u001b[0m\n\nsampler_name = 'sample_blackjax_nuts'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[90m\u001b[39;49;00m\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msampler_name\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        [\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33msample_blackjax_nuts\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33msample_numpyro_nuts\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        ],\u001b[90m\u001b[39;49;00m\n    )\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_idata_contains_stats\u001b[39;49;00m(sampler_name: \u001b[96mstr\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Tests whether sampler statistics were written to sample_stats\u001b[39;49;00m\n    \u001b[33m    group of InferenceData\"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sampler_name == \u001b[33m\"\u001b[39;49;00m\u001b[33msample_blackjax_nuts\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sampler = sample_blackjax_nuts\u001b[90m\u001b[39;49;00m\n        \u001b[94melif\u001b[39;49;00m sampler_name == \u001b[33m\"\u001b[39;49;00m\u001b[33msample_numpyro_nuts\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            sampler = sample_numpyro_nuts\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model():\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33ma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>           idata = sampler(tune=\u001b[94m50\u001b[39;49;00m, draws=\u001b[94m50\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:464: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f64985f3670>, target_accept = 0.8\ntune = 50, draws = 50, chains = 4, chain_method = 'parallel', progressbar = True\nrandom_seed = 914591878\ninitial_points = [array([ 0.72753761, -0.07670428,  0.12347629, -0.263822  ])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6613162680>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m_____________________ test_convergence_warnings[blackjax] ______________________\u001b[0m\n\ncaplog = <_pytest.logging.LogCaptureFixture object at 0x7f6631143910>\nnuts_sampler = 'blackjax'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mnuts_sampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, (\u001b[33m\"\u001b[39;49;00m\u001b[33mnumpyro\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblackjax\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m))\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_convergence_warnings\u001b[39;49;00m(caplog, nuts_sampler):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pm.Model() \u001b[94mas\u001b[39;49;00m m:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Model that should diverge\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            sigma = pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33msigma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, initval=\u001b[94m3\u001b[39;49;00m, default_transform=\u001b[94mNone\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            pm.Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mobs\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, mu=\u001b[94m0\u001b[39;49;00m, sigma=sigma, observed=[\u001b[94m0.99\u001b[39;49;00m, \u001b[94m1.0\u001b[39;49;00m, \u001b[94m1.01\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n            \u001b[94mwith\u001b[39;49;00m caplog.at_level(logging.WARNING, logger=\u001b[33m\"\u001b[39;49;00m\u001b[33mpymc\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n>               pm.sample(nuts_sampler=nuts_sampler, random_seed=\u001b[94m581\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_jax.py\u001b[0m:524: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/mcmc.py\u001b[0m:802: in sample\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m _sample_external_nuts(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/sampling/mcmc.py\u001b[0m:391: in _sample_external_nuts\n    \u001b[0midata = pymc_jax.sample_jax_nuts(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f6633f11f00>, target_accept = 0.8\ntune = 1000, draws = 1000, chains = 4, chain_method = 'parallel'\nprogressbar = True, random_seed = 581\ninitial_points = [array([3.01426488, 3.72363799, 2.13574219, 2.53982543])]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f63f6bb35b0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m________________________ test_sample_var_names[nutpie] _________________________\u001b[0m\n\nsampler = 'nutpie', draws = 100, tune = 100, chains = 1, target_accept = 0.8\nrandom_seed = 1234, initvals = None\nmodel = <pymc.model.core.Model object at 0x7f66125e7640>, var_names = None\nprogressbar = False, idata_kwargs = None, compute_convergence_checks = False\nnuts_sampler_kwargs = {}, kwargs = {}\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_external_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        sampler: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mnutpie\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mnumpyro\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblackjax\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: RandomState | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initvals: StartDict | Sequence[StartDict | \u001b[94mNone\u001b[39;49;00m] | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        var_names: Sequence[\u001b[96mstr\u001b[39;49;00m] | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        idata_kwargs: \u001b[96mdict\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        compute_convergence_checks: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        nuts_sampler_kwargs: \u001b[96mdict\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        **kwargs,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m nuts_sampler_kwargs \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            nuts_sampler_kwargs = {}\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sampler == \u001b[33m\"\u001b[39;49;00m\u001b[33mnutpie\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mnutpie\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               ModuleNotFoundError: No module named 'nutpie'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/mcmc.py\u001b[0m:314: ModuleNotFoundError\n\n\u001b[33mThe above exception was the direct cause of the following exception:\u001b[0m\n\nnuts_sampler = 'nutpie'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mnuts_sampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[33m\"\u001b[39;49;00m\u001b[33mpymc\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mnutpie\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblackjax\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mnumpyro\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_sample_var_names\u001b[39;49;00m(nuts_sampler):\u001b[90m\u001b[39;49;00m\n        seed = \u001b[94m1234\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        kwargs = {\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mtune\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m100\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mdraws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m100\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mrandom_seed\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: seed,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mprogressbar\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mcompute_convergence_checks\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        }\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Generate data\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        rng = np.random.default_rng(seed)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        group = rng.choice(\u001b[96mlist\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mABCD\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m), size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        x = rng.normal(size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        y = rng.normal(size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        group_values, group_idx = np.unique(group, return_inverse=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        coords = {\u001b[33m\"\u001b[39;49;00m\u001b[33mgroup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: group_values}\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Create model\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m Model(coords=coords) \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            b_group = Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mb_group\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, dims=\u001b[33m\"\u001b[39;49;00m\u001b[33mgroup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            b_x = Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mb_x\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            mu = Deterministic(\u001b[33m\"\u001b[39;49;00m\u001b[33mmu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, b_group[group_idx] + b_x * x)\u001b[90m\u001b[39;49;00m\n            sigma = HalfNormal(\u001b[33m\"\u001b[39;49;00m\u001b[33msigma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33my\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, mu=mu, sigma=sigma, observed=y)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        free_RVs = [var.name \u001b[94mfor\u001b[39;49;00m var \u001b[95min\u001b[39;49;00m model.free_RVs]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Sample with and without var_names, but always with the same seed\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>           idata_1 = sample(nuts_sampler=nuts_sampler, **kwargs)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_mcmc_external.py\u001b[0m:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/mcmc.py\u001b[0m:802: in sample\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m _sample_external_nuts(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsampler = 'nutpie', draws = 100, tune = 100, chains = 1, target_accept = 0.8\nrandom_seed = 1234, initvals = None\nmodel = <pymc.model.core.Model object at 0x7f66125e7640>, var_names = None\nprogressbar = False, idata_kwargs = None, compute_convergence_checks = False\nnuts_sampler_kwargs = {}, kwargs = {}\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_external_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        sampler: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mnutpie\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mnumpyro\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblackjax\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: RandomState | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initvals: StartDict | Sequence[StartDict | \u001b[94mNone\u001b[39;49;00m] | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        var_names: Sequence[\u001b[96mstr\u001b[39;49;00m] | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        idata_kwargs: \u001b[96mdict\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        compute_convergence_checks: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        nuts_sampler_kwargs: \u001b[96mdict\u001b[39;49;00m | \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        **kwargs,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m nuts_sampler_kwargs \u001b[95mis\u001b[39;49;00m \u001b[94mNone\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            nuts_sampler_kwargs = {}\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mif\u001b[39;49;00m sampler == \u001b[33m\"\u001b[39;49;00m\u001b[33mnutpie\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n                \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mnutpie\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            \u001b[94mexcept\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m \u001b[94mas\u001b[39;49;00m err:\u001b[90m\u001b[39;49;00m\n>               \u001b[94mraise\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                    \u001b[33m\"\u001b[39;49;00m\u001b[33mnutpie not found. Install it with conda install -c conda-forge nutpie\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                ) \u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96merr\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE               ImportError: nutpie not found. Install it with conda install -c conda-forge nutpie\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/mcmc.py\u001b[0m:316: ImportError\n\u001b[31m\u001b[1m_______________________ test_sample_var_names[blackjax] ________________________\u001b[0m\n\nnuts_sampler = 'blackjax'\n\n    \u001b[0m\u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mnuts_sampler\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\u001b[33m\"\u001b[39;49;00m\u001b[33mpymc\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mnutpie\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mblackjax\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mnumpyro\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m])\u001b[90m\u001b[39;49;00m\n    \u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_sample_var_names\u001b[39;49;00m(nuts_sampler):\u001b[90m\u001b[39;49;00m\n        seed = \u001b[94m1234\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        kwargs = {\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mchains\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m1\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mtune\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m100\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mdraws\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94m100\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mrandom_seed\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: seed,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mprogressbar\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mcompute_convergence_checks\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        }\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Generate data\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        rng = np.random.default_rng(seed)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        group = rng.choice(\u001b[96mlist\u001b[39;49;00m(\u001b[33m\"\u001b[39;49;00m\u001b[33mABCD\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m), size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        x = rng.normal(size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n        y = rng.normal(size=\u001b[94m100\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        group_values, group_idx = np.unique(group, return_inverse=\u001b[94mTrue\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        coords = {\u001b[33m\"\u001b[39;49;00m\u001b[33mgroup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: group_values}\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[90m# Create model\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m Model(coords=coords) \u001b[94mas\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            b_group = Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mb_group\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, dims=\u001b[33m\"\u001b[39;49;00m\u001b[33mgroup\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            b_x = Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33mb_x\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            mu = Deterministic(\u001b[33m\"\u001b[39;49;00m\u001b[33mmu\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, b_group[group_idx] + b_x * x)\u001b[90m\u001b[39;49;00m\n            sigma = HalfNormal(\u001b[33m\"\u001b[39;49;00m\u001b[33msigma\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n            Normal(\u001b[33m\"\u001b[39;49;00m\u001b[33my\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, mu=mu, sigma=sigma, observed=y)\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        free_RVs = [var.name \u001b[94mfor\u001b[39;49;00m var \u001b[95min\u001b[39;49;00m model.free_RVs]\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m model:\u001b[90m\u001b[39;49;00m\n            \u001b[90m# Sample with and without var_names, but always with the same seed\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>           idata_1 = sample(nuts_sampler=nuts_sampler, **kwargs)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/sampling/test_mcmc_external.py\u001b[0m:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/sampling/mcmc.py\u001b[0m:802: in sample\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m _sample_external_nuts(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/sampling/mcmc.py\u001b[0m:391: in _sample_external_nuts\n    \u001b[0midata = pymc_jax.sample_jax_nuts(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:652: in sample_jax_nuts\n    \u001b[0mraw_mcmc_samples, sample_stats, library = sampler_fn(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <pymc.model.core.Model object at 0x7f6612632590>, target_accept = 0.8\ntune = 100, draws = 100, chains = 1, chain_method = 'parallel'\nprogressbar = False, random_seed = 1234\ninitial_points = [array([-0.84530646,  0.71405436, -0.7990231 , -0.90425908]), array(0.42757365), array(0.05869179)]\nnuts_kwargs = {}\nlogp_fn = <function get_jaxified_logp.<locals>.logp_fn_wrap at 0x7f6612f97910>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92m_sample_blackjax_nuts\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        model: Model,\u001b[90m\u001b[39;49;00m\n        target_accept: \u001b[96mfloat\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        tune: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        draws: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chains: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        chain_method: Literal[\u001b[33m\"\u001b[39;49;00m\u001b[33mparallel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, \u001b[33m\"\u001b[39;49;00m\u001b[33mvectorized\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m],\u001b[90m\u001b[39;49;00m\n        progressbar: \u001b[96mbool\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        random_seed: \u001b[96mint\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        initial_points: np.ndarray | \u001b[96mlist\u001b[39;49;00m[np.ndarray],\u001b[90m\u001b[39;49;00m\n        nuts_kwargs: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any],\u001b[90m\u001b[39;49;00m\n        logp_fn: Callable[[ArrayLike], jax.Array] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n    ) -> \u001b[96mtuple\u001b[39;49;00m[Any, \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any], ModuleType]:\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"\u001b[39;49;00m\n    \u001b[33m    Draw samples from the posterior using the NUTS method from the ``blackjax`` library.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Parameters\u001b[39;49;00m\n    \u001b[33m    ----------\u001b[39;49;00m\n    \u001b[33m    model : Model\u001b[39;49;00m\n    \u001b[33m        Model to sample from. The model needs to have free random variables.\u001b[39;49;00m\n    \u001b[33m    target_accept : float in [0, 1].\u001b[39;49;00m\n    \u001b[33m        The step size is tuned such that we approximate this acceptance rate. Higher\u001b[39;49;00m\n    \u001b[33m        values like 0.9 or 0.95 often work better for problematic posteriors.\u001b[39;49;00m\n    \u001b[33m    tune : int\u001b[39;49;00m\n    \u001b[33m        Number of iterations to tune. Samplers adjust the step sizes, scalings or\u001b[39;49;00m\n    \u001b[33m        similar during tuning. Tuning samples will be drawn in addition to the number\u001b[39;49;00m\n    \u001b[33m        specified in the ``draws`` argument.\u001b[39;49;00m\n    \u001b[33m    draws : int\u001b[39;49;00m\n    \u001b[33m        The number of samples to draw. The number of tuned samples are discarded by default.\u001b[39;49;00m\n    \u001b[33m    chains : int\u001b[39;49;00m\n    \u001b[33m        The number of chains to sample.\u001b[39;49;00m\n    \u001b[33m    chain_method : \"parallel\" or \"vectorized\"\u001b[39;49;00m\n    \u001b[33m        Specify how samples should be drawn.\u001b[39;49;00m\n    \u001b[33m    progressbar : bool\u001b[39;49;00m\n    \u001b[33m        Whether to show progressbar or not during sampling.\u001b[39;49;00m\n    \u001b[33m    random_seed : int, RandomState or Generator\u001b[39;49;00m\n    \u001b[33m        Random seed used by the sampling steps.\u001b[39;49;00m\n    \u001b[33m    initial_points : np.ndarray or list[np.ndarray]\u001b[39;49;00m\n    \u001b[33m        Initial point(s) for sampler to begin sampling from.\u001b[39;49;00m\n    \u001b[33m    nuts_kwargs : dict\u001b[39;49;00m\n    \u001b[33m        Keyword arguments for the blackjax nuts sampler\u001b[39;49;00m\n    \u001b[33m    logp_fn : Callable[[ArrayLike], jax.Array], optional, default None\u001b[39;49;00m\n    \u001b[33m        jaxified logp function. If not passed in it will be created anew.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m        raw_mcmc_samples\u001b[39;49;00m\n    \u001b[33m            Datastructure containing raw mcmc samples\u001b[39;49;00m\n    \u001b[33m        sample_stats : dict[str, Any]\u001b[39;49;00m\n    \u001b[33m            Dictionary containing sample stats\u001b[39;49;00m\n    \u001b[33m        blackjax : ModuleType[\"blackjax\"]\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n>       \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mblackjax\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE       ModuleNotFoundError: No module named 'blackjax'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/sampling/jax.py\u001b[0m:350: ModuleNotFoundError\n\u001b[31m\u001b[1m_________________________ TestRadonModel.test_graphviz _________________________\u001b[0m\n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=sigma_a, node_type=<NodeType.FREE_RV: 'Free Ran...(names=(None,), lengths=(85,)), variables=[NodeInfo(var=eps_a, node_type=<NodeType.FREE_RV: 'Free Random Variable'>)])]\nedges = [('mu_a', 'gamma'), ('eps_a', 'sigma_a'), ('a', 'eps_a'), ('a', 'mu_a'), ('log_radon', 'y_like'), ('y_like', 'b'), ...]\nformatting = 'plain', save = None, figsize = None, dpi = 300\nnode_formatters = None, graph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ModuleNotFoundError: No module named 'graphviz'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:440: ModuleNotFoundError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.test_model_graph.TestRadonModel object at 0x7f65b876b9d0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_graphviz\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[90m# just make sure everything runs without error\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       g = model_to_graphviz(\u001b[96mself\u001b[39;49;00m.model)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/test_model_graph.py\u001b[0m:397: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:762: in model_to_graphviz\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m make_graph(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=sigma_a, node_type=<NodeType.FREE_RV: 'Free Ran...(names=(None,), lengths=(85,)), variables=[NodeInfo(var=eps_a, node_type=<NodeType.FREE_RV: 'Free Random Variable'>)])]\nedges = [('mu_a', 'gamma'), ('eps_a', 'sigma_a'), ('a', 'eps_a'), ('a', 'mu_a'), ('log_radon', 'y_like'), ('y_like', 'b'), ...]\nformatting = 'plain', save = None, figsize = None, dpi = 300\nnode_formatters = None, graph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThis function requires the python library graphviz, along with binaries. \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThe easiest way to install all of this is by running\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33m\\t\u001b[39;49;00m\u001b[33mconda install -c conda-forge python-graphviz\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ImportError: This function requires the python library graphviz, along with binaries. The easiest way to install all of this is by running\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           \tconda install -c conda-forge python-graphviz\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:442: ImportError\n\u001b[31m\u001b[1m____________________ TestRadonModel.test_checks_formatting _____________________\u001b[0m\n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=sigma_a, node_type=<NodeType.FREE_RV: 'Free Ran...(names=(None,), lengths=(85,)), variables=[NodeInfo(var=eps_a, node_type=<NodeType.FREE_RV: 'Free Random Variable'>)])]\nedges = [('mu_a', 'gamma'), ('eps_a', 'sigma_a'), ('a', 'eps_a'), ('a', 'mu_a'), ('log_radon', 'y_like'), ('y_like', 'b'), ...]\nformatting = 'plain', save = None, figsize = None, dpi = 300\nnode_formatters = None, graph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ModuleNotFoundError: No module named 'graphviz'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:440: ModuleNotFoundError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.test_model_graph.TestRadonModel object at 0x7f65b876bee0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_checks_formatting\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m warnings.catch_warnings():\u001b[90m\u001b[39;49;00m\n            warnings.simplefilter(\u001b[33m\"\u001b[39;49;00m\u001b[33merror\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n>           model_to_graphviz(\u001b[96mself\u001b[39;49;00m.model, formatting=\u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/test_model_graph.py\u001b[0m:408: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:762: in model_to_graphviz\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m make_graph(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=sigma_a, node_type=<NodeType.FREE_RV: 'Free Ran...(names=(None,), lengths=(85,)), variables=[NodeInfo(var=eps_a, node_type=<NodeType.FREE_RV: 'Free Random Variable'>)])]\nedges = [('mu_a', 'gamma'), ('eps_a', 'sigma_a'), ('a', 'eps_a'), ('a', 'mu_a'), ('log_radon', 'y_like'), ('y_like', 'b'), ...]\nformatting = 'plain', save = None, figsize = None, dpi = 300\nnode_formatters = None, graph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThis function requires the python library graphviz, along with binaries. \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThe easiest way to install all of this is by running\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33m\\t\u001b[39;49;00m\u001b[33mconda install -c conda-forge python-graphviz\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ImportError: This function requires the python library graphviz, along with binaries. The easiest way to install all of this is by running\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           \tconda install -c conda-forge python-graphviz\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:442: ImportError\n\u001b[31m\u001b[1m______________________ TestImputationModel.test_graphviz _______________________\u001b[0m\n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=a, node_type=<NodeType.FREE_RV: 'Free Random Va...mInfo(names=(None,), lengths=(12,)), variables=[NodeInfo(var=L, node_type=<NodeType.DETERMINISTIC: 'Deterministic'>)])]\nedges = [('L_observed', 'a'), ('L_unobserved', 'a'), ('L', 'L_unobserved'), ('L', 'L_observed')]\nformatting = 'plain', save = None, figsize = None, dpi = 300\nnode_formatters = None, graph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ModuleNotFoundError: No module named 'graphviz'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:440: ModuleNotFoundError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.test_model_graph.TestImputationModel object at 0x7f65b879c640>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_graphviz\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[90m# just make sure everything runs without error\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       g = model_to_graphviz(\u001b[96mself\u001b[39;49;00m.model)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/test_model_graph.py\u001b[0m:397: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:762: in model_to_graphviz\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m make_graph(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=a, node_type=<NodeType.FREE_RV: 'Free Random Va...mInfo(names=(None,), lengths=(12,)), variables=[NodeInfo(var=L, node_type=<NodeType.DETERMINISTIC: 'Deterministic'>)])]\nedges = [('L_observed', 'a'), ('L_unobserved', 'a'), ('L', 'L_unobserved'), ('L', 'L_observed')]\nformatting = 'plain', save = None, figsize = None, dpi = 300\nnode_formatters = None, graph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThis function requires the python library graphviz, along with binaries. \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThe easiest way to install all of this is by running\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33m\\t\u001b[39;49;00m\u001b[33mconda install -c conda-forge python-graphviz\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ImportError: This function requires the python library graphviz, along with binaries. The easiest way to install all of this is by running\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           \tconda install -c conda-forge python-graphviz\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:442: ImportError\n\u001b[31m\u001b[1m_______________________ TestModelWithDims.test_graphviz ________________________\u001b[0m\n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(None,), lengths=(1,)), variables=[NodeInfo(var=economics, node_type=<NodeType.FREE_RV: ...d, node_type=<NodeType.DATA: 'Data'>), NodeInfo(var=L, node_type=<NodeType.OBSERVED_RV: 'Observed Random Variable'>)])]\nedges = [('tax revenue', 'population'), ('tax revenue', 'time'), ('tax revenue', 'economics'), ('observed', 'L'), ('L', 'tax revenue')]\nformatting = 'plain', save = None, figsize = None, dpi = 300\nnode_formatters = None, graph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ModuleNotFoundError: No module named 'graphviz'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:440: ModuleNotFoundError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.test_model_graph.TestModelWithDims object at 0x7f65b879d1e0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_graphviz\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[90m# just make sure everything runs without error\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       g = model_to_graphviz(\u001b[96mself\u001b[39;49;00m.model)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/test_model_graph.py\u001b[0m:397: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:762: in model_to_graphviz\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m make_graph(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(None,), lengths=(1,)), variables=[NodeInfo(var=economics, node_type=<NodeType.FREE_RV: ...d, node_type=<NodeType.DATA: 'Data'>), NodeInfo(var=L, node_type=<NodeType.OBSERVED_RV: 'Observed Random Variable'>)])]\nedges = [('tax revenue', 'population'), ('tax revenue', 'time'), ('tax revenue', 'economics'), ('observed', 'L'), ('L', 'tax revenue')]\nformatting = 'plain', save = None, figsize = None, dpi = 300\nnode_formatters = None, graph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThis function requires the python library graphviz, along with binaries. \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThe easiest way to install all of this is by running\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33m\\t\u001b[39;49;00m\u001b[33mconda install -c conda-forge python-graphviz\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ImportError: This function requires the python library graphviz, along with binaries. The easiest way to install all of this is by running\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           \tconda install -c conda-forge python-graphviz\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:442: ImportError\n\u001b[31m\u001b[1m____________________ TestUnnamedObservedNodes.test_graphviz ____________________\u001b[0m\n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=mu, node_type=<NodeType.FREE_RV: 'Free Random V...mes=(None,), lengths=(4,)), variables=[NodeInfo(var=y, node_type=<NodeType.OBSERVED_RV: 'Observed Random Variable'>)])]\nedges = [('y', 'mu')], formatting = 'plain', save = None, figsize = None\ndpi = 300, node_formatters = None, graph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ModuleNotFoundError: No module named 'graphviz'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:440: ModuleNotFoundError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.test_model_graph.TestUnnamedObservedNodes object at 0x7f65b879dba0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_graphviz\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[90m# just make sure everything runs without error\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       g = model_to_graphviz(\u001b[96mself\u001b[39;49;00m.model)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/test_model_graph.py\u001b[0m:397: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:762: in model_to_graphviz\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m make_graph(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=mu, node_type=<NodeType.FREE_RV: 'Free Random V...mes=(None,), lengths=(4,)), variables=[NodeInfo(var=y, node_type=<NodeType.OBSERVED_RV: 'Observed Random Variable'>)])]\nedges = [('y', 'mu')], formatting = 'plain', save = None, figsize = None\ndpi = 300, node_formatters = None, graph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThis function requires the python library graphviz, along with binaries. \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThe easiest way to install all of this is by running\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33m\\t\u001b[39;49;00m\u001b[33mconda install -c conda-forge python-graphviz\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ImportError: This function requires the python library graphviz, along with binaries. The easiest way to install all of this is by running\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           \tconda install -c conda-forge python-graphviz\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:442: ImportError\n\u001b[31m\u001b[1m__________________ TestObservationDtypeCasting.test_graphviz ___________________\u001b[0m\n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(None,), lengths=(4,)), variables=[NodeInfo(var=response, node_type=<NodeType.OBSERVED_R...info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=p, node_type=<NodeType.FREE_RV: 'Free Random Variable'>)])]\nedges = [('data', 'response'), ('response', 'p')], formatting = 'plain'\nsave = None, figsize = None, dpi = 300, node_formatters = None\ngraph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ModuleNotFoundError: No module named 'graphviz'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:440: ModuleNotFoundError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.test_model_graph.TestObservationDtypeCasting object at 0x7f65b879e530>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_graphviz\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[90m# just make sure everything runs without error\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       g = model_to_graphviz(\u001b[96mself\u001b[39;49;00m.model)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/test_model_graph.py\u001b[0m:397: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:762: in model_to_graphviz\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m make_graph(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(None,), lengths=(4,)), variables=[NodeInfo(var=response, node_type=<NodeType.OBSERVED_R...info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=p, node_type=<NodeType.FREE_RV: 'Free Random Variable'>)])]\nedges = [('data', 'response'), ('response', 'p')], formatting = 'plain'\nsave = None, figsize = None, dpi = 300, node_formatters = None\ngraph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThis function requires the python library graphviz, along with binaries. \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThe easiest way to install all of this is by running\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33m\\t\u001b[39;49;00m\u001b[33mconda install -c conda-forge python-graphviz\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ImportError: This function requires the python library graphviz, along with binaries. The easiest way to install all of this is by running\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           \tconda install -c conda-forge python-graphviz\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:442: ImportError\n\u001b[31m\u001b[1m_________________ TestModelNonRandomVariableRVs.test_graphviz __________________\u001b[0m\n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=mu, node_type=<NodeType.FREE_RV: 'Free Random V...mes=(None,), lengths=(5,)), variables=[NodeInfo(var=z, node_type=<NodeType.OBSERVED_RV: 'Observed Random Variable'>)])]\nedges = [('y', 'mu'), ('z', 'y')], formatting = 'plain', save = None\nfigsize = None, dpi = 300, node_formatters = None, graph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ModuleNotFoundError: No module named 'graphviz'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:440: ModuleNotFoundError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nself = <tests.test_model_graph.TestModelNonRandomVariableRVs object at 0x7f65b879ec80>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_graphviz\u001b[39;49;00m(\u001b[96mself\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n        \u001b[90m# just make sure everything runs without error\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       g = model_to_graphviz(\u001b[96mself\u001b[39;49;00m.model)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/test_model_graph.py\u001b[0m:397: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:762: in model_to_graphviz\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m make_graph(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=mu, node_type=<NodeType.FREE_RV: 'Free Random V...mes=(None,), lengths=(5,)), variables=[NodeInfo(var=z, node_type=<NodeType.OBSERVED_RV: 'Observed Random Variable'>)])]\nedges = [('y', 'mu'), ('z', 'y')], formatting = 'plain', save = None\nfigsize = None, dpi = 300, node_formatters = None, graph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThis function requires the python library graphviz, along with binaries. \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThe easiest way to install all of this is by running\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33m\\t\u001b[39;49;00m\u001b[33mconda install -c conda-forge python-graphviz\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ImportError: This function requires the python library graphviz, along with binaries. The easiest way to install all of this is by running\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           \tconda install -c conda-forge python-graphviz\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:442: ImportError\n\u001b[31m\u001b[1m____________________________ test_unknown_node_type ____________________________\u001b[0m\n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=b, node_type=<NodeType.FREE_RV: 'Free Random Va...e=<NodeType.FREE_RV: 'Free Random Variable'>), NodeInfo(var=a, node_type=<NodeType.FREE_RV: 'Free Random Variable'>)])]\nedges = [('b', 'a'), ('c', 'b')], formatting = 'plain', save = None\nfigsize = None, dpi = 300, node_formatters = {'Unknown Node Type': 'dummy'}\ngraph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ModuleNotFoundError: No module named 'graphviz'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:440: ModuleNotFoundError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nsimple_model = <pymc.model.core.Model object at 0x7f63dfa9dbd0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_unknown_node_type\u001b[39;49;00m(simple_model):\u001b[90m\u001b[39;49;00m\n        \u001b[94mwith\u001b[39;49;00m pytest.raises(\u001b[96mValueError\u001b[39;49;00m, match=\u001b[33m\"\u001b[39;49;00m\u001b[33mNode formatters must be of type NodeType.\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m):\u001b[90m\u001b[39;49;00m\n>           model_to_graphviz(simple_model, node_formatters={\u001b[33m\"\u001b[39;49;00m\u001b[33mUnknown Node Type\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[33m\"\u001b[39;49;00m\u001b[33mdummy\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m})\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/test_model_graph.py\u001b[0m:566: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:762: in model_to_graphviz\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m make_graph(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=b, node_type=<NodeType.FREE_RV: 'Free Random Va...e=<NodeType.FREE_RV: 'Free Random Variable'>), NodeInfo(var=a, node_type=<NodeType.FREE_RV: 'Free Random Variable'>)])]\nedges = [('b', 'a'), ('c', 'b')], formatting = 'plain', save = None\nfigsize = None, dpi = 300, node_formatters = {'Unknown Node Type': 'dummy'}\ngraph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThis function requires the python library graphviz, along with binaries. \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThe easiest way to install all of this is by running\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33m\\t\u001b[39;49;00m\u001b[33mconda install -c conda-forge python-graphviz\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ImportError: This function requires the python library graphviz, along with binaries. The easiest way to install all of this is by running\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           \tconda install -c conda-forge python-graphviz\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:442: ImportError\n\u001b[31m\u001b[1m_____________________ test_custom_node_formatting_networkx _____________________\u001b[0m\n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=b, node_type=<NodeType.FREE_RV: 'Free Random Va...e=<NodeType.FREE_RV: 'Free Random Variable'>), NodeInfo(var=a, node_type=<NodeType.FREE_RV: 'Free Random Variable'>)])]\nedges = [('b', 'a'), ('c', 'b')], formatting = 'plain'\nnode_formatters = {'Free Random Variable': <function test_custom_node_formatting_networkx.<locals>.<lambda> at 0x7f640ad6c1f0>}\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_networkx\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make networkx Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    networkx.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mnetworkx\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ModuleNotFoundError: No module named 'networkx'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:510: ModuleNotFoundError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nsimple_model = <pymc.model.core.Model object at 0x7f63e2369480>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_custom_node_formatting_networkx\u001b[39;49;00m(simple_model):\u001b[90m\u001b[39;49;00m\n        node_formatters = {\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFree Random Variable\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mlambda\u001b[39;49;00m var: {\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mlabel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: var.name,\u001b[90m\u001b[39;49;00m\n            },\u001b[90m\u001b[39;49;00m\n        }\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       G = model_to_networkx(simple_model, node_formatters=node_formatters)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/test_model_graph.py\u001b[0m:576: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:647: in model_to_networkx\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m make_networkx(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=b, node_type=<NodeType.FREE_RV: 'Free Random Va...e=<NodeType.FREE_RV: 'Free Random Variable'>), NodeInfo(var=a, node_type=<NodeType.FREE_RV: 'Free Random Variable'>)])]\nedges = [('b', 'a'), ('c', 'b')], formatting = 'plain'\nnode_formatters = {'Free Random Variable': <function test_custom_node_formatting_networkx.<locals>.<lambda> at 0x7f640ad6c1f0>}\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_networkx\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make networkx Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    networkx.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mnetworkx\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThis function requires the python library networkx, along with binaries. \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThe easiest way to install all of this is by running\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33m\\t\u001b[39;49;00m\u001b[33mconda install networkx\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ImportError: This function requires the python library networkx, along with binaries. The easiest way to install all of this is by running\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           \tconda install networkx\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:512: ImportError\n\u001b[31m\u001b[1m_____________________ test_custom_node_formatting_graphviz _____________________\u001b[0m\n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=b, node_type=<NodeType.FREE_RV: 'Free Random Va...e=<NodeType.FREE_RV: 'Free Random Variable'>), NodeInfo(var=a, node_type=<NodeType.FREE_RV: 'Free Random Variable'>)])]\nedges = [('b', 'a'), ('c', 'b')], formatting = 'plain', save = None\nfigsize = None, dpi = 300\nnode_formatters = {'Free Random Variable': <function test_custom_node_formatting_graphviz.<locals>.<lambda> at 0x7f640ad6feb0>}\ngraph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ModuleNotFoundError: No module named 'graphviz'\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:440: ModuleNotFoundError\n\n\u001b[33mDuring handling of the above exception, another exception occurred:\u001b[0m\n\nsimple_model = <pymc.model.core.Model object at 0x7f63dfa9d0f0>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_custom_node_formatting_graphviz\u001b[39;49;00m(simple_model):\u001b[90m\u001b[39;49;00m\n        node_formatters = {\u001b[90m\u001b[39;49;00m\n            \u001b[33m\"\u001b[39;49;00m\u001b[33mFree Random Variable\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: \u001b[94mlambda\u001b[39;49;00m var: {\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mlabel\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m: var.name,\u001b[90m\u001b[39;49;00m\n            },\u001b[90m\u001b[39;49;00m\n        }\u001b[90m\u001b[39;49;00m\n    \u001b[90m\u001b[39;49;00m\n>       G = model_to_graphviz(simple_model, node_formatters=node_formatters)\u001b[90m\u001b[39;49;00m\n\n\u001b[1m\u001b[31mtests/test_model_graph.py\u001b[0m:591: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:762: in model_to_graphviz\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m make_graph(\u001b[90m\u001b[39;49;00m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = ''\nplates = [Plate(dim_info=DimInfo(names=(), lengths=()), variables=[NodeInfo(var=b, node_type=<NodeType.FREE_RV: 'Free Random Va...e=<NodeType.FREE_RV: 'Free Random Variable'>), NodeInfo(var=a, node_type=<NodeType.FREE_RV: 'Free Random Variable'>)])]\nedges = [('b', 'a'), ('c', 'b')], formatting = 'plain', save = None\nfigsize = None, dpi = 300\nnode_formatters = {'Free Random Variable': <function test_custom_node_formatting_graphviz.<locals>.<lambda> at 0x7f640ad6feb0>}\ngraph_attr = None\ncreate_plate_label = <function create_plate_label_with_dim_length at 0x7f66060d0310>\n\n    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mmake_graph\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n        name: \u001b[96mstr\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        plates: \u001b[96mlist\u001b[39;49;00m[Plate],\u001b[90m\u001b[39;49;00m\n        edges: \u001b[96mlist\u001b[39;49;00m[\u001b[96mtuple\u001b[39;49;00m[VarName, VarName]],\u001b[90m\u001b[39;49;00m\n        formatting: \u001b[96mstr\u001b[39;49;00m = \u001b[33m\"\u001b[39;49;00m\u001b[33mplain\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        save=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        figsize=\u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        dpi=\u001b[94m300\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        node_formatters: NodeTypeFormatterMapping | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        graph_attr: \u001b[96mdict\u001b[39;49;00m[\u001b[96mstr\u001b[39;49;00m, Any] | \u001b[94mNone\u001b[39;49;00m = \u001b[94mNone\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\n        create_plate_label: PlateLabelFunc = create_plate_label_with_dim_length,\u001b[90m\u001b[39;49;00m\n    ):\u001b[90m\u001b[39;49;00m\n    \u001b[90m    \u001b[39;49;00m\u001b[33m\"\"\"Make graphviz Digraph of PyMC model.\u001b[39;49;00m\n    \u001b[33m\u001b[39;49;00m\n    \u001b[33m    Returns\u001b[39;49;00m\n    \u001b[33m    -------\u001b[39;49;00m\n    \u001b[33m    graphviz.Digraph\u001b[39;49;00m\n    \u001b[33m    \"\"\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mtry\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n            \u001b[94mimport\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mgraphviz\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n        \u001b[94mexcept\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m:\u001b[90m\u001b[39;49;00m\n>           \u001b[94mraise\u001b[39;49;00m \u001b[96mImportError\u001b[39;49;00m(\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThis function requires the python library graphviz, along with binaries. \u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33mThe easiest way to install all of this is by running\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\\n\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n                \u001b[33m\"\u001b[39;49;00m\u001b[33m\\t\u001b[39;49;00m\u001b[33mconda install -c conda-forge python-graphviz\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n            )\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE           ImportError: This function requires the python library graphviz, along with binaries. The easiest way to install all of this is by running\u001b[0m\n\u001b[1m\u001b[31mE           \u001b[0m\n\u001b[1m\u001b[31mE           \tconda install -c conda-forge python-graphviz\u001b[0m\n\n\u001b[1m\u001b[31mpymc/model_graph.py\u001b[0m:442: ImportError\n\u001b[33m=============================== warnings summary ===============================\u001b[0m\npymc/dims/__init__.py:66\n  /app/repo_to_process/pymc/dims/__init__.py:66: UserWarning: The `pymc.dims` module is experimental and may contain critical bugs (p=0.354).\n  Please report any issues you encounter at https://github.com/pymc-devs/pymc/issues.\n  API changes are expected in future releases.\n  \n    __init__()\n\ntests/backends/test_base.py::TestInitTrace::test_init_trace_continuation_unsupported\n  /usr/local/lib/python3.10/dist-packages/pytensor/link/c/cmodule.py:2968: UserWarning: PyTensor could not link to a BLAS installation. Operations that might benefit from BLAS will be severely degraded.\n  This usually happens when PyTensor is installed via pip. We recommend it be installed via conda/mamba/pixi instead.\n  Alternatively, you can use an experimental backend such as Numba or JAX that perform their own BLAS optimizations, by setting `pytensor.config.mode == 'NUMBA'` or passing `mode='NUMBA'` when compiling a PyTensor function.\n  For more options and details see https://pytensor.readthedocs.io/en/latest/troubleshooting.html#how-do-i-configure-test-my-blas-library\n    warnings.warn(\n\ntests/backends/test_mcbackend.py::TestMcBackendSampling::test_return_multitrace[False]\n  /app/repo_to_process/tests/backends/test_mcbackend.py:285: UserWarning: Tuning samples will be included in the returned `MultiTrace` object, which can lead to complications in your downstream analysis. Please consider to switch to `InferenceData`:\n  `pm.sample(..., return_inferencedata=True)`\n    mtrace = pm.sample(\n\ntests/backends/test_mcbackend.py: 1 warning\ntests/backends/test_zarr.py: 100 warnings\ntests/distributions/test_censored.py: 2 warnings\ntests/distributions/test_simulator.py: 9 warnings\ntests/model/test_core.py: 1 warning\ntests/sampling/test_forward.py: 10 warnings\ntests/sampling/test_jax.py: 1 warning\ntests/sampling/test_mcmc.py: 41 warnings\ntests/sampling/test_parallel.py: 4 warnings\ntests/sampling/test_population.py: 1 warning\ntests/smc/test_smc.py: 14 warnings\ntests/step_methods/hmc/test_nuts.py: 8 warnings\ntests/step_methods/test_metropolis.py: 8 warnings\ntests/step_methods/test_slicer.py: 1 warning\ntests/test_progress_bar.py: 4 warnings\ntests/variational/test_approximations.py: 1 warning\n  /usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n    self.pid = os.fork()\n\ntests/distributions/moments/test_means.py: 2 warnings\ntests/distributions/test_distribution.py: 3 warnings\ntests/distributions/test_multivariate.py: 11 warnings\n  /app/repo_to_process/pymc/distributions/multivariate.py:467: FutureWarning: Use the scale argument to specify the scale matrix. cov will be removed in future versions.\n    warnings.warn(\n\ntests/distributions/test_censored.py: 1 warning\ntests/distributions/test_truncated.py: 5 warnings\ntests/test_func_utils.py: 9 warnings\n  /usr/local/lib/python3.10/dist-packages/pytensor/scalar/math.py:1340: RuntimeWarning: divide by zero encountered in log\n    return np.log(-np.expm1(x))\n\ntests/distributions/test_censored.py: 1 warning\ntests/distributions/test_truncated.py: 5 warnings\ntests/test_func_utils.py: 9 warnings\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/elemwise.py:710: RuntimeWarning: divide by zero encountered in impl (vectorized)\n    variables = ufunc(*ufunc_args, **ufunc_kwargs)\n\ntests/distributions/test_censored.py: 1 warning\ntests/distributions/test_discrete.py: 9 warnings\ntests/distributions/test_mixture.py: 75 warnings\ntests/distributions/test_multivariate.py: 2 warnings\ntests/distributions/test_transform.py: 10 warnings\ntests/distributions/test_truncated.py: 21 warnings\ntests/logprob/test_transforms.py: 2 warnings\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/elemwise.py:710: RuntimeWarning: divide by zero encountered in log\n    variables = ufunc(*ufunc_args, **ufunc_kwargs)\n\ntests/distributions/test_continuous.py: 5 warnings\ntests/distributions/test_multivariate.py: 3 warnings\ntests/distributions/test_transform.py: 16 warnings\ntests/distributions/test_truncated.py: 6 warnings\ntests/logprob/test_transforms.py: 1 warning\ntests/model/test_core.py: 3 warnings\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/elemwise.py:710: RuntimeWarning: invalid value encountered in log\n    variables = ufunc(*ufunc_args, **ufunc_kwargs)\n\ntests/distributions/test_continuous.py::TestMatchesScipy::test_triangular\ntests/distributions/test_continuous.py::TestMatchesScipy::test_triangular\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/elemwise.py:710: RuntimeWarning: invalid value encountered in log1p\n    variables = ufunc(*ufunc_args, **ufunc_kwargs)\n\ntests/distributions/test_continuous.py::TestMatchesScipy::test_skewstudentt_logcdf\n  /usr/local/lib/python3.10/dist-packages/scipy/stats/_continuous_distns.py:5738: RuntimeWarning: divide by zero encountered in divide\n    return d2 / d3\n\ntests/distributions/test_continuous.py: 1 warning\ntests/distributions/test_discrete.py: 2 warnings\ntests/distributions/test_truncated.py: 12 warnings\ntests/test_func_utils.py: 9 warnings\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/elemwise.py:710: RuntimeWarning: divide by zero encountered in log1p\n    variables = ufunc(*ufunc_args, **ufunc_kwargs)\n\ntests/distributions/test_continuous.py::TestMatchesScipy::test_interpolated_transform[None]\ntests/logprob/test_utils.py::TestReplaceRVsByValues::test_basic[False-False]\ntests/logprob/test_utils.py::TestReplaceRVsByValues::test_basic[False-True]\ntests/stats/test_log_density.py::TestComputeLogLikelihood::test_basic[False]\ntests/stats/test_log_density.py::TestComputeLogLikelihood::test_basic_log_prior[False]\n  /app/repo_to_process/pymc/model/core.py:1393: UserWarning: To disable default transform, please use default_transform=None instead of transform=None. Setting transform to None will not have any effect in future.\n    warnings.warn(\n\ntests/distributions/test_continuous.py::TestMoments::test_inverse_gamma_support_point[alpha3-1-None-expected3]\ntests/distributions/test_continuous.py::TestMoments::test_triangular_support_point[3-lower1-upper1-None-expected1]\ntests/distributions/test_continuous.py::TestMoments::test_triangular_support_point[3-lower1-upper1-None-expected1]\ntests/distributions/test_continuous.py::TestMoments::test_triangular_support_point[c2--3-3-None-expected2]\ntests/distributions/test_continuous.py::TestMoments::test_triangular_support_point[c2--3-3-None-expected2]\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/elemwise.py:710: RuntimeWarning: divide by zero encountered in divide\n    variables = ufunc(*ufunc_args, **ufunc_kwargs)\n\ntests/distributions/test_continuous.py::TestMoments::test_interpolated_support_point[x_points2-pdf_points2-size2-expected2]\ntests/distributions/test_continuous.py::TestMoments::test_interpolated_support_point[x_points2-pdf_points2-size2-expected2]\ntests/distributions/test_continuous.py::TestMoments::test_interpolated_support_point[x_points3-pdf_points3-size3-expected3]\ntests/distributions/test_continuous.py::TestMoments::test_interpolated_support_point[x_points3-pdf_points3-size3-expected3]\n  /usr/local/lib/python3.10/dist-packages/scipy/interpolate/_fitpack_impl.py:349: DeprecationWarning: Conversion of an array with ndim > 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n    aint, wrk = dfitpack.splint(t, c, k, a, b)\n\ntests/distributions/test_continuous.py::TestMoments::test_polyagamma_support_point[1.0-0.0-None-0.25]\ntests/distributions/test_transform.py::TestElementWiseLogp::test_triangular[lower2-c2-upper2-size2]\ntests/distributions/test_transform.py::TestElementWiseLogp::test_triangular[lower2-c2-upper2-size2]\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/rewriting/math.py:1402: RuntimeWarning: divide by zero encountered in scalar divide\n    v = reduce(np.multiply, num, one) / reduce(np.multiply, denum, one)\n\ntests/distributions/test_continuous.py::TestMoments::test_polyagamma_support_point[1.0-0.0-None-0.25]\ntests/distributions/test_discrete.py::TestMoments::test_geometric_support_point[p2-None-expected2]\ntests/distributions/test_discrete.py::TestMoments::test_geometric_support_point[p3-size3-expected3]\ntests/distributions/test_multivariate.py::TestMatchesScipy::test_multinomial_zero_probs\ntests/distributions/test_multivariate.py::TestMoments::test_multinomial_support_point[p7-1-None-expected7]\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/elemwise.py:710: RuntimeWarning: invalid value encountered in multiply\n    variables = ufunc(*ufunc_args, **ufunc_kwargs)\n\ntests/distributions/test_continuous.py::TestMoments::test_polyagamma_support_point[1.0-z1-None-expected1]\ntests/distributions/test_continuous.py::TestMoments::test_polyagamma_support_point[h2-z2-None-expected2]\ntests/distributions/test_continuous.py::TestMoments::test_polyagamma_support_point[h3-z3-size3-expected3]\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/elemwise.py:710: RuntimeWarning: invalid value encountered in divide\n    variables = ufunc(*ufunc_args, **ufunc_kwargs)\n\ntests/distributions/test_discrete.py: 2 warnings\ntests/distributions/test_mixture.py: 4 warnings\ntests/distributions/test_multivariate.py: 2 warnings\ntests/distributions/test_transform.py: 2 warnings\ntests/distributions/test_truncated.py: 20 warnings\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/elemwise.py:710: RuntimeWarning: invalid value encountered in subtract\n    variables = ufunc(*ufunc_args, **ufunc_kwargs)\n\ntests/distributions/test_discrete.py::TestMatchesScipy::test_orderedlogistic[2]\ntests/distributions/test_discrete.py::TestMatchesScipy::test_orderedlogistic[3]\ntests/distributions/test_discrete.py::TestMatchesScipy::test_orderedlogistic[4]\ntests/distributions/test_discrete.py::TestMatchesScipy::test_orderedprobit[2]\ntests/distributions/test_discrete.py::TestMatchesScipy::test_orderedprobit[3]\ntests/distributions/test_discrete.py::TestMatchesScipy::test_orderedprobit[4]\n  /usr/local/lib/python3.10/dist-packages/numpy/_core/numeric.py:442: RuntimeWarning: invalid value encountered in cast\n    multiarray.copyto(res, fill_value, casting='unsafe')\n\ntests/distributions/test_discrete.py::TestOrderedLogistic::test_compute_p\ntests/distributions/test_discrete.py::TestOrderedProbit::test_compute_p\n  /app/repo_to_process/pymc/model/core.py:1286: RuntimeWarning: invalid value encountered in cast\n    data = convert_observed_data(data).astype(rv_var.dtype)\n\ntests/distributions/test_mixture.py::TestMixtureMoments::test_list_univariate_components[weights2-comp_dists2-size2-expected2]\ntests/distributions/test_mixture.py::TestMixtureMoments::test_list_multivariate_components[weights1-comp_dists1-size1-expected1]\ntests/distributions/test_mixture.py::TestMixtureMoments::test_list_multivariate_components[weights2-comp_dists2-None-expected2]\n  /app/repo_to_process/pymc/distributions/mixture.py:312: MixtureTransformWarning: No safe default transform found for Mixture distribution x. This can happen when components have different supports or default transforms.\n  If appropriate, you can specify a custom transform for more efficient sampling.\n    transform_warning()\n\ntests/distributions/test_mixture.py::TestMixtureDefaultTransforms::test_expected[comp_dists4-NoneType]\n  /app/repo_to_process/pymc/distributions/mixture.py:312: MixtureTransformWarning: No safe default transform found for Mixture distribution MixtureRV{inline=True}.out. This can happen when components have different supports or default transforms.\n  If appropriate, you can specify a custom transform for more efficient sampling.\n    transform_warning()\n\ntests/distributions/test_mixture.py::TestMixtureDefaultTransforms::test_expected[comp_dists8-NoneType]\n  /app/repo_to_process/pymc/distributions/mixture.py:336: MixtureTransformWarning: No safe default transform found for Mixture distribution MixtureRV{inline=True}.out. This can happen when components have different supports or default transforms.\n  If appropriate, you can specify a custom transform for more efficient sampling.\n    transform_warning()\n\ntests/distributions/test_multivariate.py: 17 warnings\ntests/logprob/test_linalg.py: 2 warnings\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/nlinalg.py:183: FutureWarning: pytensor.tensor.linalg.trace is deprecated. Use pytensor.tensor.trace instead.\n    warnings.warn(\n\ntests/distributions/test_multivariate.py: 29 warnings\ntests/gp/test_gp.py: 1 warning\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/blas.py:1711: FutureWarning: batched_dot is deprecated. Use `dot` in conjunction with `tensor.vectorize` or `graph.replace.vectorize_graph`\n    warnings.warn(\n\ntests/distributions/test_multivariate.py::TestMatchesScipy::test_car_logp[True-(4,)]\ntests/distributions/test_multivariate.py::test_car_rng_fn[True]\n  /usr/local/lib/python3.10/dist-packages/pytensor/sparse/basic.py:270: UserWarning: Method dimshuffle is not implemented for sparse variables. The variable will be converted to dense.\n    warn(\n\ntests/distributions/test_multivariate.py::TestWishart::test_distribution\ntests/distributions/test_multivariate.py::TestWishart::test_distribution\ntests/distributions/test_multivariate.py::TestWishart::test_distribution\n  /app/repo_to_process/pymc/distributions/multivariate.py:966: DeprecationWarning: Conversion of an array with ndim > 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n    result = stats.wishart.rvs(int(nu), V, size=scipy_size, random_state=rng)\n\ntests/distributions/test_multivariate.py::test_mvnormal_no_cholesky_in_model_logp\ntests/model/transform/test_conditioning.py::test_change_value_transforms\n  /usr/local/lib/python3.10/dist-packages/pytensor/configparser.py:44: FutureWarning: hessian will stop negating the output in a future version of PyMC.\n  To suppress this warning set `negate_output=False`\n    return f(*args, **kwargs)\n\ntests/distributions/test_random_alternative_backends.py::test_dirichlet_multinomial[JAX]\n  /usr/local/lib/python3.10/dist-packages/pytensor/link/jax/linker.py:32: UserWarning: The RandomType SharedVariables [RNG(<Generator(PCG64) at 0x7F6478436500>)] will not be used in the compiled JAX graph. Instead a copy will be used.\n    warnings.warn(\n\ntests/distributions/test_random_alternative_backends.py::test_dirichlet_multinomial_dims[JAX]\n  /usr/local/lib/python3.10/dist-packages/pytensor/link/jax/linker.py:32: UserWarning: The RandomType SharedVariables [RNG(<Generator(PCG64) at 0x7F652052A880>)] will not be used in the compiled JAX graph. Instead a copy will be used.\n    warnings.warn(\n\ntests/distributions/test_random_alternative_backends.py::test_dirichlet_multinomial_dims[JAX]\n  /usr/local/lib/python3.10/dist-packages/pytensor/link/jax/linker.py:32: UserWarning: The RandomType SharedVariables [RNG(<Generator(PCG64) at 0x7F6631EB6CE0>)] will not be used in the compiled JAX graph. Instead a copy will be used.\n    warnings.warn(\n\ntests/distributions/test_random_alternative_backends.py::test_mvstudentt[JAX]\n  /usr/local/lib/python3.10/dist-packages/pytensor/link/jax/linker.py:32: UserWarning: The RandomType SharedVariables [RNG(<Generator(PCG64) at 0x7F64048334C0>)] will not be used in the compiled JAX graph. Instead a copy will be used.\n    warnings.warn(\n\ntests/distributions/test_random_alternative_backends.py::test_repeated_arguments[JAX]\n  /usr/local/lib/python3.10/dist-packages/pytensor/link/jax/linker.py:32: UserWarning: The RandomType SharedVariables [RNG(<Generator(PCG64) at 0x7F6404D10580>)] will not be used in the compiled JAX graph. Instead a copy will be used.\n    warnings.warn(\n\ntests/distributions/test_truncated.py::test_truncation_discrete_random[icdf--inf-5]\ntests/distributions/test_truncated.py::test_truncation_discrete_random[icdf--inf-5]\n  /usr/local/lib/python3.10/dist-packages/pytensor/scalar/math.py:1340: RuntimeWarning: invalid value encountered in log\n    return np.log(-np.expm1(x))\n\ntests/distributions/test_truncated.py::test_truncation_discrete_random[icdf--inf-5]\ntests/distributions/test_truncated.py::test_truncation_discrete_random[icdf--inf-5]\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/elemwise.py:710: RuntimeWarning: invalid value encountered in impl (vectorized)\n    variables = ufunc(*ufunc_args, **ufunc_kwargs)\n\ntests/distributions/test_truncated.py::test_vectorized_bounds\ntests/distributions/test_truncated.py::test_vectorized_bounds\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/elemwise.py:710: RuntimeWarning: invalid value encountered in add\n    variables = ufunc(*ufunc_args, **ufunc_kwargs)\n\ntests/gp/test_cov.py::TestCovAdd::test_leftprod_matrix\n  /app/repo_to_process/tests/gp/test_cov.py:89: DeprecationWarning: __array_wrap__ must accept context and return_scalar arguments (positionally) in the future. (Deprecated NumPy 2.0)\n    cov = M + pm.gp.cov.ExpQuad(1, 0.1)\n\ntests/gp/test_cov.py::TestCovProd::test_leftprod_matrix\n  /app/repo_to_process/tests/gp/test_cov.py:164: DeprecationWarning: __array_wrap__ must accept context and return_scalar arguments (positionally) in the future. (Deprecated NumPy 2.0)\n    cov = M * pm.gp.cov.ExpQuad(1, 0.1)\n\ntests/gp/test_cov.py::TestCovProd::test_multiops\n  /app/repo_to_process/tests/gp/test_cov.py:177: DeprecationWarning: __array_wrap__ must accept context and return_scalar arguments (positionally) in the future. (Deprecated NumPy 2.0)\n    + M * pm.gp.cov.ExpQuad(1, 0.1) * M * pm.gp.cov.ExpQuad(1, 0.1)\n\ntests/gp/test_cov.py::TestCoregion::test_fullB\n  /app/repo_to_process/pymc/gp/cov.py:188: UserWarning: Only 1 column(s) out of 2 are being used to compute the covariance function. If this is not intended, increase 'input_dim' parameter to the number of columns to use. Ignore otherwise.\n    warnings.warn(\n\ntests/gp/test_hsgp_approx.py::TestHSGP::test_parametrization_drop_first[True-cov_func0]\n  /app/repo_to_process/pymc/gp/hsgp_approx.py:297: DeprecationWarning: The drop_first argument will be deprecated in future versions. See https://github.com/pymc-devs/pymc/pull/6877\n    warnings.warn(\n\ntests/logprob/test_basic.py::test_persist_inputs\n  /app/repo_to_process/pymc/logprob/basic.py:542: UserWarning: Random variables detected in the logp graph: {y_vv2}.\n  This can happen when not all random variables have a corresponding value variable.\n    warnings.warn(\n\ntests/logprob/test_binary.py::test_potentially_measurable_operand\n  /app/repo_to_process/pymc/logprob/basic.py:542: UserWarning: Random variables detected in the logp graph: {normal_rv{\"(),()->()\"}.out}.\n  This can happen when not all random variables have a corresponding value variable.\n    warnings.warn(\n\ntests/logprob/test_checks.py::test_assert_logprob\n  /app/repo_to_process/pymc/logprob/basic.py:542: UserWarning: Random variables detected in the logp graph: {MeasurableGt.0, MeasurableCheckAndRaise{raises=AssertionError, msg='Test assert'}.0}.\n  This can happen when not all random variables have a corresponding value variable.\n    warnings.warn(\n\ntests/logprob/test_order.py::test_categorical[max]\ntests/logprob/test_order.py::test_categorical[min]\n  /app/repo_to_process/pymc/distributions/discrete.py:1142: UserWarning: `p` parameters sum to [4], instead of 1.0. They will be automatically rescaled. You can rescale them directly to get rid of this warning.\n    warnings.warn(\n\ntests/logprob/test_transform_value.py::test_default_value_transform_logprob[gamma-dist_params9-<lambda>-size9]\ntests/logprob/test_transforms.py::TestPowerRVTransform::test_reciprocal_rv_transform[1.0]\ntests/logprob/test_transforms.py::TestPowerRVTransform::test_reciprocal_rv_transform[2.0]\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/random/basic.py:477: FutureWarning: Gamma rate argument is deprecated and will stop working, use scale instead\n    warnings.warn(\n\ntests/model/test_core.py::test_empty_observed\n  /app/repo_to_process/pymc/model/core.py:1300: ImputationWarning: Data in a contains missing values and will be automatically imputed from the sampling distribution.\n    warnings.warn(impute_message, ImputationWarning)\n\ntests/model/test_core.py::TestModelCopy::test_copy_model[copy]\ntests/model/test_core.py::TestModelCopy::test_copy_model[copy]\ntests/model/test_core.py::TestModelCopy::test_copy_model[deepcopy]\ntests/model/test_core.py::TestModelCopy::test_copy_model[deepcopy]\n  /app/repo_to_process/pymc/sampling/forward.py:430: DeprecationWarning: The samples argument has been deprecated in favor of draws. Use draws=1 going forward.\n    warnings.warn(\n\ntests/model/transform/test_optimization.py::test_freeze_dim_after_do_intervention\n  /app/repo_to_process/pymc/model/transform/conditioning.py:210: UserWarning: Intervention expression references the variable that is being intervened: mu. Intervention will be given the name: do_mu\n    warnings.warn(\n\ntests/model/transform/test_optimization.py::test_freeze_dims_and_data_partially_observed_rv\n  /app/repo_to_process/pymc/model/core.py:1300: ImputationWarning: Data in y contains missing values and will be automatically imputed from the sampling distribution.\n    warnings.warn(impute_message, ImputationWarning)\n\ntests/sampling/test_jax.py: 16 warnings\n  /app/repo_to_process/pymc/sampling/jax.py:608: FutureWarning: postprocessing_vectorize={\"scan\", \"vmap\"} will be removed in a future release.\n    warnings.warn(\n\ntests/sampling/test_mcmc.py: 24 warnings\n  /app/repo_to_process/pymc/sampling/mcmc.py:757: UserWarning: A list or tuple of random_seed no longer specifies the specific random_seed of each chain. Use a single seed instead.\n    warnings.warn(\n\ntests/sampling/test_mcmc.py::test_step_args\n  /usr/local/lib/python3.10/dist-packages/arviz/stats/diagnostics.py:596: RuntimeWarning: invalid value encountered in scalar divide\n    (between_chain_variance / within_chain_variance + num_samples - 1) / (num_samples)\n\ntests/sampling/test_mcmc_external.py::test_sample_var_names[numpyro]\n  /usr/local/lib/python3.10/dist-packages/jax/_src/interpreters/mlir.py:1233: UserWarning: Some donated buffers were not usable: float64[1,100].\n  See an explanation at https://docs.jax.dev/en/latest/faq.html#buffer-donation.\n    warnings.warn(\"Some donated buffers were not usable:\"\n\ntests/sampling/test_population.py: 300 warnings\n  /app/repo_to_process/pymc/backends/ndarray.py:116: DeprecationWarning: Conversion of an array with ndim > 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n    data[key][draw_idx] = val\n\ntests/sampling/test_population.py::TestPopulationSamplers::test_demcmc_warning_on_small_populations\ntests/sampling/test_population.py::TestPopulationSamplers::test_demcmc_warning_on_small_populations\ntests/sampling/test_population.py::TestPopulationSamplers::test_demcmc_warning_on_small_populations\ntests/sampling/test_population.py::TestPopulationSamplers::test_demcmc_warning_on_small_populations\ntests/sampling/test_population.py::TestPopulationSamplers::test_demcmc_warning_on_small_populations\n  /usr/local/lib/python3.10/dist-packages/arviz/data/base.py:272: UserWarning: More chains (6) than draws (5). Passed array should have shape (chains, draws, *shape)\n    warnings.warn(\n\ntests/smc/test_smc.py::TestSMC::test_convergence_checks\n  /usr/local/lib/python3.10/dist-packages/arviz/data/base.py:272: UserWarning: More chains (6) than draws (1). Passed array should have shape (chains, draws, *shape)\n    warnings.warn(\n\ntests/stats/test_convergence.py::test_warn_treedepth_multiple_samplers\n  /usr/local/lib/python3.10/dist-packages/arviz/data/base.py:272: UserWarning: More chains (3) than draws (2). Passed array should have shape (chains, draws, *shape)\n    warnings.warn(\n\ntests/step_methods/hmc/test_quadpotential.py::test_full_adapt_not_invertible\n  /app/repo_to_process/pymc/step_methods/hmc/quadpotential.py:900: RuntimeWarning: invalid value encountered in divide\n    return np.divide(self.raw_cov, self.n_samples - 1, out=out)\n\ntests/test_func_utils.py: 27 warnings\n  /app/repo_to_process/tests/test_func_utils.py:39: FutureWarning: find_constrained_prior is deprecated and will be removed in a future version. Please use maxent function from PreliZ. https://preliz.readthedocs.io/en/latest/api_reference.html#preliz.unidimensional.maxent\n    opt_params = pm.find_constrained_prior(\n\ntests/test_func_utils.py::test_find_constrained_prior_error_too_large[Gamma-0.1-0.4-init_guess0-fixed_params0]\ntests/test_func_utils.py::test_find_constrained_prior_error_too_large[Exponential-0.1-1-init_guess1-fixed_params1]\ntests/test_func_utils.py::test_find_constrained_prior_error_too_large[Binomial-0-2-init_guess2-fixed_params2]\n  /app/repo_to_process/tests/test_func_utils.py:71: FutureWarning: find_constrained_prior is deprecated and will be removed in a future version. Please use maxent function from PreliZ. https://preliz.readthedocs.io/en/latest/api_reference.html#preliz.unidimensional.maxent\n    pm.find_constrained_prior(\n\ntests/test_func_utils.py::test_find_constrained_prior_error_too_large[Gamma-0.1-0.4-init_guess0-fixed_params0]\ntests/test_func_utils.py::test_find_constrained_prior_error_too_large[Gamma-0.1-0.4-init_guess0-fixed_params0]\ntests/test_func_utils.py::test_find_constrained_prior_error_too_large[Gamma-0.1-0.4-init_guess0-fixed_params0]\n  /usr/local/lib/python3.10/dist-packages/pytensor/tensor/elemwise.py:710: RuntimeWarning: invalid value encountered in sqrt\n    variables = ufunc(*ufunc_args, **ufunc_kwargs)\n\ntests/test_func_utils.py::test_find_constrained_prior_input_errors\n  /app/repo_to_process/tests/test_func_utils.py:84: FutureWarning: find_constrained_prior is deprecated and will be removed in a future version. Please use maxent function from PreliZ. https://preliz.readthedocs.io/en/latest/api_reference.html#preliz.unidimensional.maxent\n    pm.find_constrained_prior(\n\ntests/test_func_utils.py::test_find_constrained_prior_input_errors\n  /app/repo_to_process/tests/test_func_utils.py:94: FutureWarning: find_constrained_prior is deprecated and will be removed in a future version. Please use maxent function from PreliZ. https://preliz.readthedocs.io/en/latest/api_reference.html#preliz.unidimensional.maxent\n    pm.find_constrained_prior(\n\ntests/test_func_utils.py::test_find_constrained_prior_input_errors\n  /app/repo_to_process/tests/test_func_utils.py:105: FutureWarning: find_constrained_prior is deprecated and will be removed in a future version. Please use maxent function from PreliZ. https://preliz.readthedocs.io/en/latest/api_reference.html#preliz.unidimensional.maxent\n    pm.find_constrained_prior(\n\ntests/test_func_utils.py::test_find_constrained_prior_input_errors\n  /app/repo_to_process/tests/test_func_utils.py:116: FutureWarning: find_constrained_prior is deprecated and will be removed in a future version. Please use maxent function from PreliZ. https://preliz.readthedocs.io/en/latest/api_reference.html#preliz.unidimensional.maxent\n    pm.find_constrained_prior(\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n\u001b[36m\u001b[1m=========================== short test summary info ============================\u001b[0m\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_posterior_predictive_thinned\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_overwrite_model_coords_dims\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (4 su...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_missing_data_model\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_mv_missing_data_model\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_multiple_observed_rv[True]\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_multiple_observed_rv[False]\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_multiple_observed_rv[log_likelihood2]\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_single_observation\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_potential\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_constant_data[True]\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_constant_data[False]\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_predictions_constant_data\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (4 su...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_no_trace\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (4 su...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_multivariate_observations\u001b[0m - assert (2, 50, 1) == (2, 50, 20)\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_single_chain[2]\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestPyMCWarmupHandling::test_save_warmup[0-50-1-False]\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestPyMCWarmupHandling::test_save_warmup[0-50-1-True]\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestPyMCWarmupHandling::test_save_warmup[0-50-2-False]\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestPyMCWarmupHandling::test_save_warmup[0-50-2-True]\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestPyMCWarmupHandling::test_save_warmup[10-40-1-False]\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestPyMCWarmupHandling::test_save_warmup[10-40-1-True]\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestPyMCWarmupHandling::test_save_warmup[10-40-2-False]\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestPyMCWarmupHandling::test_save_warmup[10-40-2-True]\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestPyMCWarmupHandling::test_save_warmup[30-0-1-False]\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestPyMCWarmupHandling::test_save_warmup[30-0-1-True]\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestPyMCWarmupHandling::test_save_warmup[30-0-2-False]\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestPyMCWarmupHandling::test_save_warmup[30-0-2-True]\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestPyMCWarmupHandling::test_save_warmup_issue_1208_after_3_9\u001b[0m - UserWarning: PyTensor could not link to a BLAS installation. Operations tha...\n\u001b[31mFAILED\u001b[0m tests/dims/test_model.py::\u001b[1mtest_simple_model\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mFAILED\u001b[0m tests/dims/test_model.py::\u001b[1mtest_complex_model\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mFAILED\u001b[0m tests/distributions/test_mixture.py::\u001b[1mTestMixtureSameFamily::test_with_multinomial[(3, 4)]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_mixture.py::\u001b[1mTestMixtureSameFamily::test_with_multinomial[(20,)]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial[2]\u001b[0m - AssertionError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial[3]\u001b[0m - AssertionError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_invalid_value\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size0-p0-n1]\u001b[0m - AssertionError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size0-p0-n2]\u001b[0m - AssertionError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size0-p1-10]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size0-p1-n1]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size0-p1-n2]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size0-p2-10]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size0-p2-n1]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size0-p2-n2]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size1-p0-10]\u001b[0m - AssertionError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size1-p0-n1]\u001b[0m - AssertionError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size1-p0-n2]\u001b[0m - AssertionError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size1-p1-10]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size1-p1-n1]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size1-p1-n2]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size1-p2-10]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size1-p2-n1]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size1-p2-n2]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size2-p0-10]\u001b[0m - AssertionError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size2-p0-n1]\u001b[0m - AssertionError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size2-p0-n2]\u001b[0m - AssertionError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size2-p1-10]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size2-p1-n1]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size2-p1-n2]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size2-p2-10]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size2-p2-n1]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_vectorized[extra_size2-p2-n2]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMatchesScipy::test_multinomial_zero_probs\u001b[0m - assert array(nan) >= 0\n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMoments::test_multinomial_support_point[p3-10-None-expected3]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMoments::test_multinomial_support_point[p5-n5-None-expected5]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMoments::test_multinomial_support_point[p6-n6-size6-expected6]\u001b[0m - pymc.logprob.utils.ParameterValueError: \n\u001b[31mFAILED\u001b[0m tests/distributions/test_multivariate.py::\u001b[1mTestMoments::test_multinomial_support_point[p7-1-None-expected7]\u001b[0m - AssertionError\n\u001b[31mFAILED\u001b[0m tests/sampling/test_deterministic.py::\u001b[1mtest_docstring_example\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_transform_samples[scan-1-None-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_transform_samples[scan-1-cpu-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_transform_samples[scan-2-None-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_transform_samples[scan-2-cpu-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_transform_samples[vmap-1-None-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_transform_samples[vmap-1-cpu-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_transform_samples[vmap-2-None-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_transform_samples[vmap-2-cpu-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_deterministic_samples[sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_initvals_without_jitter[sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_idata_kwargs[None-idata_kwargs0-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_idata_kwargs[None-idata_kwargs1-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_idata_kwargs[None-idata_kwargs2-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_idata_kwargs[None-idata_kwargs3-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_idata_kwargs[None-idata_kwargs4-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_idata_kwargs[cpu-idata_kwargs0-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_idata_kwargs[cpu-idata_kwargs1-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_idata_kwargs[cpu-idata_kwargs2-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_idata_kwargs[cpu-idata_kwargs3-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_idata_kwargs[cpu-idata_kwargs4-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_seeding[1-None-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_seeding[1-123-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_seeding[2-None-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_seeding[2-123-sampler0]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_idata_contains_stats[sample_blackjax_nuts]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_jax.py::\u001b[1mtest_convergence_warnings[blackjax]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/sampling/test_mcmc_external.py::\u001b[1mtest_sample_var_names[nutpie]\u001b[0m - ImportError: nutpie not found. Install it with conda install -c conda-forge...\n\u001b[31mFAILED\u001b[0m tests/sampling/test_mcmc_external.py::\u001b[1mtest_sample_var_names[blackjax]\u001b[0m - ModuleNotFoundError: No module named 'blackjax'\n\u001b[31mFAILED\u001b[0m tests/test_model_graph.py::\u001b[1mTestRadonModel::test_graphviz\u001b[0m - ImportError: This function requires the python library graphviz, along with...\n\u001b[31mFAILED\u001b[0m tests/test_model_graph.py::\u001b[1mTestRadonModel::test_checks_formatting\u001b[0m - ImportError: This function requires the python library graphviz, along with...\n\u001b[31mFAILED\u001b[0m tests/test_model_graph.py::\u001b[1mTestImputationModel::test_graphviz\u001b[0m - ImportError: This function requires the python library graphviz, along with...\n\u001b[31mFAILED\u001b[0m tests/test_model_graph.py::\u001b[1mTestModelWithDims::test_graphviz\u001b[0m - ImportError: This function requires the python library graphviz, along with...\n\u001b[31mFAILED\u001b[0m tests/test_model_graph.py::\u001b[1mTestUnnamedObservedNodes::test_graphviz\u001b[0m - ImportError: This function requires the python library graphviz, along with...\n\u001b[31mFAILED\u001b[0m tests/test_model_graph.py::\u001b[1mTestObservationDtypeCasting::test_graphviz\u001b[0m - ImportError: This function requires the python library graphviz, along with...\n\u001b[31mFAILED\u001b[0m tests/test_model_graph.py::\u001b[1mTestModelNonRandomVariableRVs::test_graphviz\u001b[0m - ImportError: This function requires the python library graphviz, along with...\n\u001b[31mFAILED\u001b[0m tests/test_model_graph.py::\u001b[1mtest_unknown_node_type\u001b[0m - ImportError: This function requires the python library graphviz, along with...\n\u001b[31mFAILED\u001b[0m tests/test_model_graph.py::\u001b[1mtest_custom_node_formatting_networkx\u001b[0m - ImportError: This function requires the python library networkx, along with...\n\u001b[31mFAILED\u001b[0m tests/test_model_graph.py::\u001b[1mtest_custom_node_formatting_graphviz\u001b[0m - ImportError: This function requires the python library graphviz, along with...\n\u001b[31mERROR\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_to_idata\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31mERROR\u001b[0m tests/backends/test_arviz.py::\u001b[1mTestDataPyMC::test_multivariate_observations\u001b[0m - exceptiongroup.ExceptionGroup: multiple unraisable exception warnings (2 su...\n\u001b[31m= \u001b[31m\u001b[1m105 failed\u001b[0m, \u001b[32m3515 passed\u001b[0m, \u001b[33m93 skipped\u001b[0m, \u001b[33m17 xfailed\u001b[0m, \u001b[33m978 warnings\u001b[0m, \u001b[31m\u001b[1m2 errors\u001b[0m\u001b[31m in 3478.36s (0:57:58)\u001b[0m\u001b[31m =\u001b[0m\n",
    "stderr": "",
    "execution_time": 3494.853422164917
  }
]