{"task_id": "geopandas_15", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_column_order", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_column_order(tmpdir, file_format, naturalearth_lowres):\n    'The order of columns should be preserved in the output.'\n    (reader, writer) = file_format\n    df = read_file(naturalearth_lowres)\n    df = df.set_index('iso_a3')\n    df['geom2'] = df.geometry.representative_point()\n    table = _geopandas_to_arrow(df)\n    custom_column_order = ['iso_a3', 'geom2', 'pop_est', 'continent', 'name', 'geometry', 'gdp_md_est']\n    table = table.select(custom_column_order)\n    if (reader is read_parquet):\n        filename = os.path.join(str(tmpdir), 'test_column_order.pq')\n        pq.write_table(table, filename)\n    else:\n        filename = os.path.join(str(tmpdir), 'test_column_order.feather')\n        feather.write_feather(table, filename)\n    result = reader(filename)\n    assert (list(result.columns) == custom_column_order[1:])\n    assert_geodataframe_equal(result, df[custom_column_order[1:]])", "masked_code": "def test_column_order(tmpdir, file_format, naturalearth_lowres):\n    'The order of columns should be preserved in the output.'\n    (reader, writer) = file_format\n    df = read_file(naturalearth_lowres)\n    df = df.set_index('iso_a3')\n    df['geom2'] = df.geometry.representative_point()\n    table = _geopandas_to_arrow(df)\n    custom_column_order = ['iso_a3', 'geom2', 'pop_est', 'continent', 'name', 'geometry', 'gdp_md_est']\n    table = table.select(custom_column_order)\n    if (reader is read_parquet):\n        filename = os.path.join(str(tmpdir), 'test_column_order.pq')\n        pq.write_table(table, filename)\n    else:\n        filename = os.path.join(str(tmpdir), 'test_column_order.feather')\n        feather.write_feather(table, filename)\n    result = reader(filename)\n    assert (list(result.columns) == '???')\n    assert_geodataframe_equal(result, df[custom_column_order[1:]])", "ground_truth": "custom_column_order[1:]", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_0", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == '???')\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "METADATA_VERSION", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_1", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == '???')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "'geometry'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_2", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == '???')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "'WKB'", "quality_analysis": {"complexity_score": 14, "left_complexity": 13, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_3", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == '???')\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "['MultiPolygon', 'Polygon']", "quality_analysis": {"complexity_score": 17, "left_complexity": 13, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_4", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == '???')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "'geopandas'", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_5", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == '???')\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "geopandas.__version__", "quality_analysis": {"complexity_score": 11, "left_complexity": 9, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_6", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '???')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "'1.1.0'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_7", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == '???')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "'point'", "quality_analysis": {"complexity_score": 14, "left_complexity": 13, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_8", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == '???')", "ground_truth": "'WKB'", "quality_analysis": {"complexity_score": 14, "left_complexity": 13, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_9", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == '???')\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon'])\n    assert np.array_equal(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "crs_expected", "quality_analysis": {"complexity_score": 14, "left_complexity": 13, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_10", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata_with_z_geometries", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata_with_z_geometries():\n    geometry_types = ['Point', 'Point Z', 'LineString', 'LineString Z', 'Polygon', 'Polygon Z', 'MultiPolygon', 'MultiPolygon Z']\n    df = geopandas.GeoDataFrame({'geo_type': geometry_types, 'geometry': [Point(1, 2), Point(1, 2, 3), LineString([(0, 0), (1, 1), (2, 2)]), LineString([(0, 0, 1), (1, 1, 2), (2, 2, 3)]), Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]), Polygon([(0, 0, 0), (0, 1, 0.5), (1, 1, 1), (1, 0, 0.5)]), MultiPolygon([Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]), Polygon([(0.5, 0.5), (0.5, 1.5), (1.5, 1.5), (1.5, 0.5)])]), MultiPolygon([Polygon([(0, 0, 0), (0, 1, 0.5), (1, 1, 1), (1, 0, 0.5)]), Polygon([(0.5, 0.5, 1), (0.5, 1.5, 1.5), (1.5, 1.5, 2), (1.5, 0.5, 1.5)])])]})\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert (sorted(metadata['columns']['geometry']['geometry_types']) == sorted(geometry_types))\n    metadata = _create_metadata(df.iloc[1::2], geometry_encoding={'geometry': 'WKB'})\n    assert all((geom_type.endswith(' Z') for geom_type in metadata['columns']['geometry']['geometry_types']))\n    metadata = _create_metadata(df.iloc[5:7], geometry_encoding={'geometry': 'WKB'})\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon Z'])", "masked_code": "def test_create_metadata_with_z_geometries():\n    geometry_types = ['Point', 'Point Z', 'LineString', 'LineString Z', 'Polygon', 'Polygon Z', 'MultiPolygon', 'MultiPolygon Z']\n    df = geopandas.GeoDataFrame({'geo_type': geometry_types, 'geometry': [Point(1, 2), Point(1, 2, 3), LineString([(0, 0), (1, 1), (2, 2)]), LineString([(0, 0, 1), (1, 1, 2), (2, 2, 3)]), Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]), Polygon([(0, 0, 0), (0, 1, 0.5), (1, 1, 1), (1, 0, 0.5)]), MultiPolygon([Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]), Polygon([(0.5, 0.5), (0.5, 1.5), (1.5, 1.5), (1.5, 0.5)])]), MultiPolygon([Polygon([(0, 0, 0), (0, 1, 0.5), (1, 1, 1), (1, 0, 0.5)]), Polygon([(0.5, 0.5, 1), (0.5, 1.5, 1.5), (1.5, 1.5, 2), (1.5, 0.5, 1.5)])])]})\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert (sorted(metadata['columns']['geometry']['geometry_types']) == '???')\n    metadata = _create_metadata(df.iloc[1::2], geometry_encoding={'geometry': 'WKB'})\n    assert all((geom_type.endswith(' Z') for geom_type in metadata['columns']['geometry']['geometry_types']))\n    metadata = _create_metadata(df.iloc[5:7], geometry_encoding={'geometry': 'WKB'})\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon Z'])", "ground_truth": "sorted(geometry_types)", "quality_analysis": {"complexity_score": 20, "left_complexity": 16, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_11", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata_with_z_geometries", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata_with_z_geometries():\n    geometry_types = ['Point', 'Point Z', 'LineString', 'LineString Z', 'Polygon', 'Polygon Z', 'MultiPolygon', 'MultiPolygon Z']\n    df = geopandas.GeoDataFrame({'geo_type': geometry_types, 'geometry': [Point(1, 2), Point(1, 2, 3), LineString([(0, 0), (1, 1), (2, 2)]), LineString([(0, 0, 1), (1, 1, 2), (2, 2, 3)]), Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]), Polygon([(0, 0, 0), (0, 1, 0.5), (1, 1, 1), (1, 0, 0.5)]), MultiPolygon([Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]), Polygon([(0.5, 0.5), (0.5, 1.5), (1.5, 1.5), (1.5, 0.5)])]), MultiPolygon([Polygon([(0, 0, 0), (0, 1, 0.5), (1, 1, 1), (1, 0, 0.5)]), Polygon([(0.5, 0.5, 1), (0.5, 1.5, 1.5), (1.5, 1.5, 2), (1.5, 0.5, 1.5)])])]})\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert (sorted(metadata['columns']['geometry']['geometry_types']) == sorted(geometry_types))\n    metadata = _create_metadata(df.iloc[1::2], geometry_encoding={'geometry': 'WKB'})\n    assert all((geom_type.endswith(' Z') for geom_type in metadata['columns']['geometry']['geometry_types']))\n    metadata = _create_metadata(df.iloc[5:7], geometry_encoding={'geometry': 'WKB'})\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon', 'Polygon Z'])", "masked_code": "def test_create_metadata_with_z_geometries():\n    geometry_types = ['Point', 'Point Z', 'LineString', 'LineString Z', 'Polygon', 'Polygon Z', 'MultiPolygon', 'MultiPolygon Z']\n    df = geopandas.GeoDataFrame({'geo_type': geometry_types, 'geometry': [Point(1, 2), Point(1, 2, 3), LineString([(0, 0), (1, 1), (2, 2)]), LineString([(0, 0, 1), (1, 1, 2), (2, 2, 3)]), Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]), Polygon([(0, 0, 0), (0, 1, 0.5), (1, 1, 1), (1, 0, 0.5)]), MultiPolygon([Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]), Polygon([(0.5, 0.5), (0.5, 1.5), (1.5, 1.5), (1.5, 0.5)])]), MultiPolygon([Polygon([(0, 0, 0), (0, 1, 0.5), (1, 1, 1), (1, 0, 0.5)]), Polygon([(0.5, 0.5, 1), (0.5, 1.5, 1.5), (1.5, 1.5, 2), (1.5, 0.5, 1.5)])])]})\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert (sorted(metadata['columns']['geometry']['geometry_types']) == sorted(geometry_types))\n    metadata = _create_metadata(df.iloc[1::2], geometry_encoding={'geometry': 'WKB'})\n    assert all((geom_type.endswith(' Z') for geom_type in metadata['columns']['geometry']['geometry_types']))\n    metadata = _create_metadata(df.iloc[5:7], geometry_encoding={'geometry': 'WKB'})\n    assert (metadata['columns']['geometry']['geometry_types'] == '???')", "ground_truth": "['MultiPolygon', 'Polygon Z']", "quality_analysis": {"complexity_score": 17, "left_complexity": 13, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_12", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_crs_metadata_datum_ensemble", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_crs_metadata_datum_ensemble():\n    pyproj = pytest.importorskip('pyproj')\n    crs = pyproj.CRS('EPSG:4326')\n    crs_json = crs.to_json_dict()\n    check_ensemble = False\n    if ('datum_ensemble' in crs_json):\n        check_ensemble = True\n        assert ('id' in crs_json['datum_ensemble']['members'][0])\n    _remove_id_from_member_of_ensembles(crs_json)\n    if check_ensemble:\n        assert ('id' not in crs_json['datum_ensemble']['members'][0])\n    assert (pyproj.CRS(crs_json) == crs)", "masked_code": "def test_crs_metadata_datum_ensemble():\n    pyproj = pytest.importorskip('pyproj')\n    crs = pyproj.CRS('EPSG:4326')\n    crs_json = crs.to_json_dict()\n    check_ensemble = False\n    if ('datum_ensemble' in crs_json):\n        check_ensemble = True\n        assert ('id' in crs_json['datum_ensemble']['members'][0])\n    _remove_id_from_member_of_ensembles(crs_json)\n    if check_ensemble:\n        assert ('id' not in crs_json['datum_ensemble']['members'][0])\n    assert (pyproj.CRS(crs_json) == '???')", "ground_truth": "crs", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_14", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_decode_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_decode_metadata():\n    metadata_str = b'{\"a\": \"b\"}'\n    expected = {'a': 'b'}\n    assert (_decode_metadata(metadata_str) == expected)\n    assert (_decode_metadata(None) is None)", "masked_code": "def test_decode_metadata():\n    metadata_str = b'{\"a\": \"b\"}'\n    expected = {'a': 'b'}\n    assert (_decode_metadata(metadata_str) == '???')\n    assert (_decode_metadata(None) is None)", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_13", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_encode_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_encode_metadata():\n    metadata = {'a': 'b'}\n    expected = b'{\"a\": \"b\"}'\n    assert (_encode_metadata(metadata) == expected)", "masked_code": "def test_encode_metadata():\n    metadata = {'a': 'b'}\n    expected = b'{\"a\": \"b\"}'\n    assert (_encode_metadata(metadata) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_25", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_bbox", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('geometry_name', ['geometry', 'custum_geom_col'])\ndef test_read_parquet_bbox(tmpdir, naturalearth_lowres, geometry_name):\n    df = read_file(naturalearth_lowres)\n    if (geometry_name != 'geometry'):\n        df = df.rename_geometry(geometry_name)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    pq_df = read_parquet(filename, bbox=(0, 0, 10, 10))\n    assert (pq_df['name'].values.tolist() == ['France', 'Benin', 'Nigeria', 'Cameroon', 'Togo', 'Ghana', 'Burkina Faso', 'Gabon', 'Eq. Guinea'])", "masked_code": "@pytest.mark.parametrize('geometry_name', ['geometry', 'custum_geom_col'])\ndef test_read_parquet_bbox(tmpdir, naturalearth_lowres, geometry_name):\n    df = read_file(naturalearth_lowres)\n    if (geometry_name != 'geometry'):\n        df = df.rename_geometry(geometry_name)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    pq_df = read_parquet(filename, bbox=(0, 0, 10, 10))\n    assert (pq_df['name'].values.tolist() == '???')", "ground_truth": "['France', 'Benin', 'Nigeria', 'Cameroon', 'Togo', 'Ghana', 'Burkina Faso', 'Gabon', 'Eq. Guinea']", "quality_analysis": {"complexity_score": 14, "left_complexity": 3, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_27", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_bbox_column_default_behaviour", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_bbox_column_default_behaviour(tmpdir, naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    result1 = read_parquet(filename)\n    assert ('bbox' not in result1)\n    result2 = read_parquet(filename, columns=['name', 'geometry'])\n    assert ('bbox' not in result2)\n    assert (list(result2.columns) == ['name', 'geometry'])", "masked_code": "def test_read_parquet_bbox_column_default_behaviour(tmpdir, naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    result1 = read_parquet(filename)\n    assert ('bbox' not in result1)\n    result2 = read_parquet(filename, columns=['name', 'geometry'])\n    assert ('bbox' not in result2)\n    assert (list(result2.columns) == '???')", "ground_truth": "['name', 'geometry']", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_26", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_bbox_partitioned", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('geometry_name', ['geometry', 'custum_geom_col'])\ndef test_read_parquet_bbox_partitioned(tmpdir, naturalearth_lowres, geometry_name):\n    df = read_file(naturalearth_lowres)\n    if (geometry_name != 'geometry'):\n        df = df.rename_geometry(geometry_name)\n    basedir = (tmpdir / 'partitioned_dataset')\n    basedir.mkdir()\n    df[:100].to_parquet((basedir / 'data1.parquet'), write_covering_bbox=True)\n    df[100:].to_parquet((basedir / 'data2.parquet'), write_covering_bbox=True)\n    pq_df = read_parquet(basedir, bbox=(0, 0, 10, 10))\n    assert (pq_df['name'].values.tolist() == ['France', 'Benin', 'Nigeria', 'Cameroon', 'Togo', 'Ghana', 'Burkina Faso', 'Gabon', 'Eq. Guinea'])", "masked_code": "@pytest.mark.parametrize('geometry_name', ['geometry', 'custum_geom_col'])\ndef test_read_parquet_bbox_partitioned(tmpdir, naturalearth_lowres, geometry_name):\n    df = read_file(naturalearth_lowres)\n    if (geometry_name != 'geometry'):\n        df = df.rename_geometry(geometry_name)\n    basedir = (tmpdir / 'partitioned_dataset')\n    basedir.mkdir()\n    df[:100].to_parquet((basedir / 'data1.parquet'), write_covering_bbox=True)\n    df[100:].to_parquet((basedir / 'data2.parquet'), write_covering_bbox=True)\n    pq_df = read_parquet(basedir, bbox=(0, 0, 10, 10))\n    assert (pq_df['name'].values.tolist() == '???')", "ground_truth": "['France', 'Benin', 'Nigeria', 'Cameroon', 'Togo', 'Ghana', 'Burkina Faso', 'Gabon', 'Eq. Guinea']", "quality_analysis": {"complexity_score": 14, "left_complexity": 3, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_31", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_bbox_points", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_bbox_points(tmp_path):\n    df = geopandas.GeoDataFrame({'col': range(10)}, geometry=[Point(i, i) for i in range(10)])\n    df.to_parquet((tmp_path / 'test.parquet'), geometry_encoding='geoarrow')\n    result = geopandas.read_parquet((tmp_path / 'test.parquet'), bbox=(0, 0, 10, 10))\n    assert (len(result) == 10)\n    result = geopandas.read_parquet((tmp_path / 'test.parquet'), bbox=(3, 3, 5, 5))\n    assert (len(result) == 3)", "masked_code": "def test_read_parquet_bbox_points(tmp_path):\n    df = geopandas.GeoDataFrame({'col': range(10)}, geometry=[Point(i, i) for i in range(10)])\n    df.to_parquet((tmp_path / 'test.parquet'), geometry_encoding='geoarrow')\n    result = geopandas.read_parquet((tmp_path / 'test.parquet'), bbox=(0, 0, 10, 10))\n    assert (len(result) == '???')\n    result = geopandas.read_parquet((tmp_path / 'test.parquet'), bbox=(3, 3, 5, 5))\n    assert (len(result) == 3)", "ground_truth": "10", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_32", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_bbox_points", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_bbox_points(tmp_path):\n    df = geopandas.GeoDataFrame({'col': range(10)}, geometry=[Point(i, i) for i in range(10)])\n    df.to_parquet((tmp_path / 'test.parquet'), geometry_encoding='geoarrow')\n    result = geopandas.read_parquet((tmp_path / 'test.parquet'), bbox=(0, 0, 10, 10))\n    assert (len(result) == 10)\n    result = geopandas.read_parquet((tmp_path / 'test.parquet'), bbox=(3, 3, 5, 5))\n    assert (len(result) == 3)", "masked_code": "def test_read_parquet_bbox_points(tmp_path):\n    df = geopandas.GeoDataFrame({'col': range(10)}, geometry=[Point(i, i) for i in range(10)])\n    df.to_parquet((tmp_path / 'test.parquet'), geometry_encoding='geoarrow')\n    result = geopandas.read_parquet((tmp_path / 'test.parquet'), bbox=(0, 0, 10, 10))\n    assert (len(result) == 10)\n    result = geopandas.read_parquet((tmp_path / 'test.parquet'), bbox=(3, 3, 5, 5))\n    assert (len(result) == '???')", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_24", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_bbox_single_point", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_bbox_single_point(tmpdir):\n    df = GeoDataFrame(data=[[1, 2]], columns=['a', 'b'], geometry=[Point(1, 1)])\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    pq_df = read_parquet(filename, bbox=(1, 1, 1, 1))\n    assert (len(pq_df) == 1)\n    assert (pq_df.geometry[0] == Point(1, 1))", "masked_code": "def test_read_parquet_bbox_single_point(tmpdir):\n    df = GeoDataFrame(data=[[1, 2]], columns=['a', 'b'], geometry=[Point(1, 1)])\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    pq_df = read_parquet(filename, bbox=(1, 1, 1, 1))\n    assert (len(pq_df) == 1)\n    assert (pq_df.geometry[0] == '???')", "ground_truth": "Point(1, 1)", "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_30", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_file_with_custom_bbox_encoding_fieldname", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_file_with_custom_bbox_encoding_fieldname(tmpdir):\n    import pyarrow.parquet as pq\n    data = {'name': ['point1', 'point2', 'point3'], 'geometry': [Point(1, 1), Point(2, 2), Point(3, 3)]}\n    df = GeoDataFrame(data)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    table = _geopandas_to_arrow(df, schema_version='1.1.0', write_covering_bbox=True)\n    metadata = table.schema.metadata\n    table = table.rename_columns(['name', 'geometry', 'custom_bbox_name'])\n    geo_metadata = json.loads(metadata[b'geo'])\n    geo_metadata['columns']['geometry']['covering']['bbox'] = {'xmin': ['custom_bbox_name', 'xmin'], 'ymin': ['custom_bbox_name', 'ymin'], 'xmax': ['custom_bbox_name', 'xmax'], 'ymax': ['custom_bbox_name', 'ymax']}\n    metadata.update({b'geo': _encode_metadata(geo_metadata)})\n    table = table.replace_schema_metadata(metadata)\n    pq.write_table(table, filename)\n    pq_table = pq.read_table(filename)\n    assert ('custom_bbox_name' in pq_table.schema.names)\n    pq_df = read_parquet(filename, bbox=(1.5, 1.5, 2.5, 2.5))\n    assert (pq_df['name'].values.tolist() == ['point2'])", "masked_code": "def test_read_parquet_file_with_custom_bbox_encoding_fieldname(tmpdir):\n    import pyarrow.parquet as pq\n    data = {'name': ['point1', 'point2', 'point3'], 'geometry': [Point(1, 1), Point(2, 2), Point(3, 3)]}\n    df = GeoDataFrame(data)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    table = _geopandas_to_arrow(df, schema_version='1.1.0', write_covering_bbox=True)\n    metadata = table.schema.metadata\n    table = table.rename_columns(['name', 'geometry', 'custom_bbox_name'])\n    geo_metadata = json.loads(metadata[b'geo'])\n    geo_metadata['columns']['geometry']['covering']['bbox'] = {'xmin': ['custom_bbox_name', 'xmin'], 'ymin': ['custom_bbox_name', 'ymin'], 'xmax': ['custom_bbox_name', 'xmax'], 'ymax': ['custom_bbox_name', 'ymax']}\n    metadata.update({b'geo': _encode_metadata(geo_metadata)})\n    table = table.replace_schema_metadata(metadata)\n    pq.write_table(table, filename)\n    pq_table = pq.read_table(filename)\n    assert ('custom_bbox_name' in pq_table.schema.names)\n    pq_df = read_parquet(filename, bbox=(1.5, 1.5, 2.5, 2.5))\n    assert (pq_df['name'].values.tolist() == '???')", "ground_truth": "['point2']", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_28", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_filters_and_bbox", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('filters', [[('gdp_md_est', '>', 20000)], (pc.field('gdp_md_est') > 20000)])\ndef test_read_parquet_filters_and_bbox(tmpdir, naturalearth_lowres, filters):\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    result = read_parquet(filename, filters=filters, bbox=(0, 0, 20, 20))\n    assert (result['name'].values.tolist() == ['Dem. Rep. Congo', 'France', 'Nigeria', 'Cameroon', 'Ghana', 'Algeria', 'Libya'])", "masked_code": "@pytest.mark.parametrize('filters', [[('gdp_md_est', '>', 20000)], (pc.field('gdp_md_est') > 20000)])\ndef test_read_parquet_filters_and_bbox(tmpdir, naturalearth_lowres, filters):\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    result = read_parquet(filename, filters=filters, bbox=(0, 0, 20, 20))\n    assert (result['name'].values.tolist() == '???')", "ground_truth": "['Dem. Rep. Congo', 'France', 'Nigeria', 'Cameroon', 'Ghana', 'Algeria', 'Libya']", "quality_analysis": {"complexity_score": 12, "left_complexity": 3, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_29", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_filters_without_bbox", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('filters', [[('gdp_md_est', '>', 15000), ('gdp_md_est', '<', 16000)], ((pc.field('gdp_md_est') > 15000) & (pc.field('gdp_md_est') < 16000))])\ndef test_read_parquet_filters_without_bbox(tmpdir, naturalearth_lowres, filters):\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    result = read_parquet(filename, filters=filters)\n    assert (result['name'].values.tolist() == ['Burkina Faso', 'Mozambique', 'Albania'])", "masked_code": "@pytest.mark.parametrize('filters', [[('gdp_md_est', '>', 15000), ('gdp_md_est', '<', 16000)], ((pc.field('gdp_md_est') > 15000) & (pc.field('gdp_md_est') < 16000))])\ndef test_read_parquet_filters_without_bbox(tmpdir, naturalearth_lowres, filters):\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    result = read_parquet(filename, filters=filters)\n    assert (result['name'].values.tolist() == '???')", "ground_truth": "['Burkina Faso', 'Mozambique', 'Albania']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_21", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_to_parquet_bbox_structure_and_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_to_parquet_bbox_structure_and_metadata(tmpdir, naturalearth_lowres):\n    from pyarrow import parquet\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    table = parquet.read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'].decode('utf-8'))\n    assert (metadata['columns']['geometry']['covering'] == {'bbox': {'xmin': ['bbox', 'xmin'], 'ymin': ['bbox', 'ymin'], 'xmax': ['bbox', 'xmax'], 'ymax': ['bbox', 'ymax']}})\n    assert ('bbox' in table.schema.names)\n    assert ([field.name for field in table.schema.field('bbox').type] == ['xmin', 'ymin', 'xmax', 'ymax'])", "masked_code": "def test_to_parquet_bbox_structure_and_metadata(tmpdir, naturalearth_lowres):\n    from pyarrow import parquet\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    table = parquet.read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'].decode('utf-8'))\n    assert (metadata['columns']['geometry']['covering'] == '???')\n    assert ('bbox' in table.schema.names)\n    assert ([field.name for field in table.schema.field('bbox').type] == ['xmin', 'ymin', 'xmax', 'ymax'])", "ground_truth": "{'bbox': {'xmin': ['bbox', 'xmin'], 'ymin': ['bbox', 'ymin'], 'xmax': ['bbox', 'xmax'], 'ymax': ['bbox', 'ymax']}}", "quality_analysis": {"complexity_score": 40, "left_complexity": 13, "right_complexity": 27, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_22", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_to_parquet_bbox_structure_and_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_to_parquet_bbox_structure_and_metadata(tmpdir, naturalearth_lowres):\n    from pyarrow import parquet\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    table = parquet.read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'].decode('utf-8'))\n    assert (metadata['columns']['geometry']['covering'] == {'bbox': {'xmin': ['bbox', 'xmin'], 'ymin': ['bbox', 'ymin'], 'xmax': ['bbox', 'xmax'], 'ymax': ['bbox', 'ymax']}})\n    assert ('bbox' in table.schema.names)\n    assert ([field.name for field in table.schema.field('bbox').type] == ['xmin', 'ymin', 'xmax', 'ymax'])", "masked_code": "def test_to_parquet_bbox_structure_and_metadata(tmpdir, naturalearth_lowres):\n    from pyarrow import parquet\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    table = parquet.read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'].decode('utf-8'))\n    assert (metadata['columns']['geometry']['covering'] == {'bbox': {'xmin': ['bbox', 'xmin'], 'ymin': ['bbox', 'ymin'], 'xmax': ['bbox', 'xmax'], 'ymax': ['bbox', 'ymax']}})\n    assert ('bbox' in table.schema.names)\n    assert ([field.name for field in table.schema.field('bbox').type] == '???')", "ground_truth": "['xmin', 'ymin', 'xmax', 'ymax']", "quality_analysis": {"complexity_score": 6, "left_complexity": 0, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_23", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_to_parquet_bbox_values", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('geometry, expected_bbox', [(Point(1, 3), {'xmin': 1.0, 'ymin': 3.0, 'xmax': 1.0, 'ymax': 3.0}), (LineString([(1, 1), (3, 3)]), {'xmin': 1.0, 'ymin': 1.0, 'xmax': 3.0, 'ymax': 3.0}), (Polygon([(2, 1), (1, 2), (2, 3), (3, 2)]), {'xmin': 1.0, 'ymin': 1.0, 'xmax': 3.0, 'ymax': 3.0}), (MultiPolygon([box(0, 0, 1, 1), box(2, 2, 3, 3), box(4, 4, 5, 5)]), {'xmin': 0.0, 'ymin': 0.0, 'xmax': 5.0, 'ymax': 5.0})], ids=['Point', 'LineString', 'Polygon', 'Multipolygon'])\ndef test_to_parquet_bbox_values(tmpdir, geometry, expected_bbox):\n    import pyarrow.parquet as pq\n    df = GeoDataFrame(data=[[1, 2]], columns=['a', 'b'], geometry=[geometry])\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    result = pq.read_table(filename).to_pandas()\n    assert (result['bbox'][0] == expected_bbox)", "masked_code": "@pytest.mark.parametrize('geometry, expected_bbox', [(Point(1, 3), {'xmin': 1.0, 'ymin': 3.0, 'xmax': 1.0, 'ymax': 3.0}), (LineString([(1, 1), (3, 3)]), {'xmin': 1.0, 'ymin': 1.0, 'xmax': 3.0, 'ymax': 3.0}), (Polygon([(2, 1), (1, 2), (2, 3), (3, 2)]), {'xmin': 1.0, 'ymin': 1.0, 'xmax': 3.0, 'ymax': 3.0}), (MultiPolygon([box(0, 0, 1, 1), box(2, 2, 3, 3), box(4, 4, 5, 5)]), {'xmin': 0.0, 'ymin': 0.0, 'xmax': 5.0, 'ymax': 5.0})], ids=['Point', 'LineString', 'Polygon', 'Multipolygon'])\ndef test_to_parquet_bbox_values(tmpdir, geometry, expected_bbox):\n    import pyarrow.parquet as pq\n    df = GeoDataFrame(data=[[1, 2]], columns=['a', 'b'], geometry=[geometry])\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    result = pq.read_table(filename).to_pandas()\n    assert (result['bbox'][0] == '???')", "ground_truth": "expected_bbox", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_16", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_write_spec_version", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[box(0, 0, 10, 10)], crs='EPSG:4326')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_types'] == ['Polygon'])", "masked_code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[box(0, 0, 10, 10)], crs='EPSG:4326')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == '???')\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_types'] == ['Polygon'])", "ground_truth": "schema_version", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_17", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_write_spec_version", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[box(0, 0, 10, 10)], crs='EPSG:4326')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_types'] == ['Polygon'])", "masked_code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[box(0, 0, 10, 10)], crs='EPSG:4326')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == '???')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_types'] == ['Polygon'])", "ground_truth": "'Polygon'", "quality_analysis": {"complexity_score": 14, "left_complexity": 13, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_18", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_write_spec_version", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[box(0, 0, 10, 10)], crs='EPSG:4326')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_types'] == ['Polygon'])", "masked_code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[box(0, 0, 10, 10)], crs='EPSG:4326')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_types'] == '???')", "ground_truth": "['Polygon']", "quality_analysis": {"complexity_score": 16, "left_complexity": 13, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_19", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_write_spec_version", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[box(0, 0, 10, 10)], crs='EPSG:4326')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_types'] == ['Polygon'])", "masked_code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[box(0, 0, 10, 10)], crs='EPSG:4326')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == '???')\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_types'] == ['Polygon'])", "ground_truth": "gdf.crs.to_wkt()", "quality_analysis": {"complexity_score": 16, "left_complexity": 13, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_634", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_clip.py", "testname": "test_clip.py", "funcname": "test_clip_multiline", "imports": ["import numpy as np", "import pandas as pd", "import shapely", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiPoint, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries, clip", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_30", "from geopandas.array import POLYGON_GEOM_TYPES", "from geopandas.tools.clip import _mask_is_list_like_rectangle", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from pandas.testing import assert_index_equal"], "code": "def test_clip_multiline(self, multi_line, mask):\n    'Test that clipping a multiline feature with a poly returns expected\\n        output.'\n    clipped = clip(multi_line, mask)\n    assert (clipped.geom_type[0] == 'MultiLineString')", "masked_code": "def test_clip_multiline(self, multi_line, mask):\n    'Test that clipping a multiline feature with a poly returns expected\\n        output.'\n    clipped = clip(multi_line, mask)\n    assert (clipped.geom_type[0] == '???')", "ground_truth": "'MultiLineString'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestClipWithSingleRectangleGdf"}
{"task_id": "geopandas_635", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_clip.py", "testname": "test_clip.py", "funcname": "test_clip_multipoint", "imports": ["import numpy as np", "import pandas as pd", "import shapely", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiPoint, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries, clip", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_30", "from geopandas.array import POLYGON_GEOM_TYPES", "from geopandas.tools.clip import _mask_is_list_like_rectangle", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from pandas.testing import assert_index_equal"], "code": "def test_clip_multipoint(self, multi_point, mask):\n    'Clipping a multipoint feature with a polygon works as expected.\\n        should return a geodataframe with a single multi point feature'\n    clipped = clip(multi_point, mask)\n    assert (clipped.geom_type[0] == 'MultiPoint')\n    assert hasattr(clipped, 'attr')\n    assert (len(clipped) == 2)\n    clipped_mutltipoint = MultiPoint([Point(2, 2), Point(3, 4), Point(9, 8)])\n    assert (clipped.iloc[0].geometry.wkt == clipped_mutltipoint.wkt)\n    shape_for_points = (box(*mask) if _mask_is_list_like_rectangle(mask) else mask.union_all())\n    assert all(clipped.intersects(shape_for_points))", "masked_code": "def test_clip_multipoint(self, multi_point, mask):\n    'Clipping a multipoint feature with a polygon works as expected.\\n        should return a geodataframe with a single multi point feature'\n    clipped = clip(multi_point, mask)\n    assert (clipped.geom_type[0] == '???')\n    assert hasattr(clipped, 'attr')\n    assert (len(clipped) == 2)\n    clipped_mutltipoint = MultiPoint([Point(2, 2), Point(3, 4), Point(9, 8)])\n    assert (clipped.iloc[0].geometry.wkt == clipped_mutltipoint.wkt)\n    shape_for_points = (box(*mask) if _mask_is_list_like_rectangle(mask) else mask.union_all())\n    assert all(clipped.intersects(shape_for_points))", "ground_truth": "'MultiPoint'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestClipWithSingleRectangleGdf"}
{"task_id": "geopandas_631", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_clip.py", "testname": "test_clip.py", "funcname": "test_clip_poly", "imports": ["import numpy as np", "import pandas as pd", "import shapely", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiPoint, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries, clip", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_30", "from geopandas.array import POLYGON_GEOM_TYPES", "from geopandas.tools.clip import _mask_is_list_like_rectangle", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from pandas.testing import assert_index_equal"], "code": "def test_clip_poly(self, buffered_locations, mask):\n    'Test clipping a polygon GDF with a generic polygon geometry.'\n    clipped_poly = clip(buffered_locations, mask)\n    assert (len(clipped_poly.geometry) == 3)\n    assert all((clipped_poly.geom_type == 'Polygon'))", "masked_code": "def test_clip_poly(self, buffered_locations, mask):\n    'Test clipping a polygon GDF with a generic polygon geometry.'\n    clipped_poly = clip(buffered_locations, mask)\n    assert (len(clipped_poly.geometry) == '???')\n    assert all((clipped_poly.geom_type == 'Polygon'))", "ground_truth": "3", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestClipWithSingleRectangleGdf"}
{"task_id": "geopandas_632", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_clip.py", "testname": "test_clip.py", "funcname": "test_clip_poly_geom_col_rename", "imports": ["import numpy as np", "import pandas as pd", "import shapely", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiPoint, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries, clip", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_30", "from geopandas.array import POLYGON_GEOM_TYPES", "from geopandas.tools.clip import _mask_is_list_like_rectangle", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from pandas.testing import assert_index_equal"], "code": "def test_clip_poly_geom_col_rename(self, buffered_locations, mask):\n    'Test clipping a polygon GDF with a generic polygon geometry.'\n    poly_gdf_geom_col_rename = buffered_locations.rename_geometry('geometry2')\n    clipped_poly = clip(poly_gdf_geom_col_rename, mask)\n    assert (len(clipped_poly.geometry) == 3)\n    assert ('geometry' not in clipped_poly.keys())\n    assert ('geometry2' in clipped_poly.keys())", "masked_code": "def test_clip_poly_geom_col_rename(self, buffered_locations, mask):\n    'Test clipping a polygon GDF with a generic polygon geometry.'\n    poly_gdf_geom_col_rename = buffered_locations.rename_geometry('geometry2')\n    clipped_poly = clip(poly_gdf_geom_col_rename, mask)\n    assert (len(clipped_poly.geometry) == '???')\n    assert ('geometry' not in clipped_poly.keys())\n    assert ('geometry2' in clipped_poly.keys())", "ground_truth": "3", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestClipWithSingleRectangleGdf"}
{"task_id": "geopandas_633", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_clip.py", "testname": "test_clip.py", "funcname": "test_clip_poly_series", "imports": ["import numpy as np", "import pandas as pd", "import shapely", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiPoint, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries, clip", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_30", "from geopandas.array import POLYGON_GEOM_TYPES", "from geopandas.tools.clip import _mask_is_list_like_rectangle", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from pandas.testing import assert_index_equal"], "code": "def test_clip_poly_series(self, buffered_locations, mask):\n    'Test clipping a polygon GDF with a generic polygon geometry.'\n    clipped_poly = clip(buffered_locations.geometry, mask)\n    assert (len(clipped_poly) == 3)\n    assert all((clipped_poly.geom_type == 'Polygon'))", "masked_code": "def test_clip_poly_series(self, buffered_locations, mask):\n    'Test clipping a polygon GDF with a generic polygon geometry.'\n    clipped_poly = clip(buffered_locations.geometry, mask)\n    assert (len(clipped_poly) == '???')\n    assert all((clipped_poly.geom_type == 'Polygon'))", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestClipWithSingleRectangleGdf"}
{"task_id": "geopandas_630", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_clip.py", "testname": "test_clip.py", "funcname": "test_clip_single_multipoly_no_extra_geoms", "imports": ["import numpy as np", "import pandas as pd", "import shapely", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiPoint, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries, clip", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_30", "from geopandas.array import POLYGON_GEOM_TYPES", "from geopandas.tools.clip import _mask_is_list_like_rectangle", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from pandas.testing import assert_index_equal"], "code": "@pytest.mark.parametrize('mask_fixture_name', mask_variants_large_rectangle)\ndef test_clip_single_multipoly_no_extra_geoms(buffered_locations, mask_fixture_name, request):\n    'When clipping a multi-polygon feature, no additional geom types\\n    should be returned.'\n    masks = request.getfixturevalue(mask_fixture_name)\n    multi = buffered_locations.dissolve(by='type').reset_index()\n    clipped = clip(multi, masks)\n    assert (clipped.geom_type[0] == 'Polygon')", "masked_code": "@pytest.mark.parametrize('mask_fixture_name', mask_variants_large_rectangle)\ndef test_clip_single_multipoly_no_extra_geoms(buffered_locations, mask_fixture_name, request):\n    'When clipping a multi-polygon feature, no additional geom types\\n    should be returned.'\n    masks = request.getfixturevalue(mask_fixture_name)\n    multi = buffered_locations.dissolve(by='type').reset_index()\n    clipped = clip(multi, masks)\n    assert (clipped.geom_type[0] == '???')", "ground_truth": "'Polygon'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_159", "reponame": "geopandas", "testpath": "geopandas/tests/test_config.py", "testname": "test_config.py", "funcname": "test_options", "imports": ["import geopandas", "import pytest"], "code": "def test_options():\n    assert ('display_precision: ' in repr(geopandas.options))\n    assert (set(dir(geopandas.options)) == {'display_precision', 'use_pygeos', 'io_engine'})\n    with pytest.raises(AttributeError):\n        geopandas.options.non_existing_option\n    with pytest.raises(AttributeError):\n        geopandas.options.non_existing_option = 10", "masked_code": "def test_options():\n    assert ('display_precision: ' in repr(geopandas.options))\n    assert (set(dir(geopandas.options)) == '???')\n    with pytest.raises(AttributeError):\n        geopandas.options.non_existing_option\n    with pytest.raises(AttributeError):\n        geopandas.options.non_existing_option = 10", "ground_truth": "{'display_precision', 'use_pygeos', 'io_engine'}", "quality_analysis": {"complexity_score": 8, "left_complexity": 8, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_160", "reponame": "geopandas", "testpath": "geopandas/tests/test_config.py", "testname": "test_config.py", "funcname": "test_options_display_precision", "imports": ["import geopandas", "import pytest"], "code": "def test_options_display_precision():\n    assert (geopandas.options.display_precision is None)\n    geopandas.options.display_precision = 5\n    assert (geopandas.options.display_precision == 5)\n    with pytest.raises(ValueError):\n        geopandas.options.display_precision = 'abc'\n    with pytest.raises(ValueError):\n        geopandas.options.display_precision = (- 1)\n    geopandas.options.display_precision = None", "masked_code": "def test_options_display_precision():\n    assert (geopandas.options.display_precision is None)\n    geopandas.options.display_precision = 5\n    assert (geopandas.options.display_precision == '???')\n    with pytest.raises(ValueError):\n        geopandas.options.display_precision = 'abc'\n    with pytest.raises(ValueError):\n        geopandas.options.display_precision = (- 1)\n    geopandas.options.display_precision = None", "ground_truth": "5", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_161", "reponame": "geopandas", "testpath": "geopandas/tests/test_config.py", "testname": "test_config.py", "funcname": "test_options_io_engine", "imports": ["import geopandas", "import pytest"], "code": "def test_options_io_engine():\n    assert (geopandas.options.io_engine is None)\n    geopandas.options.io_engine = 'pyogrio'\n    assert (geopandas.options.io_engine == 'pyogrio')\n    with pytest.raises(ValueError):\n        geopandas.options.io_engine = 'abc'\n    with pytest.raises(ValueError):\n        geopandas.options.io_engine = (- 1)\n    geopandas.options.io_engine = None", "masked_code": "def test_options_io_engine():\n    assert (geopandas.options.io_engine is None)\n    geopandas.options.io_engine = 'pyogrio'\n    assert (geopandas.options.io_engine == '???')\n    with pytest.raises(ValueError):\n        geopandas.options.io_engine = 'abc'\n    with pytest.raises(ValueError):\n        geopandas.options.io_engine = (- 1)\n    geopandas.options.io_engine = None", "ground_truth": "'pyogrio'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_326", "reponame": "geopandas", "testpath": "geopandas/tests/test_decorator.py", "testname": "test_decorator.py", "funcname": "test_doc_template_from_func", "imports": ["from textwrap import dedent", "from geopandas._decorator import doc"], "code": "def test_doc_template_from_func():\n    docstr = dedent('\\n        This is the cummax method.\\n\\n        It computes the cumulative maximum.\\n        ')\n    assert (cummax.__doc__ == docstr)", "masked_code": "def test_doc_template_from_func():\n    docstr = dedent('\\n        This is the cummax method.\\n\\n        It computes the cumulative maximum.\\n        ')\n    assert (cummax.__doc__ == '???')", "ground_truth": "docstr", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_325", "reponame": "geopandas", "testpath": "geopandas/tests/test_decorator.py", "testname": "test_decorator.py", "funcname": "test_docstring_appending", "imports": ["from textwrap import dedent", "from geopandas._decorator import doc"], "code": "def test_docstring_appending():\n    docstr = dedent('\\n        This is the cumavg method.\\n\\n        It computes the cumulative average.\\n\\n        Examples\\n        --------\\n\\n        >>> cumavg([1, 2, 3])\\n        2\\n        ')\n    assert (cumavg.__doc__ == docstr)", "masked_code": "def test_docstring_appending():\n    docstr = dedent('\\n        This is the cumavg method.\\n\\n        It computes the cumulative average.\\n\\n        Examples\\n        --------\\n\\n        >>> cumavg([1, 2, 3])\\n        2\\n        ')\n    assert (cumavg.__doc__ == '???')", "ground_truth": "docstr", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_324", "reponame": "geopandas", "testpath": "geopandas/tests/test_decorator.py", "testname": "test_decorator.py", "funcname": "test_docstring_formatting", "imports": ["from textwrap import dedent", "from geopandas._decorator import doc"], "code": "def test_docstring_formatting():\n    docstr = dedent('\\n        This is the cumsum method.\\n\\n        It computes the cumulative sum.\\n        ')\n    assert (cumsum.__doc__ == docstr)", "masked_code": "def test_docstring_formatting():\n    docstr = dedent('\\n        This is the cumsum method.\\n\\n        It computes the cumulative sum.\\n        ')\n    assert (cumsum.__doc__ == '???')", "ground_truth": "docstr", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_327", "reponame": "geopandas", "testpath": "geopandas/tests/test_decorator.py", "testname": "test_decorator.py", "funcname": "test_inherit_doc_template", "imports": ["from textwrap import dedent", "from geopandas._decorator import doc"], "code": "def test_inherit_doc_template():\n    docstr = dedent('\\n        This is the cummin method.\\n\\n        It computes the cumulative minimum.\\n        ')\n    assert (cummin.__doc__ == docstr)", "masked_code": "def test_inherit_doc_template():\n    docstr = dedent('\\n        This is the cummin method.\\n\\n        It computes the cumulative minimum.\\n        ')\n    assert (cummin.__doc__ == '???')", "ground_truth": "docstr", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_377", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_forward", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_forward(locations, points):\n    from geopy.geocoders import Photon\n    for provider in ['photon', Photon]:\n        with mock.patch('geopy.geocoders.Photon.geocode', ForwardMock()) as m:\n            g = geocode(locations, provider=provider, timeout=2)\n            assert (len(locations) == m.call_count)\n        n = len(locations)\n        assert isinstance(g, GeoDataFrame)\n        expected = GeoSeries([Point((float(x) + 0.5), float(x)) for x in range(n)], crs='EPSG:4326')\n        assert_geoseries_equal(expected, g['geometry'])\n        assert_series_equal(g['address'], pd.Series(locations, name='address'))", "masked_code": "def test_forward(locations, points):\n    from geopy.geocoders import Photon\n    for provider in ['photon', Photon]:\n        with mock.patch('geopy.geocoders.Photon.geocode', ForwardMock()) as m:\n            g = geocode(locations, provider=provider, timeout=2)\n            assert (len(locations) == '???')\n        n = len(locations)\n        assert isinstance(g, GeoDataFrame)\n        expected = GeoSeries([Point((float(x) + 0.5), float(x)) for x in range(n)], crs='EPSG:4326')\n        assert_geoseries_equal(expected, g['geometry'])\n        assert_series_equal(g['address'], pd.Series(locations, name='address'))", "ground_truth": "m.call_count", "quality_analysis": {"complexity_score": 6, "left_complexity": 4, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_371", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_prepare_result", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_prepare_result():\n    p0 = Point(12.3, (- 45.6))\n    p1 = Point((- 23.4), 56.7)\n    d = {'a': ('address0', p0.coords[0]), 'b': ('address1', p1.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    coords = df.loc['a']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    coords = df.loc['b']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))", "masked_code": "def test_prepare_result():\n    p0 = Point(12.3, (- 45.6))\n    p1 = Point((- 23.4), 56.7)\n    d = {'a': ('address0', p0.coords[0]), 'b': ('address1', p1.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    coords = df.loc['a']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == '???')\n    assert (coords[1] == pytest.approx(test[0]))\n    coords = df.loc['b']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))", "ground_truth": "pytest.approx(test[1])", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_372", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_prepare_result", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_prepare_result():\n    p0 = Point(12.3, (- 45.6))\n    p1 = Point((- 23.4), 56.7)\n    d = {'a': ('address0', p0.coords[0]), 'b': ('address1', p1.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    coords = df.loc['a']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    coords = df.loc['b']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))", "masked_code": "def test_prepare_result():\n    p0 = Point(12.3, (- 45.6))\n    p1 = Point((- 23.4), 56.7)\n    d = {'a': ('address0', p0.coords[0]), 'b': ('address1', p1.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    coords = df.loc['a']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == '???')\n    coords = df.loc['b']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))", "ground_truth": "pytest.approx(test[0])", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_373", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_prepare_result", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_prepare_result():\n    p0 = Point(12.3, (- 45.6))\n    p1 = Point((- 23.4), 56.7)\n    d = {'a': ('address0', p0.coords[0]), 'b': ('address1', p1.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    coords = df.loc['a']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    coords = df.loc['b']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))", "masked_code": "def test_prepare_result():\n    p0 = Point(12.3, (- 45.6))\n    p1 = Point((- 23.4), 56.7)\n    d = {'a': ('address0', p0.coords[0]), 'b': ('address1', p1.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    coords = df.loc['a']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    coords = df.loc['b']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == '???')\n    assert (coords[1] == pytest.approx(test[0]))", "ground_truth": "pytest.approx(test[1])", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_374", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_prepare_result", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_prepare_result():\n    p0 = Point(12.3, (- 45.6))\n    p1 = Point((- 23.4), 56.7)\n    d = {'a': ('address0', p0.coords[0]), 'b': ('address1', p1.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    coords = df.loc['a']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    coords = df.loc['b']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))", "masked_code": "def test_prepare_result():\n    p0 = Point(12.3, (- 45.6))\n    p1 = Point((- 23.4), 56.7)\n    d = {'a': ('address0', p0.coords[0]), 'b': ('address1', p1.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    coords = df.loc['a']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    coords = df.loc['b']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == '???')", "ground_truth": "pytest.approx(test[0])", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_375", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_prepare_result", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_prepare_result():\n    p0 = Point(12.3, (- 45.6))\n    p1 = Point((- 23.4), 56.7)\n    d = {'a': ('address0', p0.coords[0]), 'b': ('address1', p1.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    coords = df.loc['a']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    coords = df.loc['b']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))", "masked_code": "def test_prepare_result():\n    p0 = Point(12.3, (- 45.6))\n    p1 = Point((- 23.4), 56.7)\n    d = {'a': ('address0', p0.coords[0]), 'b': ('address1', p1.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == '???')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    coords = df.loc['a']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    coords = df.loc['b']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))", "ground_truth": "'EPSG:4326'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_376", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_prepare_result_none", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_prepare_result_none():\n    p0 = Point(12.3, (- 45.6))\n    d = {'a': ('address0', p0.coords[0]), 'b': (None, None)}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    row = df.loc['b']\n    assert (len(row['geometry'].coords) == 0)\n    assert row['geometry'].is_empty\n    assert pd.isna(row['address'])", "masked_code": "def test_prepare_result_none():\n    p0 = Point(12.3, (- 45.6))\n    d = {'a': ('address0', p0.coords[0]), 'b': (None, None)}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == '???')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    row = df.loc['b']\n    assert (len(row['geometry'].coords) == 0)\n    assert row['geometry'].is_empty\n    assert pd.isna(row['address'])", "ground_truth": "'EPSG:4326'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_378", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_reverse", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_reverse(locations, points):\n    from geopy.geocoders import Photon\n    for provider in ['photon', Photon]:\n        with mock.patch('geopy.geocoders.Photon.reverse', ReverseMock()) as m:\n            g = reverse_geocode(points, provider=provider, timeout=2)\n            assert (len(points) == m.call_count)\n        assert isinstance(g, GeoDataFrame)\n        expected = GeoSeries(points, crs='EPSG:4326')\n        assert_geoseries_equal(expected, g['geometry'])\n        address = pd.Series([('address' + str(x)) for x in range(len(points))], name='address')\n        assert_series_equal(g['address'], address)", "masked_code": "def test_reverse(locations, points):\n    from geopy.geocoders import Photon\n    for provider in ['photon', Photon]:\n        with mock.patch('geopy.geocoders.Photon.reverse', ReverseMock()) as m:\n            g = reverse_geocode(points, provider=provider, timeout=2)\n            assert (len(points) == '???')\n        assert isinstance(g, GeoDataFrame)\n        expected = GeoSeries(points, crs='EPSG:4326')\n        assert_geoseries_equal(expected, g['geometry'])\n        address = pd.Series([('address' + str(x)) for x in range(len(points))], name='address')\n        assert_series_equal(g['address'], address)", "ground_truth": "m.call_count", "quality_analysis": {"complexity_score": 6, "left_complexity": 4, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_98", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_int32", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "@pytest.mark.parametrize('array_data,dtype', [([1, ((2 ** 31) - 1)], np.int32), ([1, np.nan], pd.Int32Dtype())])\ndef test_infer_schema_int32(array_data, dtype):\n    int32col = pd.array(data=array_data, dtype=dtype)\n    df = GeoDataFrame(geometry=[city_hall_entrance, city_hall_balcony])\n    df['int32_column'] = int32col\n    assert (infer_schema(df) == {'geometry': 'Point', 'properties': OrderedDict([('int32_column', 'int32')])})", "masked_code": "@pytest.mark.parametrize('array_data,dtype', [([1, ((2 ** 31) - 1)], np.int32), ([1, np.nan], pd.Int32Dtype())])\ndef test_infer_schema_int32(array_data, dtype):\n    int32col = pd.array(data=array_data, dtype=dtype)\n    df = GeoDataFrame(geometry=[city_hall_entrance, city_hall_balcony])\n    df['int32_column'] = int32col\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'Point', 'properties': OrderedDict([('int32_column', 'int32')])}", "quality_analysis": {"complexity_score": 19, "left_complexity": 4, "right_complexity": 15, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_99", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_int64", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_int64():\n    int64col = pd.array([1, np.nan], dtype=pd.Int64Dtype())\n    df = GeoDataFrame(geometry=[city_hall_entrance, city_hall_balcony])\n    df['int64_column'] = int64col\n    assert (infer_schema(df) == {'geometry': 'Point', 'properties': OrderedDict([('int64_column', 'int')])})", "masked_code": "def test_infer_schema_int64():\n    int64col = pd.array([1, np.nan], dtype=pd.Int64Dtype())\n    df = GeoDataFrame(geometry=[city_hall_entrance, city_hall_balcony])\n    df['int64_column'] = int64col\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'Point', 'properties': OrderedDict([('int64_column', 'int')])}", "quality_analysis": {"complexity_score": 19, "left_complexity": 4, "right_complexity": 15, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_82", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_linestrings_and_multilinestrings", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_linestrings_and_multilinestrings():\n    df = GeoDataFrame(geometry=[MultiLineString(city_hall_walls), city_hall_walls[0]])\n    assert (infer_schema(df) == {'geometry': ['MultiLineString', 'LineString'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_linestrings_and_multilinestrings():\n    df = GeoDataFrame(geometry=[MultiLineString(city_hall_walls), city_hall_walls[0]])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['MultiLineString', 'LineString'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_89", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_mixed_3D_Point", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_mixed_3D_Point():\n    df = GeoDataFrame(geometry=[city_hall_balcony, point_3D])\n    assert (infer_schema(df) == {'geometry': ['3D Point', 'Point'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_mixed_3D_Point():\n    df = GeoDataFrame(geometry=[city_hall_balcony, point_3D])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['3D Point', 'Point'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_93", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_mixed_3D_Polygon", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_mixed_3D_Polygon():\n    df = GeoDataFrame(geometry=[city_hall_boundaries, polygon_3D])\n    assert (infer_schema(df) == {'geometry': ['3D Polygon', 'Polygon'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_mixed_3D_Polygon():\n    df = GeoDataFrame(geometry=[city_hall_boundaries, polygon_3D])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['3D Polygon', 'Polygon'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_91", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_mixed_3D_linestring", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_mixed_3D_linestring():\n    df = GeoDataFrame(geometry=[city_hall_walls[0], linestring_3D])\n    assert (infer_schema(df) == {'geometry': ['3D LineString', 'LineString'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_mixed_3D_linestring():\n    df = GeoDataFrame(geometry=[city_hall_walls[0], linestring_3D])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['3D LineString', 'LineString'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_88", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_mixed_3D_shape_type", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_mixed_3D_shape_type():\n    df = GeoDataFrame(geometry=[MultiPolygon((city_hall_boundaries, vauquelin_place)), city_hall_boundaries, MultiLineString(city_hall_walls), city_hall_walls[0], MultiPoint([city_hall_entrance, city_hall_balcony]), city_hall_balcony, point_3D])\n    assert (infer_schema(df) == {'geometry': ['3D Point', 'MultiPolygon', 'Polygon', 'MultiLineString', 'LineString', 'MultiPoint', 'Point'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_mixed_3D_shape_type():\n    df = GeoDataFrame(geometry=[MultiPolygon((city_hall_boundaries, vauquelin_place)), city_hall_boundaries, MultiLineString(city_hall_walls), city_hall_walls[0], MultiPoint([city_hall_entrance, city_hall_balcony]), city_hall_balcony, point_3D])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['3D Point', 'MultiPolygon', 'Polygon', 'MultiLineString', 'LineString', 'MultiPoint', 'Point'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 21, "left_complexity": 4, "right_complexity": 17, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_87", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_multiple_shape_types", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_multiple_shape_types():\n    df = GeoDataFrame(geometry=[MultiPolygon((city_hall_boundaries, vauquelin_place)), city_hall_boundaries, MultiLineString(city_hall_walls), city_hall_walls[0], MultiPoint([city_hall_entrance, city_hall_balcony]), city_hall_balcony])\n    assert (infer_schema(df) == {'geometry': ['MultiPolygon', 'Polygon', 'MultiLineString', 'LineString', 'MultiPoint', 'Point'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_multiple_shape_types():\n    df = GeoDataFrame(geometry=[MultiPolygon((city_hall_boundaries, vauquelin_place)), city_hall_boundaries, MultiLineString(city_hall_walls), city_hall_walls[0], MultiPoint([city_hall_entrance, city_hall_balcony]), city_hall_balcony])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['MultiPolygon', 'Polygon', 'MultiLineString', 'LineString', 'MultiPoint', 'Point'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 20, "left_complexity": 4, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_97", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_null_geometry_all", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_null_geometry_all():\n    df = GeoDataFrame(geometry=[None, None])\n    assert (infer_schema(df) == {'geometry': 'Unknown', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_null_geometry_all():\n    df = GeoDataFrame(geometry=[None, None])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'Unknown', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_95", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_null_geometry_and_2D_point", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_null_geometry_and_2D_point():\n    df = GeoDataFrame(geometry=[None, city_hall_entrance])\n    assert (infer_schema(df) == {'geometry': 'Point', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_null_geometry_and_2D_point():\n    df = GeoDataFrame(geometry=[None, city_hall_entrance])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'Point', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_96", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_null_geometry_and_3D_point", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_null_geometry_and_3D_point():\n    df = GeoDataFrame(geometry=[None, point_3D])\n    assert (infer_schema(df) == {'geometry': '3D Point', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_null_geometry_and_3D_point():\n    df = GeoDataFrame(geometry=[None, point_3D])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': '3D Point', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_90", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_3D_Points", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_3D_Points():\n    df = GeoDataFrame(geometry=[point_3D, point_3D])\n    assert (infer_schema(df) == {'geometry': '3D Point', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_3D_Points():\n    df = GeoDataFrame(geometry=[point_3D, point_3D])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': '3D Point', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_94", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_3D_Polygons", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_3D_Polygons():\n    df = GeoDataFrame(geometry=[polygon_3D, polygon_3D])\n    assert (infer_schema(df) == {'geometry': '3D Polygon', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_3D_Polygons():\n    df = GeoDataFrame(geometry=[polygon_3D, polygon_3D])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': '3D Polygon', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_92", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_3D_linestrings", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_3D_linestrings():\n    df = GeoDataFrame(geometry=[linestring_3D, linestring_3D])\n    assert (infer_schema(df) == {'geometry': '3D LineString', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_3D_linestrings():\n    df = GeoDataFrame(geometry=[linestring_3D, linestring_3D])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': '3D LineString', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_81", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_linestrings", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_linestrings():\n    df = GeoDataFrame(geometry=city_hall_walls)\n    assert (infer_schema(df) == {'geometry': 'LineString', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_linestrings():\n    df = GeoDataFrame(geometry=city_hall_walls)\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'LineString', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_83", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_multilinestrings", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_multilinestrings():\n    df = GeoDataFrame(geometry=[MultiLineString(city_hall_walls)])\n    assert (infer_schema(df) == {'geometry': 'MultiLineString', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_multilinestrings():\n    df = GeoDataFrame(geometry=[MultiLineString(city_hall_walls)])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'MultiLineString', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_80", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_multipoints", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_multipoints():\n    df = GeoDataFrame(geometry=[MultiPoint([city_hall_entrance, city_hall_balcony, city_hall_council_chamber])])\n    assert (infer_schema(df) == {'geometry': 'MultiPoint', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_multipoints():\n    df = GeoDataFrame(geometry=[MultiPoint([city_hall_entrance, city_hall_balcony, city_hall_council_chamber])])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'MultiPoint', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_86", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_multipolygons", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_multipolygons():\n    df = GeoDataFrame(geometry=[MultiPolygon((city_hall_boundaries, vauquelin_place))])\n    assert (infer_schema(df) == {'geometry': 'MultiPolygon', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_multipolygons():\n    df = GeoDataFrame(geometry=[MultiPolygon((city_hall_boundaries, vauquelin_place))])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'MultiPolygon', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_78", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_points", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_points():\n    df = GeoDataFrame(geometry=[city_hall_entrance, city_hall_balcony])\n    assert (infer_schema(df) == {'geometry': 'Point', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_points():\n    df = GeoDataFrame(geometry=[city_hall_entrance, city_hall_balcony])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'Point', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_84", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_polygons", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_polygons():\n    df = GeoDataFrame(geometry=[city_hall_boundaries, vauquelin_place])\n    assert (infer_schema(df) == {'geometry': 'Polygon', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_polygons():\n    df = GeoDataFrame(geometry=[city_hall_boundaries, vauquelin_place])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'Polygon', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_79", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_points_and_multipoints", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_points_and_multipoints():\n    df = GeoDataFrame(geometry=[MultiPoint([city_hall_entrance, city_hall_balcony]), city_hall_balcony])\n    assert (infer_schema(df) == {'geometry': ['MultiPoint', 'Point'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_points_and_multipoints():\n    df = GeoDataFrame(geometry=[MultiPoint([city_hall_entrance, city_hall_balcony]), city_hall_balcony])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['MultiPoint', 'Point'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_85", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_polygons_and_multipolygons", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_polygons_and_multipolygons():\n    df = GeoDataFrame(geometry=[MultiPolygon((city_hall_boundaries, vauquelin_place)), city_hall_boundaries])\n    assert (infer_schema(df) == {'geometry': ['MultiPolygon', 'Polygon'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_polygons_and_multipolygons():\n    df = GeoDataFrame(geometry=[MultiPolygon((city_hall_boundaries, vauquelin_place)), city_hall_boundaries])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['MultiPolygon', 'Polygon'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_519", "reponame": "geopandas", "testpath": "geopandas/tests/test_merge.py", "testname": "test_merge.py", "funcname": "test_concat_axis0", "imports": ["import warnings", "import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_21", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from pandas.testing import assert_index_equal"], "code": "def test_concat_axis0(self):\n    res = pd.concat([self.gdf, self.gdf])\n    assert (res.shape == (6, 2))\n    assert isinstance(res, GeoDataFrame)\n    assert isinstance(res.geometry, GeoSeries)\n    self._check_metadata(res)\n    exp = GeoDataFrame(pd.concat([pd.DataFrame(self.gdf), pd.DataFrame(self.gdf)]))\n    assert_geodataframe_equal(exp, res)\n    res = pd.concat([self.gdf.geometry, self.gdf.geometry])\n    assert (res.shape == (6,))\n    assert isinstance(res, GeoSeries)\n    assert isinstance(res.geometry, GeoSeries)", "masked_code": "def test_concat_axis0(self):\n    res = pd.concat([self.gdf, self.gdf])\n    assert (res.shape == '???')\n    assert isinstance(res, GeoDataFrame)\n    assert isinstance(res.geometry, GeoSeries)\n    self._check_metadata(res)\n    exp = GeoDataFrame(pd.concat([pd.DataFrame(self.gdf), pd.DataFrame(self.gdf)]))\n    assert_geodataframe_equal(exp, res)\n    res = pd.concat([self.gdf.geometry, self.gdf.geometry])\n    assert (res.shape == (6,))\n    assert isinstance(res, GeoSeries)\n    assert isinstance(res.geometry, GeoSeries)", "ground_truth": "(6, 2)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMerging"}
{"task_id": "geopandas_520", "reponame": "geopandas", "testpath": "geopandas/tests/test_merge.py", "testname": "test_merge.py", "funcname": "test_concat_axis0", "imports": ["import warnings", "import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_21", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from pandas.testing import assert_index_equal"], "code": "def test_concat_axis0(self):\n    res = pd.concat([self.gdf, self.gdf])\n    assert (res.shape == (6, 2))\n    assert isinstance(res, GeoDataFrame)\n    assert isinstance(res.geometry, GeoSeries)\n    self._check_metadata(res)\n    exp = GeoDataFrame(pd.concat([pd.DataFrame(self.gdf), pd.DataFrame(self.gdf)]))\n    assert_geodataframe_equal(exp, res)\n    res = pd.concat([self.gdf.geometry, self.gdf.geometry])\n    assert (res.shape == (6,))\n    assert isinstance(res, GeoSeries)\n    assert isinstance(res.geometry, GeoSeries)", "masked_code": "def test_concat_axis0(self):\n    res = pd.concat([self.gdf, self.gdf])\n    assert (res.shape == (6, 2))\n    assert isinstance(res, GeoDataFrame)\n    assert isinstance(res.geometry, GeoSeries)\n    self._check_metadata(res)\n    exp = GeoDataFrame(pd.concat([pd.DataFrame(self.gdf), pd.DataFrame(self.gdf)]))\n    assert_geodataframe_equal(exp, res)\n    res = pd.concat([self.gdf.geometry, self.gdf.geometry])\n    assert (res.shape == '???')\n    assert isinstance(res, GeoSeries)\n    assert isinstance(res.geometry, GeoSeries)", "ground_truth": "(6,)", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMerging"}
{"task_id": "geopandas_521", "reponame": "geopandas", "testpath": "geopandas/tests/test_merge.py", "testname": "test_merge.py", "funcname": "test_concat_axis1", "imports": ["import warnings", "import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_21", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from pandas.testing import assert_index_equal"], "code": "def test_concat_axis1(self):\n    res = pd.concat([self.gdf, self.df], axis=1)\n    assert (res.shape == (3, 4))\n    assert isinstance(res, GeoDataFrame)\n    assert isinstance(res.geometry, GeoSeries)\n    self._check_metadata(res)", "masked_code": "def test_concat_axis1(self):\n    res = pd.concat([self.gdf, self.df], axis=1)\n    assert (res.shape == '???')\n    assert isinstance(res, GeoDataFrame)\n    assert isinstance(res.geometry, GeoSeries)\n    self._check_metadata(res)", "ground_truth": "(3, 4)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMerging"}
{"task_id": "geopandas_523", "reponame": "geopandas", "testpath": "geopandas/tests/test_op_output_types.py", "testname": "test_op_output_types.py", "funcname": "test_constructor_sliced_row_slices", "imports": ["import numpy as np", "import pandas as pd", "from shapely.geometry import Point", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries", "import pytest", "from geopandas.testing import assert_geodataframe_equal"], "code": "@pytest.mark.parametrize('column_set', test_case_column_sets, ids=[', '.join(i) for i in test_case_column_sets])\ndef test_constructor_sliced_row_slices(df2, column_set):\n    df_subset = df2[column_set]\n    assert isinstance(df_subset, GeoDataFrame)\n    res = df_subset.loc[0]\n    assert (type(res) is pd.Series)\n    if ('geometry' in column_set):\n        assert (not isinstance(res.geometry, pd.Series))\n        assert (res.geometry == Point(0, 0))", "masked_code": "@pytest.mark.parametrize('column_set', test_case_column_sets, ids=[', '.join(i) for i in test_case_column_sets])\ndef test_constructor_sliced_row_slices(df2, column_set):\n    df_subset = df2[column_set]\n    assert isinstance(df_subset, GeoDataFrame)\n    res = df_subset.loc[0]\n    assert (type(res) is pd.Series)\n    if ('geometry' in column_set):\n        assert (not isinstance(res.geometry, pd.Series))\n        assert (res.geometry == '???')", "ground_truth": "Point(0, 0)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_522", "reponame": "geopandas", "testpath": "geopandas/tests/test_op_output_types.py", "testname": "test_op_output_types.py", "funcname": "test_loc_add_row", "imports": ["import numpy as np", "import pandas as pd", "from shapely.geometry import Point", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries", "import pytest", "from geopandas.testing import assert_geodataframe_equal"], "code": "@pytest.mark.parametrize('geom_name', ['geometry', pytest.param('geom', marks=pytest.mark.xfail(reason='pre-regression behaviour only works for geometry col geometry'))])\ndef test_loc_add_row(geom_name, nybb_filename):\n    nybb = geopandas.read_file(nybb_filename)[['BoroCode', 'geometry']]\n    if (geom_name != 'geometry'):\n        nybb = nybb.rename_geometry(geom_name)\n    nybb.loc[5] = [6, nybb.geometry.iloc[0]]\n    assert (nybb.geometry.dtype == 'geometry')\n    assert (nybb.crs is None)", "masked_code": "@pytest.mark.parametrize('geom_name', ['geometry', pytest.param('geom', marks=pytest.mark.xfail(reason='pre-regression behaviour only works for geometry col geometry'))])\ndef test_loc_add_row(geom_name, nybb_filename):\n    nybb = geopandas.read_file(nybb_filename)[['BoroCode', 'geometry']]\n    if (geom_name != 'geometry'):\n        nybb = nybb.rename_geometry(geom_name)\n    nybb.loc[5] = [6, nybb.geometry.iloc[0]]\n    assert (nybb.geometry.dtype == '???')\n    assert (nybb.crs is None)", "ground_truth": "'geometry'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_641", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_random.py", "testname": "test_random.py", "funcname": "test_uniform", "imports": ["import numpy", "import shapely", "import geopandas", "from geopandas.tools._random import uniform", "import pytest"], "code": "@pytest.mark.parametrize('size', [10, 100])\n@pytest.mark.parametrize('geom_fixture', ['multipolygons', 'polygons', 'multilinestrings', 'linestrings'])\ndef test_uniform(geom_fixture, size, request):\n    geom = request.getfixturevalue(geom_fixture)[0]\n    sample = uniform(geom, size=size, rng=1)\n    sample_series = geopandas.GeoSeries(sample).explode(index_parts=True).reset_index(drop=True)\n    assert (len(sample_series) == size)\n    sample_in_geom = sample_series.buffer(1e-08).sindex.query(geom, predicate='intersects')\n    assert (len(sample_in_geom) == size)", "masked_code": "@pytest.mark.parametrize('size', [10, 100])\n@pytest.mark.parametrize('geom_fixture', ['multipolygons', 'polygons', 'multilinestrings', 'linestrings'])\ndef test_uniform(geom_fixture, size, request):\n    geom = request.getfixturevalue(geom_fixture)[0]\n    sample = uniform(geom, size=size, rng=1)\n    sample_series = geopandas.GeoSeries(sample).explode(index_parts=True).reset_index(drop=True)\n    assert (len(sample_series) == '???')\n    sample_in_geom = sample_series.buffer(1e-08).sindex.query(geom, predicate='intersects')\n    assert (len(sample_in_geom) == size)", "ground_truth": "size", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_642", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_random.py", "testname": "test_random.py", "funcname": "test_uniform", "imports": ["import numpy", "import shapely", "import geopandas", "from geopandas.tools._random import uniform", "import pytest"], "code": "@pytest.mark.parametrize('size', [10, 100])\n@pytest.mark.parametrize('geom_fixture', ['multipolygons', 'polygons', 'multilinestrings', 'linestrings'])\ndef test_uniform(geom_fixture, size, request):\n    geom = request.getfixturevalue(geom_fixture)[0]\n    sample = uniform(geom, size=size, rng=1)\n    sample_series = geopandas.GeoSeries(sample).explode(index_parts=True).reset_index(drop=True)\n    assert (len(sample_series) == size)\n    sample_in_geom = sample_series.buffer(1e-08).sindex.query(geom, predicate='intersects')\n    assert (len(sample_in_geom) == size)", "masked_code": "@pytest.mark.parametrize('size', [10, 100])\n@pytest.mark.parametrize('geom_fixture', ['multipolygons', 'polygons', 'multilinestrings', 'linestrings'])\ndef test_uniform(geom_fixture, size, request):\n    geom = request.getfixturevalue(geom_fixture)[0]\n    sample = uniform(geom, size=size, rng=1)\n    sample_series = geopandas.GeoSeries(sample).explode(index_parts=True).reset_index(drop=True)\n    assert (len(sample_series) == size)\n    sample_in_geom = sample_series.buffer(1e-08).sindex.query(geom, predicate='intersects')\n    assert (len(sample_in_geom) == '???')", "ground_truth": "size", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
