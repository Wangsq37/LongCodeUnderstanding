{"task_id": "stellargraph_767", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "def test_flow(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    dataset = generator.flow(batch_size=1)\n    assert (tf.data.experimental.cardinality(dataset).numpy() == (- 1))", "masked_code": "def test_flow(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    dataset = generator.flow(batch_size=1)\n    assert (tf.data.experimental.cardinality(dataset).numpy() == '???')", "ground_truth": "(- 1)", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_768", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('batch_size', [1, 5, 10])\ndef test_flow_batch_size(barbell, batch_size):\n    num_powers = 5\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == (batch_size, num_powers, len(barbell.nodes())))", "masked_code": "@pytest.mark.parametrize('batch_size', [1, 5, 10])\ndef test_flow_batch_size(barbell, batch_size):\n    num_powers = 5\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        assert (x[0].shape == '???')\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == (batch_size, num_powers, len(barbell.nodes())))", "ground_truth": "(batch_size,)", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_769", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('batch_size', [1, 5, 10])\ndef test_flow_batch_size(barbell, batch_size):\n    num_powers = 5\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == (batch_size, num_powers, len(barbell.nodes())))", "masked_code": "@pytest.mark.parametrize('batch_size', [1, 5, 10])\ndef test_flow_batch_size(barbell, batch_size):\n    num_powers = 5\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == '???')\n        assert (x[1].shape == (batch_size, num_powers, len(barbell.nodes())))", "ground_truth": "(batch_size, 1, len(barbell.nodes()))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_770", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('batch_size', [1, 5, 10])\ndef test_flow_batch_size(barbell, batch_size):\n    num_powers = 5\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == (batch_size, num_powers, len(barbell.nodes())))", "masked_code": "@pytest.mark.parametrize('batch_size', [1, 5, 10])\ndef test_flow_batch_size(barbell, batch_size):\n    num_powers = 5\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == '???')", "ground_truth": "(batch_size, num_powers, len(barbell.nodes()))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_771", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('num_powers', [2, 4, 8])\ndef test_flow_batch_size(barbell, num_powers):\n    batch_size = 2\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == (batch_size, num_powers, len(barbell.nodes())))", "masked_code": "@pytest.mark.parametrize('num_powers', [2, 4, 8])\ndef test_flow_batch_size(barbell, num_powers):\n    batch_size = 2\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        assert (x[0].shape == '???')\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == (batch_size, num_powers, len(barbell.nodes())))", "ground_truth": "(batch_size,)", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_772", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('num_powers', [2, 4, 8])\ndef test_flow_batch_size(barbell, num_powers):\n    batch_size = 2\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == (batch_size, num_powers, len(barbell.nodes())))", "masked_code": "@pytest.mark.parametrize('num_powers', [2, 4, 8])\ndef test_flow_batch_size(barbell, num_powers):\n    batch_size = 2\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == '???')\n        assert (x[1].shape == (batch_size, num_powers, len(barbell.nodes())))", "ground_truth": "(batch_size, 1, len(barbell.nodes()))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_773", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('num_powers', [2, 4, 8])\ndef test_flow_batch_size(barbell, num_powers):\n    batch_size = 2\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == (batch_size, num_powers, len(barbell.nodes())))", "masked_code": "@pytest.mark.parametrize('num_powers', [2, 4, 8])\ndef test_flow_batch_size(barbell, num_powers):\n    batch_size = 2\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == '???')", "ground_truth": "(batch_size, num_powers, len(barbell.nodes()))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_764", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_init", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "def test_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    num_nodes = len(barbell.nodes())\n    assert (generator.num_powers == 5)\n    assert (generator.Aadj_T.shape == (num_nodes, num_nodes))\n    assert (generator.transition_matrix_T.shape == (num_nodes, num_nodes))", "masked_code": "def test_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    num_nodes = len(barbell.nodes())\n    assert (generator.num_powers == '???')\n    assert (generator.Aadj_T.shape == (num_nodes, num_nodes))\n    assert (generator.transition_matrix_T.shape == (num_nodes, num_nodes))", "ground_truth": "5", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_765", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_init", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "def test_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    num_nodes = len(barbell.nodes())\n    assert (generator.num_powers == 5)\n    assert (generator.Aadj_T.shape == (num_nodes, num_nodes))\n    assert (generator.transition_matrix_T.shape == (num_nodes, num_nodes))", "masked_code": "def test_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    num_nodes = len(barbell.nodes())\n    assert (generator.num_powers == 5)\n    assert (generator.Aadj_T.shape == '???')\n    assert (generator.transition_matrix_T.shape == (num_nodes, num_nodes))", "ground_truth": "(num_nodes, num_nodes)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_766", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_init", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "def test_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    num_nodes = len(barbell.nodes())\n    assert (generator.num_powers == 5)\n    assert (generator.Aadj_T.shape == (num_nodes, num_nodes))\n    assert (generator.transition_matrix_T.shape == (num_nodes, num_nodes))", "masked_code": "def test_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    num_nodes = len(barbell.nodes())\n    assert (generator.num_powers == 5)\n    assert (generator.Aadj_T.shape == (num_nodes, num_nodes))\n    assert (generator.transition_matrix_T.shape == '???')", "ground_truth": "(num_nodes, num_nodes)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_794", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "masked_code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == '???')\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "ground_truth": "tree_len", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_795", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "masked_code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == '???')\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "ground_truth": "len(nodes)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_796", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "masked_code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == '???')\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "ground_truth": "(len(nodes), 1, 1)", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_797", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "masked_code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == '???')\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "ground_truth": "(len(nodes), 1, 1)", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_798", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "masked_code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == '???')\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "ground_truth": "(len(nodes), 1, 1)", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_799", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "masked_code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == '???')\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "ground_truth": "(len(nodes), 1, 1)", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_800", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "masked_code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == '???')\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "ground_truth": "(len(nodes), 1, 1)", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_801", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "masked_code": "def test_two_hop(self):\n    g = create_simple_graph()\n    nodes = list(g.nodes())\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[1, 1], out_samples=[1, 1])\n    flow = gen.flow(node_ids=nodes, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(nodes)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(nodes))\n    assert (node_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        assert (node_features[(idx, 0, 0)] == ((- 1.0) * node))\n    in_features = features[1]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        else:\n            assert False\n    out_features = features[2]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    in_features = features[3]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 1.0))\n        else:\n            assert False\n    in_features = features[4]\n    assert (in_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (in_features[(idx, 0, 0)] == 0.0)\n        elif (node == 2):\n            assert (in_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (in_features[(idx, 0, 0)] == (- 3.0))\n        else:\n            assert False\n    out_features = features[5]\n    assert (out_features.shape == '???')\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 1.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == (- 2.0))\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False\n    out_features = features[6]\n    assert (out_features.shape == (len(nodes), 1, 1))\n    for (idx, node) in enumerate(nodes):\n        if (node == 1):\n            assert (out_features[(idx, 0, 0)] == (- 3.0))\n        elif (node == 2):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        elif (node == 3):\n            assert (out_features[(idx, 0, 0)] == 0.0)\n        else:\n            assert False", "ground_truth": "(len(nodes), 1, 1)", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_46", "reponame": "stellargraph", "testpath": "tests/core/test_element_data.py", "testname": "test_element_data.py", "funcname": "test_external_id_index_to_iloc", "imports": ["import pytest", "import numpy as np", "from stellargraph.core.element_data import ExternalIdIndex"], "code": "@pytest.mark.parametrize('count,expected_missing', [(0, 255), (255, 255), (256, 65535), (65535, 65535), (65536, 4294967295)])\ndef test_external_id_index_to_iloc(count, expected_missing):\n    values = [f'id{x}' for x in range(count)]\n    idx = ExternalIdIndex(values)\n    all_ilocs = idx.to_iloc(values)\n    assert (all_ilocs == list(range(count))).all()\n    assert (all_ilocs < expected_missing).all()\n    if (count <= 256):\n        for (i, x) in enumerate(values):\n            np.testing.assert_array_equal(idx.to_iloc([x]), [i])\n    assert (idx.to_iloc(['A']) == expected_missing)", "masked_code": "@pytest.mark.parametrize('count,expected_missing', [(0, 255), (255, 255), (256, 65535), (65535, 65535), (65536, 4294967295)])\ndef test_external_id_index_to_iloc(count, expected_missing):\n    values = [f'id{x}' for x in range(count)]\n    idx = ExternalIdIndex(values)\n    all_ilocs = idx.to_iloc(values)\n    assert (all_ilocs == list(range(count))).all()\n    assert (all_ilocs < expected_missing).all()\n    if (count <= 256):\n        for (i, x) in enumerate(values):\n            np.testing.assert_array_equal(idx.to_iloc([x]), [i])\n    assert (idx.to_iloc(['A']) == '???')", "ground_truth": "expected_missing", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_366", "reponame": "stellargraph", "testpath": "tests/data/test_epgm.py", "testname": "test_epgm.py", "funcname": "test_node_attributes", "imports": ["import pytest", "import os", "import numpy as np", "from stellargraph.data.epgm import EPGM"], "code": "def test_node_attributes(self):\n    'Test the .node_attributes() method'\n    G_epgm = EPGM(self.input_dir)\n    graph_id = G_epgm.G['graphs'][0]['id']\n    node_attributes = G_epgm.node_attributes(graph_id, self.node_type)\n    assert (self.target_attribute in node_attributes)\n    if self.epgm_input:\n        assert (len(node_attributes) == 1433), 'There should be 1433 unique node attributes; found {}'.format(len(node_attributes))\n    else:\n        assert (len(node_attributes) == 1434), 'There should be 1434 unique node attributes; found {}'.format(len(node_attributes))\n    assert (len(G_epgm.node_attributes(graph_id, 'person')) == 0)\n    with pytest.raises(TypeError):\n        G_epgm.node_attributes(graph_id)", "masked_code": "def test_node_attributes(self):\n    'Test the .node_attributes() method'\n    G_epgm = EPGM(self.input_dir)\n    graph_id = G_epgm.G['graphs'][0]['id']\n    node_attributes = G_epgm.node_attributes(graph_id, self.node_type)\n    assert (self.target_attribute in node_attributes)\n    if self.epgm_input:\n        assert (len(node_attributes) == '???'), 'There should be 1433 unique node attributes; found {}'.format(len(node_attributes))\n    else:\n        assert (len(node_attributes) == 1434), 'There should be 1434 unique node attributes; found {}'.format(len(node_attributes))\n    assert (len(G_epgm.node_attributes(graph_id, 'person')) == 0)\n    with pytest.raises(TypeError):\n        G_epgm.node_attributes(graph_id)", "ground_truth": "1433", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_EPGM_IO_Homogeneous"}
{"task_id": "stellargraph_367", "reponame": "stellargraph", "testpath": "tests/data/test_epgm.py", "testname": "test_epgm.py", "funcname": "test_node_attributes", "imports": ["import pytest", "import os", "import numpy as np", "from stellargraph.data.epgm import EPGM"], "code": "def test_node_attributes(self):\n    'Test the .node_attributes() method'\n    G_epgm = EPGM(self.input_dir)\n    graph_id = G_epgm.G['graphs'][0]['id']\n    node_attributes = G_epgm.node_attributes(graph_id, self.node_type)\n    assert (self.target_attribute in node_attributes)\n    if self.epgm_input:\n        assert (len(node_attributes) == 1433), 'There should be 1433 unique node attributes; found {}'.format(len(node_attributes))\n    else:\n        assert (len(node_attributes) == 1434), 'There should be 1434 unique node attributes; found {}'.format(len(node_attributes))\n    assert (len(G_epgm.node_attributes(graph_id, 'person')) == 0)\n    with pytest.raises(TypeError):\n        G_epgm.node_attributes(graph_id)", "masked_code": "def test_node_attributes(self):\n    'Test the .node_attributes() method'\n    G_epgm = EPGM(self.input_dir)\n    graph_id = G_epgm.G['graphs'][0]['id']\n    node_attributes = G_epgm.node_attributes(graph_id, self.node_type)\n    assert (self.target_attribute in node_attributes)\n    if self.epgm_input:\n        assert (len(node_attributes) == 1433), 'There should be 1433 unique node attributes; found {}'.format(len(node_attributes))\n    else:\n        assert (len(node_attributes) == '???'), 'There should be 1434 unique node attributes; found {}'.format(len(node_attributes))\n    assert (len(G_epgm.node_attributes(graph_id, 'person')) == 0)\n    with pytest.raises(TypeError):\n        G_epgm.node_attributes(graph_id)", "ground_truth": "1434", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_47", "reponame": "stellargraph", "testpath": "tests/core/test_experimental.py", "testname": "test_experimental.py", "funcname": "test_experimental_class", "imports": ["import pytest", "import random", "from stellargraph.core.experimental import experimental, ExperimentalWarning"], "code": "def test_experimental_class(args, kwargs):\n    with pytest.warns(ExperimentalWarning, match='^ClassNoInit is experimental: class is experimental\\\\.'):\n        ClassNoInit()\n    with pytest.warns(ExperimentalWarning, match='^ClassInit is experimental: class is experimental\\\\.'):\n        instance = ClassInit(*args, **kwargs)\n    assert (instance.args == args)\n    assert (instance.kwargs == kwargs)", "masked_code": "def test_experimental_class(args, kwargs):\n    with pytest.warns(ExperimentalWarning, match='^ClassNoInit is experimental: class is experimental\\\\.'):\n        ClassNoInit()\n    with pytest.warns(ExperimentalWarning, match='^ClassInit is experimental: class is experimental\\\\.'):\n        instance = ClassInit(*args, **kwargs)\n    assert (instance.args == '???')\n    assert (instance.kwargs == kwargs)", "ground_truth": "args", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_48", "reponame": "stellargraph", "testpath": "tests/core/test_experimental.py", "testname": "test_experimental.py", "funcname": "test_experimental_class", "imports": ["import pytest", "import random", "from stellargraph.core.experimental import experimental, ExperimentalWarning"], "code": "def test_experimental_class(args, kwargs):\n    with pytest.warns(ExperimentalWarning, match='^ClassNoInit is experimental: class is experimental\\\\.'):\n        ClassNoInit()\n    with pytest.warns(ExperimentalWarning, match='^ClassInit is experimental: class is experimental\\\\.'):\n        instance = ClassInit(*args, **kwargs)\n    assert (instance.args == args)\n    assert (instance.kwargs == kwargs)", "masked_code": "def test_experimental_class(args, kwargs):\n    with pytest.warns(ExperimentalWarning, match='^ClassNoInit is experimental: class is experimental\\\\.'):\n        ClassNoInit()\n    with pytest.warns(ExperimentalWarning, match='^ClassInit is experimental: class is experimental\\\\.'):\n        instance = ClassInit(*args, **kwargs)\n    assert (instance.args == args)\n    assert (instance.kwargs == '???')", "ground_truth": "kwargs", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_49", "reponame": "stellargraph", "testpath": "tests/core/test_experimental.py", "testname": "test_experimental.py", "funcname": "test_experimental_method", "imports": ["import pytest", "import random", "from stellargraph.core.experimental import experimental, ExperimentalWarning"], "code": "def test_experimental_method(args, kwargs):\n    instance = Class()\n    with pytest.warns(ExperimentalWarning, match='^Class\\\\.method is experimental: method is experimental\\\\.'):\n        ret = instance.method(*args, **kwargs)\n    assert (ret[0] is instance)\n    assert (ret[1:] == (args, kwargs))", "masked_code": "def test_experimental_method(args, kwargs):\n    instance = Class()\n    with pytest.warns(ExperimentalWarning, match='^Class\\\\.method is experimental: method is experimental\\\\.'):\n        ret = instance.method(*args, **kwargs)\n    assert (ret[0] is instance)\n    assert (ret[1:] == '???')", "ground_truth": "(args, kwargs)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_818", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_fullbatch_generator_transform", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_fullbatch_generator_transform(self):\n    (G, feats) = create_graph_features()\n\n    def func(features, A, **kwargs):\n        return (features, A.dot(A))\n    generator = FullBatchNodeGenerator(G, 'test', transform=func)\n    assert (generator.name == 'test')\n    A = G.to_adjacency_matrix().toarray()\n    np.testing.assert_array_equal(A.dot(A), generator.Aadj.toarray())", "masked_code": "def test_fullbatch_generator_transform(self):\n    (G, feats) = create_graph_features()\n\n    def func(features, A, **kwargs):\n        return (features, A.dot(A))\n    generator = FullBatchNodeGenerator(G, 'test', transform=func)\n    assert (generator.name == '???')\n    A = G.to_adjacency_matrix().toarray()\n    np.testing.assert_array_equal(A.dot(A), generator.Aadj.toarray())", "ground_truth": "'test'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchNodeGenerator"}
{"task_id": "stellargraph_823", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_fullbatch_generator_transform", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_fullbatch_generator_transform(self):\n\n    def func(features, A, **kwargs):\n        return (features, A.dot(A))\n    generator = FullBatchNodeGenerator(self.G, 'test', transform=func)\n    assert (generator.name == 'test')\n    A = self.G.to_adjacency_matrix().toarray()\n    np.testing.assert_array_equal(A.dot(A), generator.Aadj.toarray())", "masked_code": "def test_fullbatch_generator_transform(self):\n\n    def func(features, A, **kwargs):\n        return (features, A.dot(A))\n    generator = FullBatchNodeGenerator(self.G, 'test', transform=func)\n    assert (generator.name == '???')\n    A = self.G.to_adjacency_matrix().toarray()\n    np.testing.assert_array_equal(A.dot(A), generator.Aadj.toarray())", "ground_truth": "'test'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchLinkGenerator"}
{"task_id": "stellargraph_814", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_constructor", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_constructor(self):\n    generator = FullBatchNodeGenerator(self.G)\n    assert (generator.Aadj.shape == (self.N, self.N))\n    assert (generator.features.shape == (self.N, self.n_feat))", "masked_code": "def test_generator_constructor(self):\n    generator = FullBatchNodeGenerator(self.G)\n    assert (generator.Aadj.shape == '???')\n    assert (generator.features.shape == (self.N, self.n_feat))", "ground_truth": "(self.N, self.N)", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchNodeGenerator"}
{"task_id": "stellargraph_815", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_constructor", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_constructor(self):\n    generator = FullBatchNodeGenerator(self.G)\n    assert (generator.Aadj.shape == (self.N, self.N))\n    assert (generator.features.shape == (self.N, self.n_feat))", "masked_code": "def test_generator_constructor(self):\n    generator = FullBatchNodeGenerator(self.G)\n    assert (generator.Aadj.shape == (self.N, self.N))\n    assert (generator.features.shape == '???')", "ground_truth": "(self.N, self.n_feat)", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchNodeGenerator"}
{"task_id": "stellargraph_819", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_constructor", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_constructor(self):\n    generator = FullBatchLinkGenerator(self.G)\n    assert (generator.Aadj.shape == (self.N, self.N))\n    assert (generator.features.shape == (self.N, self.n_feat))", "masked_code": "def test_generator_constructor(self):\n    generator = FullBatchLinkGenerator(self.G)\n    assert (generator.Aadj.shape == '???')\n    assert (generator.features.shape == (self.N, self.n_feat))", "ground_truth": "(self.N, self.N)", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchLinkGenerator"}
{"task_id": "stellargraph_820", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_constructor", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_constructor(self):\n    generator = FullBatchLinkGenerator(self.G)\n    assert (generator.Aadj.shape == (self.N, self.N))\n    assert (generator.features.shape == (self.N, self.n_feat))", "masked_code": "def test_generator_constructor(self):\n    generator = FullBatchLinkGenerator(self.G)\n    assert (generator.Aadj.shape == (self.N, self.N))\n    assert (generator.features.shape == '???')", "ground_truth": "(self.N, self.n_feat)", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchLinkGenerator"}
{"task_id": "stellargraph_816", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_flow_targets_as_list", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchNodeGenerator(self.G)\n    node_ids = list(self.G.nodes())[:3]\n    node_targets = ([1] * len(node_ids))\n    gen = generator.flow(node_ids, node_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == (1, 3))\n    assert (np.sum(y) == 3)", "masked_code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchNodeGenerator(self.G)\n    node_ids = list(self.G.nodes())[:3]\n    node_targets = ([1] * len(node_ids))\n    gen = generator.flow(node_ids, node_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == '???')\n    assert (np.sum(y) == 3)", "ground_truth": "(1, 3)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchNodeGenerator"}
{"task_id": "stellargraph_817", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_flow_targets_as_list", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchNodeGenerator(self.G)\n    node_ids = list(self.G.nodes())[:3]\n    node_targets = ([1] * len(node_ids))\n    gen = generator.flow(node_ids, node_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == (1, 3))\n    assert (np.sum(y) == 3)", "masked_code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchNodeGenerator(self.G)\n    node_ids = list(self.G.nodes())[:3]\n    node_targets = ([1] * len(node_ids))\n    gen = generator.flow(node_ids, node_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == (1, 3))\n    assert (np.sum(y) == '???')", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchNodeGenerator"}
{"task_id": "stellargraph_821", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_flow_targets_as_list", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchLinkGenerator(self.G)\n    link_ids = list(self.G.edges())[:3]\n    link_targets = ([1] * len(link_ids))\n    gen = generator.flow(link_ids, link_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == (1, 3))\n    assert (np.sum(y) == 3)", "masked_code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchLinkGenerator(self.G)\n    link_ids = list(self.G.edges())[:3]\n    link_targets = ([1] * len(link_ids))\n    gen = generator.flow(link_ids, link_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == '???')\n    assert (np.sum(y) == 3)", "ground_truth": "(1, 3)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchLinkGenerator"}
{"task_id": "stellargraph_822", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_flow_targets_as_list", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchLinkGenerator(self.G)\n    link_ids = list(self.G.edges())[:3]\n    link_targets = ([1] * len(link_ids))\n    gen = generator.flow(link_ids, link_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == (1, 3))\n    assert (np.sum(y) == 3)", "masked_code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchLinkGenerator(self.G)\n    link_ids = list(self.G.edges())[:3]\n    link_targets = ([1] * len(link_ids))\n    gen = generator.flow(link_ids, link_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == (1, 3))\n    assert (np.sum(y) == '???')", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchLinkGenerator"}
{"task_id": "stellargraph_558", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == '???')\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "ground_truth": "10", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_559", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == '???')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "ground_truth": "'relu'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_560", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == '???')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "ground_truth": "'GlorotUniform'", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_561", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == '???')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "ground_truth": "'Zeros'", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_562", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == '???')\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "ground_truth": "None", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_563", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == '???')\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "ground_truth": "None", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_564", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == '???')\n    assert (conf['bias_constraint'] == None)", "ground_truth": "None", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_565", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=10, A=a, activation='relu')\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 10)\n    assert (conf['activation'] == 'relu')\n    assert (conf['use_bias'] == True)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == '???')", "ground_truth": "None", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_571", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_activations", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_activations():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[10, 10, 10, 10, 10], lstm_layer_sizes=[8, 16, 32, 64])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu', 'relu', 'relu', 'relu'])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh', 'tanh'])\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[10], gc_activations=['relu'], lstm_layer_sizes=[8, 16, 32, 64])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh', 'tanh'])", "masked_code": "def test_gcn_lstm_activations():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[10, 10, 10, 10, 10], lstm_layer_sizes=[8, 16, 32, 64])\n    assert (gcn_lstm_model.gc_activations == '???')\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh', 'tanh'])\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[10], gc_activations=['relu'], lstm_layer_sizes=[8, 16, 32, 64])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh', 'tanh'])", "ground_truth": "['relu', 'relu', 'relu', 'relu', 'relu']", "quality_analysis": {"complexity_score": 9, "left_complexity": 2, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_572", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_activations", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_activations():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[10, 10, 10, 10, 10], lstm_layer_sizes=[8, 16, 32, 64])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu', 'relu', 'relu', 'relu'])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh', 'tanh'])\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[10], gc_activations=['relu'], lstm_layer_sizes=[8, 16, 32, 64])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh', 'tanh'])", "masked_code": "def test_gcn_lstm_activations():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[10, 10, 10, 10, 10], lstm_layer_sizes=[8, 16, 32, 64])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu', 'relu', 'relu', 'relu'])\n    assert (gcn_lstm_model.lstm_activations == '???')\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[10], gc_activations=['relu'], lstm_layer_sizes=[8, 16, 32, 64])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh', 'tanh'])", "ground_truth": "['tanh', 'tanh', 'tanh', 'tanh']", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_573", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_activations", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_activations():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[10, 10, 10, 10, 10], lstm_layer_sizes=[8, 16, 32, 64])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu', 'relu', 'relu', 'relu'])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh', 'tanh'])\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[10], gc_activations=['relu'], lstm_layer_sizes=[8, 16, 32, 64])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh', 'tanh'])", "masked_code": "def test_gcn_lstm_activations():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[10, 10, 10, 10, 10], lstm_layer_sizes=[8, 16, 32, 64])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu', 'relu', 'relu', 'relu'])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh', 'tanh'])\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[10], gc_activations=['relu'], lstm_layer_sizes=[8, 16, 32, 64])\n    assert (gcn_lstm_model.lstm_activations == '???')", "ground_truth": "['tanh', 'tanh', 'tanh', 'tanh']", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_574", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_layers", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_layers():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[8, 8, 16], gc_activations=['relu', 'relu', 'relu'], lstm_layer_sizes=[8, 16, 32], lstm_activations=['tanh'])\n    assert (len(gcn_lstm_model._gc_layers) == len(gcn_lstm_model.gc_layer_sizes))\n    assert (len(gcn_lstm_model._lstm_layers) == len(gcn_lstm_model.lstm_layer_sizes))", "masked_code": "def test_gcn_lstm_layers():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[8, 8, 16], gc_activations=['relu', 'relu', 'relu'], lstm_layer_sizes=[8, 16, 32], lstm_activations=['tanh'])\n    assert (len(gcn_lstm_model._gc_layers) == '???')\n    assert (len(gcn_lstm_model._lstm_layers) == len(gcn_lstm_model.lstm_layer_sizes))", "ground_truth": "len(gcn_lstm_model.gc_layer_sizes)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_575", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_layers", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_layers():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[8, 8, 16], gc_activations=['relu', 'relu', 'relu'], lstm_layer_sizes=[8, 16, 32], lstm_activations=['tanh'])\n    assert (len(gcn_lstm_model._gc_layers) == len(gcn_lstm_model.gc_layer_sizes))\n    assert (len(gcn_lstm_model._lstm_layers) == len(gcn_lstm_model.lstm_layer_sizes))", "masked_code": "def test_gcn_lstm_layers():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[8, 8, 16], gc_activations=['relu', 'relu', 'relu'], lstm_layer_sizes=[8, 16, 32], lstm_activations=['tanh'])\n    assert (len(gcn_lstm_model._gc_layers) == len(gcn_lstm_model.gc_layer_sizes))\n    assert (len(gcn_lstm_model._lstm_layers) == '???')", "ground_truth": "len(gcn_lstm_model.lstm_layer_sizes)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_566", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_model_parameters", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[2, 2], gc_activations=['relu', 'relu'], lstm_layer_sizes=[10], lstm_activations=['tanh'])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu'])\n    assert (gcn_lstm_model.dropout == 0.5)\n    assert (gcn_lstm_model.lstm_activations == ['tanh'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [10])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "masked_code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[2, 2], gc_activations=['relu', 'relu'], lstm_layer_sizes=[10], lstm_activations=['tanh'])\n    assert (gcn_lstm_model.gc_activations == '???')\n    assert (gcn_lstm_model.dropout == 0.5)\n    assert (gcn_lstm_model.lstm_activations == ['tanh'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [10])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "ground_truth": "['relu', 'relu']", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_567", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_model_parameters", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[2, 2], gc_activations=['relu', 'relu'], lstm_layer_sizes=[10], lstm_activations=['tanh'])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu'])\n    assert (gcn_lstm_model.dropout == 0.5)\n    assert (gcn_lstm_model.lstm_activations == ['tanh'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [10])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "masked_code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[2, 2], gc_activations=['relu', 'relu'], lstm_layer_sizes=[10], lstm_activations=['tanh'])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu'])\n    assert (gcn_lstm_model.dropout == '???')\n    assert (gcn_lstm_model.lstm_activations == ['tanh'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [10])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "ground_truth": "0.5", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_568", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_model_parameters", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[2, 2], gc_activations=['relu', 'relu'], lstm_layer_sizes=[10], lstm_activations=['tanh'])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu'])\n    assert (gcn_lstm_model.dropout == 0.5)\n    assert (gcn_lstm_model.lstm_activations == ['tanh'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [10])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "masked_code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[2, 2], gc_activations=['relu', 'relu'], lstm_layer_sizes=[10], lstm_activations=['tanh'])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu'])\n    assert (gcn_lstm_model.dropout == 0.5)\n    assert (gcn_lstm_model.lstm_activations == '???')\n    assert (gcn_lstm_model.lstm_layer_sizes == [10])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "ground_truth": "['tanh']", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_569", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_model_parameters", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[2, 2], gc_activations=['relu', 'relu'], lstm_layer_sizes=[10], lstm_activations=['tanh'])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu'])\n    assert (gcn_lstm_model.dropout == 0.5)\n    assert (gcn_lstm_model.lstm_activations == ['tanh'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [10])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "masked_code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[2, 2], gc_activations=['relu', 'relu'], lstm_layer_sizes=[10], lstm_activations=['tanh'])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu'])\n    assert (gcn_lstm_model.dropout == 0.5)\n    assert (gcn_lstm_model.lstm_activations == ['tanh'])\n    assert (gcn_lstm_model.lstm_layer_sizes == '???')\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "ground_truth": "[10]", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_570", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_model_parameters", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[2, 2], gc_activations=['relu', 'relu'], lstm_layer_sizes=[10], lstm_activations=['tanh'])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu'])\n    assert (gcn_lstm_model.dropout == 0.5)\n    assert (gcn_lstm_model.lstm_activations == ['tanh'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [10])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "masked_code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[2, 2], gc_activations=['relu', 'relu'], lstm_layer_sizes=[10], lstm_activations=['tanh'])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu'])\n    assert (gcn_lstm_model.dropout == 0.5)\n    assert (gcn_lstm_model.lstm_activations == ['tanh'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [10])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == '???')", "ground_truth": "len(gcn_lstm_model.lstm_activations)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_829", "reponame": "stellargraph", "testpath": "tests/mapper/test_graphwave_generator.py", "testname": "test_graphwave_generator.py", "funcname": "test_embedding_dim", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.graphwave_generator import GraphWaveGenerator, _empirical_characteristic_function", "from ..test_utils.graphs import barbell", "import numpy as np", "import pytest", "import scipy.sparse as sps", "import tensorflow as tf"], "code": "@pytest.mark.parametrize('num_samples', [1, 25, 50])\ndef test_embedding_dim(barbell, num_samples):\n    scales = (0.1, 2, 3, 4)\n    generator = GraphWaveGenerator(barbell, scales=scales, degree=10)\n    sample_points = np.linspace(0, 1, num_samples)\n    expected_embed_dim = ((len(sample_points) * len(scales)) * 2)\n    for x in generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=4, repeat=False):\n        assert (x.shape[1] == expected_embed_dim)", "masked_code": "@pytest.mark.parametrize('num_samples', [1, 25, 50])\ndef test_embedding_dim(barbell, num_samples):\n    scales = (0.1, 2, 3, 4)\n    generator = GraphWaveGenerator(barbell, scales=scales, degree=10)\n    sample_points = np.linspace(0, 1, num_samples)\n    expected_embed_dim = ((len(sample_points) * len(scales)) * 2)\n    for x in generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=4, repeat=False):\n        assert (x.shape[1] == '???')", "ground_truth": "expected_embed_dim", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_827", "reponame": "stellargraph", "testpath": "tests/mapper/test_graphwave_generator.py", "testname": "test_graphwave_generator.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.graphwave_generator import GraphWaveGenerator, _empirical_characteristic_function", "from ..test_utils.graphs import barbell", "import numpy as np", "import pytest", "import scipy.sparse as sps", "import tensorflow as tf"], "code": "@pytest.mark.parametrize('batch_size', [1, 5, 10])\ndef test_flow_batch_size(barbell, batch_size):\n    scales = (0.1, 2, 3, 4)\n    generator = GraphWaveGenerator(barbell, scales=scales, degree=10)\n    sample_points = np.linspace(0, 100, 25)\n    expected_embed_dim = ((len(sample_points) * len(scales)) * 2)\n    for (i, x) in enumerate(generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=batch_size, repeat=False)):\n        if (i < (barbell.number_of_nodes() // batch_size)):\n            assert (x.shape == (batch_size, expected_embed_dim))\n        else:\n            assert (x.shape == ((barbell.number_of_nodes() % batch_size), expected_embed_dim))", "masked_code": "@pytest.mark.parametrize('batch_size', [1, 5, 10])\ndef test_flow_batch_size(barbell, batch_size):\n    scales = (0.1, 2, 3, 4)\n    generator = GraphWaveGenerator(barbell, scales=scales, degree=10)\n    sample_points = np.linspace(0, 100, 25)\n    expected_embed_dim = ((len(sample_points) * len(scales)) * 2)\n    for (i, x) in enumerate(generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=batch_size, repeat=False)):\n        if (i < (barbell.number_of_nodes() // batch_size)):\n            assert (x.shape == '???')\n        else:\n            assert (x.shape == ((barbell.number_of_nodes() % batch_size), expected_embed_dim))", "ground_truth": "(batch_size, expected_embed_dim)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_828", "reponame": "stellargraph", "testpath": "tests/mapper/test_graphwave_generator.py", "testname": "test_graphwave_generator.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.graphwave_generator import GraphWaveGenerator, _empirical_characteristic_function", "from ..test_utils.graphs import barbell", "import numpy as np", "import pytest", "import scipy.sparse as sps", "import tensorflow as tf"], "code": "@pytest.mark.parametrize('batch_size', [1, 5, 10])\ndef test_flow_batch_size(barbell, batch_size):\n    scales = (0.1, 2, 3, 4)\n    generator = GraphWaveGenerator(barbell, scales=scales, degree=10)\n    sample_points = np.linspace(0, 100, 25)\n    expected_embed_dim = ((len(sample_points) * len(scales)) * 2)\n    for (i, x) in enumerate(generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=batch_size, repeat=False)):\n        if (i < (barbell.number_of_nodes() // batch_size)):\n            assert (x.shape == (batch_size, expected_embed_dim))\n        else:\n            assert (x.shape == ((barbell.number_of_nodes() % batch_size), expected_embed_dim))", "masked_code": "@pytest.mark.parametrize('batch_size', [1, 5, 10])\ndef test_flow_batch_size(barbell, batch_size):\n    scales = (0.1, 2, 3, 4)\n    generator = GraphWaveGenerator(barbell, scales=scales, degree=10)\n    sample_points = np.linspace(0, 100, 25)\n    expected_embed_dim = ((len(sample_points) * len(scales)) * 2)\n    for (i, x) in enumerate(generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=batch_size, repeat=False)):\n        if (i < (barbell.number_of_nodes() // batch_size)):\n            assert (x.shape == (batch_size, expected_embed_dim))\n        else:\n            assert (x.shape == '???')", "ground_truth": "((barbell.number_of_nodes() % batch_size), expected_embed_dim)", "quality_analysis": {"complexity_score": 11, "left_complexity": 2, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_826", "reponame": "stellargraph", "testpath": "tests/mapper/test_graphwave_generator.py", "testname": "test_graphwave_generator.py", "funcname": "test_flow_repeat", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.graphwave_generator import GraphWaveGenerator, _empirical_characteristic_function", "from ..test_utils.graphs import barbell", "import numpy as np", "import pytest", "import scipy.sparse as sps", "import tensorflow as tf"], "code": "@pytest.mark.parametrize('repeat', [False, True])\ndef test_flow_repeat(barbell, repeat):\n    generator = GraphWaveGenerator(barbell, scales=(0.1, 2, 3, 4), degree=10)\n    sample_points = np.linspace(0, 100, 25)\n    for (i, x) in enumerate(generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=1, repeat=repeat)):\n        if (i > barbell.number_of_nodes()):\n            break\n    assert ((i > barbell.number_of_nodes()) == repeat)", "masked_code": "@pytest.mark.parametrize('repeat', [False, True])\ndef test_flow_repeat(barbell, repeat):\n    generator = GraphWaveGenerator(barbell, scales=(0.1, 2, 3, 4), degree=10)\n    sample_points = np.linspace(0, 100, 25)\n    for (i, x) in enumerate(generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=1, repeat=repeat)):\n        if (i > barbell.number_of_nodes()):\n            break\n    assert ((i > barbell.number_of_nodes()) == '???')", "ground_truth": "repeat", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_824", "reponame": "stellargraph", "testpath": "tests/mapper/test_graphwave_generator.py", "testname": "test_graphwave_generator.py", "funcname": "test_init", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.graphwave_generator import GraphWaveGenerator, _empirical_characteristic_function", "from ..test_utils.graphs import barbell", "import numpy as np", "import pytest", "import scipy.sparse as sps", "import tensorflow as tf"], "code": "def test_init(barbell):\n    generator = GraphWaveGenerator(barbell, scales=(0.1, 2, 3, 4), degree=10)\n    np.testing.assert_array_equal(generator.scales, np.array((0.1, 2, 3, 4)).astype(np.float32))\n    assert (generator.coeffs.shape == (4, (10 + 1)))\n    assert (generator.laplacian.shape == (barbell.number_of_nodes(), barbell.number_of_nodes()))", "masked_code": "def test_init(barbell):\n    generator = GraphWaveGenerator(barbell, scales=(0.1, 2, 3, 4), degree=10)\n    np.testing.assert_array_equal(generator.scales, np.array((0.1, 2, 3, 4)).astype(np.float32))\n    assert (generator.coeffs.shape == '???')\n    assert (generator.laplacian.shape == (barbell.number_of_nodes(), barbell.number_of_nodes()))", "ground_truth": "(4, (10 + 1))", "quality_analysis": {"complexity_score": 9, "left_complexity": 2, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_825", "reponame": "stellargraph", "testpath": "tests/mapper/test_graphwave_generator.py", "testname": "test_graphwave_generator.py", "funcname": "test_init", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.graphwave_generator import GraphWaveGenerator, _empirical_characteristic_function", "from ..test_utils.graphs import barbell", "import numpy as np", "import pytest", "import scipy.sparse as sps", "import tensorflow as tf"], "code": "def test_init(barbell):\n    generator = GraphWaveGenerator(barbell, scales=(0.1, 2, 3, 4), degree=10)\n    np.testing.assert_array_equal(generator.scales, np.array((0.1, 2, 3, 4)).astype(np.float32))\n    assert (generator.coeffs.shape == (4, (10 + 1)))\n    assert (generator.laplacian.shape == (barbell.number_of_nodes(), barbell.number_of_nodes()))", "masked_code": "def test_init(barbell):\n    generator = GraphWaveGenerator(barbell, scales=(0.1, 2, 3, 4), degree=10)\n    np.testing.assert_array_equal(generator.scales, np.array((0.1, 2, 3, 4)).astype(np.float32))\n    assert (generator.coeffs.shape == (4, (10 + 1)))\n    assert (generator.laplacian.shape == '???')", "ground_truth": "(barbell.number_of_nodes(), barbell.number_of_nodes())", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_394", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == '???')\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_395", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == '???')\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_396", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == '???')\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_397", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == '???')\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_398", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == '???')\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "ground_truth": "nodes[0]", "quality_analysis": {"complexity_score": 18, "left_complexity": 13, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_399", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == '???')\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_400", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == '???')\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "ground_truth": "nodes[0]", "quality_analysis": {"complexity_score": 18, "left_complexity": 13, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_401", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == '???')\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_402", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == '???')\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "ground_truth": "(n * len(nodes))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_403", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == '???')\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "ground_truth": "(n * len(nodes))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_404", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n        assert (subgraph[0][0] == nodes[i])\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    for (i, subgraph) in enumerate(subgraphs):\n        assert (len(subgraph) == 3)\n    valid_result = [[_conv([0]), [(- 1), (- 1)], [(- 1), (- 1)]], [_conv([7]), _conv([7, 7]), [(- 1), (- 1)]]]\n    assert _recursive_items_equal(valid_result, subgraphs)\n    n_size = [2, 2]\n    nodes = _conv([0, 4])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[0], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None], [None, None]], [[4], ['5', 1], [2, 2], [1, 1], [6, 3], [4, 4], [2, 3], [1, 1], [4, 4]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    nodes = _conv([1, 6])\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    assert (subgraphs[0][0][0] == nodes[0])\n    valid_result = [[[1], ['5', 4], [3, 3], [1, 1, '5'], [2, 2, 2], [1, 4, 1], [3, 6, 6], [1, '5', '5'], [1, '5', 1]], [[6], ['5', '5'], [4, 4, 1], [6, 3, 6], [4, 4, 1], [6, 6, 3]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 5\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (len(nodes) * n))\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]], [[6], ['5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n = 1\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))\n    nodes = _conv([4, '5', 0])\n    n = 1\n    n_size = [3, 3, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == '???')\n    n = 99\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=999)\n    assert (len(subgraphs) == (n * len(nodes)))", "ground_truth": "(n * len(nodes))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_386", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "masked_code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == '???')\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_387", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "masked_code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == '???')\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_388", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "masked_code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == '???')\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_389", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "masked_code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == '???')\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_390", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "masked_code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == '???')\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_391", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "masked_code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == '???')\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_392", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "masked_code": "def test_walk_generation_single_root_node(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([3])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5', 1, 1])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([3]), _conv(['5']), _conv([1]), _conv([3])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv(['5'])\n    n_size = [2, 3]\n    n = 3\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=42)\n    assert (len(subgraphs) == n)\n    valid_result = [[['5'], [4, 1], [3, 3], ['5', '5', '5'], [2, 2, 2], [4, '5', 4], [2, 3, 3], [1, '5', '5'], [1, '5', '5']], [['5'], [1, 1], [6, 3], [4, 4, '5'], [3, 3, 3], ['5', '5', 4], [3, 3, 3], ['5', '5', '5'], [1, 1, 1]], [['5'], [1, 1], [3, 3], ['5', 4, 4], [2, 2, 3], ['5', '5', 4], [3, 2, 2], ['5', '5', '5'], ['5', '5', '5']]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = _conv([1])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], [4, 4], [2, 2]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    _recursive_items_equal(subgraphs, valid_result)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == '???')\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [1, 1, 1], ['5', 1, 1], [2, 2, 2], [1, 1, 1], [1, '5', 1], [2, 2, 2], [7, 7, 7], [4, 1, 1], [6, 3, 6], [7, 7, 7], [1, 4, 1], [6, 6, 6], [4, 1, 1], [1, 1, 1]]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    nodes = _conv([1])\n    n_size = [2, 0]\n    n = 2\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=19893839)\n    assert (len(subgraphs) == n)\n    valid_result = [[[1], [4, 4], ['5', '5'], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []], [[1], [4, 4], [4, 4], [2, 2], [], [], [], [], [], [], [], [], [], [], [], [], [], []]]\n    valid_result = [[_conv(x) for x in y] for y in valid_result]\n    assert _recursive_items_equal(subgraphs, valid_result)", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_372", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node_loner", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Tests that the sampler behaves correctly when a root node is isolated with no self loop\\n        Returns:\\n\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 0)\n    assert (len(subgraphs[0][2]) == 0)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 9)\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][1]])\n    assert (len(subgraphs[0][2]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][2]])", "masked_code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Tests that the sampler behaves correctly when a root node is isolated with no self loop\\n        Returns:\\n\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == '???')\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 0)\n    assert (len(subgraphs[0][2]) == 0)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 9)\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][1]])\n    assert (len(subgraphs[0][2]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][2]])", "ground_truth": "3", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_373", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node_loner", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Tests that the sampler behaves correctly when a root node is isolated with no self loop\\n        Returns:\\n\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 0)\n    assert (len(subgraphs[0][2]) == 0)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 9)\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][1]])\n    assert (len(subgraphs[0][2]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][2]])", "masked_code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Tests that the sampler behaves correctly when a root node is isolated with no self loop\\n        Returns:\\n\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == '???')\n    assert (len(subgraphs[0][1]) == 0)\n    assert (len(subgraphs[0][2]) == 0)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 9)\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][1]])\n    assert (len(subgraphs[0][2]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][2]])", "ground_truth": "g.node_ids_to_ilocs([0])[0]", "quality_analysis": {"complexity_score": 23, "left_complexity": 13, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_374", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node_loner", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Tests that the sampler behaves correctly when a root node is isolated with no self loop\\n        Returns:\\n\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 0)\n    assert (len(subgraphs[0][2]) == 0)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 9)\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][1]])\n    assert (len(subgraphs[0][2]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][2]])", "masked_code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Tests that the sampler behaves correctly when a root node is isolated with no self loop\\n        Returns:\\n\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 0)\n    assert (len(subgraphs[0][2]) == 0)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == '???')\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][1]])\n    assert (len(subgraphs[0][2]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][2]])", "ground_truth": "9", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_375", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node_loner", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Tests that the sampler behaves correctly when a root node is isolated with no self loop\\n        Returns:\\n\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 0)\n    assert (len(subgraphs[0][2]) == 0)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 9)\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][1]])\n    assert (len(subgraphs[0][2]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][2]])", "masked_code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Tests that the sampler behaves correctly when a root node is isolated with no self loop\\n        Returns:\\n\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == g.node_ids_to_ilocs([0])[0])\n    assert (len(subgraphs[0][1]) == 0)\n    assert (len(subgraphs[0][2]) == 0)\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 9)\n    assert (subgraphs[0][0][0] == '???')\n    assert (len(subgraphs[0][1]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][1]])\n    assert (len(subgraphs[0][2]) == 2)\n    assert all([(x == (- 1)) for x in subgraphs[0][2]])", "ground_truth": "g.node_ids_to_ilocs([0])[0]", "quality_analysis": {"complexity_score": 23, "left_complexity": 13, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_376", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node_self_loner", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node_self_loner(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == nodes[0])\n    assert (len(subgraphs[0][1]) == 0)\n    assert (len(subgraphs[0][2]) == 0)\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == nodes[0])\n    assert (subgraphs[0][1][0] == nodes[0])\n    assert (len(subgraphs[0][2]) == 1)\n    assert (subgraphs[0][2] == [(- 1)])\n    n_size = [2, 2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 9)\n    for level in subgraphs[0]:\n        assert (type(level) == list)\n        if (len(level) > 0):\n            for value in level:\n                assert ((value == nodes[0]) or (value == (- 1)))\n    n_size = [2, 2, 3]\n    subgraphs2 = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs2) == 1)\n    assert (len(subgraphs2[0]) == 29)\n    assert all([(subgraphs[0][ii] == subgraphs2[0][ii]) for ii in range(len(subgraphs))])\n    for level in subgraphs2[0]:\n        assert (type(level) == list)\n        if (len(level) > 0):\n            for value in level:\n                assert ((value == nodes[0]) or (value == (- 1)))", "masked_code": "def test_walk_generation_single_root_node_self_loner(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == '???')\n    assert (subgraphs[0][0][0] == nodes[0])\n    assert (len(subgraphs[0][1]) == 0)\n    assert (len(subgraphs[0][2]) == 0)\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == nodes[0])\n    assert (subgraphs[0][1][0] == nodes[0])\n    assert (len(subgraphs[0][2]) == 1)\n    assert (subgraphs[0][2] == [(- 1)])\n    n_size = [2, 2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 9)\n    for level in subgraphs[0]:\n        assert (type(level) == list)\n        if (len(level) > 0):\n            for value in level:\n                assert ((value == nodes[0]) or (value == (- 1)))\n    n_size = [2, 2, 3]\n    subgraphs2 = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs2) == 1)\n    assert (len(subgraphs2[0]) == 29)\n    assert all([(subgraphs[0][ii] == subgraphs2[0][ii]) for ii in range(len(subgraphs))])\n    for level in subgraphs2[0]:\n        assert (type(level) == list)\n        if (len(level) > 0):\n            for value in level:\n                assert ((value == nodes[0]) or (value == (- 1)))", "ground_truth": "3", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_377", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node_self_loner", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node_self_loner(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == nodes[0])\n    assert (len(subgraphs[0][1]) == 0)\n    assert (len(subgraphs[0][2]) == 0)\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == nodes[0])\n    assert (subgraphs[0][1][0] == nodes[0])\n    assert (len(subgraphs[0][2]) == 1)\n    assert (subgraphs[0][2] == [(- 1)])\n    n_size = [2, 2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 9)\n    for level in subgraphs[0]:\n        assert (type(level) == list)\n        if (len(level) > 0):\n            for value in level:\n                assert ((value == nodes[0]) or (value == (- 1)))\n    n_size = [2, 2, 3]\n    subgraphs2 = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs2) == 1)\n    assert (len(subgraphs2[0]) == 29)\n    assert all([(subgraphs[0][ii] == subgraphs2[0][ii]) for ii in range(len(subgraphs))])\n    for level in subgraphs2[0]:\n        assert (type(level) == list)\n        if (len(level) > 0):\n            for value in level:\n                assert ((value == nodes[0]) or (value == (- 1)))", "masked_code": "def test_walk_generation_single_root_node_self_loner(self):\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([7])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == '???')\n    assert (len(subgraphs[0][1]) == 0)\n    assert (len(subgraphs[0][2]) == 0)\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 3)\n    assert (subgraphs[0][0][0] == nodes[0])\n    assert (subgraphs[0][1][0] == nodes[0])\n    assert (len(subgraphs[0][2]) == 1)\n    assert (subgraphs[0][2] == [(- 1)])\n    n_size = [2, 2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 1)\n    assert (len(subgraphs[0]) == 9)\n    for level in subgraphs[0]:\n        assert (type(level) == list)\n        if (len(level) > 0):\n            for value in level:\n                assert ((value == nodes[0]) or (value == (- 1)))\n    n_size = [2, 2, 3]\n    subgraphs2 = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs2) == 1)\n    assert (len(subgraphs2[0]) == 29)\n    assert all([(subgraphs[0][ii] == subgraphs2[0][ii]) for ii in range(len(subgraphs))])\n    for level in subgraphs2[0]:\n        assert (type(level) == list)\n        if (len(level) > 0):\n            for value in level:\n                assert ((value == nodes[0]) or (value == (- 1)))", "ground_truth": "nodes[0]", "quality_analysis": {"complexity_score": 18, "left_complexity": 13, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_1049", "reponame": "stellargraph", "testpath": "tests/utils/test_hyperbolic.py", "testname": "test_hyperbolic.py", "funcname": "test_poincare_ball_distance_exp", "imports": ["import pytest", "import numpy as np", "from stellargraph.utils.hyperbolic import *"], "code": "def test_poincare_ball_distance_exp(seeded):\n    for _ in range(100):\n        (c, _vs) = _generate(0)\n        (_c, tangents) = _generate(17, euclidean_max_norm=1e-10)\n        tangent_lengths = np.linalg.norm(tangents, axis=(- 1))\n\n        def check(x, y):\n            d = poincare_ball_distance(c, x, y)\n            assert (d.shape == tangents.shape[:(- 1)])\n            np.testing.assert_allclose(d, (2 * tangent_lengths), rtol=0.001)\n        zeros = np.zeros_like(tangents)\n        zero_moved = poincare_ball_exp(c, None, tangents)\n        assert (zero_moved.shape == tangents.shape)\n        check(zeros, zero_moved)\n        check(zero_moved, zeros)", "masked_code": "def test_poincare_ball_distance_exp(seeded):\n    for _ in range(100):\n        (c, _vs) = _generate(0)\n        (_c, tangents) = _generate(17, euclidean_max_norm=1e-10)\n        tangent_lengths = np.linalg.norm(tangents, axis=(- 1))\n\n        def check(x, y):\n            d = poincare_ball_distance(c, x, y)\n            assert (d.shape == tangents.shape[:(- 1)])\n            np.testing.assert_allclose(d, (2 * tangent_lengths), rtol=0.001)\n        zeros = np.zeros_like(tangents)\n        zero_moved = poincare_ball_exp(c, None, tangents)\n        assert (zero_moved.shape == '???')\n        check(zeros, zero_moved)\n        check(zero_moved, zeros)", "ground_truth": "tangents.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1050", "reponame": "stellargraph", "testpath": "tests/utils/test_hyperbolic.py", "testname": "test_hyperbolic.py", "funcname": "test_poincare_ball_distance_exp", "imports": ["import pytest", "import numpy as np", "from stellargraph.utils.hyperbolic import *"], "code": "def test_poincare_ball_distance_exp(seeded):\n    for _ in range(100):\n        (c, _vs) = _generate(0)\n        (_c, tangents) = _generate(17, euclidean_max_norm=1e-10)\n        tangent_lengths = np.linalg.norm(tangents, axis=(- 1))\n\n        def check(x, y):\n            d = poincare_ball_distance(c, x, y)\n            assert (d.shape == tangents.shape[:(- 1)])\n            np.testing.assert_allclose(d, (2 * tangent_lengths), rtol=0.001)\n        zeros = np.zeros_like(tangents)\n        zero_moved = poincare_ball_exp(c, None, tangents)\n        assert (zero_moved.shape == tangents.shape)\n        check(zeros, zero_moved)\n        check(zero_moved, zeros)", "masked_code": "def test_poincare_ball_distance_exp(seeded):\n    for _ in range(100):\n        (c, _vs) = _generate(0)\n        (_c, tangents) = _generate(17, euclidean_max_norm=1e-10)\n        tangent_lengths = np.linalg.norm(tangents, axis=(- 1))\n\n        def check(x, y):\n            d = poincare_ball_distance(c, x, y)\n            assert (d.shape == '???')\n            np.testing.assert_allclose(d, (2 * tangent_lengths), rtol=0.001)\n        zeros = np.zeros_like(tangents)\n        zero_moved = poincare_ball_exp(c, None, tangents)\n        assert (zero_moved.shape == tangents.shape)\n        check(zeros, zero_moved)\n        check(zero_moved, zeros)", "ground_truth": "tangents.shape[:(- 1)]", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1048", "reponame": "stellargraph", "testpath": "tests/utils/test_hyperbolic.py", "testname": "test_hyperbolic.py", "funcname": "test_poincare_ball_distance_self", "imports": ["import pytest", "import numpy as np", "from stellargraph.utils.hyperbolic import *"], "code": "def test_poincare_ball_distance_self(seeded):\n    for _ in range(100):\n        (c, vs) = _generate(17)\n        d = poincare_ball_distance(c, vs, vs)\n        assert (d.shape == vs.shape[:(- 1)])\n        np.testing.assert_allclose(d, 0, rtol=1e-06, atol=1e-05)", "masked_code": "def test_poincare_ball_distance_self(seeded):\n    for _ in range(100):\n        (c, vs) = _generate(17)\n        d = poincare_ball_distance(c, vs, vs)\n        assert (d.shape == '???')\n        np.testing.assert_allclose(d, 0, rtol=1e-06, atol=1e-05)", "ground_truth": "vs.shape[:(- 1)]", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1051", "reponame": "stellargraph", "testpath": "tests/utils/test_hyperbolic.py", "testname": "test_hyperbolic.py", "funcname": "test_poincare_ball_distance_vs_euclidean", "imports": ["import pytest", "import numpy as np", "from stellargraph.utils.hyperbolic import *"], "code": "def test_poincare_ball_distance_vs_euclidean(seeded):\n    for _ in range(100):\n        (c, vs) = _generate(17, norm_range=(0, 0.01))\n        zeros = np.zeros_like(vs)\n        hyperbolic = poincare_ball_distance(c, zeros, vs)\n        assert (hyperbolic.shape == vs.shape[:(- 1)])\n        euclidean = np.linalg.norm(vs, axis=(- 1))\n        np.testing.assert_allclose(hyperbolic, (2 * euclidean), rtol=0.001, atol=1e-15)\n        (c, vs) = _generate(17, norm_range=(0.99, 1))\n        zeros = np.zeros_like(vs)\n        hyperbolic = poincare_ball_distance(c, zeros, vs)\n        assert (hyperbolic.shape == vs.shape[:(- 1)])\n        euclidean = np.linalg.norm(vs, axis=(- 1))\n        np.testing.assert_array_less((4 * euclidean), hyperbolic)", "masked_code": "def test_poincare_ball_distance_vs_euclidean(seeded):\n    for _ in range(100):\n        (c, vs) = _generate(17, norm_range=(0, 0.01))\n        zeros = np.zeros_like(vs)\n        hyperbolic = poincare_ball_distance(c, zeros, vs)\n        assert (hyperbolic.shape == '???')\n        euclidean = np.linalg.norm(vs, axis=(- 1))\n        np.testing.assert_allclose(hyperbolic, (2 * euclidean), rtol=0.001, atol=1e-15)\n        (c, vs) = _generate(17, norm_range=(0.99, 1))\n        zeros = np.zeros_like(vs)\n        hyperbolic = poincare_ball_distance(c, zeros, vs)\n        assert (hyperbolic.shape == vs.shape[:(- 1)])\n        euclidean = np.linalg.norm(vs, axis=(- 1))\n        np.testing.assert_array_less((4 * euclidean), hyperbolic)", "ground_truth": "vs.shape[:(- 1)]", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1052", "reponame": "stellargraph", "testpath": "tests/utils/test_hyperbolic.py", "testname": "test_hyperbolic.py", "funcname": "test_poincare_ball_distance_vs_euclidean", "imports": ["import pytest", "import numpy as np", "from stellargraph.utils.hyperbolic import *"], "code": "def test_poincare_ball_distance_vs_euclidean(seeded):\n    for _ in range(100):\n        (c, vs) = _generate(17, norm_range=(0, 0.01))\n        zeros = np.zeros_like(vs)\n        hyperbolic = poincare_ball_distance(c, zeros, vs)\n        assert (hyperbolic.shape == vs.shape[:(- 1)])\n        euclidean = np.linalg.norm(vs, axis=(- 1))\n        np.testing.assert_allclose(hyperbolic, (2 * euclidean), rtol=0.001, atol=1e-15)\n        (c, vs) = _generate(17, norm_range=(0.99, 1))\n        zeros = np.zeros_like(vs)\n        hyperbolic = poincare_ball_distance(c, zeros, vs)\n        assert (hyperbolic.shape == vs.shape[:(- 1)])\n        euclidean = np.linalg.norm(vs, axis=(- 1))\n        np.testing.assert_array_less((4 * euclidean), hyperbolic)", "masked_code": "def test_poincare_ball_distance_vs_euclidean(seeded):\n    for _ in range(100):\n        (c, vs) = _generate(17, norm_range=(0, 0.01))\n        zeros = np.zeros_like(vs)\n        hyperbolic = poincare_ball_distance(c, zeros, vs)\n        assert (hyperbolic.shape == vs.shape[:(- 1)])\n        euclidean = np.linalg.norm(vs, axis=(- 1))\n        np.testing.assert_allclose(hyperbolic, (2 * euclidean), rtol=0.001, atol=1e-15)\n        (c, vs) = _generate(17, norm_range=(0.99, 1))\n        zeros = np.zeros_like(vs)\n        hyperbolic = poincare_ball_distance(c, zeros, vs)\n        assert (hyperbolic.shape == '???')\n        euclidean = np.linalg.norm(vs, axis=(- 1))\n        np.testing.assert_array_less((4 * euclidean), hyperbolic)", "ground_truth": "vs.shape[:(- 1)]", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1047", "reponame": "stellargraph", "testpath": "tests/utils/test_hyperbolic.py", "testname": "test_hyperbolic.py", "funcname": "test_poincare_ball_exp_specialisation", "imports": ["import pytest", "import numpy as np", "from stellargraph.utils.hyperbolic import *"], "code": "def test_poincare_ball_exp_specialisation(seeded):\n    for _ in range(100):\n        (c, _vs) = _generate(0)\n        (_c, vs) = _generate(17, euclidean_max_norm=1000)\n        specialised = poincare_ball_exp(c, None, vs)\n        assert (specialised.shape == vs.shape)\n        actual = poincare_ball_exp(c, np.zeros_like(vs), vs)\n        np.testing.assert_allclose(specialised.numpy(), actual.numpy())", "masked_code": "def test_poincare_ball_exp_specialisation(seeded):\n    for _ in range(100):\n        (c, _vs) = _generate(0)\n        (_c, vs) = _generate(17, euclidean_max_norm=1000)\n        specialised = poincare_ball_exp(c, None, vs)\n        assert (specialised.shape == '???')\n        actual = poincare_ball_exp(c, np.zeros_like(vs), vs)\n        np.testing.assert_allclose(specialised.numpy(), actual.numpy())", "ground_truth": "vs.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_155", "reponame": "stellargraph", "testpath": "tests/core/test_indexed_array.py", "testname": "test_indexed_array.py", "funcname": "test_indexed_array_empty", "imports": ["import numpy as np", "import pytest", "from stellargraph import IndexedArray"], "code": "def test_indexed_array_empty():\n    frame = IndexedArray()\n    assert (frame.index == range(0))\n    np.testing.assert_array_equal(frame.values, np.empty((0, 0)))", "masked_code": "def test_indexed_array_empty():\n    frame = IndexedArray()\n    assert (frame.index == '???')\n    np.testing.assert_array_equal(frame.values, np.empty((0, 0)))", "ground_truth": "range(0)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_156", "reponame": "stellargraph", "testpath": "tests/core/test_indexed_array.py", "testname": "test_indexed_array.py", "funcname": "test_indexed_array_non_empty", "imports": ["import numpy as np", "import pytest", "from stellargraph import IndexedArray"], "code": "def test_indexed_array_non_empty():\n    list_ids = ['a', 'b', 'c']\n    array_ids = np.array([10, (- 1), 2])\n    range_ids = range(106, 100, (- 2))\n    values = np.random.rand(3, 4, 5)\n    frame = IndexedArray(values)\n    assert (frame.index == range(3))\n    assert (frame.values is values)\n    frame = IndexedArray(values, index=list_ids)\n    assert (frame.index is list_ids)\n    assert (frame.values is values)\n    frame = IndexedArray(values, index=array_ids)\n    assert (frame.index is array_ids)\n    assert (frame.values is values)\n    frame = IndexedArray(values, index=range_ids)\n    assert (frame.index is range_ids)\n    assert (frame.values is values)", "masked_code": "def test_indexed_array_non_empty():\n    list_ids = ['a', 'b', 'c']\n    array_ids = np.array([10, (- 1), 2])\n    range_ids = range(106, 100, (- 2))\n    values = np.random.rand(3, 4, 5)\n    frame = IndexedArray(values)\n    assert (frame.index == '???')\n    assert (frame.values is values)\n    frame = IndexedArray(values, index=list_ids)\n    assert (frame.index is list_ids)\n    assert (frame.values is values)\n    frame = IndexedArray(values, index=array_ids)\n    assert (frame.index is array_ids)\n    assert (frame.values is values)\n    frame = IndexedArray(values, index=range_ids)\n    assert (frame.index is range_ids)\n    assert (frame.values is values)", "ground_truth": "range(3)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_831", "reponame": "stellargraph", "testpath": "tests/mapper/test_knowledge_graph.py", "testname": "test_knowledge_graph.py", "funcname": "test_kg_triple_sequence_shuffle", "imports": ["import pytest", "import pandas as pd", "import numpy as np", "from stellargraph.mapper.knowledge_graph import KGTripleGenerator, KGTripleSequence", "from .. import test_utils", "from ..test_utils.graphs import knowledge_graph"], "code": "@pytest.mark.parametrize('shuffle', [False, True])\ndef test_kg_triple_sequence_shuffle(shuffle):\n    seq = KGTripleSequence(max_node_iloc=10, source_ilocs=[0, 1, 2, 3, 4], rel_ilocs=[0, 1, 0, 1, 0], target_ilocs=[4, 3, 2, 1, 0], batch_size=5, shuffle=shuffle, negative_samples=None, sample_strategy='uniform', seed=None)\n    assert (len(seq) == 1)\n\n    def sample():\n        ret = seq[0]\n        seq.on_epoch_end()\n        return ret\n    (first, *rest) = [sample() for _ in range(20)]\n    should_be_equal = (not shuffle)\n    assert (all((epoch_sample_equal(first, r) for r in rest)) == should_be_equal)", "masked_code": "@pytest.mark.parametrize('shuffle', [False, True])\ndef test_kg_triple_sequence_shuffle(shuffle):\n    seq = KGTripleSequence(max_node_iloc=10, source_ilocs=[0, 1, 2, 3, 4], rel_ilocs=[0, 1, 0, 1, 0], target_ilocs=[4, 3, 2, 1, 0], batch_size=5, shuffle=shuffle, negative_samples=None, sample_strategy='uniform', seed=None)\n    assert (len(seq) == 1)\n\n    def sample():\n        ret = seq[0]\n        seq.on_epoch_end()\n        return ret\n    (first, *rest) = [sample() for _ in range(20)]\n    should_be_equal = (not shuffle)\n    assert (all((epoch_sample_equal(first, r) for r in rest)) == '???')", "ground_truth": "should_be_equal", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_714", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_clip_limits", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_clip_limits(self):\n    \"\\n        Test calling with the leaky clip thresholds\\n        Not sure what a meaningful test should do (as the LeakyClippedLinear layer provides some advantages at model training),\\n        so just making sure applying the clip limits doesn't break anything.\\n        \"\n    print('\\n Testing clip limits...')\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, 1, self.d)\n    x_dst = x_dst.reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_regression(output_dim=self.d_out, edge_embedding_method=op, clip_limits=self.clip_limits)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link regression with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, self.d_out))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_clip_limits(self):\n    \"\\n        Test calling with the leaky clip thresholds\\n        Not sure what a meaningful test should do (as the LeakyClippedLinear layer provides some advantages at model training),\\n        so just making sure applying the clip limits doesn't break anything.\\n        \"\n    print('\\n Testing clip limits...')\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, 1, self.d)\n    x_dst = x_dst.reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_regression(output_dim=self.d_out, edge_embedding_method=op, clip_limits=self.clip_limits)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link regression with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, self.d_out)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Regression"}
{"task_id": "stellargraph_689", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == '???')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "ground_truth": "pytest.approx(0, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_690", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == '???')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "ground_truth": "pytest.approx(1, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_691", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == '???')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "ground_truth": "pytest.approx(0.5, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_692", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src, x_src])\n    assert (li.numpy() == '???')", "ground_truth": "pytest.approx(0.7310586, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_701", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li)\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li))\n    assert (li.numpy() == '???')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li)\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "ground_truth": "pytest.approx(0, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Inference"}
{"task_id": "stellargraph_702", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li)\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li)\n    assert (li.numpy() == '???')\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "ground_truth": "pytest.approx(1, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Inference"}
{"task_id": "stellargraph_703", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li)\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li)\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == '???')\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "ground_truth": "pytest.approx(0.5, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Inference"}
{"task_id": "stellargraph_704", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li)\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    print(\"link inference with 'ip' operator on unit vector: \", li)\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == '???')", "ground_truth": "pytest.approx(0.7310586, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Inference"}
{"task_id": "stellargraph_706", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    assert (li.numpy()[(0, 0)] == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    assert (li.numpy() == '???')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    assert (li.numpy()[(0, 0)] == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "ground_truth": "pytest.approx(0, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Classification"}
{"task_id": "stellargraph_707", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    assert (li.numpy()[(0, 0)] == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    assert (li.numpy()[(0, 0)] == '???')\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "ground_truth": "pytest.approx(1, abs=1.5e-07)", "quality_analysis": {"complexity_score": 14, "left_complexity": 10, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Classification"}
{"task_id": "stellargraph_708", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    assert (li.numpy()[(0, 0)] == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    assert (li.numpy()[(0, 0)] == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == '???')\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "ground_truth": "pytest.approx(0.5, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Classification"}
{"task_id": "stellargraph_709", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    assert (li.numpy()[(0, 0)] == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src, x_src])\n    assert (li.numpy()[(0, 0)] == pytest.approx(1, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_dst])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src, x_src])\n    assert (li.numpy() == '???')", "ground_truth": "pytest.approx(0.7310586, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Classification"}
{"task_id": "stellargraph_711", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    expected = np.dot(x_src, x_dst)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_regression(edge_embedding_method='ip')([x_src, x_dst])\n    print(\"link regression with 'ip' operator on orthonormal vectors: {}, expected: {}\".format(li, expected))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_regression(edge_embedding_method='ip')([x_src, x_src])\n    print(\"link regression with 'ip' operator on unit vector: \", li)\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    expected = np.dot(x_src, x_dst)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_regression(edge_embedding_method='ip')([x_src, x_dst])\n    print(\"link regression with 'ip' operator on orthonormal vectors: {}, expected: {}\".format(li, expected))\n    assert (li.numpy() == '???')\n    li = link_regression(edge_embedding_method='ip')([x_src, x_src])\n    print(\"link regression with 'ip' operator on unit vector: \", li)\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))", "ground_truth": "pytest.approx(0, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Regression"}
{"task_id": "stellargraph_712", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    expected = np.dot(x_src, x_dst)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_regression(edge_embedding_method='ip')([x_src, x_dst])\n    print(\"link regression with 'ip' operator on orthonormal vectors: {}, expected: {}\".format(li, expected))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_regression(edge_embedding_method='ip')([x_src, x_src])\n    print(\"link regression with 'ip' operator on unit vector: \", li)\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    expected = np.dot(x_src, x_dst)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_regression(edge_embedding_method='ip')([x_src, x_dst])\n    print(\"link regression with 'ip' operator on orthonormal vectors: {}, expected: {}\".format(li, expected))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_regression(edge_embedding_method='ip')([x_src, x_src])\n    print(\"link regression with 'ip' operator on unit vector: \", li)\n    assert (li.numpy() == '???')", "ground_truth": "pytest.approx(1, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Regression"}
{"task_id": "stellargraph_693", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip_single_tensor", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src, x_dst], axis=1)\n    x_link_ss = tf.stack([x_src, x_src], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src, x_dst], axis=1)\n    x_link_ss = tf.stack([x_src, x_src], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == '???')\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "ground_truth": "pytest.approx(0, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_694", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip_single_tensor", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src, x_dst], axis=1)\n    x_link_ss = tf.stack([x_src, x_src], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src, x_dst], axis=1)\n    x_link_ss = tf.stack([x_src, x_src], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == '???')\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "ground_truth": "pytest.approx(1, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_695", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip_single_tensor", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src, x_dst], axis=1)\n    x_link_ss = tf.stack([x_src, x_src], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src, x_dst], axis=1)\n    x_link_ss = tf.stack([x_src, x_src], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == '???')\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "ground_truth": "pytest.approx(0.5, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_696", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip_single_tensor", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src, x_dst], axis=1)\n    x_link_ss = tf.stack([x_src, x_src], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.7310586, abs=1.5e-07))", "masked_code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on orthogonal vectors\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src, x_dst], axis=1)\n    x_link_ss = tf.stack([x_src, x_src], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    print(\"link inference with 'ip' operator on orthonormal vectors: {}\".format(li.numpy()))\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    print(\"link inference with 'ip' operator on unit vector: \", li.numpy())\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == '???')", "ground_truth": "pytest.approx(0.7310586, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_697", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, 1, self.d)\n    x_dst = x_dst.reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, 1, self.d))\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, 1, (2 * self.d)))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, 1, self.d)\n    x_dst = x_dst.reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, 1, (2 * self.d)))\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, 1, self.d)", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_698", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, 1, self.d)\n    x_dst = x_dst.reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, 1, self.d))\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, 1, (2 * self.d)))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, 1, self.d)\n    x_dst = x_dst.reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, 1, self.d))\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, 1, (2 * self.d))", "quality_analysis": {"complexity_score": 11, "left_complexity": 2, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_705", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, 1, self.d)\n    x_dst = x_dst.reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_inference(output_dim=self.d_out, edge_embedding_method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        print(x_src.shape)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, self.d_out))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, 1, self.d)\n    x_dst = x_dst.reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_inference(output_dim=self.d_out, edge_embedding_method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        print(x_src.shape)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, self.d_out)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Inference"}
{"task_id": "stellargraph_710", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, 1, self.d)\n    x_dst = x_dst.reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_classification(output_dim=self.d_out, edge_embedding_method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link classification with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, self.d_out))\n        assert isinstance(res.flatten()[0], np.float32)\n        assert all((res.flatten() >= 0))\n        assert all((res.flatten() <= 1))", "masked_code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, 1, self.d)\n    x_dst = x_dst.reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_classification(output_dim=self.d_out, edge_embedding_method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link classification with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)\n        assert all((res.flatten() >= 0))\n        assert all((res.flatten() <= 1))", "ground_truth": "(1, self.d_out)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Classification"}
{"task_id": "stellargraph_713", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, 1, self.d)\n    x_dst = x_dst.reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_regression(output_dim=self.d_out, edge_embedding_method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link regression with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, self.d_out))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, 1, self.d)\n    x_dst = x_dst.reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_regression(output_dim=self.d_out, edge_embedding_method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        print(\"link regression with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, self.d_out)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Regression"}
{"task_id": "stellargraph_699", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg_single_tensor", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg_single_tensor(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, self.d)\n    x_dst = x_dst.reshape(1, self.d)\n    x_link_np = np.stack([x_src, x_dst], axis=1)\n    x_link = keras.Input(shape=(2, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, self.d))\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, (2 * self.d)))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_mul_l1_l2_avg_single_tensor(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, self.d)\n    x_dst = x_dst.reshape(1, self.d)\n    x_link_np = np.stack([x_src, x_dst], axis=1)\n    x_link = keras.Input(shape=(2, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, (2 * self.d)))\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, self.d)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_700", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg_single_tensor", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg_single_tensor(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, self.d)\n    x_dst = x_dst.reshape(1, self.d)\n    x_link_np = np.stack([x_src, x_dst], axis=1)\n    x_link = keras.Input(shape=(2, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, self.d))\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, (2 * self.d)))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_mul_l1_l2_avg_single_tensor(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg'\"\n    (x_src, x_dst) = make_orthonormal_vectors(self.d)\n    x_src = x_src.reshape(1, self.d)\n    x_dst = x_dst.reshape(1, self.d)\n    x_link_np = np.stack([x_src, x_dst], axis=1)\n    x_link = keras.Input(shape=(2, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == (1, self.d))\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        print(\"link inference with '{}' operator: {}\".format(op, res.flatten()))\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, (2 * self.d))", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_42", "reponame": "stellargraph", "testpath": "tests/test_losses.py", "testname": "test_losses.py", "funcname": "test_self_adversarial_negative_sampling", "imports": ["from stellargraph.losses import *", "import numpy as np", "import pytest", "import tensorflow as tf", "from scipy.special import softmax, expit"], "code": "@pytest.mark.parametrize('temperature', [0.0, 0.5, 1.0, 2.0])\ndef test_self_adversarial_negative_sampling(temperature):\n    labels = np.array([1, 0, (- 2), 0, 1], dtype=np.int32)\n    logit_scores = np.array([1.2, (- 2.3), 0.0, 4.5, (- 0.67)], dtype=np.float32)\n    scores = expit(logit_scores)\n    loss_func = SelfAdversarialNegativeSampling(temperature)\n    actual_loss = loss_func(tf.constant(labels), tf.constant(logit_scores))\n\n    def loss_part(score, label):\n        if (label == 1):\n            return (- np.log(score))\n        relevant = scores[np.where((labels == label))]\n        numer = np.exp((temperature * score))\n        denom = np.sum(np.exp((temperature * relevant)))\n        return (((- np.log((1 - score))) * numer) / denom)\n    expected_loss = np.mean([loss_part(score, label) for (score, label) in zip(scores, labels)])\n    assert (actual_loss.numpy() == pytest.approx(expected_loss, rel=1e-06))", "masked_code": "@pytest.mark.parametrize('temperature', [0.0, 0.5, 1.0, 2.0])\ndef test_self_adversarial_negative_sampling(temperature):\n    labels = np.array([1, 0, (- 2), 0, 1], dtype=np.int32)\n    logit_scores = np.array([1.2, (- 2.3), 0.0, 4.5, (- 0.67)], dtype=np.float32)\n    scores = expit(logit_scores)\n    loss_func = SelfAdversarialNegativeSampling(temperature)\n    actual_loss = loss_func(tf.constant(labels), tf.constant(logit_scores))\n\n    def loss_part(score, label):\n        if (label == 1):\n            return (- np.log(score))\n        relevant = scores[np.where((labels == label))]\n        numer = np.exp((temperature * score))\n        denom = np.sum(np.exp((temperature * relevant)))\n        return (((- np.log((1 - score))) * numer) / denom)\n    expected_loss = np.mean([loss_part(score, label) for (score, label) in zip(scores, labels)])\n    assert (actual_loss.numpy() == '???')", "ground_truth": "pytest.approx(expected_loss, rel=1e-06)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1029", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_flow_StellarGraphs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_flow_StellarGraphs():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    graph_ilocs = [1, 2, 0]\n    seq_1 = generator.flow(graph_ilocs)\n    seq_2 = generator.flow([graphs[1], graphs[2], graphs[0]])\n    assert (len(seq_1) == len(seq_2) == 3)\n    for ((values_1, targets_1), (values_2, targets_2)) in zip(seq_1, seq_2):\n        assert (len(values_1) == len(values_2) == 3)\n        assert (targets_1 is targets_2 is None)\n        for (arr_1, arr_2) in zip(values_1, values_2):\n            np.testing.assert_array_equal(arr_1, arr_2)", "masked_code": "def test_generator_flow_StellarGraphs():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    graph_ilocs = [1, 2, 0]\n    seq_1 = generator.flow(graph_ilocs)\n    seq_2 = generator.flow([graphs[1], graphs[2], graphs[0]])\n    assert (len(seq_1) == '???' == 3)\n    for ((values_1, targets_1), (values_2, targets_2)) in zip(seq_1, seq_2):\n        assert (len(values_1) == len(values_2) == 3)\n        assert (targets_1 is targets_2 is None)\n        for (arr_1, arr_2) in zip(values_1, values_2):\n            np.testing.assert_array_equal(arr_1, arr_2)", "ground_truth": "len(seq_2)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1030", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_flow_StellarGraphs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_flow_StellarGraphs():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    graph_ilocs = [1, 2, 0]\n    seq_1 = generator.flow(graph_ilocs)\n    seq_2 = generator.flow([graphs[1], graphs[2], graphs[0]])\n    assert (len(seq_1) == len(seq_2) == 3)\n    for ((values_1, targets_1), (values_2, targets_2)) in zip(seq_1, seq_2):\n        assert (len(values_1) == len(values_2) == 3)\n        assert (targets_1 is targets_2 is None)\n        for (arr_1, arr_2) in zip(values_1, values_2):\n            np.testing.assert_array_equal(arr_1, arr_2)", "masked_code": "def test_generator_flow_StellarGraphs():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    graph_ilocs = [1, 2, 0]\n    seq_1 = generator.flow(graph_ilocs)\n    seq_2 = generator.flow([graphs[1], graphs[2], graphs[0]])\n    assert (len(seq_1) == len(seq_2) == 3)\n    for ((values_1, targets_1), (values_2, targets_2)) in zip(seq_1, seq_2):\n        assert (len(values_1) == '???' == 3)\n        assert (targets_1 is targets_2 is None)\n        for (arr_1, arr_2) in zip(values_1, values_2):\n            np.testing.assert_array_equal(arr_1, arr_2)", "ground_truth": "len(values_2)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1026", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_flow_check_padding", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_flow_check_padding():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 2], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    batch = seq[0]\n    assert (batch[0][0].shape == (2, 6, 4))\n    assert (batch[0][1].shape == (2, 6))\n    assert (batch[0][2].shape == (2, 6, 6))\n    for mask in batch[0][1]:\n        assert ((np.sum(mask) == 6) or (np.sum(mask) == 3))", "masked_code": "def test_generator_flow_check_padding():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 2], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    batch = seq[0]\n    assert (batch[0][0].shape == '???')\n    assert (batch[0][1].shape == (2, 6))\n    assert (batch[0][2].shape == (2, 6, 6))\n    for mask in batch[0][1]:\n        assert ((np.sum(mask) == 6) or (np.sum(mask) == 3))", "ground_truth": "(2, 6, 4)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1027", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_flow_check_padding", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_flow_check_padding():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 2], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    batch = seq[0]\n    assert (batch[0][0].shape == (2, 6, 4))\n    assert (batch[0][1].shape == (2, 6))\n    assert (batch[0][2].shape == (2, 6, 6))\n    for mask in batch[0][1]:\n        assert ((np.sum(mask) == 6) or (np.sum(mask) == 3))", "masked_code": "def test_generator_flow_check_padding():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 2], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    batch = seq[0]\n    assert (batch[0][0].shape == (2, 6, 4))\n    assert (batch[0][1].shape == '???')\n    assert (batch[0][2].shape == (2, 6, 6))\n    for mask in batch[0][1]:\n        assert ((np.sum(mask) == 6) or (np.sum(mask) == 3))", "ground_truth": "(2, 6)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1028", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_flow_check_padding", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_flow_check_padding():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 2], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    batch = seq[0]\n    assert (batch[0][0].shape == (2, 6, 4))\n    assert (batch[0][1].shape == (2, 6))\n    assert (batch[0][2].shape == (2, 6, 6))\n    for mask in batch[0][1]:\n        assert ((np.sum(mask) == 6) or (np.sum(mask) == 3))", "masked_code": "def test_generator_flow_check_padding():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 2], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    batch = seq[0]\n    assert (batch[0][0].shape == (2, 6, 4))\n    assert (batch[0][1].shape == (2, 6))\n    assert (batch[0][2].shape == '???')\n    for mask in batch[0][1]:\n        assert ((np.sum(mask) == 6) or (np.sum(mask) == 3))", "ground_truth": "(2, 6, 6)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1024", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_flow_no_targets", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_flow_no_targets():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 1, 2], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 2)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 3)\n    assert (values_0[0].shape[0] == 2)\n    assert (values_0[1].shape[0] == 2)\n    assert (values_0[2].shape[0] == 2)\n    assert (targets_0 is None)\n    (values_1, targets_1) = seq[1]\n    assert (len(values_1) == 3)\n    assert (values_1[0].shape[0] == 1)\n    assert (values_1[1].shape[0] == 1)\n    assert (values_1[2].shape[0] == 1)\n    assert (targets_1 is None)", "masked_code": "def test_generator_flow_no_targets():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 1, 2], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 2)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == '???')\n    assert (values_0[0].shape[0] == 2)\n    assert (values_0[1].shape[0] == 2)\n    assert (values_0[2].shape[0] == 2)\n    assert (targets_0 is None)\n    (values_1, targets_1) = seq[1]\n    assert (len(values_1) == 3)\n    assert (values_1[0].shape[0] == 1)\n    assert (values_1[1].shape[0] == 1)\n    assert (values_1[2].shape[0] == 1)\n    assert (targets_1 is None)", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1023", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_init", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_init():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    assert (len(generator.graphs) == len(graphs))", "masked_code": "def test_generator_init():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    assert (len(generator.graphs) == '???')", "ground_truth": "len(graphs)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1031", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_pairs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([12, 34, 56] if use_targets else None)\n    ilocs = [(1, 0), (0, 2), (2, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 2)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 6, 4))\n    assert (values_0[3].shape == (2, 6, 4))\n    np.testing.assert_array_equal(values_0[1], [_mask(5, 6), _mask(6, 6)])\n    np.testing.assert_array_equal(values_0[4], [_mask(6, 6), _mask(3, 6)])\n    assert (values_0[2].shape == (2, 6, 6))\n    assert (values_0[5].shape == (2, 6, 6))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [12, 34])\n    else:\n        assert (targets_0 is None)\n    (values_1, targets_1) = seq[1]\n    assert (len(values_1) == 6)\n    assert (values_1[0].shape == (1, 5, 4))\n    assert (values_1[3].shape == (1, 5, 4))\n    np.testing.assert_array_equal(values_1[1], [_mask(3, 5)])\n    np.testing.assert_array_equal(values_1[4], [_mask(5, 5)])\n    assert (values_1[2].shape == (1, 5, 5))\n    assert (values_1[5].shape == (1, 5, 5))\n    if use_targets:\n        np.testing.assert_array_equal(targets_1, [56])\n    else:\n        assert (targets_1 is None)", "masked_code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([12, 34, 56] if use_targets else None)\n    ilocs = [(1, 0), (0, 2), (2, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 2)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == '???')\n    assert (values_0[0].shape == (2, 6, 4))\n    assert (values_0[3].shape == (2, 6, 4))\n    np.testing.assert_array_equal(values_0[1], [_mask(5, 6), _mask(6, 6)])\n    np.testing.assert_array_equal(values_0[4], [_mask(6, 6), _mask(3, 6)])\n    assert (values_0[2].shape == (2, 6, 6))\n    assert (values_0[5].shape == (2, 6, 6))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [12, 34])\n    else:\n        assert (targets_0 is None)\n    (values_1, targets_1) = seq[1]\n    assert (len(values_1) == 6)\n    assert (values_1[0].shape == (1, 5, 4))\n    assert (values_1[3].shape == (1, 5, 4))\n    np.testing.assert_array_equal(values_1[1], [_mask(3, 5)])\n    np.testing.assert_array_equal(values_1[4], [_mask(5, 5)])\n    assert (values_1[2].shape == (1, 5, 5))\n    assert (values_1[5].shape == (1, 5, 5))\n    if use_targets:\n        np.testing.assert_array_equal(targets_1, [56])\n    else:\n        assert (targets_1 is None)", "ground_truth": "6", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1032", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_pairs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([12, 34, 56] if use_targets else None)\n    ilocs = [(1, 0), (0, 2), (2, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 2)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 6, 4))\n    assert (values_0[3].shape == (2, 6, 4))\n    np.testing.assert_array_equal(values_0[1], [_mask(5, 6), _mask(6, 6)])\n    np.testing.assert_array_equal(values_0[4], [_mask(6, 6), _mask(3, 6)])\n    assert (values_0[2].shape == (2, 6, 6))\n    assert (values_0[5].shape == (2, 6, 6))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [12, 34])\n    else:\n        assert (targets_0 is None)\n    (values_1, targets_1) = seq[1]\n    assert (len(values_1) == 6)\n    assert (values_1[0].shape == (1, 5, 4))\n    assert (values_1[3].shape == (1, 5, 4))\n    np.testing.assert_array_equal(values_1[1], [_mask(3, 5)])\n    np.testing.assert_array_equal(values_1[4], [_mask(5, 5)])\n    assert (values_1[2].shape == (1, 5, 5))\n    assert (values_1[5].shape == (1, 5, 5))\n    if use_targets:\n        np.testing.assert_array_equal(targets_1, [56])\n    else:\n        assert (targets_1 is None)", "masked_code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([12, 34, 56] if use_targets else None)\n    ilocs = [(1, 0), (0, 2), (2, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 2)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == '???')\n    assert (values_0[3].shape == (2, 6, 4))\n    np.testing.assert_array_equal(values_0[1], [_mask(5, 6), _mask(6, 6)])\n    np.testing.assert_array_equal(values_0[4], [_mask(6, 6), _mask(3, 6)])\n    assert (values_0[2].shape == (2, 6, 6))\n    assert (values_0[5].shape == (2, 6, 6))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [12, 34])\n    else:\n        assert (targets_0 is None)\n    (values_1, targets_1) = seq[1]\n    assert (len(values_1) == 6)\n    assert (values_1[0].shape == (1, 5, 4))\n    assert (values_1[3].shape == (1, 5, 4))\n    np.testing.assert_array_equal(values_1[1], [_mask(3, 5)])\n    np.testing.assert_array_equal(values_1[4], [_mask(5, 5)])\n    assert (values_1[2].shape == (1, 5, 5))\n    assert (values_1[5].shape == (1, 5, 5))\n    if use_targets:\n        np.testing.assert_array_equal(targets_1, [56])\n    else:\n        assert (targets_1 is None)", "ground_truth": "(2, 6, 4)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1033", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_pairs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([12, 34, 56] if use_targets else None)\n    ilocs = [(1, 0), (0, 2), (2, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 2)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 6, 4))\n    assert (values_0[3].shape == (2, 6, 4))\n    np.testing.assert_array_equal(values_0[1], [_mask(5, 6), _mask(6, 6)])\n    np.testing.assert_array_equal(values_0[4], [_mask(6, 6), _mask(3, 6)])\n    assert (values_0[2].shape == (2, 6, 6))\n    assert (values_0[5].shape == (2, 6, 6))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [12, 34])\n    else:\n        assert (targets_0 is None)\n    (values_1, targets_1) = seq[1]\n    assert (len(values_1) == 6)\n    assert (values_1[0].shape == (1, 5, 4))\n    assert (values_1[3].shape == (1, 5, 4))\n    np.testing.assert_array_equal(values_1[1], [_mask(3, 5)])\n    np.testing.assert_array_equal(values_1[4], [_mask(5, 5)])\n    assert (values_1[2].shape == (1, 5, 5))\n    assert (values_1[5].shape == (1, 5, 5))\n    if use_targets:\n        np.testing.assert_array_equal(targets_1, [56])\n    else:\n        assert (targets_1 is None)", "masked_code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([12, 34, 56] if use_targets else None)\n    ilocs = [(1, 0), (0, 2), (2, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 2)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 6, 4))\n    assert (values_0[3].shape == '???')\n    np.testing.assert_array_equal(values_0[1], [_mask(5, 6), _mask(6, 6)])\n    np.testing.assert_array_equal(values_0[4], [_mask(6, 6), _mask(3, 6)])\n    assert (values_0[2].shape == (2, 6, 6))\n    assert (values_0[5].shape == (2, 6, 6))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [12, 34])\n    else:\n        assert (targets_0 is None)\n    (values_1, targets_1) = seq[1]\n    assert (len(values_1) == 6)\n    assert (values_1[0].shape == (1, 5, 4))\n    assert (values_1[3].shape == (1, 5, 4))\n    np.testing.assert_array_equal(values_1[1], [_mask(3, 5)])\n    np.testing.assert_array_equal(values_1[4], [_mask(5, 5)])\n    assert (values_1[2].shape == (1, 5, 5))\n    assert (values_1[5].shape == (1, 5, 5))\n    if use_targets:\n        np.testing.assert_array_equal(targets_1, [56])\n    else:\n        assert (targets_1 is None)", "ground_truth": "(2, 6, 4)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1034", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_pairs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([12, 34, 56] if use_targets else None)\n    ilocs = [(1, 0), (0, 2), (2, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 2)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 6, 4))\n    assert (values_0[3].shape == (2, 6, 4))\n    np.testing.assert_array_equal(values_0[1], [_mask(5, 6), _mask(6, 6)])\n    np.testing.assert_array_equal(values_0[4], [_mask(6, 6), _mask(3, 6)])\n    assert (values_0[2].shape == (2, 6, 6))\n    assert (values_0[5].shape == (2, 6, 6))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [12, 34])\n    else:\n        assert (targets_0 is None)\n    (values_1, targets_1) = seq[1]\n    assert (len(values_1) == 6)\n    assert (values_1[0].shape == (1, 5, 4))\n    assert (values_1[3].shape == (1, 5, 4))\n    np.testing.assert_array_equal(values_1[1], [_mask(3, 5)])\n    np.testing.assert_array_equal(values_1[4], [_mask(5, 5)])\n    assert (values_1[2].shape == (1, 5, 5))\n    assert (values_1[5].shape == (1, 5, 5))\n    if use_targets:\n        np.testing.assert_array_equal(targets_1, [56])\n    else:\n        assert (targets_1 is None)", "masked_code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([12, 34, 56] if use_targets else None)\n    ilocs = [(1, 0), (0, 2), (2, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 2)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 6, 4))\n    assert (values_0[3].shape == (2, 6, 4))\n    np.testing.assert_array_equal(values_0[1], [_mask(5, 6), _mask(6, 6)])\n    np.testing.assert_array_equal(values_0[4], [_mask(6, 6), _mask(3, 6)])\n    assert (values_0[2].shape == '???')\n    assert (values_0[5].shape == (2, 6, 6))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [12, 34])\n    else:\n        assert (targets_0 is None)\n    (values_1, targets_1) = seq[1]\n    assert (len(values_1) == 6)\n    assert (values_1[0].shape == (1, 5, 4))\n    assert (values_1[3].shape == (1, 5, 4))\n    np.testing.assert_array_equal(values_1[1], [_mask(3, 5)])\n    np.testing.assert_array_equal(values_1[4], [_mask(5, 5)])\n    assert (values_1[2].shape == (1, 5, 5))\n    assert (values_1[5].shape == (1, 5, 5))\n    if use_targets:\n        np.testing.assert_array_equal(targets_1, [56])\n    else:\n        assert (targets_1 is None)", "ground_truth": "(2, 6, 6)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1035", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_pairs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([12, 34, 56] if use_targets else None)\n    ilocs = [(1, 0), (0, 2), (2, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 2)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 6, 4))\n    assert (values_0[3].shape == (2, 6, 4))\n    np.testing.assert_array_equal(values_0[1], [_mask(5, 6), _mask(6, 6)])\n    np.testing.assert_array_equal(values_0[4], [_mask(6, 6), _mask(3, 6)])\n    assert (values_0[2].shape == (2, 6, 6))\n    assert (values_0[5].shape == (2, 6, 6))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [12, 34])\n    else:\n        assert (targets_0 is None)\n    (values_1, targets_1) = seq[1]\n    assert (len(values_1) == 6)\n    assert (values_1[0].shape == (1, 5, 4))\n    assert (values_1[3].shape == (1, 5, 4))\n    np.testing.assert_array_equal(values_1[1], [_mask(3, 5)])\n    np.testing.assert_array_equal(values_1[4], [_mask(5, 5)])\n    assert (values_1[2].shape == (1, 5, 5))\n    assert (values_1[5].shape == (1, 5, 5))\n    if use_targets:\n        np.testing.assert_array_equal(targets_1, [56])\n    else:\n        assert (targets_1 is None)", "masked_code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([12, 34, 56] if use_targets else None)\n    ilocs = [(1, 0), (0, 2), (2, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 2)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 6, 4))\n    assert (values_0[3].shape == (2, 6, 4))\n    np.testing.assert_array_equal(values_0[1], [_mask(5, 6), _mask(6, 6)])\n    np.testing.assert_array_equal(values_0[4], [_mask(6, 6), _mask(3, 6)])\n    assert (values_0[2].shape == (2, 6, 6))\n    assert (values_0[5].shape == '???')\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [12, 34])\n    else:\n        assert (targets_0 is None)\n    (values_1, targets_1) = seq[1]\n    assert (len(values_1) == 6)\n    assert (values_1[0].shape == (1, 5, 4))\n    assert (values_1[3].shape == (1, 5, 4))\n    np.testing.assert_array_equal(values_1[1], [_mask(3, 5)])\n    np.testing.assert_array_equal(values_1[4], [_mask(5, 5)])\n    assert (values_1[2].shape == (1, 5, 5))\n    assert (values_1[5].shape == (1, 5, 5))\n    if use_targets:\n        np.testing.assert_array_equal(targets_1, [56])\n    else:\n        assert (targets_1 is None)", "ground_truth": "(2, 6, 6)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_757", "reponame": "stellargraph", "testpath": "tests/layer/test_watch_your_step.py", "testname": "test_watch_your_step.py", "funcname": "test_AttentiveWalk_config", "imports": ["from stellargraph.layer import AttentiveWalk, WatchYourStep", "import numpy as np", "from ..test_utils.graphs import barbell", "from stellargraph.mapper import AdjacencyPowerGenerator", "from stellargraph.losses import graph_log_likelihood", "import pytest", "from tensorflow.keras import Model", "from .. import test_utils"], "code": "def test_AttentiveWalk_config():\n    att_wlk = AttentiveWalk(walk_length=10)\n    conf = att_wlk.get_config()\n    assert (conf['walk_length'] == 10)\n    assert (conf['attention_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['attention_regularizer'] is None)\n    assert (conf['attention_constraint'] is None)", "masked_code": "def test_AttentiveWalk_config():\n    att_wlk = AttentiveWalk(walk_length=10)\n    conf = att_wlk.get_config()\n    assert (conf['walk_length'] == '???')\n    assert (conf['attention_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['attention_regularizer'] is None)\n    assert (conf['attention_constraint'] is None)", "ground_truth": "10", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_763", "reponame": "stellargraph", "testpath": "tests/layer/test_watch_your_step.py", "testname": "test_watch_your_step.py", "funcname": "test_WatchYourStep", "imports": ["from stellargraph.layer import AttentiveWalk, WatchYourStep", "import numpy as np", "from ..test_utils.graphs import barbell", "from stellargraph.mapper import AdjacencyPowerGenerator", "from stellargraph.losses import graph_log_likelihood", "import pytest", "from tensorflow.keras import Model", "from .. import test_utils"], "code": "@pytest.mark.parametrize('weighted', [False, True])\ndef test_WatchYourStep(barbell, weighted):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5, weighted=weighted)\n    gen = generator.flow(batch_size=4)\n    wys = WatchYourStep(generator)\n    (x_in, x_out) = wys.in_out_tensors()\n    model = Model(inputs=x_in, outputs=x_out)\n    model.compile(optimizer='adam', loss=graph_log_likelihood)\n    model.fit(gen, epochs=1, steps_per_epoch=int((len(barbell.nodes()) // 4)))\n    embs = wys.embeddings()\n    assert (embs.shape == (len(barbell.nodes()), wys.embedding_dimension))\n    preds1 = model.predict(gen, steps=8)\n    preds2 = Model(*wys.in_out_tensors()).predict(gen, steps=8)\n    np.testing.assert_array_equal(preds1, preds2)", "masked_code": "@pytest.mark.parametrize('weighted', [False, True])\ndef test_WatchYourStep(barbell, weighted):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5, weighted=weighted)\n    gen = generator.flow(batch_size=4)\n    wys = WatchYourStep(generator)\n    (x_in, x_out) = wys.in_out_tensors()\n    model = Model(inputs=x_in, outputs=x_out)\n    model.compile(optimizer='adam', loss=graph_log_likelihood)\n    model.fit(gen, epochs=1, steps_per_epoch=int((len(barbell.nodes()) // 4)))\n    embs = wys.embeddings()\n    assert (embs.shape == '???')\n    preds1 = model.predict(gen, steps=8)\n    preds2 = Model(*wys.in_out_tensors()).predict(gen, steps=8)\n    np.testing.assert_array_equal(preds1, preds2)", "ground_truth": "(len(barbell.nodes()), wys.embedding_dimension)", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_759", "reponame": "stellargraph", "testpath": "tests/layer/test_watch_your_step.py", "testname": "test_watch_your_step.py", "funcname": "test_WatchYourStep_init", "imports": ["from stellargraph.layer import AttentiveWalk, WatchYourStep", "import numpy as np", "from ..test_utils.graphs import barbell", "from stellargraph.mapper import AdjacencyPowerGenerator", "from stellargraph.losses import graph_log_likelihood", "import pytest", "from tensorflow.keras import Model", "from .. import test_utils"], "code": "def test_WatchYourStep_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    wys = WatchYourStep(generator)\n    assert (wys.num_powers == 5)\n    assert (wys.n_nodes == len(barbell.nodes()))\n    assert (wys.num_walks == 80)\n    assert (wys.embedding_dimension == 64)", "masked_code": "def test_WatchYourStep_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    wys = WatchYourStep(generator)\n    assert (wys.num_powers == '???')\n    assert (wys.n_nodes == len(barbell.nodes()))\n    assert (wys.num_walks == 80)\n    assert (wys.embedding_dimension == 64)", "ground_truth": "5", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_760", "reponame": "stellargraph", "testpath": "tests/layer/test_watch_your_step.py", "testname": "test_watch_your_step.py", "funcname": "test_WatchYourStep_init", "imports": ["from stellargraph.layer import AttentiveWalk, WatchYourStep", "import numpy as np", "from ..test_utils.graphs import barbell", "from stellargraph.mapper import AdjacencyPowerGenerator", "from stellargraph.losses import graph_log_likelihood", "import pytest", "from tensorflow.keras import Model", "from .. import test_utils"], "code": "def test_WatchYourStep_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    wys = WatchYourStep(generator)\n    assert (wys.num_powers == 5)\n    assert (wys.n_nodes == len(barbell.nodes()))\n    assert (wys.num_walks == 80)\n    assert (wys.embedding_dimension == 64)", "masked_code": "def test_WatchYourStep_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    wys = WatchYourStep(generator)\n    assert (wys.num_powers == 5)\n    assert (wys.n_nodes == '???')\n    assert (wys.num_walks == 80)\n    assert (wys.embedding_dimension == 64)", "ground_truth": "len(barbell.nodes())", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_761", "reponame": "stellargraph", "testpath": "tests/layer/test_watch_your_step.py", "testname": "test_watch_your_step.py", "funcname": "test_WatchYourStep_init", "imports": ["from stellargraph.layer import AttentiveWalk, WatchYourStep", "import numpy as np", "from ..test_utils.graphs import barbell", "from stellargraph.mapper import AdjacencyPowerGenerator", "from stellargraph.losses import graph_log_likelihood", "import pytest", "from tensorflow.keras import Model", "from .. import test_utils"], "code": "def test_WatchYourStep_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    wys = WatchYourStep(generator)\n    assert (wys.num_powers == 5)\n    assert (wys.n_nodes == len(barbell.nodes()))\n    assert (wys.num_walks == 80)\n    assert (wys.embedding_dimension == 64)", "masked_code": "def test_WatchYourStep_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=5)\n    wys = WatchYourStep(generator)\n    assert (wys.num_powers == 5)\n    assert (wys.n_nodes == len(barbell.nodes()))\n    assert (wys.num_walks == '???')\n    assert (wys.embedding_dimension == 64)", "ground_truth": "80", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
