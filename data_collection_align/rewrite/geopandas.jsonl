{"task_id": "geopandas_15", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_column_order", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_column_order(tmpdir, file_format, naturalearth_lowres):\n    (reader, writer) = file_format\n    df = read_file(naturalearth_lowres)\n    df = df.set_index('iso_a3')\n    df['geom2'] = df.geometry.representative_point()\n    df['float_col'] = np.linspace(0, 1, len(df))\n    custom_column_order = ['iso_a3', 'float_col', 'geom2', 'pop_est', 'continent', 'geometry', 'gdp_md_est', 'name']\n    table = _geopandas_to_arrow(df)\n    table = table.select(custom_column_order)\n    if (reader is read_parquet):\n        filename = os.path.join(str(tmpdir), 'test_column_order.pq')\n        pq.write_table(table, filename)\n    else:\n        filename = os.path.join(str(tmpdir), 'test_column_order.feather')\n        feather.write_feather(table, filename)\n    result = reader(filename)\n    assert (list(result.columns) == custom_column_order[1:])\n    assert_geodataframe_equal(result, df[custom_column_order[1:]])", "masked_code": "def test_column_order(tmpdir, file_format, naturalearth_lowres):\n    (reader, writer) = file_format\n    df = read_file(naturalearth_lowres)\n    df = df.set_index('iso_a3')\n    df['geom2'] = df.geometry.representative_point()\n    df['float_col'] = np.linspace(0, 1, len(df))\n    custom_column_order = ['iso_a3', 'float_col', 'geom2', 'pop_est', 'continent', 'geometry', 'gdp_md_est', 'name']\n    table = _geopandas_to_arrow(df)\n    table = table.select(custom_column_order)\n    if (reader is read_parquet):\n        filename = os.path.join(str(tmpdir), 'test_column_order.pq')\n        pq.write_table(table, filename)\n    else:\n        filename = os.path.join(str(tmpdir), 'test_column_order.feather')\n        feather.write_feather(table, filename)\n    result = reader(filename)\n    assert (list(result.columns) == '???')\n    assert_geodataframe_equal(result, df[custom_column_order[1:]])", "ground_truth": "custom_column_order[1:]", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_0", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == '???')\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "METADATA_VERSION", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_1", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == '???')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "'geometry'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_2", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == '???')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "'WKB'", "quality_analysis": {"complexity_score": 14, "left_complexity": 13, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_3", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == '???')\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "expected_types", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_4", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == '???')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "'geopandas'", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_5", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == '???')\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "geopandas.__version__", "quality_analysis": {"complexity_score": 11, "left_complexity": 9, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_6", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '???')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "'1.1.0'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_7", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == '???')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "'point'", "quality_analysis": {"complexity_score": 14, "left_complexity": 13, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_8", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == '???')", "ground_truth": "'WKB'", "quality_analysis": {"complexity_score": 14, "left_complexity": 13, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_9", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "masked_code": "def test_create_metadata(naturalearth_lowres):\n    df = geopandas.GeoDataFrame({'name': ['empty', 'neg', 'large', 'float'], 'geometry': [Polygon([]), Point((- 1000), (- 2000)), box((- 1000000.0), (- 1000000.0), 1000000.0, 1000000.0), LineString([(0.1, 0.5), (1.3, 2.6)])]})\n    df.crs = 'EPSG:4326'\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert isinstance(metadata, dict)\n    assert (metadata['version'] == METADATA_VERSION)\n    assert (metadata['primary_column'] == 'geometry')\n    assert ('geometry' in metadata['columns'])\n    if HAS_PYPROJ:\n        crs_expected = df.crs.to_json_dict()\n        _remove_id_from_member_of_ensembles(crs_expected)\n        assert (metadata['columns']['geometry']['crs'] == '???')\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')\n    expected_types = sorted(['Polygon', 'Point', 'LineString'])\n    assert (sorted(set((t.replace(' Z', '') for t in metadata['columns']['geometry']['geometry_types']))) == expected_types)\n    assert np.allclose(metadata['columns']['geometry']['bbox'], df.geometry.total_bounds)\n    assert (metadata['creator']['library'] == 'geopandas')\n    assert (metadata['creator']['version'] == geopandas.__version__)\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'point'})\n    assert (metadata['version'] == '1.1.0')\n    assert (metadata['columns']['geometry']['encoding'] == 'point')\n    metadata = _create_metadata(df)\n    assert (metadata['columns']['geometry']['encoding'] == 'WKB')", "ground_truth": "crs_expected", "quality_analysis": {"complexity_score": 14, "left_complexity": 13, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_10", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata_with_z_geometries", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata_with_z_geometries():\n    geometry_types = ['Point Z', 'LineString Z', 'Polygon Z', 'MultiPolygon Z']\n    df = geopandas.GeoDataFrame({'geo_type': geometry_types, 'geometry': [Point(1, 2, 5), LineString([(0, 0, 0.1), (1, 1, 2.5), (2, 2, 6.6)]), Polygon([(0, 0, 1), (0, 1, 2), (1, 1, 3), (1, 0, 4)]), MultiPolygon([Polygon([(0, 0, 3), (0, 1, 4), (1, 1, 5), (1, 0, 6)]), Polygon([(0.5, 0.5, 7), (0.5, 1.5, 8), (1.5, 1.5, 9), (1.5, 0.5, 10)])])]})\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert (metadata['columns']['geometry']['geometry_types'] == ['LineString Z', 'MultiPolygon Z', 'Point Z', 'Polygon Z'])\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert all((geom_type.endswith(' Z') for geom_type in metadata['columns']['geometry']['geometry_types']))\n    metadata = _create_metadata(df.iloc[2:], geometry_encoding={'geometry': 'WKB'})\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon Z', 'Polygon Z'])", "masked_code": "def test_create_metadata_with_z_geometries():\n    geometry_types = ['Point Z', 'LineString Z', 'Polygon Z', 'MultiPolygon Z']\n    df = geopandas.GeoDataFrame({'geo_type': geometry_types, 'geometry': [Point(1, 2, 5), LineString([(0, 0, 0.1), (1, 1, 2.5), (2, 2, 6.6)]), Polygon([(0, 0, 1), (0, 1, 2), (1, 1, 3), (1, 0, 4)]), MultiPolygon([Polygon([(0, 0, 3), (0, 1, 4), (1, 1, 5), (1, 0, 6)]), Polygon([(0.5, 0.5, 7), (0.5, 1.5, 8), (1.5, 1.5, 9), (1.5, 0.5, 10)])])]})\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert (metadata['columns']['geometry']['geometry_types'] == '???')\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert all((geom_type.endswith(' Z') for geom_type in metadata['columns']['geometry']['geometry_types']))\n    metadata = _create_metadata(df.iloc[2:], geometry_encoding={'geometry': 'WKB'})\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon Z', 'Polygon Z'])", "ground_truth": "['LineString Z', 'MultiPolygon Z', 'Point Z', 'Polygon Z']", "quality_analysis": {"complexity_score": 19, "left_complexity": 13, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_11", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_create_metadata_with_z_geometries", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_create_metadata_with_z_geometries():\n    geometry_types = ['Point Z', 'LineString Z', 'Polygon Z', 'MultiPolygon Z']\n    df = geopandas.GeoDataFrame({'geo_type': geometry_types, 'geometry': [Point(1, 2, 5), LineString([(0, 0, 0.1), (1, 1, 2.5), (2, 2, 6.6)]), Polygon([(0, 0, 1), (0, 1, 2), (1, 1, 3), (1, 0, 4)]), MultiPolygon([Polygon([(0, 0, 3), (0, 1, 4), (1, 1, 5), (1, 0, 6)]), Polygon([(0.5, 0.5, 7), (0.5, 1.5, 8), (1.5, 1.5, 9), (1.5, 0.5, 10)])])]})\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert (metadata['columns']['geometry']['geometry_types'] == ['LineString Z', 'MultiPolygon Z', 'Point Z', 'Polygon Z'])\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert all((geom_type.endswith(' Z') for geom_type in metadata['columns']['geometry']['geometry_types']))\n    metadata = _create_metadata(df.iloc[2:], geometry_encoding={'geometry': 'WKB'})\n    assert (metadata['columns']['geometry']['geometry_types'] == ['MultiPolygon Z', 'Polygon Z'])", "masked_code": "def test_create_metadata_with_z_geometries():\n    geometry_types = ['Point Z', 'LineString Z', 'Polygon Z', 'MultiPolygon Z']\n    df = geopandas.GeoDataFrame({'geo_type': geometry_types, 'geometry': [Point(1, 2, 5), LineString([(0, 0, 0.1), (1, 1, 2.5), (2, 2, 6.6)]), Polygon([(0, 0, 1), (0, 1, 2), (1, 1, 3), (1, 0, 4)]), MultiPolygon([Polygon([(0, 0, 3), (0, 1, 4), (1, 1, 5), (1, 0, 6)]), Polygon([(0.5, 0.5, 7), (0.5, 1.5, 8), (1.5, 1.5, 9), (1.5, 0.5, 10)])])]})\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert (metadata['columns']['geometry']['geometry_types'] == ['LineString Z', 'MultiPolygon Z', 'Point Z', 'Polygon Z'])\n    metadata = _create_metadata(df, geometry_encoding={'geometry': 'WKB'})\n    assert all((geom_type.endswith(' Z') for geom_type in metadata['columns']['geometry']['geometry_types']))\n    metadata = _create_metadata(df.iloc[2:], geometry_encoding={'geometry': 'WKB'})\n    assert (metadata['columns']['geometry']['geometry_types'] == '???')", "ground_truth": "['MultiPolygon Z', 'Polygon Z']", "quality_analysis": {"complexity_score": 17, "left_complexity": 13, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_12", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_crs_metadata_datum_ensemble", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_crs_metadata_datum_ensemble():\n    pyproj = pytest.importorskip('pyproj')\n    crs = pyproj.CRS.from_epsg(3857)\n    crs_json = crs.to_json_dict()\n    check_ensemble = False\n    if ('datum_ensemble' in crs_json):\n        check_ensemble = True\n        assert ('id' in crs_json['datum_ensemble']['members'][0])\n    _remove_id_from_member_of_ensembles(crs_json)\n    if check_ensemble:\n        assert ('id' not in crs_json['datum_ensemble']['members'][0])\n    assert (pyproj.CRS(crs_json) == crs)", "masked_code": "def test_crs_metadata_datum_ensemble():\n    pyproj = pytest.importorskip('pyproj')\n    crs = pyproj.CRS.from_epsg(3857)\n    crs_json = crs.to_json_dict()\n    check_ensemble = False\n    if ('datum_ensemble' in crs_json):\n        check_ensemble = True\n        assert ('id' in crs_json['datum_ensemble']['members'][0])\n    _remove_id_from_member_of_ensembles(crs_json)\n    if check_ensemble:\n        assert ('id' not in crs_json['datum_ensemble']['members'][0])\n    assert (pyproj.CRS(crs_json) == '???')", "ground_truth": "crs", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_14", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_decode_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_decode_metadata():\n    metadata_str = b'{\"foo\": [99, \"bar\"], \"baz\": {\"x\": 12.5}}'\n    expected = {'foo': [99, 'bar'], 'baz': {'x': 12.5}}\n    assert (_decode_metadata(metadata_str) == expected)\n    assert (_decode_metadata(None) is None)", "masked_code": "def test_decode_metadata():\n    metadata_str = b'{\"foo\": [99, \"bar\"], \"baz\": {\"x\": 12.5}}'\n    expected = {'foo': [99, 'bar'], 'baz': {'x': 12.5}}\n    assert (_decode_metadata(metadata_str) == '???')\n    assert (_decode_metadata(None) is None)", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_13", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_encode_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_encode_metadata():\n    metadata = {'x': [1, 2, 3], 'y': 'z'}\n    expected = b'{\"x\": [1, 2, 3], \"y\": \"z\"}'\n    assert (_encode_metadata(metadata) == expected)", "masked_code": "def test_encode_metadata():\n    metadata = {'x': [1, 2, 3], 'y': 'z'}\n    expected = b'{\"x\": [1, 2, 3], \"y\": \"z\"}'\n    assert (_encode_metadata(metadata) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_25", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_bbox", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_bbox(tmpdir, naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    df = df.rename_geometry('geo_custom')\n    filename = os.path.join(str(tmpdir), 'test_bbox_new.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    pq_df = read_parquet(filename, bbox=(4, 0, 12, 18))\n    expected_names = ['Niger', 'Gabon', 'Eq. Guinea', 'Cameroon', 'Nigeria', 'Congo', 'Mali', 'France']\n    assert (set(pq_df['name'].values.tolist()) == set(expected_names))", "masked_code": "def test_read_parquet_bbox(tmpdir, naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    df = df.rename_geometry('geo_custom')\n    filename = os.path.join(str(tmpdir), 'test_bbox_new.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    pq_df = read_parquet(filename, bbox=(4, 0, 12, 18))\n    expected_names = ['Niger', 'Gabon', 'Eq. Guinea', 'Cameroon', 'Nigeria', 'Congo', 'Mali', 'France']\n    assert (set(pq_df['name'].values.tolist()) == '???')", "ground_truth": "set(expected_names)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_27", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_bbox_column_default_behaviour", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_bbox_column_default_behaviour(tmpdir, naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test_column_bbox.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    result1 = read_parquet(filename)\n    assert ('bbox' not in result1)\n    result2 = read_parquet(filename, columns=['pop_est', 'geometry'])\n    assert ('bbox' not in result2)\n    assert (set(result2.columns) == {'pop_est', 'geometry'})", "masked_code": "def test_read_parquet_bbox_column_default_behaviour(tmpdir, naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test_column_bbox.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    result1 = read_parquet(filename)\n    assert ('bbox' not in result1)\n    result2 = read_parquet(filename, columns=['pop_est', 'geometry'])\n    assert ('bbox' not in result2)\n    assert (set(result2.columns) == '???')", "ground_truth": "{'pop_est', 'geometry'}", "quality_analysis": {"complexity_score": 5, "left_complexity": 5, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_26", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_bbox_partitioned", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_bbox_partitioned(tmpdir, naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    df = df.rename_geometry('geo2')\n    basedir = (tmpdir / 'partitioned_bbox_new')\n    basedir.mkdir()\n    df[:60].to_parquet((basedir / 'dataA.parquet'), write_covering_bbox=True)\n    df[60:].to_parquet((basedir / 'dataB.parquet'), write_covering_bbox=True)\n    pq_df = read_parquet(basedir, bbox=(4, 0, 12, 18))\n    expected_names = ['Niger', 'Gabon', 'Eq. Guinea', 'Cameroon', 'Nigeria', 'Congo', 'Mali', 'France']\n    assert (set(pq_df['name'].values.tolist()) == set(expected_names))", "masked_code": "def test_read_parquet_bbox_partitioned(tmpdir, naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    df = df.rename_geometry('geo2')\n    basedir = (tmpdir / 'partitioned_bbox_new')\n    basedir.mkdir()\n    df[:60].to_parquet((basedir / 'dataA.parquet'), write_covering_bbox=True)\n    df[60:].to_parquet((basedir / 'dataB.parquet'), write_covering_bbox=True)\n    pq_df = read_parquet(basedir, bbox=(4, 0, 12, 18))\n    expected_names = ['Niger', 'Gabon', 'Eq. Guinea', 'Cameroon', 'Nigeria', 'Congo', 'Mali', 'France']\n    assert (set(pq_df['name'].values.tolist()) == '???')", "ground_truth": "set(expected_names)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_31", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_bbox_points", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_bbox_points(tmp_path):\n    df = geopandas.GeoDataFrame({'col': range(5)}, geometry=[Point((i * (- 2.5)), (i * 2.1)) for i in range(5)])\n    df.to_parquet((tmp_path / 'test_parquet_bbox_points.parquet'), geometry_encoding='geoarrow')\n    result = geopandas.read_parquet((tmp_path / 'test_parquet_bbox_points.parquet'), bbox=((- 10), 0, 0, 10.5))\n    assert (len(result) == 3)\n    result = geopandas.read_parquet((tmp_path / 'test_parquet_bbox_points.parquet'), bbox=((- 5), 8, (- 2), 8.3))\n    assert (len(result) == 1)", "masked_code": "def test_read_parquet_bbox_points(tmp_path):\n    df = geopandas.GeoDataFrame({'col': range(5)}, geometry=[Point((i * (- 2.5)), (i * 2.1)) for i in range(5)])\n    df.to_parquet((tmp_path / 'test_parquet_bbox_points.parquet'), geometry_encoding='geoarrow')\n    result = geopandas.read_parquet((tmp_path / 'test_parquet_bbox_points.parquet'), bbox=((- 10), 0, 0, 10.5))\n    assert (len(result) == '???')\n    result = geopandas.read_parquet((tmp_path / 'test_parquet_bbox_points.parquet'), bbox=((- 5), 8, (- 2), 8.3))\n    assert (len(result) == 1)", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_32", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_bbox_points", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_bbox_points(tmp_path):\n    df = geopandas.GeoDataFrame({'col': ['A', 'B', 'C', 'D', 'E']}, geometry=[Point(x, (x + 50)) for x in range((- 2), 3)])\n    df.to_parquet((tmp_path / 'test_parquet_bbox_points2.parquet'), geometry_encoding='geoarrow')\n    result = geopandas.read_parquet((tmp_path / 'test_parquet_bbox_points2.parquet'), bbox=((- 2), 48, 2, 53))\n    assert (len(result) == 5)", "masked_code": "def test_read_parquet_bbox_points(tmp_path):\n    df = geopandas.GeoDataFrame({'col': ['A', 'B', 'C', 'D', 'E']}, geometry=[Point(x, (x + 50)) for x in range((- 2), 3)])\n    df.to_parquet((tmp_path / 'test_parquet_bbox_points2.parquet'), geometry_encoding='geoarrow')\n    result = geopandas.read_parquet((tmp_path / 'test_parquet_bbox_points2.parquet'), bbox=((- 2), 48, 2, 53))\n    assert (len(result) == '???')", "ground_truth": "5", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_24", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_bbox_single_point", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_bbox_single_point(tmpdir):\n    df = GeoDataFrame(data=[[5, 6.3]], columns=['x', 'y'], geometry=[Point((- 2.5), 3.14)])\n    filename = os.path.join(str(tmpdir), 'test_single_point.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    pq_df = read_parquet(filename, bbox=((- 2.5), 3.14, (- 2.5), 3.14))\n    assert (len(pq_df) == 1)\n    assert (pq_df.geometry[0] == Point((- 2.5), 3.14))", "masked_code": "def test_read_parquet_bbox_single_point(tmpdir):\n    df = GeoDataFrame(data=[[5, 6.3]], columns=['x', 'y'], geometry=[Point((- 2.5), 3.14)])\n    filename = os.path.join(str(tmpdir), 'test_single_point.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    pq_df = read_parquet(filename, bbox=((- 2.5), 3.14, (- 2.5), 3.14))\n    assert (len(pq_df) == 1)\n    assert (pq_df.geometry[0] == '???')", "ground_truth": "Point((- 2.5), 3.14)", "quality_analysis": {"complexity_score": 13, "left_complexity": 6, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_30", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_file_with_custom_bbox_encoding_fieldname", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_file_with_custom_bbox_encoding_fieldname(tmpdir):\n    import pyarrow.parquet as pq\n    data = {'name': ['simple1', 'simple2', 'simple3'], 'geometry': [Point((- 10), 10), Point(100, 100), Point(3.3, (- 3.3))]}\n    df = GeoDataFrame(data)\n    filename = os.path.join(str(tmpdir), 'test_custom_bbox_field.pq')\n    table = _geopandas_to_arrow(df, schema_version='1.1.0', write_covering_bbox=True)\n    metadata = table.schema.metadata\n    table = table.rename_columns(['name', 'geometry', 'bbox_custom_name'])\n    geo_metadata = json.loads(metadata[b'geo'])\n    geo_metadata['columns']['geometry']['covering']['bbox'] = {'xmin': ['bbox_custom_name', 'xmin'], 'ymin': ['bbox_custom_name', 'ymin'], 'xmax': ['bbox_custom_name', 'xmax'], 'ymax': ['bbox_custom_name', 'ymax']}\n    metadata.update({b'geo': _encode_metadata(geo_metadata)})\n    table = table.replace_schema_metadata(metadata)\n    pq.write_table(table, filename)\n    pq_table = pq.read_table(filename)\n    assert ('bbox_custom_name' in pq_table.schema.names)\n    pq_df = read_parquet(filename, bbox=(2, (- 4), 4, (- 2)))\n    assert (set(pq_df['name'].values.tolist()) == {'simple3'})", "masked_code": "def test_read_parquet_file_with_custom_bbox_encoding_fieldname(tmpdir):\n    import pyarrow.parquet as pq\n    data = {'name': ['simple1', 'simple2', 'simple3'], 'geometry': [Point((- 10), 10), Point(100, 100), Point(3.3, (- 3.3))]}\n    df = GeoDataFrame(data)\n    filename = os.path.join(str(tmpdir), 'test_custom_bbox_field.pq')\n    table = _geopandas_to_arrow(df, schema_version='1.1.0', write_covering_bbox=True)\n    metadata = table.schema.metadata\n    table = table.rename_columns(['name', 'geometry', 'bbox_custom_name'])\n    geo_metadata = json.loads(metadata[b'geo'])\n    geo_metadata['columns']['geometry']['covering']['bbox'] = {'xmin': ['bbox_custom_name', 'xmin'], 'ymin': ['bbox_custom_name', 'ymin'], 'xmax': ['bbox_custom_name', 'xmax'], 'ymax': ['bbox_custom_name', 'ymax']}\n    metadata.update({b'geo': _encode_metadata(geo_metadata)})\n    table = table.replace_schema_metadata(metadata)\n    pq.write_table(table, filename)\n    pq_table = pq.read_table(filename)\n    assert ('bbox_custom_name' in pq_table.schema.names)\n    pq_df = read_parquet(filename, bbox=(2, (- 4), 4, (- 2)))\n    assert (set(pq_df['name'].values.tolist()) == '???')", "ground_truth": "{'simple3'}", "quality_analysis": {"complexity_score": 6, "left_complexity": 6, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_28", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_filters_and_bbox", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_filters_and_bbox(tmpdir, naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test_filters_bbox.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    filters = [('gdp_md_est', '<', 10000)]\n    result = read_parquet(filename, filters=filters, bbox=(0, 0, 10, 10))\n    expected_names = ['Togo']\n    assert (set(result['name'].values.tolist()) == set(expected_names))", "masked_code": "def test_read_parquet_filters_and_bbox(tmpdir, naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test_filters_bbox.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    filters = [('gdp_md_est', '<', 10000)]\n    result = read_parquet(filename, filters=filters, bbox=(0, 0, 10, 10))\n    expected_names = ['Togo']\n    assert (set(result['name'].values.tolist()) == '???')", "ground_truth": "set(expected_names)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_29", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_read_parquet_filters_without_bbox", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_read_parquet_filters_without_bbox(tmpdir, naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test_filters_no_bbox.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    filters = [('gdp_md_est', '<', 9000)]\n    result = read_parquet(filename, filters=filters)\n    expected_names = set(result['name'].values.tolist())\n    assert (set(result['name'].values.tolist()) == expected_names)", "masked_code": "def test_read_parquet_filters_without_bbox(tmpdir, naturalearth_lowres):\n    df = read_file(naturalearth_lowres)\n    filename = os.path.join(str(tmpdir), 'test_filters_no_bbox.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    filters = [('gdp_md_est', '<', 9000)]\n    result = read_parquet(filename, filters=filters)\n    expected_names = set(result['name'].values.tolist())\n    assert (set(result['name'].values.tolist()) == '???')", "ground_truth": "expected_names", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_21", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_to_parquet_bbox_structure_and_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_to_parquet_bbox_structure_and_metadata(tmpdir, naturalearth_lowres):\n    from pyarrow import parquet\n    df = read_file(naturalearth_lowres)\n    df['bbox_col'] = ([[0, 1, 2, 3]] * len(df))\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    table = parquet.read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'].decode('utf-8'))\n    assert (metadata['columns']['geometry']['covering'] == {'bbox': {'xmin': ['bbox', 'xmin'], 'ymin': ['bbox', 'ymin'], 'xmax': ['bbox', 'xmax'], 'ymax': ['bbox', 'ymax']}})\n    assert ('bbox' in table.schema.names)\n    assert ([field.name for field in table.schema.field('bbox').type] == ['xmin', 'ymin', 'xmax', 'ymax'])", "masked_code": "def test_to_parquet_bbox_structure_and_metadata(tmpdir, naturalearth_lowres):\n    from pyarrow import parquet\n    df = read_file(naturalearth_lowres)\n    df['bbox_col'] = ([[0, 1, 2, 3]] * len(df))\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    table = parquet.read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'].decode('utf-8'))\n    assert (metadata['columns']['geometry']['covering'] == '???')\n    assert ('bbox' in table.schema.names)\n    assert ([field.name for field in table.schema.field('bbox').type] == ['xmin', 'ymin', 'xmax', 'ymax'])", "ground_truth": "{'bbox': {'xmin': ['bbox', 'xmin'], 'ymin': ['bbox', 'ymin'], 'xmax': ['bbox', 'xmax'], 'ymax': ['bbox', 'ymax']}}", "quality_analysis": {"complexity_score": 40, "left_complexity": 13, "right_complexity": 27, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_22", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_to_parquet_bbox_structure_and_metadata", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "def test_to_parquet_bbox_structure_and_metadata(tmpdir, naturalearth_lowres):\n    from pyarrow import parquet\n    df = read_file(naturalearth_lowres)\n    df['bbox_col'] = ([[0, 1, 2, 3]] * len(df))\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    table = parquet.read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'].decode('utf-8'))\n    assert (metadata['columns']['geometry']['covering'] == {'bbox': {'xmin': ['bbox', 'xmin'], 'ymin': ['bbox', 'ymin'], 'xmax': ['bbox', 'xmax'], 'ymax': ['bbox', 'ymax']}})\n    assert ('bbox' in table.schema.names)\n    assert ([field.name for field in table.schema.field('bbox').type] == ['xmin', 'ymin', 'xmax', 'ymax'])", "masked_code": "def test_to_parquet_bbox_structure_and_metadata(tmpdir, naturalearth_lowres):\n    from pyarrow import parquet\n    df = read_file(naturalearth_lowres)\n    df['bbox_col'] = ([[0, 1, 2, 3]] * len(df))\n    filename = os.path.join(str(tmpdir), 'test.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    table = parquet.read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'].decode('utf-8'))\n    assert (metadata['columns']['geometry']['covering'] == {'bbox': {'xmin': ['bbox', 'xmin'], 'ymin': ['bbox', 'ymin'], 'xmax': ['bbox', 'xmax'], 'ymax': ['bbox', 'ymax']}})\n    assert ('bbox' in table.schema.names)\n    assert ([field.name for field in table.schema.field('bbox').type] == '???')", "ground_truth": "['xmin', 'ymin', 'xmax', 'ymax']", "quality_analysis": {"complexity_score": 6, "left_complexity": 0, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_23", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_to_parquet_bbox_values", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('geometry, expected_bbox', [(Polygon([(0, 0), (1, 0), (0, 1)]), {'xmin': 0.0, 'ymin': 0.0, 'xmax': 1.0, 'ymax': 1.0}), (LineString([(0, 1), (2, 3), (4, 5)]), {'xmin': 0.0, 'ymin': 1.0, 'xmax': 4.0, 'ymax': 5.0}), (Point((- 9999), 9999), {'xmin': (- 9999.0), 'ymin': 9999.0, 'xmax': (- 9999.0), 'ymax': 9999.0}), (MultiPolygon([box(1, 2, 3, 4)]), {'xmin': 1.0, 'ymin': 2.0, 'xmax': 3.0, 'ymax': 4.0})], ids=['Polygon', 'LineString', 'Point', 'Multipolygon'])\ndef test_to_parquet_bbox_values(tmpdir, geometry, expected_bbox):\n    import pyarrow.parquet as pq\n    df = GeoDataFrame(data=[[0, (- 1)]], columns=['a', 'b'], geometry=[geometry])\n    filename = os.path.join(str(tmpdir), 'test_new_bbox.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    result = pq.read_table(filename).to_pandas()\n    assert (result['bbox'][0] == expected_bbox)", "masked_code": "@pytest.mark.parametrize('geometry, expected_bbox', [(Polygon([(0, 0), (1, 0), (0, 1)]), {'xmin': 0.0, 'ymin': 0.0, 'xmax': 1.0, 'ymax': 1.0}), (LineString([(0, 1), (2, 3), (4, 5)]), {'xmin': 0.0, 'ymin': 1.0, 'xmax': 4.0, 'ymax': 5.0}), (Point((- 9999), 9999), {'xmin': (- 9999.0), 'ymin': 9999.0, 'xmax': (- 9999.0), 'ymax': 9999.0}), (MultiPolygon([box(1, 2, 3, 4)]), {'xmin': 1.0, 'ymin': 2.0, 'xmax': 3.0, 'ymax': 4.0})], ids=['Polygon', 'LineString', 'Point', 'Multipolygon'])\ndef test_to_parquet_bbox_values(tmpdir, geometry, expected_bbox):\n    import pyarrow.parquet as pq\n    df = GeoDataFrame(data=[[0, (- 1)]], columns=['a', 'b'], geometry=[geometry])\n    filename = os.path.join(str(tmpdir), 'test_new_bbox.pq')\n    df.to_parquet(filename, write_covering_bbox=True)\n    result = pq.read_table(filename).to_pandas()\n    assert (result['bbox'][0] == '???')", "ground_truth": "expected_bbox", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_16", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_write_spec_version", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[Polygon([(0, 0), (10, 0), (10, 10), (0, 10)]), box((- 50), (- 50), 50, 50)], crs='EPSG:3857')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert ('Polygon' in metadata['columns']['geometry']['geometry_types'])", "masked_code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[Polygon([(0, 0), (10, 0), (10, 10), (0, 10)]), box((- 50), (- 50), 50, 50)], crs='EPSG:3857')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == '???')\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert ('Polygon' in metadata['columns']['geometry']['geometry_types'])", "ground_truth": "schema_version", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_17", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_write_spec_version", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[Polygon([(0, 0), (10, 0), (10, 10), (0, 10)]), box((- 50), (- 50), 50, 50)], crs='EPSG:3857')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert ('Polygon' in metadata['columns']['geometry']['geometry_types'])", "masked_code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[Polygon([(0, 0), (10, 0), (10, 10), (0, 10)]), box((- 50), (- 50), 50, 50)], crs='EPSG:3857')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == '???')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert ('Polygon' in metadata['columns']['geometry']['geometry_types'])", "ground_truth": "'Polygon'", "quality_analysis": {"complexity_score": 14, "left_complexity": 13, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_18", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_write_spec_version", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[Polygon([(0, 0), (10, 0), (10, 10), (0, 10)]), box((- 50), (- 50), 50, 50)], crs='EPSG:3857')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert ('Polygon' in metadata['columns']['geometry']['geometry_types'])", "masked_code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[Polygon([(0, 0), (10, 0), (10, 10), (0, 10)]), box((- 50), (- 50), 50, 50)], crs='EPSG:3857')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == '???')\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert ('Polygon' in metadata['columns']['geometry']['geometry_types'])", "ground_truth": "gdf.crs.to_wkt()", "quality_analysis": {"complexity_score": 16, "left_complexity": 13, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_19", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_arrow.py", "testname": "test_arrow.py", "funcname": "test_write_spec_version", "imports": ["import json", "import os", "import pathlib", "from itertools import product", "from packaging.version import Version", "import numpy as np", "from pandas import ArrowDtype, DataFrame", "from pandas import read_parquet as pd_read_parquet", "import shapely", "from shapely.geometry import LineString, MultiPolygon, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, read_feather, read_file, read_parquet", "from geopandas._compat import HAS_PYPROJ", "from geopandas.array import to_wkb", "from geopandas.io.arrow import METADATA_VERSION, SUPPORTED_VERSIONS, _convert_bbox_to_parquet_filter, _create_metadata, _decode_metadata, _encode_metadata, _geopandas_to_arrow, _get_filesystem_path, _remove_id_from_member_of_ensembles, _validate_dataframe, _validate_geo_metadata", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from geopandas.tests.util import mock", "from pandas.testing import assert_frame_equal", "import pyarrow.compute as pc", "import pyarrow.parquet as pq", "from pyarrow import feather"], "code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[Polygon([(0, 0), (10, 0), (10, 10), (0, 10)]), box((- 50), (- 50), 50, 50)], crs='EPSG:3857')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == crs_expected)\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert ('Polygon' in metadata['columns']['geometry']['geometry_types'])", "masked_code": "@pytest.mark.parametrize('format,schema_version', product(['feather', 'parquet'], ([None] + SUPPORTED_VERSIONS)))\ndef test_write_spec_version(tmpdir, format, schema_version):\n    if (format == 'feather'):\n        from pyarrow.feather import read_table\n    else:\n        from pyarrow.parquet import read_table\n    filename = os.path.join(str(tmpdir), f'test.{format}')\n    gdf = geopandas.GeoDataFrame(geometry=[Polygon([(0, 0), (10, 0), (10, 10), (0, 10)]), box((- 50), (- 50), 50, 50)], crs='EPSG:3857')\n    write = getattr(gdf, f'to_{format}')\n    write(filename, schema_version=schema_version)\n    read = getattr(geopandas, f'read_{format}')\n    df = read(filename)\n    assert_geodataframe_equal(df, gdf)\n    schema_version = (schema_version or METADATA_VERSION)\n    table = read_table(filename)\n    metadata = json.loads(table.schema.metadata[b'geo'])\n    assert (metadata['version'] == schema_version)\n    if HAS_PYPROJ:\n        if (schema_version == '0.1.0'):\n            assert (metadata['columns']['geometry']['crs'] == gdf.crs.to_wkt())\n        else:\n            crs_expected = gdf.crs.to_json_dict()\n            _remove_id_from_member_of_ensembles(crs_expected)\n            assert (metadata['columns']['geometry']['crs'] == '???')\n    if (Version(schema_version) <= Version('0.4.0')):\n        assert ('geometry_type' in metadata['columns']['geometry'])\n        assert (metadata['columns']['geometry']['geometry_type'] == 'Polygon')\n    else:\n        assert ('geometry_types' in metadata['columns']['geometry'])\n        assert ('Polygon' in metadata['columns']['geometry']['geometry_types'])", "ground_truth": "crs_expected", "quality_analysis": {"complexity_score": 14, "left_complexity": 13, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_634", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_clip.py", "testname": "test_clip.py", "funcname": "test_clip_multiline", "imports": ["import numpy as np", "import pandas as pd", "import shapely", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiPoint, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries, clip", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_30", "from geopandas.array import POLYGON_GEOM_TYPES", "from geopandas.tools.clip import _mask_is_list_like_rectangle", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from pandas.testing import assert_index_equal"], "code": "def test_clip_multiline(self, multi_line, mask):\n    'Test that clipping a multiline feature with a poly returns expected output (AGENT MODIFIED).'\n    extended_line = LineString([(0, 0), (20, 20), ((- 10), (- 10))])\n    multi_line_mod = multi_line.copy()\n    multi_line_mod.loc[len(multi_line_mod)] = [extended_line, 'highway']\n    clipped = clip(multi_line_mod, mask)\n    assert (clipped.geom_type[0] == 'MultiLineString')\n    assert (('LineString' in clipped.geom_type.values) or ('MultiLineString' in clipped.geom_type.values))", "masked_code": "def test_clip_multiline(self, multi_line, mask):\n    'Test that clipping a multiline feature with a poly returns expected output (AGENT MODIFIED).'\n    extended_line = LineString([(0, 0), (20, 20), ((- 10), (- 10))])\n    multi_line_mod = multi_line.copy()\n    multi_line_mod.loc[len(multi_line_mod)] = [extended_line, 'highway']\n    clipped = clip(multi_line_mod, mask)\n    assert (clipped.geom_type[0] == '???')\n    assert (('LineString' in clipped.geom_type.values) or ('MultiLineString' in clipped.geom_type.values))", "ground_truth": "'MultiLineString'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestClipWithSingleRectangleGdf"}
{"task_id": "geopandas_635", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_clip.py", "testname": "test_clip.py", "funcname": "test_clip_multipoint", "imports": ["import numpy as np", "import pandas as pd", "import shapely", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiPoint, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries, clip", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_30", "from geopandas.array import POLYGON_GEOM_TYPES", "from geopandas.tools.clip import _mask_is_list_like_rectangle", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from pandas.testing import assert_index_equal"], "code": "def test_clip_multipoint(self, multi_point, mask):\n    'Clipping a multipoint feature with a polygon works as expected (AGENT MODIFIED).\\n        should return a geodataframe with multiple multi point features.'\n    extended_points = MultiPoint([(20, 20), (30, 30), (0, 0), ((- 12), (- 15))])\n    multi_point_mod = multi_point.copy()\n    multi_point_mod.loc[len(multi_point_mod)] = [extended_points, 'extra tree']\n    clipped = clip(multi_point_mod, mask)\n    assert hasattr(clipped, 'attr')\n    assert (clipped.geom_type[0] == 'MultiPoint')\n    assert (len(clipped) >= 2)\n    assert all(((g in ['MultiPoint', 'Point']) for g in clipped.geom_type))", "masked_code": "def test_clip_multipoint(self, multi_point, mask):\n    'Clipping a multipoint feature with a polygon works as expected (AGENT MODIFIED).\\n        should return a geodataframe with multiple multi point features.'\n    extended_points = MultiPoint([(20, 20), (30, 30), (0, 0), ((- 12), (- 15))])\n    multi_point_mod = multi_point.copy()\n    multi_point_mod.loc[len(multi_point_mod)] = [extended_points, 'extra tree']\n    clipped = clip(multi_point_mod, mask)\n    assert hasattr(clipped, 'attr')\n    assert (clipped.geom_type[0] == '???')\n    assert (len(clipped) >= 2)\n    assert all(((g in ['MultiPoint', 'Point']) for g in clipped.geom_type))", "ground_truth": "'MultiPoint'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestClipWithSingleRectangleGdf"}
{"task_id": "geopandas_631", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_clip.py", "testname": "test_clip.py", "funcname": "test_clip_poly", "imports": ["import numpy as np", "import pandas as pd", "import shapely", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiPoint, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries, clip", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_30", "from geopandas.array import POLYGON_GEOM_TYPES", "from geopandas.tools.clip import _mask_is_list_like_rectangle", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from pandas.testing import assert_index_equal"], "code": "def test_clip_poly(self, buffered_locations, mask):\n    'Test clipping a polygon GDF with a generic polygon geometry (AGENT MODIFIED).'\n    buffered_locations_mod = buffered_locations.copy()\n    buffered_locations_mod['geometry'] = buffered_locations_mod['geometry'].buffer(6)\n    buffered_locations_mod['type'] = 'big_plot'\n    clipped_poly = clip(buffered_locations_mod, mask)\n    assert (len(clipped_poly.geometry) == 3)\n    assert all((clipped_poly.geom_type == 'Polygon'))", "masked_code": "def test_clip_poly(self, buffered_locations, mask):\n    'Test clipping a polygon GDF with a generic polygon geometry (AGENT MODIFIED).'\n    buffered_locations_mod = buffered_locations.copy()\n    buffered_locations_mod['geometry'] = buffered_locations_mod['geometry'].buffer(6)\n    buffered_locations_mod['type'] = 'big_plot'\n    clipped_poly = clip(buffered_locations_mod, mask)\n    assert (len(clipped_poly.geometry) == '???')\n    assert all((clipped_poly.geom_type == 'Polygon'))", "ground_truth": "3", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestClipWithSingleRectangleGdf"}
{"task_id": "geopandas_632", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_clip.py", "testname": "test_clip.py", "funcname": "test_clip_poly_geom_col_rename", "imports": ["import numpy as np", "import pandas as pd", "import shapely", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiPoint, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries, clip", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_30", "from geopandas.array import POLYGON_GEOM_TYPES", "from geopandas.tools.clip import _mask_is_list_like_rectangle", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from pandas.testing import assert_index_equal"], "code": "def test_clip_poly_geom_col_rename(self, buffered_locations, mask):\n    'Test clipping a polygon GDF with a generic polygon geometry (AGENT MODIFIED).'\n    poly_gdf_geom_col_rename = buffered_locations.rename_geometry('geometry2')\n    poly_gdf_geom_col_rename['geometry2'] = poly_gdf_geom_col_rename['geometry2'].buffer(6)\n    poly_gdf_geom_col_rename['new_col'] = 42\n    clipped_poly = clip(poly_gdf_geom_col_rename, mask)\n    assert (len(clipped_poly.geometry2) == 3)\n    assert ('geometry' not in clipped_poly.keys())\n    assert ('geometry2' in clipped_poly.keys())", "masked_code": "def test_clip_poly_geom_col_rename(self, buffered_locations, mask):\n    'Test clipping a polygon GDF with a generic polygon geometry (AGENT MODIFIED).'\n    poly_gdf_geom_col_rename = buffered_locations.rename_geometry('geometry2')\n    poly_gdf_geom_col_rename['geometry2'] = poly_gdf_geom_col_rename['geometry2'].buffer(6)\n    poly_gdf_geom_col_rename['new_col'] = 42\n    clipped_poly = clip(poly_gdf_geom_col_rename, mask)\n    assert (len(clipped_poly.geometry2) == '???')\n    assert ('geometry' not in clipped_poly.keys())\n    assert ('geometry2' in clipped_poly.keys())", "ground_truth": "3", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestClipWithSingleRectangleGdf"}
{"task_id": "geopandas_633", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_clip.py", "testname": "test_clip.py", "funcname": "test_clip_poly_series", "imports": ["import numpy as np", "import pandas as pd", "import shapely", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiPoint, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries, clip", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_30", "from geopandas.array import POLYGON_GEOM_TYPES", "from geopandas.tools.clip import _mask_is_list_like_rectangle", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from pandas.testing import assert_index_equal"], "code": "def test_clip_poly_series(self, buffered_locations, mask):\n    'Test clipping a polygon GDF with a generic polygon geometry (AGENT MODIFIED).'\n    buffered_series = buffered_locations.geometry.buffer(6)\n    clipped_poly = clip(buffered_series, mask)\n    assert (len(clipped_poly) == 3)\n    assert all((clipped_poly.geom_type == 'Polygon'))", "masked_code": "def test_clip_poly_series(self, buffered_locations, mask):\n    'Test clipping a polygon GDF with a generic polygon geometry (AGENT MODIFIED).'\n    buffered_series = buffered_locations.geometry.buffer(6)\n    clipped_poly = clip(buffered_series, mask)\n    assert (len(clipped_poly) == '???')\n    assert all((clipped_poly.geom_type == 'Polygon'))", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestClipWithSingleRectangleGdf"}
{"task_id": "geopandas_630", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_clip.py", "testname": "test_clip.py", "funcname": "test_clip_single_multipoly_no_extra_geoms", "imports": ["import numpy as np", "import pandas as pd", "import shapely", "from shapely.geometry import GeometryCollection, LinearRing, LineString, MultiPoint, Point, Polygon, box", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries, clip", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_30", "from geopandas.array import POLYGON_GEOM_TYPES", "from geopandas.tools.clip import _mask_is_list_like_rectangle", "import pytest", "from geopandas.testing import assert_geodataframe_equal, assert_geoseries_equal", "from pandas.testing import assert_index_equal"], "code": "@pytest.mark.parametrize('mask_fixture_name', mask_variants_large_rectangle)\ndef test_clip_single_multipoly_no_extra_geoms(buffered_locations, mask_fixture_name, request):\n    'When clipping a multi-polygon feature, no additional geom types\\n    should be returned (AGENT MODIFIED).'\n    masks = request.getfixturevalue(mask_fixture_name)\n    multi = buffered_locations.dissolve(by='type').reset_index()\n    multi['geometry'] = multi['geometry'].buffer(9)\n    clipped = clip(multi, masks)\n    assert (clipped.geom_type[0] == 'Polygon')", "masked_code": "@pytest.mark.parametrize('mask_fixture_name', mask_variants_large_rectangle)\ndef test_clip_single_multipoly_no_extra_geoms(buffered_locations, mask_fixture_name, request):\n    'When clipping a multi-polygon feature, no additional geom types\\n    should be returned (AGENT MODIFIED).'\n    masks = request.getfixturevalue(mask_fixture_name)\n    multi = buffered_locations.dissolve(by='type').reset_index()\n    multi['geometry'] = multi['geometry'].buffer(9)\n    clipped = clip(multi, masks)\n    assert (clipped.geom_type[0] == '???')", "ground_truth": "'Polygon'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_159", "reponame": "geopandas", "testpath": "geopandas/tests/test_config.py", "testname": "test_config.py", "funcname": "test_options", "imports": ["import geopandas", "import pytest"], "code": "def test_options():\n    assert ('io_engine: ' in repr(geopandas.options))\n    assert (set(dir(geopandas.options)) == {'display_precision', 'use_pygeos', 'io_engine'})\n    with pytest.raises(AttributeError):\n        geopandas.options._private_attribute\n    with pytest.raises(AttributeError):\n        geopandas.options.non_existing_option = 1.234", "masked_code": "def test_options():\n    assert ('io_engine: ' in repr(geopandas.options))\n    assert (set(dir(geopandas.options)) == '???')\n    with pytest.raises(AttributeError):\n        geopandas.options._private_attribute\n    with pytest.raises(AttributeError):\n        geopandas.options.non_existing_option = 1.234", "ground_truth": "{'display_precision', 'use_pygeos', 'io_engine'}", "quality_analysis": {"complexity_score": 8, "left_complexity": 8, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_160", "reponame": "geopandas", "testpath": "geopandas/tests/test_config.py", "testname": "test_config.py", "funcname": "test_options_display_precision", "imports": ["import geopandas", "import pytest"], "code": "def test_options_display_precision():\n    assert (geopandas.options.display_precision is None)\n    geopandas.options.display_precision = 12\n    assert (geopandas.options.display_precision == 12)\n    with pytest.raises(ValueError):\n        geopandas.options.display_precision = 3.0\n    with pytest.raises(ValueError):\n        geopandas.options.display_precision = ''\n    with pytest.raises(ValueError):\n        geopandas.options.display_precision = (- 2.5)\n    geopandas.options.display_precision = None", "masked_code": "def test_options_display_precision():\n    assert (geopandas.options.display_precision is None)\n    geopandas.options.display_precision = 12\n    assert (geopandas.options.display_precision == '???')\n    with pytest.raises(ValueError):\n        geopandas.options.display_precision = 3.0\n    with pytest.raises(ValueError):\n        geopandas.options.display_precision = ''\n    with pytest.raises(ValueError):\n        geopandas.options.display_precision = (- 2.5)\n    geopandas.options.display_precision = None", "ground_truth": "12", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_161", "reponame": "geopandas", "testpath": "geopandas/tests/test_config.py", "testname": "test_config.py", "funcname": "test_options_io_engine", "imports": ["import geopandas", "import pytest"], "code": "def test_options_io_engine():\n    assert (geopandas.options.io_engine is None)\n    geopandas.options.io_engine = 'fiona'\n    assert (geopandas.options.io_engine == 'fiona')\n    geopandas.options.io_engine = 'pyogrio'\n    assert (geopandas.options.io_engine == 'pyogrio')\n    with pytest.raises(ValueError):\n        geopandas.options.io_engine = ''\n    with pytest.raises(ValueError):\n        geopandas.options.io_engine = 0\n    geopandas.options.io_engine = None", "masked_code": "def test_options_io_engine():\n    assert (geopandas.options.io_engine is None)\n    geopandas.options.io_engine = 'fiona'\n    assert (geopandas.options.io_engine == '???')\n    geopandas.options.io_engine = 'pyogrio'\n    assert (geopandas.options.io_engine == 'pyogrio')\n    with pytest.raises(ValueError):\n        geopandas.options.io_engine = ''\n    with pytest.raises(ValueError):\n        geopandas.options.io_engine = 0\n    geopandas.options.io_engine = None", "ground_truth": "'fiona'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_326", "reponame": "geopandas", "testpath": "geopandas/tests/test_decorator.py", "testname": "test_decorator.py", "funcname": "test_doc_template_from_func", "imports": ["from textwrap import dedent", "from geopandas._decorator import doc"], "code": "def test_doc_template_from_func():\n    cummax_aug = doc(cumsum, method=3.1415, operation=2.718)((lambda x: None))\n    docstr = dedent('\\n        This is the 3.1415 method.\\n\\n        It computes the cumulative 2.718.\\n        ')\n    assert (cummax_aug.__doc__ == docstr)", "masked_code": "def test_doc_template_from_func():\n    cummax_aug = doc(cumsum, method=3.1415, operation=2.718)((lambda x: None))\n    docstr = dedent('\\n        This is the 3.1415 method.\\n\\n        It computes the cumulative 2.718.\\n        ')\n    assert (cummax_aug.__doc__ == '???')", "ground_truth": "docstr", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_325", "reponame": "geopandas", "testpath": "geopandas/tests/test_decorator.py", "testname": "test_decorator.py", "funcname": "test_docstring_appending", "imports": ["from textwrap import dedent", "from geopandas._decorator import doc"], "code": "def test_docstring_appending():\n    cumavg_aug = doc(cumsum, dedent('\\n            Examples\\n            --------\\n\\n            >>> cumavg([1000000, -5000000, 1e10])\\n            3333333333.6666665\\n            '), method='massive_cumavg', operation='super average')((lambda x: None))\n    docstr = dedent('\\n        This is the massive_cumavg method.\\n\\n        It computes the cumulative super average.\\n\\n        Examples\\n        --------\\n\\n        >>> cumavg([1000000, -5000000, 1e10])\\n        3333333333.6666665\\n        ')\n    assert (cumavg_aug.__doc__ == docstr)", "masked_code": "def test_docstring_appending():\n    cumavg_aug = doc(cumsum, dedent('\\n            Examples\\n            --------\\n\\n            >>> cumavg([1000000, -5000000, 1e10])\\n            3333333333.6666665\\n            '), method='massive_cumavg', operation='super average')((lambda x: None))\n    docstr = dedent('\\n        This is the massive_cumavg method.\\n\\n        It computes the cumulative super average.\\n\\n        Examples\\n        --------\\n\\n        >>> cumavg([1000000, -5000000, 1e10])\\n        3333333333.6666665\\n        ')\n    assert (cumavg_aug.__doc__ == '???')", "ground_truth": "docstr", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_324", "reponame": "geopandas", "testpath": "geopandas/tests/test_decorator.py", "testname": "test_decorator.py", "funcname": "test_docstring_formatting", "imports": ["from textwrap import dedent", "from geopandas._decorator import doc"], "code": "def test_docstring_formatting():\n    cumsum_edge = doc(method='', operation='')((lambda x: None))\n    docstr = ''\n    assert (cumsum_edge.__doc__ == docstr)", "masked_code": "def test_docstring_formatting():\n    cumsum_edge = doc(method='', operation='')((lambda x: None))\n    docstr = ''\n    assert (cumsum_edge.__doc__ == '???')", "ground_truth": "docstr", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_327", "reponame": "geopandas", "testpath": "geopandas/tests/test_decorator.py", "testname": "test_decorator.py", "funcname": "test_inherit_doc_template", "imports": ["from textwrap import dedent", "from geopandas._decorator import doc"], "code": "def test_inherit_doc_template():\n    cummin_edge = doc(cummax, method=None, operation=None)((lambda x: None))\n    docstr = dedent('\\n        This is the None method.\\n\\n        It computes the cumulative None.\\n        ')\n    assert (cummin_edge.__doc__ == docstr)", "masked_code": "def test_inherit_doc_template():\n    cummin_edge = doc(cummax, method=None, operation=None)((lambda x: None))\n    docstr = dedent('\\n        This is the None method.\\n\\n        It computes the cumulative None.\\n        ')\n    assert (cummin_edge.__doc__ == '???')", "ground_truth": "docstr", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_377", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_forward", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_forward(locations, points):\n    from geopy.geocoders import Photon\n    for provider in ['photon', Photon]:\n        with mock.patch('geopy.geocoders.Photon.geocode', ForwardMock()) as m:\n            g = geocode(locations, provider=provider, timeout=2)\n            assert (len(locations) == m.call_count)\n        n = len(locations)\n        assert isinstance(g, GeoDataFrame)\n        expected = GeoSeries([Point((float(x) + 0.5), float(x)) for x in range(n)], crs='EPSG:4326')\n        assert_geoseries_equal(expected, g['geometry'])\n        assert_series_equal(g['address'], pd.Series(locations, name='address'))", "masked_code": "def test_forward(locations, points):\n    from geopy.geocoders import Photon\n    for provider in ['photon', Photon]:\n        with mock.patch('geopy.geocoders.Photon.geocode', ForwardMock()) as m:\n            g = geocode(locations, provider=provider, timeout=2)\n            assert (len(locations) == '???')\n        n = len(locations)\n        assert isinstance(g, GeoDataFrame)\n        expected = GeoSeries([Point((float(x) + 0.5), float(x)) for x in range(n)], crs='EPSG:4326')\n        assert_geoseries_equal(expected, g['geometry'])\n        assert_series_equal(g['address'], pd.Series(locations, name='address'))", "ground_truth": "m.call_count", "quality_analysis": {"complexity_score": 6, "left_complexity": 4, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_371", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_prepare_result", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_prepare_result():\n    p0 = Point(0, 0)\n    p1 = Point(179.9999, (- 85.05112878))\n    p2 = Point((- 180), 85.05112878)\n    d = {'empty': ('', p0.coords[0]), 'max_ll': ('address_max', p1.coords[0]), 'min_ll': ('address_min', p2.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 3)\n    assert ('address' in df)\n    coords = df.loc['empty']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['empty']['address'] == '')\n    coords = df.loc['max_ll']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['max_ll']['address'] == 'address_max')\n    coords = df.loc['min_ll']['geometry'].coords[0]\n    test = p2.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['min_ll']['address'] == 'address_min')", "masked_code": "def test_prepare_result():\n    p0 = Point(0, 0)\n    p1 = Point(179.9999, (- 85.05112878))\n    p2 = Point((- 180), 85.05112878)\n    d = {'empty': ('', p0.coords[0]), 'max_ll': ('address_max', p1.coords[0]), 'min_ll': ('address_min', p2.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == '???')\n    assert ('address' in df)\n    coords = df.loc['empty']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['empty']['address'] == '')\n    coords = df.loc['max_ll']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['max_ll']['address'] == 'address_max')\n    coords = df.loc['min_ll']['geometry'].coords[0]\n    test = p2.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['min_ll']['address'] == 'address_min')", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_372", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_prepare_result", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_prepare_result():\n    p0 = Point(0, 0)\n    p1 = Point(179.9999, (- 85.05112878))\n    p2 = Point((- 180), 85.05112878)\n    d = {'empty': ('', p0.coords[0]), 'max_ll': ('address_max', p1.coords[0]), 'min_ll': ('address_min', p2.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 3)\n    assert ('address' in df)\n    coords = df.loc['empty']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['empty']['address'] == '')\n    coords = df.loc['max_ll']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['max_ll']['address'] == 'address_max')\n    coords = df.loc['min_ll']['geometry'].coords[0]\n    test = p2.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['min_ll']['address'] == 'address_min')", "masked_code": "def test_prepare_result():\n    p0 = Point(0, 0)\n    p1 = Point(179.9999, (- 85.05112878))\n    p2 = Point((- 180), 85.05112878)\n    d = {'empty': ('', p0.coords[0]), 'max_ll': ('address_max', p1.coords[0]), 'min_ll': ('address_min', p2.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 3)\n    assert ('address' in df)\n    coords = df.loc['empty']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == '???')\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['empty']['address'] == '')\n    coords = df.loc['max_ll']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['max_ll']['address'] == 'address_max')\n    coords = df.loc['min_ll']['geometry'].coords[0]\n    test = p2.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['min_ll']['address'] == 'address_min')", "ground_truth": "pytest.approx(test[1])", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_373", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_prepare_result", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_prepare_result():\n    p0 = Point(0, 0)\n    p1 = Point(179.9999, (- 85.05112878))\n    p2 = Point((- 180), 85.05112878)\n    d = {'empty': ('', p0.coords[0]), 'max_ll': ('address_max', p1.coords[0]), 'min_ll': ('address_min', p2.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 3)\n    assert ('address' in df)\n    coords = df.loc['empty']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['empty']['address'] == '')\n    coords = df.loc['max_ll']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['max_ll']['address'] == 'address_max')\n    coords = df.loc['min_ll']['geometry'].coords[0]\n    test = p2.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['min_ll']['address'] == 'address_min')", "masked_code": "def test_prepare_result():\n    p0 = Point(0, 0)\n    p1 = Point(179.9999, (- 85.05112878))\n    p2 = Point((- 180), 85.05112878)\n    d = {'empty': ('', p0.coords[0]), 'max_ll': ('address_max', p1.coords[0]), 'min_ll': ('address_min', p2.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 3)\n    assert ('address' in df)\n    coords = df.loc['empty']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == '???')\n    assert (df.loc['empty']['address'] == '')\n    coords = df.loc['max_ll']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['max_ll']['address'] == 'address_max')\n    coords = df.loc['min_ll']['geometry'].coords[0]\n    test = p2.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['min_ll']['address'] == 'address_min')", "ground_truth": "pytest.approx(test[0])", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_374", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_prepare_result", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_prepare_result():\n    p0 = Point(0, 0)\n    p1 = Point(179.9999, (- 85.05112878))\n    p2 = Point((- 180), 85.05112878)\n    d = {'empty': ('', p0.coords[0]), 'max_ll': ('address_max', p1.coords[0]), 'min_ll': ('address_min', p2.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 3)\n    assert ('address' in df)\n    coords = df.loc['empty']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['empty']['address'] == '')\n    coords = df.loc['max_ll']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['max_ll']['address'] == 'address_max')\n    coords = df.loc['min_ll']['geometry'].coords[0]\n    test = p2.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['min_ll']['address'] == 'address_min')", "masked_code": "def test_prepare_result():\n    p0 = Point(0, 0)\n    p1 = Point(179.9999, (- 85.05112878))\n    p2 = Point((- 180), 85.05112878)\n    d = {'empty': ('', p0.coords[0]), 'max_ll': ('address_max', p1.coords[0]), 'min_ll': ('address_min', p2.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 3)\n    assert ('address' in df)\n    coords = df.loc['empty']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['empty']['address'] == '')\n    coords = df.loc['max_ll']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == '???')\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['max_ll']['address'] == 'address_max')\n    coords = df.loc['min_ll']['geometry'].coords[0]\n    test = p2.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['min_ll']['address'] == 'address_min')", "ground_truth": "pytest.approx(test[1])", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_375", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_prepare_result", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_prepare_result():\n    p0 = Point(0, 0)\n    p1 = Point(179.9999, (- 85.05112878))\n    p2 = Point((- 180), 85.05112878)\n    d = {'empty': ('', p0.coords[0]), 'max_ll': ('address_max', p1.coords[0]), 'min_ll': ('address_min', p2.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 3)\n    assert ('address' in df)\n    coords = df.loc['empty']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['empty']['address'] == '')\n    coords = df.loc['max_ll']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['max_ll']['address'] == 'address_max')\n    coords = df.loc['min_ll']['geometry'].coords[0]\n    test = p2.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['min_ll']['address'] == 'address_min')", "masked_code": "def test_prepare_result():\n    p0 = Point(0, 0)\n    p1 = Point(179.9999, (- 85.05112878))\n    p2 = Point((- 180), 85.05112878)\n    d = {'empty': ('', p0.coords[0]), 'max_ll': ('address_max', p1.coords[0]), 'min_ll': ('address_min', p2.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 3)\n    assert ('address' in df)\n    coords = df.loc['empty']['geometry'].coords[0]\n    test = p0.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['empty']['address'] == '')\n    coords = df.loc['max_ll']['geometry'].coords[0]\n    test = p1.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == '???')\n    assert (df.loc['max_ll']['address'] == 'address_max')\n    coords = df.loc['min_ll']['geometry'].coords[0]\n    test = p2.coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))\n    assert (df.loc['min_ll']['address'] == 'address_min')", "ground_truth": "pytest.approx(test[0])", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_376", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_prepare_result_none", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_prepare_result_none():\n    p0 = Point(123456789.123, (- 987654321.321))\n    d = {'nan': (None, None), 'huge': ('address_huge', p0.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    row = df.loc['nan']\n    assert (len(row['geometry'].coords) == 0)\n    assert row['geometry'].is_empty\n    assert pd.isna(row['address'])\n    row_huge = df.loc['huge']\n    assert (row_huge['address'] == 'address_huge')\n    test = p0.coords[0]\n    coords = row_huge['geometry'].coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))", "masked_code": "def test_prepare_result_none():\n    p0 = Point(123456789.123, (- 987654321.321))\n    d = {'nan': (None, None), 'huge': ('address_huge', p0.coords[0])}\n    df = _prepare_geocode_result(d)\n    assert (type(df) is GeoDataFrame)\n    if HAS_PYPROJ:\n        assert (df.crs == 'EPSG:4326')\n    assert (len(df) == 2)\n    assert ('address' in df)\n    row = df.loc['nan']\n    assert (len(row['geometry'].coords) == 0)\n    assert row['geometry'].is_empty\n    assert pd.isna(row['address'])\n    row_huge = df.loc['huge']\n    assert (row_huge['address'] == '???')\n    test = p0.coords[0]\n    coords = row_huge['geometry'].coords[0]\n    assert (coords[0] == pytest.approx(test[1]))\n    assert (coords[1] == pytest.approx(test[0]))", "ground_truth": "'address_huge'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_378", "reponame": "geopandas", "testpath": "geopandas/tests/test_geocode.py", "testname": "test_geocode.py", "funcname": "test_reverse", "imports": ["import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ", "from geopandas.tools import geocode, reverse_geocode", "from geopandas.tools.geocoding import _prepare_geocode_result", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from geopandas.tests.util import assert_geoseries_equal, mock", "from pandas.testing import assert_series_equal"], "code": "def test_reverse(locations, points):\n    from geopy.geocoders import Photon\n    for provider in ['photon', Photon]:\n        with mock.patch('geopy.geocoders.Photon.reverse', ReverseMock()) as m:\n            g = reverse_geocode(points, provider=provider, timeout=2)\n            assert (len(points) == m.call_count)\n        assert isinstance(g, GeoDataFrame)\n        expected = GeoSeries(points, crs='EPSG:4326')\n        assert_geoseries_equal(expected, g['geometry'])\n        address = pd.Series([('address' + str(x)) for x in range(len(points))], name='address')\n        assert_series_equal(g['address'], address)", "masked_code": "def test_reverse(locations, points):\n    from geopy.geocoders import Photon\n    for provider in ['photon', Photon]:\n        with mock.patch('geopy.geocoders.Photon.reverse', ReverseMock()) as m:\n            g = reverse_geocode(points, provider=provider, timeout=2)\n            assert (len(points) == '???')\n        assert isinstance(g, GeoDataFrame)\n        expected = GeoSeries(points, crs='EPSG:4326')\n        assert_geoseries_equal(expected, g['geometry'])\n        address = pd.Series([('address' + str(x)) for x in range(len(points))], name='address')\n        assert_series_equal(g['address'], address)", "ground_truth": "m.call_count", "quality_analysis": {"complexity_score": 6, "left_complexity": 4, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_98", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_int32", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "@pytest.mark.parametrize('array_data,dtype', [([(- 2147483648), ((2 ** 31) - 1)], np.int32), ([np.nan, (- 999999)], pd.Int32Dtype()), ([0, 123456], np.int32)])\ndef test_infer_schema_int32(array_data, dtype):\n    int32col = pd.array(data=array_data, dtype=dtype)\n    df = GeoDataFrame(geometry=[city_hall_entrance, city_hall_balcony])\n    df['int32_column'] = int32col\n    assert (infer_schema(df) == {'geometry': 'Point', 'properties': OrderedDict([('int32_column', 'int32')])})", "masked_code": "@pytest.mark.parametrize('array_data,dtype', [([(- 2147483648), ((2 ** 31) - 1)], np.int32), ([np.nan, (- 999999)], pd.Int32Dtype()), ([0, 123456], np.int32)])\ndef test_infer_schema_int32(array_data, dtype):\n    int32col = pd.array(data=array_data, dtype=dtype)\n    df = GeoDataFrame(geometry=[city_hall_entrance, city_hall_balcony])\n    df['int32_column'] = int32col\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'Point', 'properties': OrderedDict([('int32_column', 'int32')])}", "quality_analysis": {"complexity_score": 19, "left_complexity": 4, "right_complexity": 15, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_99", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_int64", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_int64():\n    int64col = pd.array([0, np.nan, (2 ** 60)], dtype=pd.Int64Dtype())\n    df = GeoDataFrame(geometry=[city_hall_entrance, city_hall_balcony, city_hall_council_chamber])\n    df['int64_column'] = int64col\n    assert (infer_schema(df) == {'geometry': 'Point', 'properties': OrderedDict([('int64_column', 'int')])})", "masked_code": "def test_infer_schema_int64():\n    int64col = pd.array([0, np.nan, (2 ** 60)], dtype=pd.Int64Dtype())\n    df = GeoDataFrame(geometry=[city_hall_entrance, city_hall_balcony, city_hall_council_chamber])\n    df['int64_column'] = int64col\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'Point', 'properties': OrderedDict([('int64_column', 'int')])}", "quality_analysis": {"complexity_score": 19, "left_complexity": 4, "right_complexity": 15, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_82", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_linestrings_and_multilinestrings", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_linestrings_and_multilinestrings():\n    mls = MultiLineString([LineString([(0, 0), (100, 100)]), LineString([((- 100000.0), 100000.0), (100000.0, (- 100000.0))])])\n    ls = LineString([((- 999), 999), (500, 500)])\n    df = GeoDataFrame(geometry=[mls, ls])\n    assert (infer_schema(df) == {'geometry': ['MultiLineString', 'LineString'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_linestrings_and_multilinestrings():\n    mls = MultiLineString([LineString([(0, 0), (100, 100)]), LineString([((- 100000.0), 100000.0), (100000.0, (- 100000.0))])])\n    ls = LineString([((- 999), 999), (500, 500)])\n    df = GeoDataFrame(geometry=[mls, ls])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['MultiLineString', 'LineString'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_89", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_mixed_3D_Point", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_mixed_3D_Point():\n    pt1 = Point(10, (- 10), 5000)\n    pt2 = Point(0, 0)\n    df = GeoDataFrame(geometry=[pt2, pt1])\n    assert (infer_schema(df) == {'geometry': ['3D Point', 'Point'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_mixed_3D_Point():\n    pt1 = Point(10, (- 10), 5000)\n    pt2 = Point(0, 0)\n    df = GeoDataFrame(geometry=[pt2, pt1])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['3D Point', 'Point'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_93", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_mixed_3D_Polygon", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_mixed_3D_Polygon():\n    shell_2d = [(0, 0), (5, 0), (5, 5), (0, 5), (0, 0)]\n    shell_3d = [(1, 2, 3), (4, 5, 6), (7, 8, 9), (1, 2, 3)]\n    hole_3d = [(3, 4, 5), (4, 5, 6), (5, 4, 3), (3, 4, 5)]\n    poly_2d = Polygon(shell_2d)\n    poly_3d = Polygon(shell_3d, [hole_3d])\n    df = GeoDataFrame(geometry=[poly_2d, poly_3d])\n    assert (infer_schema(df) == {'geometry': ['3D Polygon', 'Polygon'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_mixed_3D_Polygon():\n    shell_2d = [(0, 0), (5, 0), (5, 5), (0, 5), (0, 0)]\n    shell_3d = [(1, 2, 3), (4, 5, 6), (7, 8, 9), (1, 2, 3)]\n    hole_3d = [(3, 4, 5), (4, 5, 6), (5, 4, 3), (3, 4, 5)]\n    poly_2d = Polygon(shell_2d)\n    poly_3d = Polygon(shell_3d, [hole_3d])\n    df = GeoDataFrame(geometry=[poly_2d, poly_3d])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['3D Polygon', 'Polygon'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_91", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_mixed_3D_linestring", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_mixed_3D_linestring():\n    ls_3d = LineString([(0, 0, 0), (1000, (- 1000), 0)])\n    ls_2d = LineString([((- 500), 500), (500, (- 500))])\n    df = GeoDataFrame(geometry=[ls_2d, ls_3d])\n    assert (infer_schema(df) == {'geometry': ['3D LineString', 'LineString'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_mixed_3D_linestring():\n    ls_3d = LineString([(0, 0, 0), (1000, (- 1000), 0)])\n    ls_2d = LineString([((- 500), 500), (500, (- 500))])\n    df = GeoDataFrame(geometry=[ls_2d, ls_3d])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['3D LineString', 'LineString'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_88", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_mixed_3D_shape_type", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_mixed_3D_shape_type():\n    mp = MultiPolygon((city_hall_boundaries, vauquelin_place))\n    multi3D = MultiPoint([(0, 0, 0), (100000.0, (- 100000.0), 135)])\n    ls_2d = city_hall_walls[0]\n    ls_3d = linestring_3D\n    pt_2d = city_hall_balcony\n    pt_3d = Point((- 77.1), 48.1, (- 999))\n    df = GeoDataFrame(geometry=[mp, city_hall_boundaries, MultiLineString(city_hall_walls), ls_2d, multi3D, pt_2d, pt_3d, ls_3d])\n    assert (infer_schema(df) == {'geometry': ['3D MultiPoint', '3D Point', '3D LineString', 'MultiPolygon', 'Polygon', 'MultiLineString', 'LineString', 'Point'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_mixed_3D_shape_type():\n    mp = MultiPolygon((city_hall_boundaries, vauquelin_place))\n    multi3D = MultiPoint([(0, 0, 0), (100000.0, (- 100000.0), 135)])\n    ls_2d = city_hall_walls[0]\n    ls_3d = linestring_3D\n    pt_2d = city_hall_balcony\n    pt_3d = Point((- 77.1), 48.1, (- 999))\n    df = GeoDataFrame(geometry=[mp, city_hall_boundaries, MultiLineString(city_hall_walls), ls_2d, multi3D, pt_2d, pt_3d, ls_3d])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['3D MultiPoint', '3D Point', '3D LineString', 'MultiPolygon', 'Polygon', 'MultiLineString', 'LineString', 'Point'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 22, "left_complexity": 4, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_87", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_multiple_shape_types", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_multiple_shape_types():\n    mp = MultiPolygon((city_hall_boundaries, vauquelin_place))\n    mls = MultiLineString(city_hall_walls)\n    multi3D = MultiPoint([(1, 2, 3), (100, 200, 300)])\n    pt_extreme = Point((- 9000000000000.0), 9000000000000.0)\n    df = GeoDataFrame(geometry=[mp, city_hall_boundaries, mls, city_hall_walls[0], multi3D, pt_extreme])\n    assert (infer_schema(df) == {'geometry': ['3D MultiPoint', 'MultiPolygon', 'Polygon', 'MultiLineString', 'LineString', 'Point'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_multiple_shape_types():\n    mp = MultiPolygon((city_hall_boundaries, vauquelin_place))\n    mls = MultiLineString(city_hall_walls)\n    multi3D = MultiPoint([(1, 2, 3), (100, 200, 300)])\n    pt_extreme = Point((- 9000000000000.0), 9000000000000.0)\n    df = GeoDataFrame(geometry=[mp, city_hall_boundaries, mls, city_hall_walls[0], multi3D, pt_extreme])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['3D MultiPoint', 'MultiPolygon', 'Polygon', 'MultiLineString', 'LineString', 'Point'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 20, "left_complexity": 4, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_97", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_null_geometry_all", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_null_geometry_all():\n    df = GeoDataFrame(geometry=[None, None])\n    assert (infer_schema(df) == {'geometry': 'Unknown', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_null_geometry_all():\n    df = GeoDataFrame(geometry=[None, None])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'Unknown', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_95", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_null_geometry_and_2D_point", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_null_geometry_and_2D_point():\n    df = GeoDataFrame(geometry=[None, Point(0, 0)])\n    assert (infer_schema(df) == {'geometry': 'Point', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_null_geometry_and_2D_point():\n    df = GeoDataFrame(geometry=[None, Point(0, 0)])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'Point', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_96", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_null_geometry_and_3D_point", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_null_geometry_and_3D_point():\n    df = GeoDataFrame(geometry=[None, Point(0, 0, 0)])\n    assert (infer_schema(df) == {'geometry': '3D Point', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_null_geometry_and_3D_point():\n    df = GeoDataFrame(geometry=[None, Point(0, 0, 0)])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': '3D Point', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_90", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_3D_Points", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_3D_Points():\n    pt1 = Point((- 1), (- 2), (- 100))\n    pt2 = Point(1, 2, 100)\n    df = GeoDataFrame(geometry=[pt1, pt2])\n    assert (infer_schema(df) == {'geometry': '3D Point', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_3D_Points():\n    pt1 = Point((- 1), (- 2), (- 100))\n    pt2 = Point(1, 2, 100)\n    df = GeoDataFrame(geometry=[pt1, pt2])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': '3D Point', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_94", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_3D_Polygons", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_3D_Polygons():\n    shell1 = [((- 1), (- 1), 1), (2, (- 1), 1), (2, 2, 1), ((- 1), 2, 1), ((- 1), (- 1), 1)]\n    hole1 = [(0, 0, 1), (1, 0, 1), (1, 1, 1), (0, 1, 1), (0, 0, 1)]\n    shell2 = [(5, 5, 5), (7, 5, 5), (7, 7, 5), (5, 7, 5), (5, 5, 5)]\n    poly1 = Polygon(shell1, [hole1])\n    poly2 = Polygon(shell2)\n    df = GeoDataFrame(geometry=[poly1, poly2])\n    assert (infer_schema(df) == {'geometry': '3D Polygon', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_3D_Polygons():\n    shell1 = [((- 1), (- 1), 1), (2, (- 1), 1), (2, 2, 1), ((- 1), 2, 1), ((- 1), (- 1), 1)]\n    hole1 = [(0, 0, 1), (1, 0, 1), (1, 1, 1), (0, 1, 1), (0, 0, 1)]\n    shell2 = [(5, 5, 5), (7, 5, 5), (7, 7, 5), (5, 7, 5), (5, 5, 5)]\n    poly1 = Polygon(shell1, [hole1])\n    poly2 = Polygon(shell2)\n    df = GeoDataFrame(geometry=[poly1, poly2])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': '3D Polygon', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_92", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_3D_linestrings", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_3D_linestrings():\n    ls1 = LineString([(0, 0, 0), (10, 10, 10)])\n    ls2 = LineString([(1000000.0, (- 1000000.0), 1234.56), ((- 1000000.0), 1000000.0, (- 7890.12))])\n    df = GeoDataFrame(geometry=[ls1, ls2])\n    assert (infer_schema(df) == {'geometry': '3D LineString', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_3D_linestrings():\n    ls1 = LineString([(0, 0, 0), (10, 10, 10)])\n    ls2 = LineString([(1000000.0, (- 1000000.0), 1234.56), ((- 1000000.0), 1000000.0, (- 7890.12))])\n    df = GeoDataFrame(geometry=[ls1, ls2])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': '3D LineString', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_81", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_linestrings", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_linestrings():\n    ls = [LineString([(0, 0), (1000, 1000)]), LineString([(1000000000.0, (- 1000000000.0)), ((- 1000000000.0), 1000000000.0), (0, 0)])]\n    df = GeoDataFrame(geometry=ls)\n    assert (infer_schema(df) == {'geometry': 'LineString', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_linestrings():\n    ls = [LineString([(0, 0), (1000, 1000)]), LineString([(1000000000.0, (- 1000000000.0)), ((- 1000000000.0), 1000000000.0), (0, 0)])]\n    df = GeoDataFrame(geometry=ls)\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'LineString', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_83", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_multilinestrings", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_multilinestrings():\n    mls = MultiLineString([LineString([(0, 0), (2, 2), ((- 2), (- 2))]), LineString([(1000.0, 0), (0, (- 1000.0)), ((- 1000.0), 1000.0)]), LineString([(10, 100), (10000.0, 10000.0)])])\n    df = GeoDataFrame(geometry=[mls])\n    assert (infer_schema(df) == {'geometry': 'MultiLineString', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_multilinestrings():\n    mls = MultiLineString([LineString([(0, 0), (2, 2), ((- 2), (- 2))]), LineString([(1000.0, 0), (0, (- 1000.0)), ((- 1000.0), 1000.0)]), LineString([(10, 100), (10000.0, 10000.0)])])\n    df = GeoDataFrame(geometry=[mls])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'MultiLineString', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_80", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_multipoints", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_multipoints():\n    df = GeoDataFrame(geometry=[MultiPoint([Point((- 100), 0), Point(0, (- 100)), Point(1000000.0, 1e-06), Point(3.14, 2.71)])])\n    assert (infer_schema(df) == {'geometry': 'MultiPoint', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_multipoints():\n    df = GeoDataFrame(geometry=[MultiPoint([Point((- 100), 0), Point(0, (- 100)), Point(1000000.0, 1e-06), Point(3.14, 2.71)])])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'MultiPoint', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_86", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_multipolygons", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_multipolygons():\n    shellA = [(0, 0), (1, 2), (2, 0), (0, 0)]\n    shellB = [(3, 3), (5, 3), (5, 5), (3, 5), (3, 3)]\n    holeB = [(4, 4), (4.5, 4), (4.5, 4.5), (4, 4.5), (4, 4)]\n    polyA = Polygon(shellA)\n    polyB = Polygon(shellB, [holeB])\n    shellC = [((- 9), (- 9)), ((- 9), (- 7)), ((- 7), (- 7)), ((- 7), (- 9)), ((- 9), (- 9))]\n    polyC = Polygon(shellC)\n    mp = MultiPolygon((polyA, polyB, polyC))\n    df = GeoDataFrame(geometry=[mp])\n    assert (infer_schema(df) == {'geometry': 'MultiPolygon', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_multipolygons():\n    shellA = [(0, 0), (1, 2), (2, 0), (0, 0)]\n    shellB = [(3, 3), (5, 3), (5, 5), (3, 5), (3, 3)]\n    holeB = [(4, 4), (4.5, 4), (4.5, 4.5), (4, 4.5), (4, 4)]\n    polyA = Polygon(shellA)\n    polyB = Polygon(shellB, [holeB])\n    shellC = [((- 9), (- 9)), ((- 9), (- 7)), ((- 7), (- 7)), ((- 7), (- 9)), ((- 9), (- 9))]\n    polyC = Polygon(shellC)\n    mp = MultiPolygon((polyA, polyB, polyC))\n    df = GeoDataFrame(geometry=[mp])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'MultiPolygon', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_78", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_points", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_points():\n    pts = [Point(0, 0), Point((- 1), (- 1)), Point(1000000.0, 1000000.0)]\n    df = GeoDataFrame(geometry=pts)\n    assert (infer_schema(df) == {'geometry': 'Point', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_points():\n    pts = [Point(0, 0), Point((- 1), (- 1)), Point(1000000.0, 1000000.0)]\n    df = GeoDataFrame(geometry=pts)\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'Point', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_84", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_only_polygons", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_only_polygons():\n    shell = [((- 2), (- 2)), ((- 2), 2), (2, 2), (2, (- 2)), ((- 2), (- 2))]\n    hole = [((- 1), (- 1)), ((- 1), 1), (1, 1), (1, (- 1)), ((- 1), (- 1))]\n    poly_with_hole = Polygon(shell, [hole])\n    poly_negative = Polygon([((- 50), 0), (0, (- 50)), ((- 50), (- 50)), ((- 50), 0)])\n    df = GeoDataFrame(geometry=[poly_with_hole, poly_negative])\n    assert (infer_schema(df) == {'geometry': 'Polygon', 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_only_polygons():\n    shell = [((- 2), (- 2)), ((- 2), 2), (2, 2), (2, (- 2)), ((- 2), (- 2))]\n    hole = [((- 1), (- 1)), ((- 1), 1), (1, 1), (1, (- 1)), ((- 1), (- 1))]\n    poly_with_hole = Polygon(shell, [hole])\n    poly_negative = Polygon([((- 50), 0), (0, (- 50)), ((- 50), (- 50)), ((- 50), 0)])\n    df = GeoDataFrame(geometry=[poly_with_hole, poly_negative])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': 'Polygon', 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_79", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_points_and_multipoints", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_points_and_multipoints():\n    df = GeoDataFrame(geometry=[MultiPoint([]), MultiPoint([Point(1000000000.0, (- 1000000000.0)), Point((- 1000000000.0), 1000000000.0), Point(0, 0)]), Point(3.3, 10.4)])\n    assert (infer_schema(df) == {'geometry': ['MultiPoint', 'Point'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_points_and_multipoints():\n    df = GeoDataFrame(geometry=[MultiPoint([]), MultiPoint([Point(1000000000.0, (- 1000000000.0)), Point((- 1000000000.0), 1000000000.0), Point(0, 0)]), Point(3.3, 10.4)])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['MultiPoint', 'Point'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_85", "reponame": "geopandas", "testpath": "geopandas/io/tests/test_infer_schema.py", "testname": "test_infer_schema.py", "funcname": "test_infer_schema_polygons_and_multipolygons", "imports": ["from collections import OrderedDict", "import numpy as np", "import pandas as pd", "from shapely.geometry import LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon", "from geopandas import GeoDataFrame", "from geopandas.io.file import infer_schema", "import pytest"], "code": "def test_infer_schema_polygons_and_multipolygons():\n    shell1 = [(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)]\n    hole1 = [(2, 2), (2, 8), (8, 8), (8, 2), (2, 2)]\n    poly1 = Polygon(shell1, [hole1])\n    shell2 = [((- 10), (- 10)), ((- 10), 0), (0, 0), (0, (- 10)), ((- 10), (- 10))]\n    poly2 = Polygon(shell2)\n    mp = MultiPolygon((poly1, poly2))\n    df = GeoDataFrame(geometry=[mp, poly1])\n    assert (infer_schema(df) == {'geometry': ['MultiPolygon', 'Polygon'], 'properties': OrderedDict()})", "masked_code": "def test_infer_schema_polygons_and_multipolygons():\n    shell1 = [(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)]\n    hole1 = [(2, 2), (2, 8), (8, 8), (8, 2), (2, 2)]\n    poly1 = Polygon(shell1, [hole1])\n    shell2 = [((- 10), (- 10)), ((- 10), 0), (0, 0), (0, (- 10)), ((- 10), (- 10))]\n    poly2 = Polygon(shell2)\n    mp = MultiPolygon((poly1, poly2))\n    df = GeoDataFrame(geometry=[mp, poly1])\n    assert (infer_schema(df) == '???')", "ground_truth": "{'geometry': ['MultiPolygon', 'Polygon'], 'properties': OrderedDict()}", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_519", "reponame": "geopandas", "testpath": "geopandas/tests/test_merge.py", "testname": "test_merge.py", "funcname": "test_concat_axis0", "imports": ["import warnings", "import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_21", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from pandas.testing import assert_index_equal"], "code": "def test_concat_axis0(self):\n    gdf1 = GeoDataFrame({'geometry': GeoSeries([Point((- 1), 1), Point(1000000000000.0, (- 1000000000000.0)), Point(0, 0)]), 'values': [0.0, (- 99999.99), 1e+20]})\n    gdf2 = GeoDataFrame({'geometry': GeoSeries([Point(2.2, (- 3.3)), Point(1000, 2000)]), 'values': [float('inf'), float('-inf')]})\n    empty_gdf = GeoDataFrame({'geometry': GeoSeries([], dtype='geometry'), 'values': []})\n    res = pd.concat([gdf1, gdf2])\n    assert (res.shape == (5, 2))\n    assert isinstance(res, GeoDataFrame)\n    assert isinstance(res.geometry, GeoSeries)\n    self._check_metadata(res)\n    exp = GeoDataFrame(pd.concat([pd.DataFrame(gdf1), pd.DataFrame(gdf2)]))\n    assert_geodataframe_equal(exp, res)\n    res_empty = pd.concat([gdf1, empty_gdf])\n    assert (res_empty.shape == (3, 2))\n    assert isinstance(res_empty, GeoDataFrame)\n    assert isinstance(res_empty.geometry, GeoSeries)\n    geo_ser = GeoSeries([Point((- 500), 0), Point(0, 500), Point(1e+16, (- 1e+16)), Point(0, 0)])\n    res_series = pd.concat([geo_ser, geo_ser])\n    assert (res_series.shape == (8,))\n    assert isinstance(res_series, GeoSeries)\n    assert isinstance(res_series.geometry, GeoSeries)", "masked_code": "def test_concat_axis0(self):\n    gdf1 = GeoDataFrame({'geometry': GeoSeries([Point((- 1), 1), Point(1000000000000.0, (- 1000000000000.0)), Point(0, 0)]), 'values': [0.0, (- 99999.99), 1e+20]})\n    gdf2 = GeoDataFrame({'geometry': GeoSeries([Point(2.2, (- 3.3)), Point(1000, 2000)]), 'values': [float('inf'), float('-inf')]})\n    empty_gdf = GeoDataFrame({'geometry': GeoSeries([], dtype='geometry'), 'values': []})\n    res = pd.concat([gdf1, gdf2])\n    assert (res.shape == '???')\n    assert isinstance(res, GeoDataFrame)\n    assert isinstance(res.geometry, GeoSeries)\n    self._check_metadata(res)\n    exp = GeoDataFrame(pd.concat([pd.DataFrame(gdf1), pd.DataFrame(gdf2)]))\n    assert_geodataframe_equal(exp, res)\n    res_empty = pd.concat([gdf1, empty_gdf])\n    assert (res_empty.shape == (3, 2))\n    assert isinstance(res_empty, GeoDataFrame)\n    assert isinstance(res_empty.geometry, GeoSeries)\n    geo_ser = GeoSeries([Point((- 500), 0), Point(0, 500), Point(1e+16, (- 1e+16)), Point(0, 0)])\n    res_series = pd.concat([geo_ser, geo_ser])\n    assert (res_series.shape == (8,))\n    assert isinstance(res_series, GeoSeries)\n    assert isinstance(res_series.geometry, GeoSeries)", "ground_truth": "(5, 2)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMerging"}
{"task_id": "geopandas_520", "reponame": "geopandas", "testpath": "geopandas/tests/test_merge.py", "testname": "test_merge.py", "funcname": "test_concat_axis0", "imports": ["import warnings", "import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_21", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from pandas.testing import assert_index_equal"], "code": "def test_concat_axis0(self):\n    gdf1 = GeoDataFrame({'geometry': GeoSeries([Point((- 1), 1), Point(1000000000000.0, (- 1000000000000.0)), Point(0, 0)]), 'values': [0.0, (- 99999.99), 1e+20]})\n    gdf2 = GeoDataFrame({'geometry': GeoSeries([Point(2.2, (- 3.3)), Point(1000, 2000)]), 'values': [float('inf'), float('-inf')]})\n    empty_gdf = GeoDataFrame({'geometry': GeoSeries([], dtype='geometry'), 'values': []})\n    res = pd.concat([gdf1, gdf2])\n    assert (res.shape == (5, 2))\n    assert isinstance(res, GeoDataFrame)\n    assert isinstance(res.geometry, GeoSeries)\n    self._check_metadata(res)\n    exp = GeoDataFrame(pd.concat([pd.DataFrame(gdf1), pd.DataFrame(gdf2)]))\n    assert_geodataframe_equal(exp, res)\n    res_empty = pd.concat([gdf1, empty_gdf])\n    assert (res_empty.shape == (3, 2))\n    assert isinstance(res_empty, GeoDataFrame)\n    assert isinstance(res_empty.geometry, GeoSeries)\n    geo_ser = GeoSeries([Point((- 500), 0), Point(0, 500), Point(1e+16, (- 1e+16)), Point(0, 0)])\n    res_series = pd.concat([geo_ser, geo_ser])\n    assert (res_series.shape == (8,))\n    assert isinstance(res_series, GeoSeries)\n    assert isinstance(res_series.geometry, GeoSeries)", "masked_code": "def test_concat_axis0(self):\n    gdf1 = GeoDataFrame({'geometry': GeoSeries([Point((- 1), 1), Point(1000000000000.0, (- 1000000000000.0)), Point(0, 0)]), 'values': [0.0, (- 99999.99), 1e+20]})\n    gdf2 = GeoDataFrame({'geometry': GeoSeries([Point(2.2, (- 3.3)), Point(1000, 2000)]), 'values': [float('inf'), float('-inf')]})\n    empty_gdf = GeoDataFrame({'geometry': GeoSeries([], dtype='geometry'), 'values': []})\n    res = pd.concat([gdf1, gdf2])\n    assert (res.shape == (5, 2))\n    assert isinstance(res, GeoDataFrame)\n    assert isinstance(res.geometry, GeoSeries)\n    self._check_metadata(res)\n    exp = GeoDataFrame(pd.concat([pd.DataFrame(gdf1), pd.DataFrame(gdf2)]))\n    assert_geodataframe_equal(exp, res)\n    res_empty = pd.concat([gdf1, empty_gdf])\n    assert (res_empty.shape == '???')\n    assert isinstance(res_empty, GeoDataFrame)\n    assert isinstance(res_empty.geometry, GeoSeries)\n    geo_ser = GeoSeries([Point((- 500), 0), Point(0, 500), Point(1e+16, (- 1e+16)), Point(0, 0)])\n    res_series = pd.concat([geo_ser, geo_ser])\n    assert (res_series.shape == (8,))\n    assert isinstance(res_series, GeoSeries)\n    assert isinstance(res_series.geometry, GeoSeries)", "ground_truth": "(3, 2)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMerging"}
{"task_id": "geopandas_521", "reponame": "geopandas", "testpath": "geopandas/tests/test_merge.py", "testname": "test_merge.py", "funcname": "test_concat_axis1", "imports": ["import warnings", "import pandas as pd", "from shapely.geometry import Point", "from geopandas import GeoDataFrame, GeoSeries", "from geopandas._compat import HAS_PYPROJ, PANDAS_GE_21", "import pytest", "from geopandas.testing import assert_geodataframe_equal", "from pandas.testing import assert_index_equal"], "code": "def test_concat_axis1(self):\n    gdf = GeoDataFrame({'geometry': GeoSeries([Point(0, 0), Point(1.5, (- 2.3)), Point((- 1000000000.0), 1000000000.0)]), 'val_flt': [0.0, (- 999.4), 9999999.9], 'val_str': ['', 'abc', 'xyz'], 'val_nan': [float('nan'), 2, None]})\n    df = pd.DataFrame({'colA': [0, (- 1), 100000.0], 'colB': [float('inf'), float('-inf'), 0], 'colS': ['foo', '', 'bar']})\n    res = pd.concat([gdf, df], axis=1)\n    assert (res.shape == (3, 7))\n    assert isinstance(res, GeoDataFrame)\n    assert isinstance(res.geometry, GeoSeries)\n    self._check_metadata(res)", "masked_code": "def test_concat_axis1(self):\n    gdf = GeoDataFrame({'geometry': GeoSeries([Point(0, 0), Point(1.5, (- 2.3)), Point((- 1000000000.0), 1000000000.0)]), 'val_flt': [0.0, (- 999.4), 9999999.9], 'val_str': ['', 'abc', 'xyz'], 'val_nan': [float('nan'), 2, None]})\n    df = pd.DataFrame({'colA': [0, (- 1), 100000.0], 'colB': [float('inf'), float('-inf'), 0], 'colS': ['foo', '', 'bar']})\n    res = pd.concat([gdf, df], axis=1)\n    assert (res.shape == '???')\n    assert isinstance(res, GeoDataFrame)\n    assert isinstance(res.geometry, GeoSeries)\n    self._check_metadata(res)", "ground_truth": "(3, 7)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestMerging"}
{"task_id": "geopandas_523", "reponame": "geopandas", "testpath": "geopandas/tests/test_op_output_types.py", "testname": "test_op_output_types.py", "funcname": "test_constructor_sliced_row_slices", "imports": ["import numpy as np", "import pandas as pd", "from shapely.geometry import Point", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries", "import pytest", "from geopandas.testing import assert_geodataframe_equal"], "code": "@pytest.mark.parametrize('column_set', test_case_column_sets, ids=[', '.join(i) for i in test_case_column_sets])\ndef test_constructor_sliced_row_slices(df2, column_set):\n    df_subset = df2[column_set]\n    assert isinstance(df_subset, GeoDataFrame)\n    res = df_subset.loc[0]\n    assert (type(res) is pd.Series)\n    if ('geometry' in column_set):\n        assert (not isinstance(res.geometry, pd.Series))\n        assert (res.geometry == Point(0.0, 0.0))\n    if ('geometry2' in column_set):\n        assert (res.geometry2 == Point((- 1000), 10000000000.0))\n    if ('geometry3' in column_set):\n        assert (res.geometry3 == Point(0, 1000))\n    if ('value' in column_set):\n        assert (res.value == 0)\n    if ('value_nan' in column_set):\n        assert (pd.isnull(res.value_nan) or (res.value_nan == '') or (res.value_nan is None))", "masked_code": "@pytest.mark.parametrize('column_set', test_case_column_sets, ids=[', '.join(i) for i in test_case_column_sets])\ndef test_constructor_sliced_row_slices(df2, column_set):\n    df_subset = df2[column_set]\n    assert isinstance(df_subset, GeoDataFrame)\n    res = df_subset.loc[0]\n    assert (type(res) is pd.Series)\n    if ('geometry' in column_set):\n        assert (not isinstance(res.geometry, pd.Series))\n        assert (res.geometry == '???')\n    if ('geometry2' in column_set):\n        assert (res.geometry2 == Point((- 1000), 10000000000.0))\n    if ('geometry3' in column_set):\n        assert (res.geometry3 == Point(0, 1000))\n    if ('value' in column_set):\n        assert (res.value == 0)\n    if ('value_nan' in column_set):\n        assert (pd.isnull(res.value_nan) or (res.value_nan == '') or (res.value_nan is None))", "ground_truth": "Point(0.0, 0.0)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_522", "reponame": "geopandas", "testpath": "geopandas/tests/test_op_output_types.py", "testname": "test_op_output_types.py", "funcname": "test_loc_add_row", "imports": ["import numpy as np", "import pandas as pd", "from shapely.geometry import Point", "import geopandas", "from geopandas import GeoDataFrame, GeoSeries", "import pytest", "from geopandas.testing import assert_geodataframe_equal"], "code": "@pytest.mark.parametrize('geom_name', ['geometry', pytest.param('geom', marks=pytest.mark.xfail(reason='pre-regression behaviour only works for geometry col geometry'))])\ndef test_loc_add_row(geom_name, nybb_filename):\n    nybb = geopandas.read_file(nybb_filename)[['BoroCode', 'geometry']]\n    if (geom_name != 'geometry'):\n        nybb = nybb.rename_geometry(geom_name)\n    nybb.loc[100] = [(- 99999999), None]\n    nybb.loc[5] = [6.7, nybb.geometry.iloc[0]]\n    assert (nybb.geometry.dtype == 'geometry')\n    assert (nybb.crs is None)", "masked_code": "@pytest.mark.parametrize('geom_name', ['geometry', pytest.param('geom', marks=pytest.mark.xfail(reason='pre-regression behaviour only works for geometry col geometry'))])\ndef test_loc_add_row(geom_name, nybb_filename):\n    nybb = geopandas.read_file(nybb_filename)[['BoroCode', 'geometry']]\n    if (geom_name != 'geometry'):\n        nybb = nybb.rename_geometry(geom_name)\n    nybb.loc[100] = [(- 99999999), None]\n    nybb.loc[5] = [6.7, nybb.geometry.iloc[0]]\n    assert (nybb.geometry.dtype == '???')\n    assert (nybb.crs is None)", "ground_truth": "'geometry'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_641", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_random.py", "testname": "test_random.py", "funcname": "test_uniform", "imports": ["import numpy", "import shapely", "import geopandas", "from geopandas.tools._random import uniform", "import pytest"], "code": "@pytest.mark.parametrize('size', [0, 1, 10, 999])\n@pytest.mark.parametrize('geom_fixture', ['multipolygons', 'polygons', 'multilinestrings', 'linestrings'])\ndef test_uniform(geom_fixture, size, request):\n    geom = request.getfixturevalue(geom_fixture)[0]\n    sample = uniform(geom, size=size, rng=1)\n    sample_series = geopandas.GeoSeries(sample).explode(index_parts=True).reset_index(drop=True)\n    assert (len(sample_series) == size)\n    sample_in_geom = sample_series.buffer(1e-08).sindex.query(geom, predicate='intersects')\n    assert (len(sample_in_geom) == size)", "masked_code": "@pytest.mark.parametrize('size', [0, 1, 10, 999])\n@pytest.mark.parametrize('geom_fixture', ['multipolygons', 'polygons', 'multilinestrings', 'linestrings'])\ndef test_uniform(geom_fixture, size, request):\n    geom = request.getfixturevalue(geom_fixture)[0]\n    sample = uniform(geom, size=size, rng=1)\n    sample_series = geopandas.GeoSeries(sample).explode(index_parts=True).reset_index(drop=True)\n    assert (len(sample_series) == '???')\n    sample_in_geom = sample_series.buffer(1e-08).sindex.query(geom, predicate='intersects')\n    assert (len(sample_in_geom) == size)", "ground_truth": "size", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "geopandas_642", "reponame": "geopandas", "testpath": "geopandas/tools/tests/test_random.py", "testname": "test_random.py", "funcname": "test_uniform", "imports": ["import numpy", "import shapely", "import geopandas", "from geopandas.tools._random import uniform", "import pytest"], "code": "@pytest.mark.parametrize('size', [0, 1, 10, 999])\n@pytest.mark.parametrize('geom_fixture', ['multipolygons', 'polygons', 'multilinestrings', 'linestrings'])\ndef test_uniform(geom_fixture, size, request):\n    geom = request.getfixturevalue(geom_fixture)[0]\n    sample = uniform(geom, size=size, rng=1)\n    sample_series = geopandas.GeoSeries(sample).explode(index_parts=True).reset_index(drop=True)\n    assert (len(sample_series) == size)\n    sample_in_geom = sample_series.buffer(1e-08).sindex.query(geom, predicate='intersects')\n    assert (len(sample_in_geom) == size)", "masked_code": "@pytest.mark.parametrize('size', [0, 1, 10, 999])\n@pytest.mark.parametrize('geom_fixture', ['multipolygons', 'polygons', 'multilinestrings', 'linestrings'])\ndef test_uniform(geom_fixture, size, request):\n    geom = request.getfixturevalue(geom_fixture)[0]\n    sample = uniform(geom, size=size, rng=1)\n    sample_series = geopandas.GeoSeries(sample).explode(index_parts=True).reset_index(drop=True)\n    assert (len(sample_series) == size)\n    sample_in_geom = sample_series.buffer(1e-08).sindex.query(geom, predicate='intersects')\n    assert (len(sample_in_geom) == '???')", "ground_truth": "size", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
