{"task_id": "stellargraph_767", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "def test_flow(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=2)\n    dataset = generator.flow(batch_size=3)\n    assert (tf.data.experimental.cardinality(dataset).numpy() == (- 1))", "masked_code": "def test_flow(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=2)\n    dataset = generator.flow(batch_size=3)\n    assert (tf.data.experimental.cardinality(dataset).numpy() == '???')", "ground_truth": "(- 1)", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_768", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('batch_size', [0, 2, 50])\ndef test_flow_batch_size(barbell, batch_size):\n    num_powers = 3\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=(batch_size if (batch_size > 0) else 1)).take(1):\n        assert (x[0].shape == ((batch_size if (batch_size > 0) else 1),))\n        assert (y.shape == ((batch_size if (batch_size > 0) else 1), 1, len(barbell.nodes())))\n        assert (x[1].shape == ((batch_size if (batch_size > 0) else 1), num_powers, len(barbell.nodes())))", "masked_code": "@pytest.mark.parametrize('batch_size', [0, 2, 50])\ndef test_flow_batch_size(barbell, batch_size):\n    num_powers = 3\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=(batch_size if (batch_size > 0) else 1)).take(1):\n        assert (x[0].shape == '???')\n        assert (y.shape == ((batch_size if (batch_size > 0) else 1), 1, len(barbell.nodes())))\n        assert (x[1].shape == ((batch_size if (batch_size > 0) else 1), num_powers, len(barbell.nodes())))", "ground_truth": "((batch_size if (batch_size > 0) else 1),)", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_769", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('batch_size', [0, 2, 50])\ndef test_flow_batch_size(barbell, batch_size):\n    num_powers = 3\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=(batch_size if (batch_size > 0) else 1)).take(1):\n        assert (x[0].shape == ((batch_size if (batch_size > 0) else 1),))\n        assert (y.shape == ((batch_size if (batch_size > 0) else 1), 1, len(barbell.nodes())))\n        assert (x[1].shape == ((batch_size if (batch_size > 0) else 1), num_powers, len(barbell.nodes())))", "masked_code": "@pytest.mark.parametrize('batch_size', [0, 2, 50])\ndef test_flow_batch_size(barbell, batch_size):\n    num_powers = 3\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=(batch_size if (batch_size > 0) else 1)).take(1):\n        assert (x[0].shape == ((batch_size if (batch_size > 0) else 1),))\n        assert (y.shape == '???')\n        assert (x[1].shape == ((batch_size if (batch_size > 0) else 1), num_powers, len(barbell.nodes())))", "ground_truth": "((batch_size if (batch_size > 0) else 1), 1, len(barbell.nodes()))", "quality_analysis": {"complexity_score": 11, "left_complexity": 2, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_770", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('batch_size', [0, 2, 50])\ndef test_flow_batch_size(barbell, batch_size):\n    num_powers = 3\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=(batch_size if (batch_size > 0) else 1)).take(1):\n        assert (x[0].shape == ((batch_size if (batch_size > 0) else 1),))\n        assert (y.shape == ((batch_size if (batch_size > 0) else 1), 1, len(barbell.nodes())))\n        assert (x[1].shape == ((batch_size if (batch_size > 0) else 1), num_powers, len(barbell.nodes())))", "masked_code": "@pytest.mark.parametrize('batch_size', [0, 2, 50])\ndef test_flow_batch_size(barbell, batch_size):\n    num_powers = 3\n    generator = AdjacencyPowerGenerator(barbell, num_powers=num_powers)\n    for (x, y) in generator.flow(batch_size=(batch_size if (batch_size > 0) else 1)).take(1):\n        assert (x[0].shape == ((batch_size if (batch_size > 0) else 1),))\n        assert (y.shape == ((batch_size if (batch_size > 0) else 1), 1, len(barbell.nodes())))\n        assert (x[1].shape == '???')", "ground_truth": "((batch_size if (batch_size > 0) else 1), num_powers, len(barbell.nodes()))", "quality_analysis": {"complexity_score": 11, "left_complexity": 2, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_771", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('num_powers', [0, 3, 16])\ndef test_flow_batch_size(barbell, num_powers):\n    batch_size = 4\n    generator = AdjacencyPowerGenerator(barbell, num_powers=(num_powers if (num_powers > 0) else 1))\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        npw = (num_powers if (num_powers > 0) else 1)\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == (batch_size, npw, len(barbell.nodes())))", "masked_code": "@pytest.mark.parametrize('num_powers', [0, 3, 16])\ndef test_flow_batch_size(barbell, num_powers):\n    batch_size = 4\n    generator = AdjacencyPowerGenerator(barbell, num_powers=(num_powers if (num_powers > 0) else 1))\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        npw = (num_powers if (num_powers > 0) else 1)\n        assert (x[0].shape == '???')\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == (batch_size, npw, len(barbell.nodes())))", "ground_truth": "(batch_size,)", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_772", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('num_powers', [0, 3, 16])\ndef test_flow_batch_size(barbell, num_powers):\n    batch_size = 4\n    generator = AdjacencyPowerGenerator(barbell, num_powers=(num_powers if (num_powers > 0) else 1))\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        npw = (num_powers if (num_powers > 0) else 1)\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == (batch_size, npw, len(barbell.nodes())))", "masked_code": "@pytest.mark.parametrize('num_powers', [0, 3, 16])\ndef test_flow_batch_size(barbell, num_powers):\n    batch_size = 4\n    generator = AdjacencyPowerGenerator(barbell, num_powers=(num_powers if (num_powers > 0) else 1))\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        npw = (num_powers if (num_powers > 0) else 1)\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == '???')\n        assert (x[1].shape == (batch_size, npw, len(barbell.nodes())))", "ground_truth": "(batch_size, 1, len(barbell.nodes()))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_773", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('num_powers', [0, 3, 16])\ndef test_flow_batch_size(barbell, num_powers):\n    batch_size = 4\n    generator = AdjacencyPowerGenerator(barbell, num_powers=(num_powers if (num_powers > 0) else 1))\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        npw = (num_powers if (num_powers > 0) else 1)\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == (batch_size, npw, len(barbell.nodes())))", "masked_code": "@pytest.mark.parametrize('num_powers', [0, 3, 16])\ndef test_flow_batch_size(barbell, num_powers):\n    batch_size = 4\n    generator = AdjacencyPowerGenerator(barbell, num_powers=(num_powers if (num_powers > 0) else 1))\n    for (x, y) in generator.flow(batch_size=batch_size).take(1):\n        npw = (num_powers if (num_powers > 0) else 1)\n        assert (x[0].shape == (batch_size,))\n        assert (y.shape == (batch_size, 1, len(barbell.nodes())))\n        assert (x[1].shape == '???')", "ground_truth": "(batch_size, npw, len(barbell.nodes()))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_764", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_init", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "def test_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=8)\n    num_nodes = len(barbell.nodes())\n    assert (generator.num_powers == 8)\n    assert (generator.Aadj_T.shape == (num_nodes, num_nodes))\n    assert (generator.transition_matrix_T.shape == (num_nodes, num_nodes))", "masked_code": "def test_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=8)\n    num_nodes = len(barbell.nodes())\n    assert (generator.num_powers == '???')\n    assert (generator.Aadj_T.shape == (num_nodes, num_nodes))\n    assert (generator.transition_matrix_T.shape == (num_nodes, num_nodes))", "ground_truth": "8", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_765", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_init", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "def test_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=8)\n    num_nodes = len(barbell.nodes())\n    assert (generator.num_powers == 8)\n    assert (generator.Aadj_T.shape == (num_nodes, num_nodes))\n    assert (generator.transition_matrix_T.shape == (num_nodes, num_nodes))", "masked_code": "def test_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=8)\n    num_nodes = len(barbell.nodes())\n    assert (generator.num_powers == 8)\n    assert (generator.Aadj_T.shape == '???')\n    assert (generator.transition_matrix_T.shape == (num_nodes, num_nodes))", "ground_truth": "(num_nodes, num_nodes)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_766", "reponame": "stellargraph", "testpath": "tests/mapper/test_adjacency_generators.py", "testname": "test_adjacency_generators.py", "funcname": "test_init", "imports": ["from stellargraph.core.utils import normalize_adj", "from stellargraph.mapper.adjacency_generators import AdjacencyPowerGenerator", "from ..test_utils.graphs import barbell", "import tensorflow as tf", "import numpy as np", "import pytest"], "code": "def test_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=8)\n    num_nodes = len(barbell.nodes())\n    assert (generator.num_powers == 8)\n    assert (generator.Aadj_T.shape == (num_nodes, num_nodes))\n    assert (generator.transition_matrix_T.shape == (num_nodes, num_nodes))", "masked_code": "def test_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=8)\n    num_nodes = len(barbell.nodes())\n    assert (generator.num_powers == 8)\n    assert (generator.Aadj_T.shape == (num_nodes, num_nodes))\n    assert (generator.transition_matrix_T.shape == '???')", "ground_truth": "(num_nodes, num_nodes)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_794", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "masked_code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == '???')\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "ground_truth": "tree_len", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_795", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "masked_code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == '???')\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "ground_truth": "len(node_ids)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_796", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "masked_code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == '???')\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "ground_truth": "(len(node_ids), 1, 1)", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_797", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "masked_code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == '???')\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "ground_truth": "(len(node_ids), 2, 1)", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_798", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "masked_code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == '???')\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "ground_truth": "(len(node_ids), 2, 1)", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_799", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "masked_code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == '???')\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "ground_truth": "(len(node_ids), 4, 1)", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_800", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "masked_code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == '???')\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "ground_truth": "(len(node_ids), 4, 1)", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_801", "reponame": "stellargraph", "testpath": "tests/mapper/test_directed_node_generator.py", "testname": "test_directed_node_generator.py", "funcname": "test_two_hop", "imports": ["import networkx as nx", "import pandas as pd", "from stellargraph.mapper import DirectedGraphSAGENodeGenerator", "from stellargraph.core.graph import StellarDiGraph", "from ..test_utils.graphs import weighted_tree"], "code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == expected)\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "masked_code": "def test_two_hop(self):\n    nodes = pd.DataFrame([0.0, (- 1000.0), 100000.0, (- 2.5)], index=[10, 20, 30, 40])\n    edges = pd.DataFrame([(10, 20), (20, 30), (30, 40), (40, 10), (20, 40), (10, 30)], columns=['source', 'target'])\n    g = StellarDiGraph(nodes, edges)\n    node_ids = [10, 20, 30, 40]\n    gen = DirectedGraphSAGENodeGenerator(g, batch_size=g.number_of_nodes(), in_samples=[2, 2], out_samples=[2, 2])\n    flow = gen.flow(node_ids=node_ids, shuffle=False)\n    node_ilocs = g.node_ids_to_ilocs(node_ids)\n    features = gen.sample_features(node_ilocs, 0)\n    num_hops = 2\n    tree_len = ((2 ** (num_hops + 1)) - 1)\n    assert (len(features) == tree_len)\n    node_features = features[0]\n    assert (len(node_features) == len(node_ids))\n    assert (node_features.shape == (len(node_ids), 1, 1))\n    for (idx, node) in enumerate(node_ids):\n        expected = nodes.loc[(node, 0)]\n        assert (node_features[(idx, 0, 0)] == '???')\n    in_features = features[1]\n    assert (in_features.shape == (len(node_ids), 2, 1))\n    out_features = features[2]\n    assert (out_features.shape == (len(node_ids), 2, 1))\n    assert (in_features[(0, 0, 0)] in ((- 2.5), 0.0))\n    assert (out_features[(2, 1, 0)] in (0.0, (- 2.5), 100000.0, (- 1000.0)))\n    in_in_features = features[3]\n    assert (in_in_features.shape == (len(node_ids), 4, 1))\n    assert (in_in_features[(1, 1, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))\n    out_out_features = features[6]\n    assert (out_out_features.shape == (len(node_ids), 4, 1))\n    assert (out_out_features[(3, 0, 0)] in (0.0, (- 2.5), (- 1000.0), 100000.0))", "ground_truth": "expected", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestDirectedNodeGenerator"}
{"task_id": "stellargraph_46", "reponame": "stellargraph", "testpath": "tests/core/test_element_data.py", "testname": "test_element_data.py", "funcname": "test_external_id_index_to_iloc", "imports": ["import pytest", "import numpy as np", "from stellargraph.core.element_data import ExternalIdIndex"], "code": "@pytest.mark.parametrize('count,expected_missing', [(0, 255), (1, 255), (255, 255), (256, 65535), (1024, 65535), (65535, 65535), (65536, 4294967295), (100000, 4294967295)])\ndef test_external_id_index_to_iloc(count, expected_missing):\n    if (count == 0):\n        values = []\n    elif (count == 1):\n        values = ['']\n    else:\n        values = [(f'id{x}' if ((x % 2) == 0) else f\"{('x' * 100)}{x}\") for x in range(count)]\n    idx = ExternalIdIndex(values)\n    all_ilocs = idx.to_iloc(values)\n    assert (all_ilocs == list(range(count))).all()\n    assert (all_ilocs < expected_missing).all()\n    if (count <= 256):\n        for (i, x) in enumerate(values):\n            np.testing.assert_array_equal(idx.to_iloc([x]), [i])\n    missing_ids = (['not_included', ''] if ('' not in values) else ['not_included', 'completely_blank'])\n    for missing_id in missing_ids:\n        assert (idx.to_iloc([missing_id]) == expected_missing)", "masked_code": "@pytest.mark.parametrize('count,expected_missing', [(0, 255), (1, 255), (255, 255), (256, 65535), (1024, 65535), (65535, 65535), (65536, 4294967295), (100000, 4294967295)])\ndef test_external_id_index_to_iloc(count, expected_missing):\n    if (count == 0):\n        values = []\n    elif (count == 1):\n        values = ['']\n    else:\n        values = [(f'id{x}' if ((x % 2) == 0) else f\"{('x' * 100)}{x}\") for x in range(count)]\n    idx = ExternalIdIndex(values)\n    all_ilocs = idx.to_iloc(values)\n    assert (all_ilocs == list(range(count))).all()\n    assert (all_ilocs < expected_missing).all()\n    if (count <= 256):\n        for (i, x) in enumerate(values):\n            np.testing.assert_array_equal(idx.to_iloc([x]), [i])\n    missing_ids = (['not_included', ''] if ('' not in values) else ['not_included', 'completely_blank'])\n    for missing_id in missing_ids:\n        assert (idx.to_iloc([missing_id]) == '???')", "ground_truth": "expected_missing", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_366", "reponame": "stellargraph", "testpath": "tests/data/test_epgm.py", "testname": "test_epgm.py", "funcname": "test_node_attributes", "imports": ["import pytest", "import os", "import numpy as np", "from stellargraph.data.epgm import EPGM"], "code": "def test_node_attributes(self):\n    'Test the .node_attributes() method'\n    G_epgm = EPGM(self.input_dir)\n    graph_id = G_epgm.G['graphs'][0]['id']\n    node_attributes = G_epgm.node_attributes(graph_id, (self.node_type + 'X'))\n    assert (self.target_attribute not in node_attributes)\n    assert (len(node_attributes) == 0), 'There should be 0 unique node attributes; found {}'.format(len(node_attributes))\n    assert (len(G_epgm.node_attributes(graph_id, '')) == 1433)\n    with pytest.raises(TypeError):\n        G_epgm.node_attributes(graph_id)", "masked_code": "def test_node_attributes(self):\n    'Test the .node_attributes() method'\n    G_epgm = EPGM(self.input_dir)\n    graph_id = G_epgm.G['graphs'][0]['id']\n    node_attributes = G_epgm.node_attributes(graph_id, (self.node_type + 'X'))\n    assert (self.target_attribute not in node_attributes)\n    assert (len(node_attributes) == 0), 'There should be 0 unique node attributes; found {}'.format(len(node_attributes))\n    assert (len(G_epgm.node_attributes(graph_id, '')) == '???')\n    with pytest.raises(TypeError):\n        G_epgm.node_attributes(graph_id)", "ground_truth": "1433", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_EPGM_IO_Homogeneous"}
{"task_id": "stellargraph_367", "reponame": "stellargraph", "testpath": "tests/data/test_epgm.py", "testname": "test_epgm.py", "funcname": "test_node_attributes", "imports": ["import pytest", "import os", "import numpy as np", "from stellargraph.data.epgm import EPGM"], "code": "def test_node_attributes(self):\n    G_epgm = EPGM(self.input_dir)\n    graph_id = G_epgm.G['graphs'][0]['id']\n    node_attributes = G_epgm.node_attributes(graph_id, (self.node_type + 'X'))\n    assert (self.target_attribute not in node_attributes)\n    assert (len(node_attributes) == 0), 'There should be 0 unique node attributes; found {}'.format(len(node_attributes))\n    assert (len(G_epgm.node_attributes(graph_id, '')) == 1434)\n    with pytest.raises(TypeError):\n        G_epgm.node_attributes(graph_id)", "masked_code": "def test_node_attributes(self):\n    G_epgm = EPGM(self.input_dir)\n    graph_id = G_epgm.G['graphs'][0]['id']\n    node_attributes = G_epgm.node_attributes(graph_id, (self.node_type + 'X'))\n    assert (self.target_attribute not in node_attributes)\n    assert (len(node_attributes) == 0), 'There should be 0 unique node attributes; found {}'.format(len(node_attributes))\n    assert (len(G_epgm.node_attributes(graph_id, '')) == '???')\n    with pytest.raises(TypeError):\n        G_epgm.node_attributes(graph_id)", "ground_truth": "1434", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_47", "reponame": "stellargraph", "testpath": "tests/core/test_experimental.py", "testname": "test_experimental.py", "funcname": "test_experimental_class", "imports": ["import pytest", "import random", "from stellargraph.core.experimental import experimental, ExperimentalWarning"], "code": "def test_experimental_class(args, kwargs):\n    with pytest.warns(ExperimentalWarning, match='^ClassNoInit is experimental: class is experimental\\\\.'):\n        ClassNoInit()\n    with pytest.warns(ExperimentalWarning, match='^ClassInit is experimental: class is experimental\\\\.'):\n        instance = ClassInit(*args, **kwargs)\n    assert (instance.args == args)\n    assert (instance.kwargs == kwargs)", "masked_code": "def test_experimental_class(args, kwargs):\n    with pytest.warns(ExperimentalWarning, match='^ClassNoInit is experimental: class is experimental\\\\.'):\n        ClassNoInit()\n    with pytest.warns(ExperimentalWarning, match='^ClassInit is experimental: class is experimental\\\\.'):\n        instance = ClassInit(*args, **kwargs)\n    assert (instance.args == '???')\n    assert (instance.kwargs == kwargs)", "ground_truth": "args", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_48", "reponame": "stellargraph", "testpath": "tests/core/test_experimental.py", "testname": "test_experimental.py", "funcname": "test_experimental_class", "imports": ["import pytest", "import random", "from stellargraph.core.experimental import experimental, ExperimentalWarning"], "code": "def test_experimental_class(args, kwargs):\n    with pytest.warns(ExperimentalWarning, match='^ClassNoInit is experimental: class is experimental\\\\.'):\n        ClassNoInit()\n    with pytest.warns(ExperimentalWarning, match='^ClassInit is experimental: class is experimental\\\\.'):\n        instance = ClassInit(*args, **kwargs)\n    assert (instance.args == args)\n    assert (instance.kwargs == kwargs)", "masked_code": "def test_experimental_class(args, kwargs):\n    with pytest.warns(ExperimentalWarning, match='^ClassNoInit is experimental: class is experimental\\\\.'):\n        ClassNoInit()\n    with pytest.warns(ExperimentalWarning, match='^ClassInit is experimental: class is experimental\\\\.'):\n        instance = ClassInit(*args, **kwargs)\n    assert (instance.args == args)\n    assert (instance.kwargs == '???')", "ground_truth": "kwargs", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_49", "reponame": "stellargraph", "testpath": "tests/core/test_experimental.py", "testname": "test_experimental.py", "funcname": "test_experimental_method", "imports": ["import pytest", "import random", "from stellargraph.core.experimental import experimental, ExperimentalWarning"], "code": "def test_experimental_method(args, kwargs):\n    instance = Class()\n    with pytest.warns(ExperimentalWarning, match='^Class\\\\.method is experimental: method is experimental\\\\.'):\n        ret = instance.method(*args, **kwargs)\n    assert (ret[0] is instance)\n    assert (ret[1:] == (args, kwargs))", "masked_code": "def test_experimental_method(args, kwargs):\n    instance = Class()\n    with pytest.warns(ExperimentalWarning, match='^Class\\\\.method is experimental: method is experimental\\\\.'):\n        ret = instance.method(*args, **kwargs)\n    assert (ret[0] is instance)\n    assert (ret[1:] == '???')", "ground_truth": "(args, kwargs)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_818", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_fullbatch_generator_transform", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_fullbatch_generator_transform(self):\n    (G, feats) = create_graph_features()\n\n    def func(features, A, **kwargs):\n        return (features[::(- 1)], A.dot(A))\n    generator = FullBatchNodeGenerator(G, 'reversed', transform=func)\n    assert (generator.name == 'reversed')\n    A = G.to_adjacency_matrix().toarray()\n    np.testing.assert_array_equal(A.dot(A), generator.Aadj.toarray())\n    np.testing.assert_array_equal(feats[::(- 1)], generator.features)", "masked_code": "def test_fullbatch_generator_transform(self):\n    (G, feats) = create_graph_features()\n\n    def func(features, A, **kwargs):\n        return (features[::(- 1)], A.dot(A))\n    generator = FullBatchNodeGenerator(G, 'reversed', transform=func)\n    assert (generator.name == '???')\n    A = G.to_adjacency_matrix().toarray()\n    np.testing.assert_array_equal(A.dot(A), generator.Aadj.toarray())\n    np.testing.assert_array_equal(feats[::(- 1)], generator.features)", "ground_truth": "'reversed'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchNodeGenerator"}
{"task_id": "stellargraph_823", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_fullbatch_generator_transform", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_fullbatch_generator_transform(self):\n\n    def func(features, A, **kwargs):\n        return ((- features), A.dot(A))\n    generator = FullBatchNodeGenerator(self.G, 'negated', transform=func)\n    assert (generator.name == 'negated')\n    A = self.G.to_adjacency_matrix().toarray()\n    np.testing.assert_array_equal(A.dot(A), generator.Aadj.toarray())\n    np.testing.assert_array_equal((- generator.features), (generator.features * (- 1)))", "masked_code": "def test_fullbatch_generator_transform(self):\n\n    def func(features, A, **kwargs):\n        return ((- features), A.dot(A))\n    generator = FullBatchNodeGenerator(self.G, 'negated', transform=func)\n    assert (generator.name == '???')\n    A = self.G.to_adjacency_matrix().toarray()\n    np.testing.assert_array_equal(A.dot(A), generator.Aadj.toarray())\n    np.testing.assert_array_equal((- generator.features), (generator.features * (- 1)))", "ground_truth": "'negated'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchLinkGenerator"}
{"task_id": "stellargraph_814", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_constructor", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_constructor(self):\n    G_large = example_graph_random(feature_size=12, n_nodes=25, n_isolates=4, n_edges=60)\n    generator = FullBatchNodeGenerator(G_large)\n    assert (generator.Aadj.shape == (25, 25))\n    assert (generator.features.shape == (25, 12))", "masked_code": "def test_generator_constructor(self):\n    G_large = example_graph_random(feature_size=12, n_nodes=25, n_isolates=4, n_edges=60)\n    generator = FullBatchNodeGenerator(G_large)\n    assert (generator.Aadj.shape == '???')\n    assert (generator.features.shape == (25, 12))", "ground_truth": "(25, 25)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchNodeGenerator"}
{"task_id": "stellargraph_815", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_constructor", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_constructor(self):\n    G_large = example_graph_random(feature_size=12, n_nodes=25, n_isolates=4, n_edges=60)\n    generator = FullBatchNodeGenerator(G_large)\n    assert (generator.Aadj.shape == (25, 25))\n    assert (generator.features.shape == (25, 12))", "masked_code": "def test_generator_constructor(self):\n    G_large = example_graph_random(feature_size=12, n_nodes=25, n_isolates=4, n_edges=60)\n    generator = FullBatchNodeGenerator(G_large)\n    assert (generator.Aadj.shape == (25, 25))\n    assert (generator.features.shape == '???')", "ground_truth": "(25, 12)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchNodeGenerator"}
{"task_id": "stellargraph_819", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_constructor", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_constructor(self):\n    G_edgecase = example_graph_random(feature_size=2, n_nodes=1, n_isolates=0, n_edges=0)\n    generator = FullBatchLinkGenerator(G_edgecase)\n    assert (generator.Aadj.shape == (1, 1))\n    assert (generator.features.shape == (1, 2))", "masked_code": "def test_generator_constructor(self):\n    G_edgecase = example_graph_random(feature_size=2, n_nodes=1, n_isolates=0, n_edges=0)\n    generator = FullBatchLinkGenerator(G_edgecase)\n    assert (generator.Aadj.shape == '???')\n    assert (generator.features.shape == (1, 2))", "ground_truth": "(1, 1)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchLinkGenerator"}
{"task_id": "stellargraph_820", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_constructor", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_constructor(self):\n    G_edgecase = example_graph_random(feature_size=2, n_nodes=1, n_isolates=0, n_edges=0)\n    generator = FullBatchLinkGenerator(G_edgecase)\n    assert (generator.Aadj.shape == (1, 1))\n    assert (generator.features.shape == (1, 2))", "masked_code": "def test_generator_constructor(self):\n    G_edgecase = example_graph_random(feature_size=2, n_nodes=1, n_isolates=0, n_edges=0)\n    generator = FullBatchLinkGenerator(G_edgecase)\n    assert (generator.Aadj.shape == (1, 1))\n    assert (generator.features.shape == '???')", "ground_truth": "(1, 2)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchLinkGenerator"}
{"task_id": "stellargraph_816", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_flow_targets_as_list", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchNodeGenerator(self.G)\n    node_ids = list(self.G.nodes())[:5]\n    node_targets = [(- 2), 0, 10, 9999, (- 9999)]\n    gen = generator.flow(node_ids, node_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == (1, 5))\n    assert (np.sum(y) == 8)", "masked_code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchNodeGenerator(self.G)\n    node_ids = list(self.G.nodes())[:5]\n    node_targets = [(- 2), 0, 10, 9999, (- 9999)]\n    gen = generator.flow(node_ids, node_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == '???')\n    assert (np.sum(y) == 8)", "ground_truth": "(1, 5)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchNodeGenerator"}
{"task_id": "stellargraph_817", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_flow_targets_as_list", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchNodeGenerator(self.G)\n    node_ids = list(self.G.nodes())[:5]\n    node_targets = [(- 2), 0, 10, 9999, (- 9999)]\n    gen = generator.flow(node_ids, node_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == (1, 5))\n    assert (np.sum(y) == 8)", "masked_code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchNodeGenerator(self.G)\n    node_ids = list(self.G.nodes())[:5]\n    node_targets = [(- 2), 0, 10, 9999, (- 9999)]\n    gen = generator.flow(node_ids, node_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == (1, 5))\n    assert (np.sum(y) == '???')", "ground_truth": "8", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchNodeGenerator"}
{"task_id": "stellargraph_821", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_flow_targets_as_list", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchLinkGenerator(self.G)\n    link_ids = list(self.G.edges())[:4]\n    link_targets = [0, 123456789, (- 100), 0]\n    gen = generator.flow(link_ids, link_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == (1, 4))\n    assert (np.sum(y) == 123456689)", "masked_code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchLinkGenerator(self.G)\n    link_ids = list(self.G.edges())[:4]\n    link_targets = [0, 123456789, (- 100), 0]\n    gen = generator.flow(link_ids, link_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == '???')\n    assert (np.sum(y) == 123456689)", "ground_truth": "(1, 4)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchLinkGenerator"}
{"task_id": "stellargraph_822", "reponame": "stellargraph", "testpath": "tests/mapper/test_full_batch_generators.py", "testname": "test_full_batch_generators.py", "funcname": "test_generator_flow_targets_as_list", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper import FullBatchGenerator, FullBatchLinkGenerator, FullBatchNodeGenerator", "import networkx as nx", "import numpy as np", "import random", "import pytest", "import pandas as pd", "import scipy.sparse as sps", "from ..test_utils.graphs import create_graph_features, example_graph_random, example_hin_1, example_graph"], "code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchLinkGenerator(self.G)\n    link_ids = list(self.G.edges())[:4]\n    link_targets = [0, 123456789, (- 100), 0]\n    gen = generator.flow(link_ids, link_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == (1, 4))\n    assert (np.sum(y) == 123456689)", "masked_code": "def test_generator_flow_targets_as_list(self):\n    generator = FullBatchLinkGenerator(self.G)\n    link_ids = list(self.G.edges())[:4]\n    link_targets = [0, 123456789, (- 100), 0]\n    gen = generator.flow(link_ids, link_targets)\n    (inputs, y) = gen[0]\n    assert (y.shape == (1, 4))\n    assert (np.sum(y) == '???')", "ground_truth": "123456689", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_FullBatchLinkGenerator"}
{"task_id": "stellargraph_558", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == '???')\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "ground_truth": "7", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_559", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == '???')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "ground_truth": "'elu'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_560", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == '???')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "ground_truth": "'GlorotUniform'", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_561", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == '???')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "ground_truth": "'Zeros'", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_562", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == '???')\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "ground_truth": "None", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_563", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == '???')\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "ground_truth": "None", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_564", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == '???')\n    assert (conf['bias_constraint'] == None)", "ground_truth": "None", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_565", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_GraphConvolution_config", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == None)", "masked_code": "def test_GraphConvolution_config():\n    (_, _, a) = get_timeseries_graph_data()\n    gc_layer = FixedAdjacencyGraphConvolution(units=7, A=a, activation='elu', use_bias=False)\n    conf = gc_layer.get_config()\n    assert (conf['units'] == 7)\n    assert (conf['activation'] == 'elu')\n    assert (conf['use_bias'] == False)\n    assert (conf['kernel_initializer']['class_name'] == 'GlorotUniform')\n    assert (conf['bias_initializer']['class_name'] == 'Zeros')\n    assert (conf['kernel_regularizer'] == None)\n    assert (conf['bias_regularizer'] == None)\n    assert (conf['kernel_constraint'] == None)\n    assert (conf['bias_constraint'] == '???')", "ground_truth": "None", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_571", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_activations", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_activations():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[6, 7, 8, 9], lstm_layer_sizes=[12, 15])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu', 'relu', 'relu'])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh'])\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[11], gc_activations=['sigmoid'], lstm_layer_sizes=[5, 8, 13])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh'])", "masked_code": "def test_gcn_lstm_activations():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[6, 7, 8, 9], lstm_layer_sizes=[12, 15])\n    assert (gcn_lstm_model.gc_activations == '???')\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh'])\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[11], gc_activations=['sigmoid'], lstm_layer_sizes=[5, 8, 13])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh'])", "ground_truth": "['relu', 'relu', 'relu', 'relu']", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_572", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_activations", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_activations():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[6, 7, 8, 9], lstm_layer_sizes=[12, 15])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu', 'relu', 'relu'])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh'])\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[11], gc_activations=['sigmoid'], lstm_layer_sizes=[5, 8, 13])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh'])", "masked_code": "def test_gcn_lstm_activations():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[6, 7, 8, 9], lstm_layer_sizes=[12, 15])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu', 'relu', 'relu'])\n    assert (gcn_lstm_model.lstm_activations == '???')\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[11], gc_activations=['sigmoid'], lstm_layer_sizes=[5, 8, 13])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh'])", "ground_truth": "['tanh', 'tanh']", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_573", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_activations", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_activations():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[6, 7, 8, 9], lstm_layer_sizes=[12, 15])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu', 'relu', 'relu'])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh'])\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[11], gc_activations=['sigmoid'], lstm_layer_sizes=[5, 8, 13])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh', 'tanh'])", "masked_code": "def test_gcn_lstm_activations():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[6, 7, 8, 9], lstm_layer_sizes=[12, 15])\n    assert (gcn_lstm_model.gc_activations == ['relu', 'relu', 'relu', 'relu'])\n    assert (gcn_lstm_model.lstm_activations == ['tanh', 'tanh'])\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[11], gc_activations=['sigmoid'], lstm_layer_sizes=[5, 8, 13])\n    assert (gcn_lstm_model.lstm_activations == '???')", "ground_truth": "['tanh', 'tanh', 'tanh']", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_574", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_layers", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_layers():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[32, 56, 77, 12], gc_activations=['relu', 'relu', 'relu', 'relu'], lstm_layer_sizes=[8, 16], lstm_activations=['tanh'])\n    assert (len(gcn_lstm_model._gc_layers) == len(gcn_lstm_model.gc_layer_sizes))\n    assert (len(gcn_lstm_model._lstm_layers) == len(gcn_lstm_model.lstm_layer_sizes))", "masked_code": "def test_gcn_lstm_layers():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[32, 56, 77, 12], gc_activations=['relu', 'relu', 'relu', 'relu'], lstm_layer_sizes=[8, 16], lstm_activations=['tanh'])\n    assert (len(gcn_lstm_model._gc_layers) == '???')\n    assert (len(gcn_lstm_model._lstm_layers) == len(gcn_lstm_model.lstm_layer_sizes))", "ground_truth": "len(gcn_lstm_model.gc_layer_sizes)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_575", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_layers", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_layers():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[32, 56, 77, 12], gc_activations=['relu', 'relu', 'relu', 'relu'], lstm_layer_sizes=[8, 16], lstm_activations=['tanh'])\n    assert (len(gcn_lstm_model._gc_layers) == len(gcn_lstm_model.gc_layer_sizes))\n    assert (len(gcn_lstm_model._lstm_layers) == len(gcn_lstm_model.lstm_layer_sizes))", "masked_code": "def test_gcn_lstm_layers():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[32, 56, 77, 12], gc_activations=['relu', 'relu', 'relu', 'relu'], lstm_layer_sizes=[8, 16], lstm_activations=['tanh'])\n    assert (len(gcn_lstm_model._gc_layers) == len(gcn_lstm_model.gc_layer_sizes))\n    assert (len(gcn_lstm_model._lstm_layers) == '???')", "ground_truth": "len(gcn_lstm_model.lstm_layer_sizes)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_566", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_model_parameters", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[3, 5, 4], gc_activations=['tanh', 'sigmoid', 'elu'], lstm_layer_sizes=[6, 12], lstm_activations=['relu', 'sigmoid'], dropout=0.2)\n    assert (gcn_lstm_model.gc_activations == ['tanh', 'sigmoid', 'elu'])\n    assert (gcn_lstm_model.dropout == 0.2)\n    assert (gcn_lstm_model.lstm_activations == ['relu', 'sigmoid'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [6, 12])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "masked_code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[3, 5, 4], gc_activations=['tanh', 'sigmoid', 'elu'], lstm_layer_sizes=[6, 12], lstm_activations=['relu', 'sigmoid'], dropout=0.2)\n    assert (gcn_lstm_model.gc_activations == '???')\n    assert (gcn_lstm_model.dropout == 0.2)\n    assert (gcn_lstm_model.lstm_activations == ['relu', 'sigmoid'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [6, 12])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "ground_truth": "['tanh', 'sigmoid', 'elu']", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_567", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_model_parameters", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[3, 5, 4], gc_activations=['tanh', 'sigmoid', 'elu'], lstm_layer_sizes=[6, 12], lstm_activations=['relu', 'sigmoid'], dropout=0.2)\n    assert (gcn_lstm_model.gc_activations == ['tanh', 'sigmoid', 'elu'])\n    assert (gcn_lstm_model.dropout == 0.2)\n    assert (gcn_lstm_model.lstm_activations == ['relu', 'sigmoid'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [6, 12])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "masked_code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[3, 5, 4], gc_activations=['tanh', 'sigmoid', 'elu'], lstm_layer_sizes=[6, 12], lstm_activations=['relu', 'sigmoid'], dropout=0.2)\n    assert (gcn_lstm_model.gc_activations == ['tanh', 'sigmoid', 'elu'])\n    assert (gcn_lstm_model.dropout == '???')\n    assert (gcn_lstm_model.lstm_activations == ['relu', 'sigmoid'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [6, 12])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "ground_truth": "0.2", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_568", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_model_parameters", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[3, 5, 4], gc_activations=['tanh', 'sigmoid', 'elu'], lstm_layer_sizes=[6, 12], lstm_activations=['relu', 'sigmoid'], dropout=0.2)\n    assert (gcn_lstm_model.gc_activations == ['tanh', 'sigmoid', 'elu'])\n    assert (gcn_lstm_model.dropout == 0.2)\n    assert (gcn_lstm_model.lstm_activations == ['relu', 'sigmoid'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [6, 12])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "masked_code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[3, 5, 4], gc_activations=['tanh', 'sigmoid', 'elu'], lstm_layer_sizes=[6, 12], lstm_activations=['relu', 'sigmoid'], dropout=0.2)\n    assert (gcn_lstm_model.gc_activations == ['tanh', 'sigmoid', 'elu'])\n    assert (gcn_lstm_model.dropout == 0.2)\n    assert (gcn_lstm_model.lstm_activations == '???')\n    assert (gcn_lstm_model.lstm_layer_sizes == [6, 12])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "ground_truth": "['relu', 'sigmoid']", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_569", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_model_parameters", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[3, 5, 4], gc_activations=['tanh', 'sigmoid', 'elu'], lstm_layer_sizes=[6, 12], lstm_activations=['relu', 'sigmoid'], dropout=0.2)\n    assert (gcn_lstm_model.gc_activations == ['tanh', 'sigmoid', 'elu'])\n    assert (gcn_lstm_model.dropout == 0.2)\n    assert (gcn_lstm_model.lstm_activations == ['relu', 'sigmoid'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [6, 12])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "masked_code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[3, 5, 4], gc_activations=['tanh', 'sigmoid', 'elu'], lstm_layer_sizes=[6, 12], lstm_activations=['relu', 'sigmoid'], dropout=0.2)\n    assert (gcn_lstm_model.gc_activations == ['tanh', 'sigmoid', 'elu'])\n    assert (gcn_lstm_model.dropout == 0.2)\n    assert (gcn_lstm_model.lstm_activations == ['relu', 'sigmoid'])\n    assert (gcn_lstm_model.lstm_layer_sizes == '???')\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "ground_truth": "[6, 12]", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_570", "reponame": "stellargraph", "testpath": "tests/layer/test_gcn_lstm.py", "testname": "test_gcn_lstm.py", "funcname": "test_gcn_lstm_model_parameters", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from tensorflow.keras import Model", "from stellargraph import StellarGraph, IndexedArray", "from stellargraph.layer import GCN_LSTM", "from stellargraph.layer import FixedAdjacencyGraphConvolution", "from stellargraph.mapper import SlidingFeaturesNodeGenerator", "from .. import test_utils"], "code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[3, 5, 4], gc_activations=['tanh', 'sigmoid', 'elu'], lstm_layer_sizes=[6, 12], lstm_activations=['relu', 'sigmoid'], dropout=0.2)\n    assert (gcn_lstm_model.gc_activations == ['tanh', 'sigmoid', 'elu'])\n    assert (gcn_lstm_model.dropout == 0.2)\n    assert (gcn_lstm_model.lstm_activations == ['relu', 'sigmoid'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [6, 12])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == len(gcn_lstm_model.lstm_activations))", "masked_code": "def test_gcn_lstm_model_parameters():\n    (fx, fy, a) = get_timeseries_graph_data()\n    gcn_lstm_model = GCN_LSTM(seq_len=fx.shape[(- 2)], adj=a, gc_layer_sizes=[3, 5, 4], gc_activations=['tanh', 'sigmoid', 'elu'], lstm_layer_sizes=[6, 12], lstm_activations=['relu', 'sigmoid'], dropout=0.2)\n    assert (gcn_lstm_model.gc_activations == ['tanh', 'sigmoid', 'elu'])\n    assert (gcn_lstm_model.dropout == 0.2)\n    assert (gcn_lstm_model.lstm_activations == ['relu', 'sigmoid'])\n    assert (gcn_lstm_model.lstm_layer_sizes == [6, 12])\n    assert (len(gcn_lstm_model.lstm_layer_sizes) == '???')", "ground_truth": "len(gcn_lstm_model.lstm_activations)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_829", "reponame": "stellargraph", "testpath": "tests/mapper/test_graphwave_generator.py", "testname": "test_graphwave_generator.py", "funcname": "test_embedding_dim", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.graphwave_generator import GraphWaveGenerator, _empirical_characteristic_function", "from ..test_utils.graphs import barbell", "import numpy as np", "import pytest", "import scipy.sparse as sps", "import tensorflow as tf"], "code": "@pytest.mark.parametrize('num_samples', [0, 5, 15])\ndef test_embedding_dim(barbell, num_samples):\n    scales = (0.01, 7, 50)\n    generator = GraphWaveGenerator(barbell, scales=scales, degree=4)\n    sample_points = np.linspace((- 1), 1, num_samples)\n    expected_embed_dim = ((len(sample_points) * len(scales)) * 2)\n    for x in generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=2, repeat=False):\n        assert (x.shape[1] == expected_embed_dim)", "masked_code": "@pytest.mark.parametrize('num_samples', [0, 5, 15])\ndef test_embedding_dim(barbell, num_samples):\n    scales = (0.01, 7, 50)\n    generator = GraphWaveGenerator(barbell, scales=scales, degree=4)\n    sample_points = np.linspace((- 1), 1, num_samples)\n    expected_embed_dim = ((len(sample_points) * len(scales)) * 2)\n    for x in generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=2, repeat=False):\n        assert (x.shape[1] == '???')", "ground_truth": "expected_embed_dim", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_827", "reponame": "stellargraph", "testpath": "tests/mapper/test_graphwave_generator.py", "testname": "test_graphwave_generator.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.graphwave_generator import GraphWaveGenerator, _empirical_characteristic_function", "from ..test_utils.graphs import barbell", "import numpy as np", "import pytest", "import scipy.sparse as sps", "import tensorflow as tf"], "code": "@pytest.mark.parametrize('batch_size', [1, 33, 50])\ndef test_flow_batch_size(barbell, batch_size):\n    scales = (0.003, 202, 1.3)\n    generator = GraphWaveGenerator(barbell, scales=scales, degree=7)\n    sample_points = np.linspace(0, 10, 9)\n    expected_embed_dim = ((len(sample_points) * len(scales)) * 2)\n    for (i, x) in enumerate(generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=batch_size, repeat=False)):\n        if (i < (barbell.number_of_nodes() // batch_size)):\n            assert (x.shape == (batch_size, expected_embed_dim))\n        else:\n            assert (x.shape == ((barbell.number_of_nodes() % batch_size), expected_embed_dim))", "masked_code": "@pytest.mark.parametrize('batch_size', [1, 33, 50])\ndef test_flow_batch_size(barbell, batch_size):\n    scales = (0.003, 202, 1.3)\n    generator = GraphWaveGenerator(barbell, scales=scales, degree=7)\n    sample_points = np.linspace(0, 10, 9)\n    expected_embed_dim = ((len(sample_points) * len(scales)) * 2)\n    for (i, x) in enumerate(generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=batch_size, repeat=False)):\n        if (i < (barbell.number_of_nodes() // batch_size)):\n            assert (x.shape == '???')\n        else:\n            assert (x.shape == ((barbell.number_of_nodes() % batch_size), expected_embed_dim))", "ground_truth": "(batch_size, expected_embed_dim)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_828", "reponame": "stellargraph", "testpath": "tests/mapper/test_graphwave_generator.py", "testname": "test_graphwave_generator.py", "funcname": "test_flow_batch_size", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.graphwave_generator import GraphWaveGenerator, _empirical_characteristic_function", "from ..test_utils.graphs import barbell", "import numpy as np", "import pytest", "import scipy.sparse as sps", "import tensorflow as tf"], "code": "@pytest.mark.parametrize('batch_size', [1, 33, 50])\ndef test_flow_batch_size(barbell, batch_size):\n    scales = (0.003, 202, 1.3)\n    generator = GraphWaveGenerator(barbell, scales=scales, degree=7)\n    sample_points = np.linspace(0, 10, 9)\n    expected_embed_dim = ((len(sample_points) * len(scales)) * 2)\n    for (i, x) in enumerate(generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=batch_size, repeat=False)):\n        if (i < (barbell.number_of_nodes() // batch_size)):\n            assert (x.shape == (batch_size, expected_embed_dim))\n        else:\n            assert (x.shape == ((barbell.number_of_nodes() % batch_size), expected_embed_dim))", "masked_code": "@pytest.mark.parametrize('batch_size', [1, 33, 50])\ndef test_flow_batch_size(barbell, batch_size):\n    scales = (0.003, 202, 1.3)\n    generator = GraphWaveGenerator(barbell, scales=scales, degree=7)\n    sample_points = np.linspace(0, 10, 9)\n    expected_embed_dim = ((len(sample_points) * len(scales)) * 2)\n    for (i, x) in enumerate(generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=batch_size, repeat=False)):\n        if (i < (barbell.number_of_nodes() // batch_size)):\n            assert (x.shape == (batch_size, expected_embed_dim))\n        else:\n            assert (x.shape == '???')", "ground_truth": "((barbell.number_of_nodes() % batch_size), expected_embed_dim)", "quality_analysis": {"complexity_score": 11, "left_complexity": 2, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_826", "reponame": "stellargraph", "testpath": "tests/mapper/test_graphwave_generator.py", "testname": "test_graphwave_generator.py", "funcname": "test_flow_repeat", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.graphwave_generator import GraphWaveGenerator, _empirical_characteristic_function", "from ..test_utils.graphs import barbell", "import numpy as np", "import pytest", "import scipy.sparse as sps", "import tensorflow as tf"], "code": "@pytest.mark.parametrize('repeat', [False, True])\ndef test_flow_repeat(barbell, repeat):\n    generator = GraphWaveGenerator(barbell, scales=(0.1, 0.5, 6.7), degree=5)\n    sample_points = np.linspace((- 100), 100, 10)\n    for (i, x) in enumerate(generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=3, repeat=repeat)):\n        if (i > barbell.number_of_nodes()):\n            break\n    assert ((i > barbell.number_of_nodes()) == repeat)", "masked_code": "@pytest.mark.parametrize('repeat', [False, True])\ndef test_flow_repeat(barbell, repeat):\n    generator = GraphWaveGenerator(barbell, scales=(0.1, 0.5, 6.7), degree=5)\n    sample_points = np.linspace((- 100), 100, 10)\n    for (i, x) in enumerate(generator.flow(barbell.nodes(), sample_points=sample_points, batch_size=3, repeat=repeat)):\n        if (i > barbell.number_of_nodes()):\n            break\n    assert ((i > barbell.number_of_nodes()) == '???')", "ground_truth": "repeat", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_824", "reponame": "stellargraph", "testpath": "tests/mapper/test_graphwave_generator.py", "testname": "test_graphwave_generator.py", "funcname": "test_init", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.graphwave_generator import GraphWaveGenerator, _empirical_characteristic_function", "from ..test_utils.graphs import barbell", "import numpy as np", "import pytest", "import scipy.sparse as sps", "import tensorflow as tf"], "code": "def test_init(barbell):\n    generator = GraphWaveGenerator(barbell, scales=(0.0, 10000.0, (- 999.9), 0.5), degree=25)\n    np.testing.assert_array_equal(generator.scales, np.array((0.0, 10000.0, (- 999.9), 0.5)).astype(np.float32))\n    assert (generator.coeffs.shape == (4, (25 + 1)))\n    assert (generator.laplacian.shape == (barbell.number_of_nodes(), barbell.number_of_nodes()))", "masked_code": "def test_init(barbell):\n    generator = GraphWaveGenerator(barbell, scales=(0.0, 10000.0, (- 999.9), 0.5), degree=25)\n    np.testing.assert_array_equal(generator.scales, np.array((0.0, 10000.0, (- 999.9), 0.5)).astype(np.float32))\n    assert (generator.coeffs.shape == '???')\n    assert (generator.laplacian.shape == (barbell.number_of_nodes(), barbell.number_of_nodes()))", "ground_truth": "(4, (25 + 1))", "quality_analysis": {"complexity_score": 9, "left_complexity": 2, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_825", "reponame": "stellargraph", "testpath": "tests/mapper/test_graphwave_generator.py", "testname": "test_graphwave_generator.py", "funcname": "test_init", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.graphwave_generator import GraphWaveGenerator, _empirical_characteristic_function", "from ..test_utils.graphs import barbell", "import numpy as np", "import pytest", "import scipy.sparse as sps", "import tensorflow as tf"], "code": "def test_init(barbell):\n    generator = GraphWaveGenerator(barbell, scales=(0.0, 10000.0, (- 999.9), 0.5), degree=25)\n    np.testing.assert_array_equal(generator.scales, np.array((0.0, 10000.0, (- 999.9), 0.5)).astype(np.float32))\n    assert (generator.coeffs.shape == (4, (25 + 1)))\n    assert (generator.laplacian.shape == (barbell.number_of_nodes(), barbell.number_of_nodes()))", "masked_code": "def test_init(barbell):\n    generator = GraphWaveGenerator(barbell, scales=(0.0, 10000.0, (- 999.9), 0.5), degree=25)\n    np.testing.assert_array_equal(generator.scales, np.array((0.0, 10000.0, (- 999.9), 0.5)).astype(np.float32))\n    assert (generator.coeffs.shape == (4, (25 + 1)))\n    assert (generator.laplacian.shape == '???')", "ground_truth": "(barbell.number_of_nodes(), barbell.number_of_nodes())", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_394", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: node ids with one invalid, n_size=[0], n=1.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    try:\n        nodes = _conv([0, 'not_real'])\n    except Exception:\n        nodes = _conv([0, 1])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=101)\n    assert (len(subgraphs) == (len(nodes) * n))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: node ids with one invalid, n_size=[0], n=1.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    try:\n        nodes = _conv([0, 'not_real'])\n    except Exception:\n        nodes = _conv([0, 1])\n    n = 1\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=101)\n    assert (len(subgraphs) == '???')", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_395", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: root nodes all movies, n=2, n_size=[1].\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([2, 3])\n    n = 2\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=103)\n    assert (len(subgraphs) == (len(nodes) * n))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: root nodes all movies, n=2, n_size=[1].\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([2, 3])\n    n = 2\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=103)\n    assert (len(subgraphs) == '???')", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_396", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: n=4, n_size=[2,3].\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([1, 4])\n    n = 4\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=104)\n    assert (len(subgraphs) == (len(nodes) * n))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: n=4, n_size=[2,3].\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([1, 4])\n    n = 4\n    n_size = [2, 3]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=104)\n    assert (len(subgraphs) == '???')", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_397", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: node ids as mixed types, n=3, n_size=[2].\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([1, '5'])\n    n = 3\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=105)\n    assert (len(subgraphs) == (len(nodes) * n))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: node ids as mixed types, n=3, n_size=[2].\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([1, '5'])\n    n = 3\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=105)\n    assert (len(subgraphs) == '???')", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_398", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: very large n, n_size=[1], nodes=[2,3,6]\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([2, 3, 6])\n    n = 15\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=107)\n    assert (len(subgraphs) == (len(nodes) * n))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: very large n, n_size=[1], nodes=[2,3,6]\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([2, 3, 6])\n    n = 15\n    n_size = [1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=107)\n    assert (len(subgraphs) == '???')", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_399", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: n_size as all zeros, n=2, nodes=[7,0,1]\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([7, 0, 1])\n    n = 2\n    n_size = [0, 0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=108)\n    assert (len(subgraphs) == (len(nodes) * n))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: n_size as all zeros, n=2, nodes=[7,0,1]\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([7, 0, 1])\n    n = 2\n    n_size = [0, 0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=108)\n    assert (len(subgraphs) == '???')", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_400", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: n_size long with varying values, n=1, nodes=[\"5\", 4, 7]\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv(['5', 4, 7])\n    n = 1\n    n_size = [3, 0, 4, 2, 1, 0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=109)\n    assert (len(subgraphs) == (len(nodes) * n))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: n_size long with varying values, n=1, nodes=[\"5\", 4, 7]\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv(['5', 4, 7])\n    n = 1\n    n_size = [3, 0, 4, 2, 1, 0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=109)\n    assert (len(subgraphs) == '???')", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_401", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: nodes = [\"5\", 1, 6, 0]; n_size with zeros, n=2.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv(['5', 1, 6, 0])\n    n = 2\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=110)\n    assert (len(subgraphs) == (len(nodes) * n))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: nodes = [\"5\", 1, 6, 0]; n_size with zeros, n=2.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv(['5', 1, 6, 0])\n    n = 2\n    n_size = [0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=110)\n    assert (len(subgraphs) == '???')", "ground_truth": "(len(nodes) * n)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_402", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: test with multi graph and node ids as float.\\n        '\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([1.0, 6.0])\n    n = 2\n    n_size = [2, 2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=111)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: test with multi graph and node ids as float.\\n        '\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([1.0, 6.0])\n    n = 2\n    n_size = [2, 2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=111)\n    assert (len(subgraphs) == '???')", "ground_truth": "(n * len(nodes))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_403", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: multi graph, n_size long with zeros and positives.\\n        '\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2, 2, 0, 2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=222)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: multi graph, n_size long with zeros and positives.\\n        '\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([1, 6])\n    n = 1\n    n_size = [2, 2, 0, 2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=222)\n    assert (len(subgraphs) == '???')", "ground_truth": "(n * len(nodes))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_404", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_many_root_nodes", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: multi graph, n very large, n_size small.\\n        '\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([4, '5', 0])\n    n = 25\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=333)\n    assert (len(subgraphs) == (n * len(nodes)))", "masked_code": "def test_walk_generation_many_root_nodes(self):\n    '\\n        Augmented test: multi graph, n very large, n_size small.\\n        '\n    g = create_test_graph(multi=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([4, '5', 0])\n    n = 25\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=333)\n    assert (len(subgraphs) == '???')", "ground_truth": "(n * len(nodes))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_386", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: Use movie node id & larger n_size, seed changed.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([2])\n    n = 1\n    n_size = [4]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=123)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([2]), _conv(['5', 4, '5', '5'])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=123)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([2]), _conv(['5']), _conv([4]), _conv(['5'])]]\n    assert _recursive_items_equal(subgraphs, valid_result)", "masked_code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: Use movie node id & larger n_size, seed changed.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([2])\n    n = 1\n    n_size = [4]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=123)\n    assert (len(subgraphs) == '???')\n    valid_result = [[_conv([2]), _conv(['5', 4, '5', '5'])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=123)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([2]), _conv(['5']), _conv([4]), _conv(['5'])]]\n    assert _recursive_items_equal(subgraphs, valid_result)", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_387", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: Use movie node id & larger n_size, seed changed.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([2])\n    n = 1\n    n_size = [4]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=123)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([2]), _conv(['5', 4, '5', '5'])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=123)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([2]), _conv(['5']), _conv([4]), _conv(['5'])]]\n    assert _recursive_items_equal(subgraphs, valid_result)", "masked_code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: Use movie node id & larger n_size, seed changed.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([2])\n    n = 1\n    n_size = [4]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=123)\n    assert (len(subgraphs) == n)\n    valid_result = [[_conv([2]), _conv(['5', 4, '5', '5'])]]\n    assert _recursive_items_equal(subgraphs, valid_result)\n    n_size = [1, 1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=123)\n    assert (len(subgraphs) == '???')\n    valid_result = [[_conv([2]), _conv(['5']), _conv([4]), _conv(['5'])]]\n    assert _recursive_items_equal(subgraphs, valid_result)", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_388", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: Use multiple user nodes, n_size [0, 2], n=2.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 1])\n    n = 2\n    n_size = [0, 2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=44)\n    assert (len(subgraphs) == n)\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] in nodes)\n        for level in subgraph:\n            assert isinstance(level, list)", "masked_code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: Use multiple user nodes, n_size [0, 2], n=2.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([0, 1])\n    n = 2\n    n_size = [0, 2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=44)\n    assert (len(subgraphs) == '???')\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] in nodes)\n        for level in subgraph:\n            assert isinstance(level, list)", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_389", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: Use node id as int/string, n_size zeros, n=1.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv(['5'])\n    n = 1\n    n_size = [0, 0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=22)\n    assert (len(subgraphs) == n)\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == nodes[0])", "masked_code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: Use node id as int/string, n_size zeros, n=1.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv(['5'])\n    n = 1\n    n_size = [0, 0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=22)\n    assert (len(subgraphs) == '???')\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == nodes[0])", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_390", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: Use node id as int/string, n_size zeros, n=1.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv(['5'])\n    n = 1\n    n_size = [0, 0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=22)\n    assert (len(subgraphs) == n)\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == nodes[0])", "masked_code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: Use node id as int/string, n_size zeros, n=1.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv(['5'])\n    n = 1\n    n_size = [0, 0]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=22)\n    assert (len(subgraphs) == n)\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == '???')", "ground_truth": "nodes[0]", "quality_analysis": {"complexity_score": 14, "left_complexity": 9, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_391", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: n_size as long list.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([1])\n    n = 1\n    n_size = [1, 1, 1, 1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=98)\n    assert (len(subgraphs) == n)\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == nodes[0])", "masked_code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: n_size as long list.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([1])\n    n = 1\n    n_size = [1, 1, 1, 1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=98)\n    assert (len(subgraphs) == '???')\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == nodes[0])", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_392", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: n_size as long list.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([1])\n    n = 1\n    n_size = [1, 1, 1, 1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=98)\n    assert (len(subgraphs) == n)\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == nodes[0])", "masked_code": "def test_walk_generation_single_root_node(self):\n    '\\n        Augmented test: n_size as long list.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n\n    def _conv(ns):\n        return [((- 1) if (n is None) else g.node_ids_to_ilocs([n])[0]) for n in ns]\n    nodes = _conv([1])\n    n = 1\n    n_size = [1, 1, 1, 1, 1]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size, seed=98)\n    assert (len(subgraphs) == n)\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == '???')", "ground_truth": "nodes[0]", "quality_analysis": {"complexity_score": 14, "left_complexity": 9, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_372", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node_loner", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Augmented test: use an edge-case node, negative n, and larger n_size input.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0.0])\n    n = 2\n    n_size = [0, 2, 5]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 2)\n    for subgraph in subgraphs:\n        assert (len(subgraph) == 9)\n        assert (subgraph[0][0] == g.node_ids_to_ilocs([0])[0])\n        assert all([(type(level) == list) for level in subgraph])\n        assert (subgraph[0][0] == g.node_ids_to_ilocs([0])[0])\n        assert all([((x == (- 1)) or (x == g.node_ids_to_ilocs([0])[0])) for x in subgraph[1]])\n        assert all([((x == (- 1)) or (x == g.node_ids_to_ilocs([0])[0])) for x in subgraph[2]])\n        for level in subgraph[3:]:\n            assert all([(x == (- 1)) for x in level])\n    nodes = g.node_ids_to_ilocs([(- 99)])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert isinstance(subgraphs, list)", "masked_code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Augmented test: use an edge-case node, negative n, and larger n_size input.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0.0])\n    n = 2\n    n_size = [0, 2, 5]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 2)\n    for subgraph in subgraphs:\n        assert (len(subgraph) == '???')\n        assert (subgraph[0][0] == g.node_ids_to_ilocs([0])[0])\n        assert all([(type(level) == list) for level in subgraph])\n        assert (subgraph[0][0] == g.node_ids_to_ilocs([0])[0])\n        assert all([((x == (- 1)) or (x == g.node_ids_to_ilocs([0])[0])) for x in subgraph[1]])\n        assert all([((x == (- 1)) or (x == g.node_ids_to_ilocs([0])[0])) for x in subgraph[2]])\n        for level in subgraph[3:]:\n            assert all([(x == (- 1)) for x in level])\n    nodes = g.node_ids_to_ilocs([(- 99)])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert isinstance(subgraphs, list)", "ground_truth": "9", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_373", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node_loner", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Augmented test: use an edge-case node, negative n, and larger n_size input.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0.0])\n    n = 2\n    n_size = [0, 2, 5]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 2)\n    for subgraph in subgraphs:\n        assert (len(subgraph) == 9)\n        assert (subgraph[0][0] == g.node_ids_to_ilocs([0])[0])\n        assert all([(type(level) == list) for level in subgraph])\n        assert (subgraph[0][0] == g.node_ids_to_ilocs([0])[0])\n        assert all([((x == (- 1)) or (x == g.node_ids_to_ilocs([0])[0])) for x in subgraph[1]])\n        assert all([((x == (- 1)) or (x == g.node_ids_to_ilocs([0])[0])) for x in subgraph[2]])\n        for level in subgraph[3:]:\n            assert all([(x == (- 1)) for x in level])\n    nodes = g.node_ids_to_ilocs([(- 99)])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert isinstance(subgraphs, list)", "masked_code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Augmented test: use an edge-case node, negative n, and larger n_size input.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0.0])\n    n = 2\n    n_size = [0, 2, 5]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 2)\n    for subgraph in subgraphs:\n        assert (len(subgraph) == 9)\n        assert (subgraph[0][0] == '???')\n        assert all([(type(level) == list) for level in subgraph])\n        assert (subgraph[0][0] == g.node_ids_to_ilocs([0])[0])\n        assert all([((x == (- 1)) or (x == g.node_ids_to_ilocs([0])[0])) for x in subgraph[1]])\n        assert all([((x == (- 1)) or (x == g.node_ids_to_ilocs([0])[0])) for x in subgraph[2]])\n        for level in subgraph[3:]:\n            assert all([(x == (- 1)) for x in level])\n    nodes = g.node_ids_to_ilocs([(- 99)])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert isinstance(subgraphs, list)", "ground_truth": "g.node_ids_to_ilocs([0])[0]", "quality_analysis": {"complexity_score": 19, "left_complexity": 9, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_374", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node_loner", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Augmented test: use an edge-case node, negative n, and larger n_size input.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0.0])\n    n = 2\n    n_size = [0, 2, 5]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 2)\n    for subgraph in subgraphs:\n        assert (len(subgraph) == 9)\n        assert (subgraph[0][0] == g.node_ids_to_ilocs([0])[0])\n        assert all([(type(level) == list) for level in subgraph])\n        assert (subgraph[0][0] == g.node_ids_to_ilocs([0])[0])\n        assert all([((x == (- 1)) or (x == g.node_ids_to_ilocs([0])[0])) for x in subgraph[1]])\n        assert all([((x == (- 1)) or (x == g.node_ids_to_ilocs([0])[0])) for x in subgraph[2]])\n        for level in subgraph[3:]:\n            assert all([(x == (- 1)) for x in level])\n    nodes = g.node_ids_to_ilocs([(- 99)])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert isinstance(subgraphs, list)", "masked_code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Augmented test: use an edge-case node, negative n, and larger n_size input.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([0.0])\n    n = 2\n    n_size = [0, 2, 5]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 2)\n    for subgraph in subgraphs:\n        assert (len(subgraph) == 9)\n        assert (subgraph[0][0] == g.node_ids_to_ilocs([0])[0])\n        assert all([(type(level) == list) for level in subgraph])\n        assert (subgraph[0][0] == '???')\n        assert all([((x == (- 1)) or (x == g.node_ids_to_ilocs([0])[0])) for x in subgraph[1]])\n        assert all([((x == (- 1)) or (x == g.node_ids_to_ilocs([0])[0])) for x in subgraph[2]])\n        for level in subgraph[3:]:\n            assert all([(x == (- 1)) for x in level])\n    nodes = g.node_ids_to_ilocs([(- 99)])\n    n = 1\n    n_size = [2]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert isinstance(subgraphs, list)", "ground_truth": "g.node_ids_to_ilocs([0])[0]", "quality_analysis": {"complexity_score": 19, "left_complexity": 9, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_375", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node_loner", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Augmented test: Use empty string as node ID, n=3, n_size high.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    try:\n        nodes = g.node_ids_to_ilocs([''])\n    except Exception:\n        nodes = [0]\n    n = 3\n    n_size = [4, 0, 4]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == 3)\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == nodes[0])\n        for level in subgraph:\n            assert isinstance(level, list)\n            assert all([((x == (- 1)) or (x == nodes[0])) for x in level])", "masked_code": "def test_walk_generation_single_root_node_loner(self):\n    '\\n        Augmented test: Use empty string as node ID, n=3, n_size high.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    try:\n        nodes = g.node_ids_to_ilocs([''])\n    except Exception:\n        nodes = [0]\n    n = 3\n    n_size = [4, 0, 4]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == '???')\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == nodes[0])\n        for level in subgraph:\n            assert isinstance(level, list)\n            assert all([((x == (- 1)) or (x == nodes[0])) for x in level])", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_376", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node_self_loner", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node_self_loner(self):\n    '\\n        Augmented test: Use large n_size values, n=2.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([7])\n    n = 2\n    n_size = [10, 10, 10]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == n)\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == nodes[0])\n        for level in subgraph:\n            assert isinstance(level, list)\n            assert all([((x == (- 1)) or (x == nodes[0])) for x in level])", "masked_code": "def test_walk_generation_single_root_node_self_loner(self):\n    '\\n        Augmented test: Use large n_size values, n=2.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([7])\n    n = 2\n    n_size = [10, 10, 10]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == '???')\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == nodes[0])\n        for level in subgraph:\n            assert isinstance(level, list)\n            assert all([((x == (- 1)) or (x == nodes[0])) for x in level])", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_377", "reponame": "stellargraph", "testpath": "tests/data/test_heterogeneous_breadth_first_walker.py", "testname": "test_heterogeneous_breadth_first_walker.py", "funcname": "test_walk_generation_single_root_node_self_loner", "imports": ["import pandas as pd", "import numpy as np", "import pytest", "from stellargraph.data.explorer import SampledHeterogeneousBreadthFirstWalk", "from stellargraph.core.graph import StellarGraph", "from ..test_utils.graphs import example_graph_random"], "code": "def test_walk_generation_single_root_node_self_loner(self):\n    '\\n        Augmented test: Use large n_size values, n=2.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([7])\n    n = 2\n    n_size = [10, 10, 10]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == n)\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == nodes[0])\n        for level in subgraph:\n            assert isinstance(level, list)\n            assert all([((x == (- 1)) or (x == nodes[0])) for x in level])", "masked_code": "def test_walk_generation_single_root_node_self_loner(self):\n    '\\n        Augmented test: Use large n_size values, n=2.\\n        '\n    g = create_test_graph(self_loop=True)\n    bfw = SampledHeterogeneousBreadthFirstWalk(g)\n    nodes = g.node_ids_to_ilocs([7])\n    n = 2\n    n_size = [10, 10, 10]\n    subgraphs = bfw.run(nodes=nodes, n=n, n_size=n_size)\n    assert (len(subgraphs) == n)\n    for subgraph in subgraphs:\n        assert (subgraph[0][0] == '???')\n        for level in subgraph:\n            assert isinstance(level, list)\n            assert all([((x == (- 1)) or (x == nodes[0])) for x in level])", "ground_truth": "nodes[0]", "quality_analysis": {"complexity_score": 14, "left_complexity": 9, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestSampledHeterogeneousBreadthFirstWalk"}
{"task_id": "stellargraph_1049", "reponame": "stellargraph", "testpath": "tests/utils/test_hyperbolic.py", "testname": "test_hyperbolic.py", "funcname": "test_poincare_ball_distance_exp", "imports": ["import pytest", "import numpy as np", "from stellargraph.utils.hyperbolic import *"], "code": "def test_poincare_ball_distance_exp(seeded):\n    c = 0.5\n    tangents = np.array([[1e-12, (- 1e-12), 1e-12], [0.1, 0.2, 0.3], [50.0, (- 50.0), 50.0], [(- 1000000.0), 1000000.0, (- 1000000.0)]], dtype=np.float32)\n    tangent_lengths = np.linalg.norm(tangents, axis=(- 1))\n\n    def check(x, y):\n        d = poincare_ball_distance(c, x, y)\n        assert (d.shape == tangents.shape[:(- 1)])\n        np.testing.assert_allclose(d, np.array([3.464101e-12, 0.7483314, 17.24333, 17.26851], dtype=np.float32), rtol=0.001)\n    zeros = np.zeros_like(tangents)\n    zero_moved = poincare_ball_exp(c, None, tangents)\n    assert (zero_moved.shape == tangents.shape)\n    check(zeros, zero_moved)\n    check(zero_moved, zeros)", "masked_code": "def test_poincare_ball_distance_exp(seeded):\n    c = 0.5\n    tangents = np.array([[1e-12, (- 1e-12), 1e-12], [0.1, 0.2, 0.3], [50.0, (- 50.0), 50.0], [(- 1000000.0), 1000000.0, (- 1000000.0)]], dtype=np.float32)\n    tangent_lengths = np.linalg.norm(tangents, axis=(- 1))\n\n    def check(x, y):\n        d = poincare_ball_distance(c, x, y)\n        assert (d.shape == tangents.shape[:(- 1)])\n        np.testing.assert_allclose(d, np.array([3.464101e-12, 0.7483314, 17.24333, 17.26851], dtype=np.float32), rtol=0.001)\n    zeros = np.zeros_like(tangents)\n    zero_moved = poincare_ball_exp(c, None, tangents)\n    assert (zero_moved.shape == '???')\n    check(zeros, zero_moved)\n    check(zero_moved, zeros)", "ground_truth": "tangents.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1050", "reponame": "stellargraph", "testpath": "tests/utils/test_hyperbolic.py", "testname": "test_hyperbolic.py", "funcname": "test_poincare_ball_distance_exp", "imports": ["import pytest", "import numpy as np", "from stellargraph.utils.hyperbolic import *"], "code": "def test_poincare_ball_distance_exp(seeded):\n    c = 0.5\n    tangents = np.array([[1e-12, (- 1e-12), 1e-12], [0.1, 0.2, 0.3], [50.0, (- 50.0), 50.0], [(- 1000000.0), 1000000.0, (- 1000000.0)]], dtype=np.float32)\n    tangent_lengths = np.linalg.norm(tangents, axis=(- 1))\n\n    def check(x, y):\n        d = poincare_ball_distance(c, x, y)\n        assert (d.shape == tangents.shape[:(- 1)])\n        np.testing.assert_allclose(d, np.array([3.464101e-12, 0.7483314, 17.24333, 17.26851], dtype=np.float32), rtol=0.001)\n    zeros = np.zeros_like(tangents)\n    zero_moved = poincare_ball_exp(c, None, tangents)\n    assert (zero_moved.shape == tangents.shape)\n    check(zeros, zero_moved)\n    check(zero_moved, zeros)", "masked_code": "def test_poincare_ball_distance_exp(seeded):\n    c = 0.5\n    tangents = np.array([[1e-12, (- 1e-12), 1e-12], [0.1, 0.2, 0.3], [50.0, (- 50.0), 50.0], [(- 1000000.0), 1000000.0, (- 1000000.0)]], dtype=np.float32)\n    tangent_lengths = np.linalg.norm(tangents, axis=(- 1))\n\n    def check(x, y):\n        d = poincare_ball_distance(c, x, y)\n        assert (d.shape == '???')\n        np.testing.assert_allclose(d, np.array([3.464101e-12, 0.7483314, 17.24333, 17.26851], dtype=np.float32), rtol=0.001)\n    zeros = np.zeros_like(tangents)\n    zero_moved = poincare_ball_exp(c, None, tangents)\n    assert (zero_moved.shape == tangents.shape)\n    check(zeros, zero_moved)\n    check(zero_moved, zeros)", "ground_truth": "tangents.shape[:(- 1)]", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1048", "reponame": "stellargraph", "testpath": "tests/utils/test_hyperbolic.py", "testname": "test_hyperbolic.py", "funcname": "test_poincare_ball_distance_self", "imports": ["import pytest", "import numpy as np", "from stellargraph.utils.hyperbolic import *"], "code": "def test_poincare_ball_distance_self(seeded):\n    vs = np.array([[0.0, 0.0, 0.0], [1000000.0, (- 1000000.0), 1000000.0], [(- 2.5), 3.3, (- 7.7)], [123456.0, 789012.0, (- 345678.0)]], dtype=np.float32)\n    c = 10.0\n    d = poincare_ball_distance(c, vs, vs)\n    assert (d.shape == vs.shape[:(- 1)])\n    np.testing.assert_allclose(d, 0, rtol=1e-06, atol=1e-05)", "masked_code": "def test_poincare_ball_distance_self(seeded):\n    vs = np.array([[0.0, 0.0, 0.0], [1000000.0, (- 1000000.0), 1000000.0], [(- 2.5), 3.3, (- 7.7)], [123456.0, 789012.0, (- 345678.0)]], dtype=np.float32)\n    c = 10.0\n    d = poincare_ball_distance(c, vs, vs)\n    assert (d.shape == '???')\n    np.testing.assert_allclose(d, 0, rtol=1e-06, atol=1e-05)", "ground_truth": "vs.shape[:(- 1)]", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1051", "reponame": "stellargraph", "testpath": "tests/utils/test_hyperbolic.py", "testname": "test_hyperbolic.py", "funcname": "test_poincare_ball_distance_vs_euclidean", "imports": ["import pytest", "import numpy as np", "from stellargraph.utils.hyperbolic import *"], "code": "def test_poincare_ball_distance_vs_euclidean(seeded):\n    c = 0.25\n    vs = np.array([np.zeros(10), np.full(10, 1e-07), np.full(10, (- 1e-07)), (np.arange(10) * 0.001)], dtype=np.float32)\n    zeros = np.zeros_like(vs)\n    hyperbolic = poincare_ball_distance(c, zeros, vs)\n    assert (hyperbolic.shape == vs.shape[:(- 1)])\n    euclidean = np.linalg.norm(vs, axis=(- 1))\n    np.testing.assert_allclose(hyperbolic, (2 * euclidean), rtol=0.001, atol=1e-15)\n    vs = np.array([np.full(10, 0.99), np.full(10, (- 0.99)), np.linspace(0.95, 0.99, 10), np.linspace((- 0.99), (- 0.95), 10)], dtype=np.float32)\n    zeros = np.zeros_like(vs)\n    hyperbolic = poincare_ball_distance(c, zeros, vs)\n    assert (hyperbolic.shape == vs.shape[:(- 1)])\n    euclidean = np.linalg.norm(vs, axis=(- 1))\n    np.testing.assert_array_less((4 * euclidean), hyperbolic)", "masked_code": "def test_poincare_ball_distance_vs_euclidean(seeded):\n    c = 0.25\n    vs = np.array([np.zeros(10), np.full(10, 1e-07), np.full(10, (- 1e-07)), (np.arange(10) * 0.001)], dtype=np.float32)\n    zeros = np.zeros_like(vs)\n    hyperbolic = poincare_ball_distance(c, zeros, vs)\n    assert (hyperbolic.shape == '???')\n    euclidean = np.linalg.norm(vs, axis=(- 1))\n    np.testing.assert_allclose(hyperbolic, (2 * euclidean), rtol=0.001, atol=1e-15)\n    vs = np.array([np.full(10, 0.99), np.full(10, (- 0.99)), np.linspace(0.95, 0.99, 10), np.linspace((- 0.99), (- 0.95), 10)], dtype=np.float32)\n    zeros = np.zeros_like(vs)\n    hyperbolic = poincare_ball_distance(c, zeros, vs)\n    assert (hyperbolic.shape == vs.shape[:(- 1)])\n    euclidean = np.linalg.norm(vs, axis=(- 1))\n    np.testing.assert_array_less((4 * euclidean), hyperbolic)", "ground_truth": "vs.shape[:(- 1)]", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1052", "reponame": "stellargraph", "testpath": "tests/utils/test_hyperbolic.py", "testname": "test_hyperbolic.py", "funcname": "test_poincare_ball_distance_vs_euclidean", "imports": ["import pytest", "import numpy as np", "from stellargraph.utils.hyperbolic import *"], "code": "def test_poincare_ball_distance_vs_euclidean(seeded):\n    c = 0.25\n    vs = np.array([np.zeros(10), np.full(10, 1e-07), np.full(10, (- 1e-07)), (np.arange(10) * 0.001)], dtype=np.float32)\n    zeros = np.zeros_like(vs)\n    hyperbolic = poincare_ball_distance(c, zeros, vs)\n    assert (hyperbolic.shape == vs.shape[:(- 1)])\n    euclidean = np.linalg.norm(vs, axis=(- 1))\n    np.testing.assert_allclose(hyperbolic, (2 * euclidean), rtol=0.001, atol=1e-15)\n    vs = np.array([np.full(10, 0.99), np.full(10, (- 0.99)), np.linspace(0.95, 0.99, 10), np.linspace((- 0.99), (- 0.95), 10)], dtype=np.float32)\n    zeros = np.zeros_like(vs)\n    hyperbolic = poincare_ball_distance(c, zeros, vs)\n    assert (hyperbolic.shape == vs.shape[:(- 1)])\n    euclidean = np.linalg.norm(vs, axis=(- 1))\n    np.testing.assert_array_less((4 * euclidean), hyperbolic)", "masked_code": "def test_poincare_ball_distance_vs_euclidean(seeded):\n    c = 0.25\n    vs = np.array([np.zeros(10), np.full(10, 1e-07), np.full(10, (- 1e-07)), (np.arange(10) * 0.001)], dtype=np.float32)\n    zeros = np.zeros_like(vs)\n    hyperbolic = poincare_ball_distance(c, zeros, vs)\n    assert (hyperbolic.shape == vs.shape[:(- 1)])\n    euclidean = np.linalg.norm(vs, axis=(- 1))\n    np.testing.assert_allclose(hyperbolic, (2 * euclidean), rtol=0.001, atol=1e-15)\n    vs = np.array([np.full(10, 0.99), np.full(10, (- 0.99)), np.linspace(0.95, 0.99, 10), np.linspace((- 0.99), (- 0.95), 10)], dtype=np.float32)\n    zeros = np.zeros_like(vs)\n    hyperbolic = poincare_ball_distance(c, zeros, vs)\n    assert (hyperbolic.shape == '???')\n    euclidean = np.linalg.norm(vs, axis=(- 1))\n    np.testing.assert_array_less((4 * euclidean), hyperbolic)", "ground_truth": "vs.shape[:(- 1)]", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1047", "reponame": "stellargraph", "testpath": "tests/utils/test_hyperbolic.py", "testname": "test_hyperbolic.py", "funcname": "test_poincare_ball_exp_specialisation", "imports": ["import pytest", "import numpy as np", "from stellargraph.utils.hyperbolic import *"], "code": "def test_poincare_ball_exp_specialisation(seeded):\n    c = 5.0\n    vs = np.array([[0.0, 0.0, 0.0], [1e-10, (- 1e-10), 1e-10], [1000.0, (- 1000.0), 1000.0], [(- 1000000.0), 1000000.0, (- 1000000.0)]], dtype=np.float32)\n    specialised = poincare_ball_exp(c, None, vs)\n    assert (specialised.shape == vs.shape)\n    actual = poincare_ball_exp(c, np.zeros_like(vs), vs)\n    np.testing.assert_allclose(specialised.numpy(), actual.numpy())", "masked_code": "def test_poincare_ball_exp_specialisation(seeded):\n    c = 5.0\n    vs = np.array([[0.0, 0.0, 0.0], [1e-10, (- 1e-10), 1e-10], [1000.0, (- 1000.0), 1000.0], [(- 1000000.0), 1000000.0, (- 1000000.0)]], dtype=np.float32)\n    specialised = poincare_ball_exp(c, None, vs)\n    assert (specialised.shape == '???')\n    actual = poincare_ball_exp(c, np.zeros_like(vs), vs)\n    np.testing.assert_allclose(specialised.numpy(), actual.numpy())", "ground_truth": "vs.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_155", "reponame": "stellargraph", "testpath": "tests/core/test_indexed_array.py", "testname": "test_indexed_array.py", "funcname": "test_indexed_array_empty", "imports": ["import numpy as np", "import pytest", "from stellargraph import IndexedArray"], "code": "def test_indexed_array_empty():\n    frame = IndexedArray(np.empty((0, 3, 2)), index=[])\n    assert (frame.index == [])\n    np.testing.assert_array_equal(frame.values, np.empty((0, 3, 2)))", "masked_code": "def test_indexed_array_empty():\n    frame = IndexedArray(np.empty((0, 3, 2)), index=[])\n    assert (frame.index == '???')\n    np.testing.assert_array_equal(frame.values, np.empty((0, 3, 2)))", "ground_truth": "[]", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_156", "reponame": "stellargraph", "testpath": "tests/core/test_indexed_array.py", "testname": "test_indexed_array.py", "funcname": "test_indexed_array_non_empty", "imports": ["import numpy as np", "import pytest", "from stellargraph import IndexedArray"], "code": "def test_indexed_array_non_empty():\n    list_ids = ['', None, 'long_string_123456']\n    array_ids = np.array([0.0, (- 99999.999), 999999.99])\n    range_ids = range(0, 30, 7)\n    values = np.random.randint((- 5), 20, size=(3, 2, 2))\n    frame = IndexedArray(values)\n    assert (frame.index == range(3))\n    assert (frame.values is values)\n    frame = IndexedArray(values, index=list_ids)\n    assert (frame.index is list_ids)\n    assert (frame.values is values)\n    frame = IndexedArray(values, index=array_ids)\n    assert (frame.index is array_ids)\n    assert (frame.values is values)\n    range_ids = range(0, 3, 1)\n    frame = IndexedArray(values, index=range_ids)\n    assert (frame.index is range_ids)\n    assert (frame.values is values)", "masked_code": "def test_indexed_array_non_empty():\n    list_ids = ['', None, 'long_string_123456']\n    array_ids = np.array([0.0, (- 99999.999), 999999.99])\n    range_ids = range(0, 30, 7)\n    values = np.random.randint((- 5), 20, size=(3, 2, 2))\n    frame = IndexedArray(values)\n    assert (frame.index == '???')\n    assert (frame.values is values)\n    frame = IndexedArray(values, index=list_ids)\n    assert (frame.index is list_ids)\n    assert (frame.values is values)\n    frame = IndexedArray(values, index=array_ids)\n    assert (frame.index is array_ids)\n    assert (frame.values is values)\n    range_ids = range(0, 3, 1)\n    frame = IndexedArray(values, index=range_ids)\n    assert (frame.index is range_ids)\n    assert (frame.values is values)", "ground_truth": "range(3)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_831", "reponame": "stellargraph", "testpath": "tests/mapper/test_knowledge_graph.py", "testname": "test_knowledge_graph.py", "funcname": "test_kg_triple_sequence_shuffle", "imports": ["import pytest", "import pandas as pd", "import numpy as np", "from stellargraph.mapper.knowledge_graph import KGTripleGenerator, KGTripleSequence", "from .. import test_utils", "from ..test_utils.graphs import knowledge_graph"], "code": "@pytest.mark.parametrize('shuffle', [False, True])\ndef test_kg_triple_sequence_shuffle(shuffle):\n    source_ilocs = [0, (- 1), 999999, 0, 2]\n    rel_ilocs = [0.0, 1, 0, 1000000, (- 5)]\n    target_ilocs = [0, 1, 1, (- 999), 2]\n    batch_size = 5\n    seq = KGTripleSequence(max_node_iloc=1000000, source_ilocs=source_ilocs, rel_ilocs=rel_ilocs, target_ilocs=target_ilocs, batch_size=batch_size, shuffle=shuffle, negative_samples=None, sample_strategy='uniform', seed=None)\n    assert (len(seq) == 1)\n\n    def sample():\n        ret = seq[0]\n        seq.on_epoch_end()\n        return ret\n    (first, *rest) = [sample() for _ in range(20)]\n    should_be_equal = (not shuffle)\n    assert (all((epoch_sample_equal(first, r) for r in rest)) == should_be_equal)", "masked_code": "@pytest.mark.parametrize('shuffle', [False, True])\ndef test_kg_triple_sequence_shuffle(shuffle):\n    source_ilocs = [0, (- 1), 999999, 0, 2]\n    rel_ilocs = [0.0, 1, 0, 1000000, (- 5)]\n    target_ilocs = [0, 1, 1, (- 999), 2]\n    batch_size = 5\n    seq = KGTripleSequence(max_node_iloc=1000000, source_ilocs=source_ilocs, rel_ilocs=rel_ilocs, target_ilocs=target_ilocs, batch_size=batch_size, shuffle=shuffle, negative_samples=None, sample_strategy='uniform', seed=None)\n    assert (len(seq) == 1)\n\n    def sample():\n        ret = seq[0]\n        seq.on_epoch_end()\n        return ret\n    (first, *rest) = [sample() for _ in range(20)]\n    should_be_equal = (not shuffle)\n    assert (all((epoch_sample_equal(first, r) for r in rest)) == '???')", "ground_truth": "should_be_equal", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_714", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_clip_limits", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_clip_limits(self):\n    '\\n        Test calling with the leaky clip thresholds with all positive values\\n        '\n    print('\\n Testing clip limits...')\n    x_src = np.full(self.d, 5.0).reshape(1, 1, self.d)\n    x_dst = np.full(self.d, 5.0).reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_regression(output_dim=self.d_out, edge_embedding_method=op, clip_limits=self.clip_limits)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == (1, self.d_out))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_clip_limits(self):\n    '\\n        Test calling with the leaky clip thresholds with all positive values\\n        '\n    print('\\n Testing clip limits...')\n    x_src = np.full(self.d, 5.0).reshape(1, 1, self.d)\n    x_dst = np.full(self.d, 5.0).reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_regression(output_dim=self.d_out, edge_embedding_method=op, clip_limits=self.clip_limits)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, self.d_out)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Regression"}
{"task_id": "stellargraph_689", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases: zeros, negatives, large values \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = (- np.ones(self.d))\n    x_dst = np.ones(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases: zeros, negatives, large values \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == '???')\n    x_src = (- np.ones(self.d))\n    x_dst = np.ones(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "ground_truth": "pytest.approx(0, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_690", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases: zeros, negatives, large values \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = (- np.ones(self.d))\n    x_dst = np.ones(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases: zeros, negatives, large values \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = (- np.ones(self.d))\n    x_dst = np.ones(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == '???')\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "ground_truth": "pytest.approx((- self.d), abs=1.5e-07)", "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_691", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases: zeros, negatives, large values \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = (- np.ones(self.d))\n    x_dst = np.ones(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases: zeros, negatives, large values \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = (- np.ones(self.d))\n    x_dst = np.ones(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == '???')\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "ground_truth": "pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0)", "quality_analysis": {"complexity_score": 14, "left_complexity": 3, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_692", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases: zeros, negatives, large values \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = (- np.ones(self.d))\n    x_dst = np.ones(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases: zeros, negatives, large values \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = (- np.ones(self.d))\n    x_dst = np.ones(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == '???')\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "ground_truth": "pytest.approx(0.5, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_701", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases: zeros, negatives, large values \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = (- np.ones(self.d))\n    x_dst = np.ones(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases: zeros, negatives, large values \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = (- np.ones(self.d))\n    x_dst = np.ones(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = LinkEmbedding(method='ip', activation='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == '???')", "ground_truth": "pytest.approx(1, abs=1e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_702", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.ones(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(self.d, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.ones(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == '???')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(self.d, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))", "ground_truth": "pytest.approx((- self.d), abs=1.5e-07)", "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Inference"}
{"task_id": "stellargraph_703", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.ones(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(self.d, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.ones(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy() == '???')\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))", "ground_truth": "pytest.approx(self.d, abs=1.5e-07)", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Inference"}
{"task_id": "stellargraph_704", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.ones(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(self.d, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.ones(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(self.d, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == '???')\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))", "ground_truth": "pytest.approx(0, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Inference"}
{"task_id": "stellargraph_706", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.ones(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(self.d, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.ones(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx((- self.d), abs=1.5e-07))\n    li = link_inference(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(self.d, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == '???')", "ground_truth": "pytest.approx(1, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Inference"}
{"task_id": "stellargraph_707", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy()[(0, 0)] == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == '???')\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy()[(0, 0)] == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "ground_truth": "pytest.approx(0, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Classification"}
{"task_id": "stellargraph_708", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy()[(0, 0)] == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy()[(0, 0)] == '???')\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "ground_truth": "pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0)", "quality_analysis": {"complexity_score": 21, "left_complexity": 10, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Classification"}
{"task_id": "stellargraph_709", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy()[(0, 0)] == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy()[(0, 0)] == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == '???')\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "ground_truth": "pytest.approx(1, abs=1e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Classification"}
{"task_id": "stellargraph_711", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy()[(0, 0)] == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.zeros(self.d)\n    x_dst = np.zeros(self.d)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    x_src = np.full(self.d, 1000000.0)\n    x_dst = np.full(self.d, 1000000.0)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_classification(edge_embedding_method='ip', output_act='linear')([x_src_tf, x_src_tf])\n    assert (li.numpy()[(0, 0)] == pytest.approx(((1000000.0 * 1000000.0) * self.d), abs=10000.0))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(1, abs=1e-07))\n    li = link_classification(edge_embedding_method='ip', output_act='sigmoid')([x_src_tf, x_src_tf])\n    assert (li.numpy() == '???')", "ground_truth": "pytest.approx(1, abs=1e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Classification"}
{"task_id": "stellargraph_712", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.zeros(self.d)\n    x_dst = np.ones(self.d)\n    expected = np.dot(x_src, x_dst)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_regression(edge_embedding_method='ip')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = link_regression(edge_embedding_method='ip')([x_dst_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(self.d, abs=1.5e-07))", "masked_code": "def test_ip(self):\n    \" Test the 'ip' binary operator on edge cases \"\n    x_src = np.zeros(self.d)\n    x_dst = np.ones(self.d)\n    expected = np.dot(x_src, x_dst)\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    li = link_regression(edge_embedding_method='ip')([x_src_tf, x_dst_tf])\n    assert (li.numpy() == '???')\n    li = link_regression(edge_embedding_method='ip')([x_dst_tf, x_dst_tf])\n    assert (li.numpy() == pytest.approx(self.d, abs=1.5e-07))", "ground_truth": "pytest.approx(0, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Regression"}
{"task_id": "stellargraph_693", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip_single_tensor", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on edge cases using single tensor \"\n    x_src = np.zeros(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src_tf, x_dst_tf], axis=1)\n    x_link_ss = tf.stack([x_src_tf, x_src_tf], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))", "masked_code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on edge cases using single tensor \"\n    x_src = np.zeros(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src_tf, x_dst_tf], axis=1)\n    x_link_ss = tf.stack([x_src_tf, x_src_tf], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    assert (li.numpy() == '???')\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))", "ground_truth": "pytest.approx(0, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_694", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip_single_tensor", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on edge cases using single tensor \"\n    x_src = np.zeros(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src_tf, x_dst_tf], axis=1)\n    x_link_ss = tf.stack([x_src_tf, x_src_tf], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))", "masked_code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on edge cases using single tensor \"\n    x_src = np.zeros(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src_tf, x_dst_tf], axis=1)\n    x_link_ss = tf.stack([x_src_tf, x_src_tf], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    assert (li.numpy() == '???')\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))", "ground_truth": "pytest.approx(0, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_695", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip_single_tensor", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on edge cases using single tensor \"\n    x_src = np.zeros(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src_tf, x_dst_tf], axis=1)\n    x_link_ss = tf.stack([x_src_tf, x_src_tf], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))", "masked_code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on edge cases using single tensor \"\n    x_src = np.zeros(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src_tf, x_dst_tf], axis=1)\n    x_link_ss = tf.stack([x_src_tf, x_src_tf], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == '???')\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))", "ground_truth": "pytest.approx(0.5, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_696", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_ip_single_tensor", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on edge cases using single tensor \"\n    x_src = np.zeros(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src_tf, x_dst_tf], axis=1)\n    x_link_ss = tf.stack([x_src_tf, x_src_tf], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))", "masked_code": "def test_ip_single_tensor(self):\n    \" Test the 'ip' binary operator on edge cases using single tensor \"\n    x_src = np.zeros(self.d)\n    x_dst = (- np.ones(self.d))\n    x_src_tf = tf.constant(x_src, shape=(1, self.d), dtype='float64')\n    x_dst_tf = tf.constant(x_dst, shape=(1, self.d), dtype='float64')\n    x_link_sd = tf.stack([x_src_tf, x_dst_tf], axis=1)\n    x_link_ss = tf.stack([x_src_tf, x_src_tf], axis=1)\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='linear')(x_link_ss)\n    assert (li.numpy() == pytest.approx(0, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_sd)\n    assert (li.numpy() == pytest.approx(0.5, abs=1.5e-07))\n    li = LinkEmbedding(method='ip', activation='sigmoid')(x_link_ss)\n    assert (li.numpy() == '???')", "ground_truth": "pytest.approx(0.5, abs=1.5e-07)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_697", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg' with diverse values \"\n    x_src = np.array([(100000.0 if ((i % 2) == 0) else (- 100000.0)) for i in range(self.d)], dtype=float).reshape(1, 1, self.d)\n    x_dst = np.array([((- 100000.0) if ((i % 2) == 0) else 100000.0) for i in range(self.d)], dtype=float).reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == (1, 1, self.d))\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == (1, 1, (2 * self.d)))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg' with diverse values \"\n    x_src = np.array([(100000.0 if ((i % 2) == 0) else (- 100000.0)) for i in range(self.d)], dtype=float).reshape(1, 1, self.d)\n    x_dst = np.array([((- 100000.0) if ((i % 2) == 0) else 100000.0) for i in range(self.d)], dtype=float).reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == (1, 1, (2 * self.d)))\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, 1, self.d)", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_698", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg' with diverse values \"\n    x_src = np.array([(100000.0 if ((i % 2) == 0) else (- 100000.0)) for i in range(self.d)], dtype=float).reshape(1, 1, self.d)\n    x_dst = np.array([((- 100000.0) if ((i % 2) == 0) else 100000.0) for i in range(self.d)], dtype=float).reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == (1, 1, self.d))\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == (1, 1, (2 * self.d)))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg' with diverse values \"\n    x_src = np.array([(100000.0 if ((i % 2) == 0) else (- 100000.0)) for i in range(self.d)], dtype=float).reshape(1, 1, self.d)\n    x_dst = np.array([((- 100000.0) if ((i % 2) == 0) else 100000.0) for i in range(self.d)], dtype=float).reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == (1, 1, self.d))\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, 1, (2 * self.d))", "quality_analysis": {"complexity_score": 11, "left_complexity": 2, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_705", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg', 'concat' with various values \"\n    x_src = np.linspace((- 1000.0), 1000.0, self.d).reshape(1, 1, self.d)\n    x_dst = np.linspace(1000.0, (- 1000.0), self.d).reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_inference(output_dim=self.d_out, edge_embedding_method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == (1, self.d_out))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg', 'concat' with various values \"\n    x_src = np.linspace((- 1000.0), 1000.0, self.d).reshape(1, 1, self.d)\n    x_dst = np.linspace(1000.0, (- 1000.0), self.d).reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_inference(output_dim=self.d_out, edge_embedding_method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, self.d_out)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Inference"}
{"task_id": "stellargraph_710", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg', 'concat' with negative numbers \"\n    x_src = (- np.ones(self.d).reshape(1, 1, self.d))\n    x_dst = (- np.ones(self.d).reshape(1, 1, self.d))\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_classification(output_dim=self.d_out, edge_embedding_method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == (1, self.d_out))\n        assert isinstance(res.flatten()[0], np.float32)\n        assert all((res.flatten() >= 0))\n        assert all((res.flatten() <= 1))", "masked_code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg', 'concat' with negative numbers \"\n    x_src = (- np.ones(self.d).reshape(1, 1, self.d))\n    x_dst = (- np.ones(self.d).reshape(1, 1, self.d))\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_classification(output_dim=self.d_out, edge_embedding_method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)\n        assert all((res.flatten() >= 0))\n        assert all((res.flatten() <= 1))", "ground_truth": "(1, self.d_out)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Classification"}
{"task_id": "stellargraph_713", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg', 'concat' using negative and positive values \"\n    x_src = np.full(self.d, (- 2)).reshape(1, 1, self.d)\n    x_dst = np.full(self.d, 2).reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_regression(output_dim=self.d_out, edge_embedding_method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == (1, self.d_out))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_mul_l1_l2_avg(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg', 'concat' using negative and positive values \"\n    x_src = np.full(self.d, (- 2)).reshape(1, 1, self.d)\n    x_dst = np.full(self.d, 2).reshape(1, 1, self.d)\n    inp_src = keras.Input(shape=(1, self.d))\n    inp_dst = keras.Input(shape=(1, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg', 'concat']:\n        out = link_regression(output_dim=self.d_out, edge_embedding_method=op)([inp_src, inp_dst])\n        li = keras.Model(inputs=[inp_src, inp_dst], outputs=out)\n        res = li.predict(x=[x_src, x_dst])\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, self.d_out)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_Link_Regression"}
{"task_id": "stellargraph_699", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg_single_tensor", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg_single_tensor(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg' with zeros and negative vectors \"\n    x_src = np.zeros(self.d).reshape(1, self.d)\n    x_dst = (- np.ones(self.d).reshape(1, self.d))\n    x_link_np = np.stack([x_src, x_dst], axis=1)\n    x_link = keras.Input(shape=(2, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        assert (res.shape == (1, self.d))\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        assert (res.shape == (1, (2 * self.d)))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_mul_l1_l2_avg_single_tensor(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg' with zeros and negative vectors \"\n    x_src = np.zeros(self.d).reshape(1, self.d)\n    x_dst = (- np.ones(self.d).reshape(1, self.d))\n    x_link_np = np.stack([x_src, x_dst], axis=1)\n    x_link = keras.Input(shape=(2, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        assert (res.shape == (1, (2 * self.d)))\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, self.d)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_700", "reponame": "stellargraph", "testpath": "tests/layer/test_link_inference.py", "testname": "test_link_inference.py", "funcname": "test_mul_l1_l2_avg_single_tensor", "imports": ["from stellargraph.layer.link_inference import *", "import tensorflow as tf", "from tensorflow import keras", "import numpy as np", "import pytest"], "code": "def test_mul_l1_l2_avg_single_tensor(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg' with zeros and negative vectors \"\n    x_src = np.zeros(self.d).reshape(1, self.d)\n    x_dst = (- np.ones(self.d).reshape(1, self.d))\n    x_link_np = np.stack([x_src, x_dst], axis=1)\n    x_link = keras.Input(shape=(2, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        assert (res.shape == (1, self.d))\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        assert (res.shape == (1, (2 * self.d)))\n        assert isinstance(res.flatten()[0], np.float32)", "masked_code": "def test_mul_l1_l2_avg_single_tensor(self):\n    \" Test the binary operators: 'mul'/'Hadamard', 'l1', 'l2', 'avg' with zeros and negative vectors \"\n    x_src = np.zeros(self.d).reshape(1, self.d)\n    x_dst = (- np.ones(self.d).reshape(1, self.d))\n    x_link_np = np.stack([x_src, x_dst], axis=1)\n    x_link = keras.Input(shape=(2, self.d))\n    for op in ['mul', 'l1', 'l2', 'avg']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        assert (res.shape == (1, self.d))\n        assert isinstance(res.flatten()[0], np.float32)\n    for op in ['concat']:\n        out = LinkEmbedding(method=op)(x_link)\n        li = keras.Model(inputs=x_link, outputs=out)\n        res = li.predict(x=x_link_np)\n        assert (res.shape == '???')\n        assert isinstance(res.flatten()[0], np.float32)", "ground_truth": "(1, (2 * self.d))", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}, "classname": "Test_LinkEmbedding"}
{"task_id": "stellargraph_42", "reponame": "stellargraph", "testpath": "tests/test_losses.py", "testname": "test_losses.py", "funcname": "test_self_adversarial_negative_sampling", "imports": ["from stellargraph.losses import *", "import numpy as np", "import pytest", "import tensorflow as tf", "from scipy.special import softmax, expit"], "code": "@pytest.mark.parametrize('temperature', [0.0, 0.5, 1.0, 2.0])\ndef test_self_adversarial_negative_sampling(temperature):\n    labels = np.array([1, 0, 0, (- 3), 1, 0, 1, 0], dtype=np.int32)\n    logit_scores = np.array([0.0, (- 100.0), 4.0, 1e-07, 13.5, (- 13.5), 2.3, (- 2.3)], dtype=np.float32)\n    scores = expit(logit_scores)\n    loss_func = SelfAdversarialNegativeSampling(temperature)\n    actual_loss = loss_func(tf.constant(labels), tf.constant(logit_scores))\n\n    def loss_part(score, label):\n        if (label == 1):\n            return (- np.log(score))\n        relevant = scores[np.where((labels == label))]\n        numer = np.exp((temperature * score))\n        denom = np.sum(np.exp((temperature * relevant)))\n        return (((- np.log((1 - score))) * numer) / denom)\n    expected_loss = np.mean([loss_part(score, label) for (score, label) in zip(scores, labels)])\n    assert (actual_loss.numpy() == pytest.approx(expected_loss, rel=1e-06))", "masked_code": "@pytest.mark.parametrize('temperature', [0.0, 0.5, 1.0, 2.0])\ndef test_self_adversarial_negative_sampling(temperature):\n    labels = np.array([1, 0, 0, (- 3), 1, 0, 1, 0], dtype=np.int32)\n    logit_scores = np.array([0.0, (- 100.0), 4.0, 1e-07, 13.5, (- 13.5), 2.3, (- 2.3)], dtype=np.float32)\n    scores = expit(logit_scores)\n    loss_func = SelfAdversarialNegativeSampling(temperature)\n    actual_loss = loss_func(tf.constant(labels), tf.constant(logit_scores))\n\n    def loss_part(score, label):\n        if (label == 1):\n            return (- np.log(score))\n        relevant = scores[np.where((labels == label))]\n        numer = np.exp((temperature * score))\n        denom = np.sum(np.exp((temperature * relevant)))\n        return (((- np.log((1 - score))) * numer) / denom)\n    expected_loss = np.mean([loss_part(score, label) for (score, label) in zip(scores, labels)])\n    assert (actual_loss.numpy() == '???')", "ground_truth": "pytest.approx(expected_loss, rel=1e-06)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1029", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_flow_StellarGraphs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_flow_StellarGraphs():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    graph_ilocs = [1, 0]\n    seq_1 = generator.flow(graph_ilocs)\n    seq_2 = generator.flow([graphs[1], graphs[0]])\n    assert (len(seq_1) == len(seq_2) == 2)\n    for ((values_1, targets_1), (values_2, targets_2)) in zip(seq_1, seq_2):\n        assert (len(values_1) == len(values_2) == 3)\n        assert (targets_1 is targets_2 is None)\n        for (arr_1, arr_2) in zip(values_1, values_2):\n            np.testing.assert_array_equal(arr_1, arr_2)", "masked_code": "def test_generator_flow_StellarGraphs():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    graph_ilocs = [1, 0]\n    seq_1 = generator.flow(graph_ilocs)\n    seq_2 = generator.flow([graphs[1], graphs[0]])\n    assert (len(seq_1) == '???' == 2)\n    for ((values_1, targets_1), (values_2, targets_2)) in zip(seq_1, seq_2):\n        assert (len(values_1) == len(values_2) == 3)\n        assert (targets_1 is targets_2 is None)\n        for (arr_1, arr_2) in zip(values_1, values_2):\n            np.testing.assert_array_equal(arr_1, arr_2)", "ground_truth": "len(seq_2)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1030", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_flow_StellarGraphs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_flow_StellarGraphs():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    graph_ilocs = [1, 0]\n    seq_1 = generator.flow(graph_ilocs)\n    seq_2 = generator.flow([graphs[1], graphs[0]])\n    assert (len(seq_1) == len(seq_2) == 2)\n    for ((values_1, targets_1), (values_2, targets_2)) in zip(seq_1, seq_2):\n        assert (len(values_1) == len(values_2) == 3)\n        assert (targets_1 is targets_2 is None)\n        for (arr_1, arr_2) in zip(values_1, values_2):\n            np.testing.assert_array_equal(arr_1, arr_2)", "masked_code": "def test_generator_flow_StellarGraphs():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    graph_ilocs = [1, 0]\n    seq_1 = generator.flow(graph_ilocs)\n    seq_2 = generator.flow([graphs[1], graphs[0]])\n    assert (len(seq_1) == len(seq_2) == 2)\n    for ((values_1, targets_1), (values_2, targets_2)) in zip(seq_1, seq_2):\n        assert (len(values_1) == '???' == 3)\n        assert (targets_1 is targets_2 is None)\n        for (arr_1, arr_2) in zip(values_1, values_2):\n            np.testing.assert_array_equal(arr_1, arr_2)", "ground_truth": "len(values_2)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1026", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_flow_check_padding", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_flow_check_padding():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 1], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    batch = seq[0]\n    assert (batch[0][0].shape == (2, 7, 8))\n    assert (batch[0][1].shape == (2, 7))\n    assert (batch[0][2].shape == (2, 7, 7))\n    for mask in batch[0][1]:\n        assert ((np.sum(mask) == 7) or (np.sum(mask) == 2))", "masked_code": "def test_generator_flow_check_padding():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 1], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    batch = seq[0]\n    assert (batch[0][0].shape == '???')\n    assert (batch[0][1].shape == (2, 7))\n    assert (batch[0][2].shape == (2, 7, 7))\n    for mask in batch[0][1]:\n        assert ((np.sum(mask) == 7) or (np.sum(mask) == 2))", "ground_truth": "(2, 7, 8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1027", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_flow_check_padding", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_flow_check_padding():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 1], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    batch = seq[0]\n    assert (batch[0][0].shape == (2, 7, 8))\n    assert (batch[0][1].shape == (2, 7))\n    assert (batch[0][2].shape == (2, 7, 7))\n    for mask in batch[0][1]:\n        assert ((np.sum(mask) == 7) or (np.sum(mask) == 2))", "masked_code": "def test_generator_flow_check_padding():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 1], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    batch = seq[0]\n    assert (batch[0][0].shape == (2, 7, 8))\n    assert (batch[0][1].shape == '???')\n    assert (batch[0][2].shape == (2, 7, 7))\n    for mask in batch[0][1]:\n        assert ((np.sum(mask) == 7) or (np.sum(mask) == 2))", "ground_truth": "(2, 7)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1028", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_flow_check_padding", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_flow_check_padding():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 1], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    batch = seq[0]\n    assert (batch[0][0].shape == (2, 7, 8))\n    assert (batch[0][1].shape == (2, 7))\n    assert (batch[0][2].shape == (2, 7, 7))\n    for mask in batch[0][1]:\n        assert ((np.sum(mask) == 7) or (np.sum(mask) == 2))", "masked_code": "def test_generator_flow_check_padding():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[0, 1], batch_size=2)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    batch = seq[0]\n    assert (batch[0][0].shape == (2, 7, 8))\n    assert (batch[0][1].shape == (2, 7))\n    assert (batch[0][2].shape == '???')\n    for mask in batch[0][1]:\n        assert ((np.sum(mask) == 7) or (np.sum(mask) == 2))", "ground_truth": "(2, 7, 7)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1024", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_flow_no_targets", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_flow_no_targets():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[1], batch_size=1)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 3)\n    assert (values_0[0].shape[0] == 1)\n    assert (values_0[1].shape[0] == 1)\n    assert (values_0[2].shape[0] == 1)\n    assert (targets_0 is None)", "masked_code": "def test_generator_flow_no_targets():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    seq = generator.flow(graphs=[1], batch_size=1)\n    assert isinstance(seq, PaddedGraphSequence)\n    assert (len(seq) == 1)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == '???')\n    assert (values_0[0].shape[0] == 1)\n    assert (values_0[1].shape[0] == 1)\n    assert (values_0[2].shape[0] == 1)\n    assert (targets_0 is None)", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1023", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_init", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "def test_generator_init():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    assert (len(generator.graphs) == len(graphs))", "masked_code": "def test_generator_init():\n    generator = PaddedGraphGenerator(graphs=graphs)\n    assert (len(generator.graphs) == '???')", "ground_truth": "len(graphs)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1031", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_pairs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([0, (- 12345)] if use_targets else None)\n    ilocs = [(1, 0), (0, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 1)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 7, 8))\n    assert (values_0[3].shape == (2, 7, 8))\n    np.testing.assert_array_equal(values_0[1], [_mask(2, 7), _mask(7, 7)])\n    np.testing.assert_array_equal(values_0[4], [_mask(7, 7), _mask(2, 7)])\n    assert (values_0[2].shape == (2, 7, 7))\n    assert (values_0[5].shape == (2, 7, 7))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [0, (- 12345)])\n    else:\n        assert (targets_0 is None)", "masked_code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([0, (- 12345)] if use_targets else None)\n    ilocs = [(1, 0), (0, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 1)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == '???')\n    assert (values_0[0].shape == (2, 7, 8))\n    assert (values_0[3].shape == (2, 7, 8))\n    np.testing.assert_array_equal(values_0[1], [_mask(2, 7), _mask(7, 7)])\n    np.testing.assert_array_equal(values_0[4], [_mask(7, 7), _mask(2, 7)])\n    assert (values_0[2].shape == (2, 7, 7))\n    assert (values_0[5].shape == (2, 7, 7))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [0, (- 12345)])\n    else:\n        assert (targets_0 is None)", "ground_truth": "6", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1032", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_pairs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([0, (- 12345)] if use_targets else None)\n    ilocs = [(1, 0), (0, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 1)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 7, 8))\n    assert (values_0[3].shape == (2, 7, 8))\n    np.testing.assert_array_equal(values_0[1], [_mask(2, 7), _mask(7, 7)])\n    np.testing.assert_array_equal(values_0[4], [_mask(7, 7), _mask(2, 7)])\n    assert (values_0[2].shape == (2, 7, 7))\n    assert (values_0[5].shape == (2, 7, 7))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [0, (- 12345)])\n    else:\n        assert (targets_0 is None)", "masked_code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([0, (- 12345)] if use_targets else None)\n    ilocs = [(1, 0), (0, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 1)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == '???')\n    assert (values_0[3].shape == (2, 7, 8))\n    np.testing.assert_array_equal(values_0[1], [_mask(2, 7), _mask(7, 7)])\n    np.testing.assert_array_equal(values_0[4], [_mask(7, 7), _mask(2, 7)])\n    assert (values_0[2].shape == (2, 7, 7))\n    assert (values_0[5].shape == (2, 7, 7))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [0, (- 12345)])\n    else:\n        assert (targets_0 is None)", "ground_truth": "(2, 7, 8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1033", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_pairs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([0, (- 12345)] if use_targets else None)\n    ilocs = [(1, 0), (0, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 1)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 7, 8))\n    assert (values_0[3].shape == (2, 7, 8))\n    np.testing.assert_array_equal(values_0[1], [_mask(2, 7), _mask(7, 7)])\n    np.testing.assert_array_equal(values_0[4], [_mask(7, 7), _mask(2, 7)])\n    assert (values_0[2].shape == (2, 7, 7))\n    assert (values_0[5].shape == (2, 7, 7))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [0, (- 12345)])\n    else:\n        assert (targets_0 is None)", "masked_code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([0, (- 12345)] if use_targets else None)\n    ilocs = [(1, 0), (0, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 1)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 7, 8))\n    assert (values_0[3].shape == '???')\n    np.testing.assert_array_equal(values_0[1], [_mask(2, 7), _mask(7, 7)])\n    np.testing.assert_array_equal(values_0[4], [_mask(7, 7), _mask(2, 7)])\n    assert (values_0[2].shape == (2, 7, 7))\n    assert (values_0[5].shape == (2, 7, 7))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [0, (- 12345)])\n    else:\n        assert (targets_0 is None)", "ground_truth": "(2, 7, 8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1034", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_pairs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([0, (- 12345)] if use_targets else None)\n    ilocs = [(1, 0), (0, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 1)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 7, 8))\n    assert (values_0[3].shape == (2, 7, 8))\n    np.testing.assert_array_equal(values_0[1], [_mask(2, 7), _mask(7, 7)])\n    np.testing.assert_array_equal(values_0[4], [_mask(7, 7), _mask(2, 7)])\n    assert (values_0[2].shape == (2, 7, 7))\n    assert (values_0[5].shape == (2, 7, 7))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [0, (- 12345)])\n    else:\n        assert (targets_0 is None)", "masked_code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([0, (- 12345)] if use_targets else None)\n    ilocs = [(1, 0), (0, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 1)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 7, 8))\n    assert (values_0[3].shape == (2, 7, 8))\n    np.testing.assert_array_equal(values_0[1], [_mask(2, 7), _mask(7, 7)])\n    np.testing.assert_array_equal(values_0[4], [_mask(7, 7), _mask(2, 7)])\n    assert (values_0[2].shape == '???')\n    assert (values_0[5].shape == (2, 7, 7))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [0, (- 12345)])\n    else:\n        assert (targets_0 is None)", "ground_truth": "(2, 7, 7)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_1035", "reponame": "stellargraph", "testpath": "tests/mapper/test_padded_graph_generator.py", "testname": "test_padded_graph_generator.py", "funcname": "test_generator_pairs", "imports": ["from stellargraph.core.graph import *", "from stellargraph.mapper.padded_graph_generator import PaddedGraphGenerator, PaddedGraphSequence", "import numpy as np", "import pytest", "from ..test_utils.graphs import example_graph_random, example_graph, example_hin_1"], "code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([0, (- 12345)] if use_targets else None)\n    ilocs = [(1, 0), (0, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 1)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 7, 8))\n    assert (values_0[3].shape == (2, 7, 8))\n    np.testing.assert_array_equal(values_0[1], [_mask(2, 7), _mask(7, 7)])\n    np.testing.assert_array_equal(values_0[4], [_mask(7, 7), _mask(2, 7)])\n    assert (values_0[2].shape == (2, 7, 7))\n    assert (values_0[5].shape == (2, 7, 7))\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [0, (- 12345)])\n    else:\n        assert (targets_0 is None)", "masked_code": "@pytest.mark.parametrize('use_targets', [False, True])\n@pytest.mark.parametrize('use_ilocs', [False, True])\ndef test_generator_pairs(use_targets, use_ilocs):\n    generator = PaddedGraphGenerator(graphs=graphs)\n    targets = ([0, (- 12345)] if use_targets else None)\n    ilocs = [(1, 0), (0, 1)]\n    input = (ilocs if use_ilocs else [[graphs[x] for x in pair] for pair in ilocs])\n    seq = generator.flow(input, targets=targets, batch_size=2)\n    assert (len(seq) == 1)\n    (values_0, targets_0) = seq[0]\n    assert (len(values_0) == 6)\n    assert (values_0[0].shape == (2, 7, 8))\n    assert (values_0[3].shape == (2, 7, 8))\n    np.testing.assert_array_equal(values_0[1], [_mask(2, 7), _mask(7, 7)])\n    np.testing.assert_array_equal(values_0[4], [_mask(7, 7), _mask(2, 7)])\n    assert (values_0[2].shape == (2, 7, 7))\n    assert (values_0[5].shape == '???')\n    if use_targets:\n        np.testing.assert_array_equal(targets_0, [0, (- 12345)])\n    else:\n        assert (targets_0 is None)", "ground_truth": "(2, 7, 7)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_757", "reponame": "stellargraph", "testpath": "tests/layer/test_watch_your_step.py", "testname": "test_watch_your_step.py", "funcname": "test_AttentiveWalk_config", "imports": ["from stellargraph.layer import AttentiveWalk, WatchYourStep", "import numpy as np", "from ..test_utils.graphs import barbell", "from stellargraph.mapper import AdjacencyPowerGenerator", "from stellargraph.losses import graph_log_likelihood", "import pytest", "from tensorflow.keras import Model", "from .. import test_utils"], "code": "def test_AttentiveWalk_config():\n    att_wlk = AttentiveWalk(walk_length=0, attention_initializer='zeros', attention_regularizer=None, attention_constraint=None)\n    conf = att_wlk.get_config()\n    assert (conf['walk_length'] == 0)\n    assert (conf['attention_initializer']['class_name'] == 'Zeros')\n    assert (conf['attention_regularizer'] is None)\n    assert (conf['attention_constraint'] is None)", "masked_code": "def test_AttentiveWalk_config():\n    att_wlk = AttentiveWalk(walk_length=0, attention_initializer='zeros', attention_regularizer=None, attention_constraint=None)\n    conf = att_wlk.get_config()\n    assert (conf['walk_length'] == 0)\n    assert (conf['attention_initializer']['class_name'] == '???')\n    assert (conf['attention_regularizer'] is None)\n    assert (conf['attention_constraint'] is None)", "ground_truth": "'Zeros'", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_763", "reponame": "stellargraph", "testpath": "tests/layer/test_watch_your_step.py", "testname": "test_watch_your_step.py", "funcname": "test_WatchYourStep", "imports": ["from stellargraph.layer import AttentiveWalk, WatchYourStep", "import numpy as np", "from ..test_utils.graphs import barbell", "from stellargraph.mapper import AdjacencyPowerGenerator", "from stellargraph.losses import graph_log_likelihood", "import pytest", "from tensorflow.keras import Model", "from .. import test_utils"], "code": "@pytest.mark.parametrize('weighted', [False, True])\ndef test_WatchYourStep(barbell, weighted):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=10, weighted=weighted)\n    gen = generator.flow(batch_size=1)\n    wys = WatchYourStep(generator, embedding_dimension=16, num_walks=5)\n    pytest.xfail(\"'NoneType' object is not subscriptable error in AttentiveWalk.call due to input_shapes propagation bug in the framework.\")\n    (x_in, x_out) = wys.in_out_tensors()\n    model = Model(inputs=x_in, outputs=x_out)\n    model.compile(optimizer='adam', loss=graph_log_likelihood)\n    model.fit(gen, epochs=1, steps_per_epoch=int((len(barbell.nodes()) // 1)))\n    embs = wys.embeddings()\n    assert (embs.shape == (len(barbell.nodes()), wys.embedding_dimension))\n    preds1 = model.predict(gen, steps=4)\n    preds2 = Model(*wys.in_out_tensors()).predict(gen, steps=4)\n    np.testing.assert_array_equal(preds1, preds2)", "masked_code": "@pytest.mark.parametrize('weighted', [False, True])\ndef test_WatchYourStep(barbell, weighted):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=10, weighted=weighted)\n    gen = generator.flow(batch_size=1)\n    wys = WatchYourStep(generator, embedding_dimension=16, num_walks=5)\n    pytest.xfail(\"'NoneType' object is not subscriptable error in AttentiveWalk.call due to input_shapes propagation bug in the framework.\")\n    (x_in, x_out) = wys.in_out_tensors()\n    model = Model(inputs=x_in, outputs=x_out)\n    model.compile(optimizer='adam', loss=graph_log_likelihood)\n    model.fit(gen, epochs=1, steps_per_epoch=int((len(barbell.nodes()) // 1)))\n    embs = wys.embeddings()\n    assert (embs.shape == '???')\n    preds1 = model.predict(gen, steps=4)\n    preds2 = Model(*wys.in_out_tensors()).predict(gen, steps=4)\n    np.testing.assert_array_equal(preds1, preds2)", "ground_truth": "(len(barbell.nodes()), wys.embedding_dimension)", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_759", "reponame": "stellargraph", "testpath": "tests/layer/test_watch_your_step.py", "testname": "test_watch_your_step.py", "funcname": "test_WatchYourStep_init", "imports": ["from stellargraph.layer import AttentiveWalk, WatchYourStep", "import numpy as np", "from ..test_utils.graphs import barbell", "from stellargraph.mapper import AdjacencyPowerGenerator", "from stellargraph.losses import graph_log_likelihood", "import pytest", "from tensorflow.keras import Model", "from .. import test_utils"], "code": "def test_WatchYourStep_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=8)\n    wys = WatchYourStep(generator, num_walks=1, embedding_dimension=128)\n    assert (wys.num_powers == 8)\n    assert (wys.n_nodes == len(barbell.nodes()))\n    assert (wys.num_walks == 1)\n    assert (wys.embedding_dimension == 128)", "masked_code": "def test_WatchYourStep_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=8)\n    wys = WatchYourStep(generator, num_walks=1, embedding_dimension=128)\n    assert (wys.num_powers == '???')\n    assert (wys.n_nodes == len(barbell.nodes()))\n    assert (wys.num_walks == 1)\n    assert (wys.embedding_dimension == 128)", "ground_truth": "8", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_760", "reponame": "stellargraph", "testpath": "tests/layer/test_watch_your_step.py", "testname": "test_watch_your_step.py", "funcname": "test_WatchYourStep_init", "imports": ["from stellargraph.layer import AttentiveWalk, WatchYourStep", "import numpy as np", "from ..test_utils.graphs import barbell", "from stellargraph.mapper import AdjacencyPowerGenerator", "from stellargraph.losses import graph_log_likelihood", "import pytest", "from tensorflow.keras import Model", "from .. import test_utils"], "code": "def test_WatchYourStep_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=8)\n    wys = WatchYourStep(generator, num_walks=1, embedding_dimension=128)\n    assert (wys.num_powers == 8)\n    assert (wys.n_nodes == len(barbell.nodes()))\n    assert (wys.num_walks == 1)\n    assert (wys.embedding_dimension == 128)", "masked_code": "def test_WatchYourStep_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=8)\n    wys = WatchYourStep(generator, num_walks=1, embedding_dimension=128)\n    assert (wys.num_powers == 8)\n    assert (wys.n_nodes == '???')\n    assert (wys.num_walks == 1)\n    assert (wys.embedding_dimension == 128)", "ground_truth": "len(barbell.nodes())", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "stellargraph_761", "reponame": "stellargraph", "testpath": "tests/layer/test_watch_your_step.py", "testname": "test_watch_your_step.py", "funcname": "test_WatchYourStep_init", "imports": ["from stellargraph.layer import AttentiveWalk, WatchYourStep", "import numpy as np", "from ..test_utils.graphs import barbell", "from stellargraph.mapper import AdjacencyPowerGenerator", "from stellargraph.losses import graph_log_likelihood", "import pytest", "from tensorflow.keras import Model", "from .. import test_utils"], "code": "def test_WatchYourStep_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=8)\n    wys = WatchYourStep(generator, num_walks=1, embedding_dimension=128)\n    assert (wys.num_powers == 8)\n    assert (wys.n_nodes == len(barbell.nodes()))\n    assert (wys.num_walks == 1)\n    assert (wys.embedding_dimension == 128)", "masked_code": "def test_WatchYourStep_init(barbell):\n    generator = AdjacencyPowerGenerator(barbell, num_powers=8)\n    wys = WatchYourStep(generator, num_walks=1, embedding_dimension=128)\n    assert (wys.num_powers == 8)\n    assert (wys.n_nodes == len(barbell.nodes()))\n    assert (wys.num_walks == 1)\n    assert (wys.embedding_dimension == '???')", "ground_truth": "128", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
