{"task_id": "plotly_0", "reponame": "plotly", "testpath": "tests/test_core/test_figure_messages/test_add_traces.py", "testname": "test_add_traces.py", "funcname": "test_add_trace_exclude_empty_subplots", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from unittest.mock import MagicMock"], "code": "def test_add_trace_exclude_empty_subplots():\n    fig = make_subplots(3, 3)\n    fig.add_trace(go.Scatter(x=[(- 1.5), 0.0, 2.7], y=[0.0, '', 5.5]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[10, 2.5, (- 7.7), 10000], y=[0, (- 5), 2, 3]), row=3, col=3)\n    fig.add_trace(go.Scatter(x=[4, 0, (- 100)], y=[(- 1), 23.3, 1000000000.0]), row='all', col='all', exclude_empty_subplots=True)\n    assert (len(fig.data) == 4)\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x9') and (fig.data[3]['yaxis'] == 'y9'))", "masked_code": "def test_add_trace_exclude_empty_subplots():\n    fig = make_subplots(3, 3)\n    fig.add_trace(go.Scatter(x=[(- 1.5), 0.0, 2.7], y=[0.0, '', 5.5]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[10, 2.5, (- 7.7), 10000], y=[0, (- 5), 2, 3]), row=3, col=3)\n    fig.add_trace(go.Scatter(x=[4, 0, (- 100)], y=[(- 1), 23.3, 1000000000.0]), row='all', col='all', exclude_empty_subplots=True)\n    assert (len(fig.data) == '???')\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x9') and (fig.data[3]['yaxis'] == 'y9'))", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_2", "reponame": "plotly", "testpath": "tests/test_core/test_figure_messages/test_add_traces.py", "testname": "test_add_traces.py", "funcname": "test_add_trace_exclude_totally_empty_subplots", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from unittest.mock import MagicMock"], "code": "def test_add_trace_exclude_totally_empty_subplots():\n    fig = make_subplots(2, 3)\n    fig.add_trace(go.Scatter(x=[0, 1], y=[0, 1]), row=1, col=2)\n    fig.add_trace(go.Scatter(x=['a', 'b', 'c'], y=[1.1, 2.2, 3.3]), row=2, col=3)\n    fig.add_shape(dict(type='rect', x0=(- 10), x1=10, y0=(- 10), y1=10), row=1, col=2)\n    fig.add_shape(dict(type='line', x0=0, x1=2, y0=2, y1=0), row=1, col=3)\n    fig.add_shape(dict(type='circle', x0=1, x1=2, y0=1, y1=2), row=2, col=2)\n    fig.add_trace(go.Scatter(x=[0, 0], y=[999, (- 999)]), row='all', col='all', exclude_empty_subplots=['foo', 'bar', 'baz'])\n    assert (len(fig.data) == 6)\n    assert ((fig.data[2]['xaxis'] == 'x2') and (fig.data[2]['yaxis'] == 'y2'))\n    assert ((fig.data[3]['xaxis'] == 'x3') and (fig.data[3]['yaxis'] == 'y3'))", "masked_code": "def test_add_trace_exclude_totally_empty_subplots():\n    fig = make_subplots(2, 3)\n    fig.add_trace(go.Scatter(x=[0, 1], y=[0, 1]), row=1, col=2)\n    fig.add_trace(go.Scatter(x=['a', 'b', 'c'], y=[1.1, 2.2, 3.3]), row=2, col=3)\n    fig.add_shape(dict(type='rect', x0=(- 10), x1=10, y0=(- 10), y1=10), row=1, col=2)\n    fig.add_shape(dict(type='line', x0=0, x1=2, y0=2, y1=0), row=1, col=3)\n    fig.add_shape(dict(type='circle', x0=1, x1=2, y0=1, y1=2), row=2, col=2)\n    fig.add_trace(go.Scatter(x=[0, 0], y=[999, (- 999)]), row='all', col='all', exclude_empty_subplots=['foo', 'bar', 'baz'])\n    assert (len(fig.data) == '???')\n    assert ((fig.data[2]['xaxis'] == 'x2') and (fig.data[2]['yaxis'] == 'y2'))\n    assert ((fig.data[3]['xaxis'] == 'x3') and (fig.data[3]['yaxis'] == 'y3'))", "ground_truth": "6", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_1", "reponame": "plotly", "testpath": "tests/test_core/test_figure_messages/test_add_traces.py", "testname": "test_add_traces.py", "funcname": "test_add_trace_no_exclude_empty_subplots", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from unittest.mock import MagicMock"], "code": "def test_add_trace_no_exclude_empty_subplots():\n    fig = make_subplots(3, 2)\n    fig.add_trace(go.Scatter(x=[float('inf'), (- 10000000000.0)], y=[(- 0.1), 0.0]), row=2, col=1)\n    fig.add_trace(go.Scatter(x=[2.2, 3.3, 4.4, 5.5], y=[2, 1, 0, (- 1)]), row=3, col=2)\n    fig.add_trace(go.Scatter(x=[8, 9, 10], y=[(- 8), (- 9), (- 10)]), row='all', col='all')\n    assert (len(fig.data) == 8)\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x2') and (fig.data[3]['yaxis'] == 'y2'))\n    assert ((fig.data[4]['xaxis'] == 'x3') and (fig.data[4]['yaxis'] == 'y3'))\n    assert ((fig.data[5]['xaxis'] == 'x4') and (fig.data[5]['yaxis'] == 'y4'))\n    assert ((fig.data[6]['xaxis'] == 'x5') and (fig.data[6]['yaxis'] == 'y5'))\n    assert ((fig.data[7]['xaxis'] == 'x6') and (fig.data[7]['yaxis'] == 'y6'))", "masked_code": "def test_add_trace_no_exclude_empty_subplots():\n    fig = make_subplots(3, 2)\n    fig.add_trace(go.Scatter(x=[float('inf'), (- 10000000000.0)], y=[(- 0.1), 0.0]), row=2, col=1)\n    fig.add_trace(go.Scatter(x=[2.2, 3.3, 4.4, 5.5], y=[2, 1, 0, (- 1)]), row=3, col=2)\n    fig.add_trace(go.Scatter(x=[8, 9, 10], y=[(- 8), (- 9), (- 10)]), row='all', col='all')\n    assert (len(fig.data) == '???')\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x2') and (fig.data[3]['yaxis'] == 'y2'))\n    assert ((fig.data[4]['xaxis'] == 'x3') and (fig.data[4]['yaxis'] == 'y3'))\n    assert ((fig.data[5]['xaxis'] == 'x4') and (fig.data[5]['yaxis'] == 'y4'))\n    assert ((fig.data[6]['xaxis'] == 'x5') and (fig.data[6]['yaxis'] == 'y5'))\n    assert ((fig.data[7]['xaxis'] == 'x6') and (fig.data[7]['yaxis'] == 'y6'))", "ground_truth": "8", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_3", "reponame": "plotly", "testpath": "tests/test_core/test_figure_messages/test_add_traces.py", "testname": "test_add_traces.py", "funcname": "test_add_trace_no_exclude_totally_empty_subplots", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from unittest.mock import MagicMock"], "code": "def test_add_trace_no_exclude_totally_empty_subplots():\n    fig = make_subplots(1, 4)\n    fig.add_trace(go.Scatter(x=[(- 100), 0], y=[1000, (- 1000)]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[5000, 9000, (- 500)], y=[0, 0, 0]), row=1, col=4)\n    fig.add_shape(dict(type='rect', x0=(- 20), x1=200, y0=(- 5), y1=50), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[22, (- 33)], y=[44, (- 55)]), row='all', col='all')\n    assert (len(fig.data) == 6)\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x2') and (fig.data[3]['yaxis'] == 'y2'))\n    assert ((fig.data[4]['xaxis'] == 'x3') and (fig.data[4]['yaxis'] == 'y3'))\n    assert ((fig.data[5]['xaxis'] == 'x4') and (fig.data[5]['yaxis'] == 'y4'))", "masked_code": "def test_add_trace_no_exclude_totally_empty_subplots():\n    fig = make_subplots(1, 4)\n    fig.add_trace(go.Scatter(x=[(- 100), 0], y=[1000, (- 1000)]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[5000, 9000, (- 500)], y=[0, 0, 0]), row=1, col=4)\n    fig.add_shape(dict(type='rect', x0=(- 20), x1=200, y0=(- 5), y1=50), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[22, (- 33)], y=[44, (- 55)]), row='all', col='all')\n    assert (len(fig.data) == '???')\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x2') and (fig.data[3]['yaxis'] == 'y2'))\n    assert ((fig.data[4]['xaxis'] == 'x3') and (fig.data[4]['yaxis'] == 'y3'))\n    assert ((fig.data[5]['xaxis'] == 'x4') and (fig.data[5]['yaxis'] == 'y4'))", "ground_truth": "6", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_354", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_angle_validator.py", "testname": "test_angle_validator.py", "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import AngleValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val', [0, 180, (- 180), 179.99, (- 179.99), 1000000.0, (- 1000000.0), 0.0, (- 0.0), 360, (- 360), np.float64(90), np.int64((- 90))])\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == validator.validate_coerce(val))", "masked_code": "@pytest.mark.parametrize('val', [0, 180, (- 180), 179.99, (- 179.99), 1000000.0, (- 1000000.0), 0.0, (- 0.0), 360, (- 360), np.float64(90), np.int64((- 90))])\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "validator.validate_coerce(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_356", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_angle_validator.py", "testname": "test_angle_validator.py", "funcname": "test_aok_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import AngleValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val', [[0, 180, (- 180), 179.99, (- 179.99), 0.0], [360, (- 360), 90, (- 90), 270, (- 270)], [np.float64(180), np.int64((- 180))], [1000000.0, (- 1000000.0), 720, (- 720)], [], [0, 0, 0]])\ndef test_aok_acceptance(val, validator_aok):\n    coerced = validator_aok.validate_coerce(val)\n    if isinstance(val, list):\n        assert (coerced == validator_aok.validate_coerce(val))\n    else:\n        assert (coerced == val)\n    assert (validator_aok.validate_coerce(tuple(val)) == validator_aok.validate_coerce(val))\n    assert np.array_equal(validator_aok.validate_coerce(np.array(val)), np.array(validator_aok.validate_coerce(val)))", "masked_code": "@pytest.mark.parametrize('val', [[0, 180, (- 180), 179.99, (- 179.99), 0.0], [360, (- 360), 90, (- 90), 270, (- 270)], [np.float64(180), np.int64((- 180))], [1000000.0, (- 1000000.0), 720, (- 720)], [], [0, 0, 0]])\ndef test_aok_acceptance(val, validator_aok):\n    coerced = validator_aok.validate_coerce(val)\n    if isinstance(val, list):\n        assert (coerced == validator_aok.validate_coerce(val))\n    else:\n        assert (coerced == val)\n    assert (validator_aok.validate_coerce(tuple(val)) == '???')\n    assert np.array_equal(validator_aok.validate_coerce(np.array(val)), np.array(validator_aok.validate_coerce(val)))", "ground_truth": "validator_aok.validate_coerce(val)", "quality_analysis": {"complexity_score": 11, "left_complexity": 7, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_358", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_angle_validator.py", "testname": "test_angle_validator.py", "funcname": "test_aok_coercion", "imports": ["import pytest", "from _plotly_utils.basevalidators import AngleValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val,expected', [(180, (- 180)), (181, (- 179)), ((- 180.25), 179.75), (540, (- 180)), ((- 541), 179), (360, 0), ((- 360), 0), (720, 0), ((- 720), 0), (1000000.0, (- 80.0)), ((- 1000000.0), 80.0)])\ndef test_aok_coercion(val, expected, validator_aok):\n    assert (validator_aok.validate_coerce([val]) == [expected])\n    assert np.array_equal(validator_aok.validate_coerce(np.array([val])), np.array([expected]))", "masked_code": "@pytest.mark.parametrize('val,expected', [(180, (- 180)), (181, (- 179)), ((- 180.25), 179.75), (540, (- 180)), ((- 541), 179), (360, 0), ((- 360), 0), (720, 0), ((- 720), 0), (1000000.0, (- 80.0)), ((- 1000000.0), 80.0)])\ndef test_aok_coercion(val, expected, validator_aok):\n    assert (validator_aok.validate_coerce([val]) == '???')\n    assert np.array_equal(validator_aok.validate_coerce(np.array([val])), np.array([expected]))", "ground_truth": "[expected]", "quality_analysis": {"complexity_score": 9, "left_complexity": 6, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_355", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_angle_validator.py", "testname": "test_angle_validator.py", "funcname": "test_coercion", "imports": ["import pytest", "from _plotly_utils.basevalidators import AngleValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val,expected', [(180, (- 180)), (181, (- 179)), ((- 180.25), 179.75), (540, (- 180)), ((- 541), 179), (720, 0), ((- 720), 0), (360.5, 0.5), ((- 361), (- 1)), (1000000.0, (- 80.0)), ((- 1000000.0), 80.0)])\ndef test_coercion(val, expected, validator):\n    assert (validator.validate_coerce(val) == expected)", "masked_code": "@pytest.mark.parametrize('val,expected', [(180, (- 180)), (181, (- 179)), ((- 180.25), 179.75), (540, (- 180)), ((- 541), 179), (720, 0), ((- 720), 0), (360.5, 0.5), ((- 361), (- 1)), (1000000.0, (- 80.0)), ((- 1000000.0), 80.0)])\ndef test_coercion(val, expected, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_76", "reponame": "plotly", "testpath": "tests/test_optional/test_autoshapes/test_annotated_shapes.py", "testname": "test_annotated_shapes.py", "funcname": "test_add_shape_no_annotation", "imports": ["import plotly.graph_objects as go", "from plotly.subplots import make_subplots", "from itertools import product", "import os", "import pytest", "import json", "from .common import _cmp_partial_dict"], "code": "def test_add_shape_no_annotation(multi_plot_fixture):\n    multi_plot_fixture.add_hline(y=0.0, row='all', col='all')\n    multi_plot_fixture.add_hline(y=(- 10000), row='all', col='all')\n    multi_plot_fixture.add_hline(y=1000000000000.0, row='all', col='all')\n    assert (len(multi_plot_fixture.layout.annotations) == 0)\n    assert (len(multi_plot_fixture.layout.shapes) == 12)", "masked_code": "def test_add_shape_no_annotation(multi_plot_fixture):\n    multi_plot_fixture.add_hline(y=0.0, row='all', col='all')\n    multi_plot_fixture.add_hline(y=(- 10000), row='all', col='all')\n    multi_plot_fixture.add_hline(y=1000000000000.0, row='all', col='all')\n    assert (len(multi_plot_fixture.layout.annotations) == 0)\n    assert (len(multi_plot_fixture.layout.shapes) == '???')", "ground_truth": "12", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_8", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_annotations.py", "testname": "test_annotations.py", "funcname": "test_dict_instantiation_graph_obj_error_0", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_graph_obj_error_0():\n    d = Data()\n    assert (Annotations([d]) == [[]])", "masked_code": "def test_dict_instantiation_graph_obj_error_0():\n    d = Data()\n    assert (Annotations([d]) == '???')", "ground_truth": "[[]]", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_9", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_annotations.py", "testname": "test_annotations.py", "funcname": "test_dict_instantiation_graph_obj_error_2", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_graph_obj_error_2():\n    assert (Annotations([Annotations([{}])]) == [[{}]])", "masked_code": "def test_dict_instantiation_graph_obj_error_2():\n    assert (Annotations([Annotations([{}])]) == '???')", "ground_truth": "[[{}]]", "quality_analysis": {"complexity_score": 20, "left_complexity": 13, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_6", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_annotations.py", "testname": "test_annotations.py", "funcname": "test_dict_instantiation_key_error", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_key_error():\n    assert (Annotations([{'': None}]) == [{'': None}])", "masked_code": "def test_dict_instantiation_key_error():\n    assert (Annotations([{'': None}]) == '???')", "ground_truth": "[{'': None}]", "quality_analysis": {"complexity_score": 17, "left_complexity": 10, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_7", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_annotations.py", "testname": "test_annotations.py", "funcname": "test_dict_instantiation_key_error_2", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_key_error_2():\n    assert (Annotations([{'font': 12345}]) == [{'font': 12345}])", "masked_code": "def test_dict_instantiation_key_error_2():\n    assert (Annotations([{'font': 12345}]) == '???')", "ground_truth": "[{'font': 12345}]", "quality_analysis": {"complexity_score": 17, "left_complexity": 10, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_4", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_annotations.py", "testname": "test_annotations.py", "funcname": "test_trivial", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_trivial():\n    assert (Annotations('') == list())", "masked_code": "def test_trivial():\n    assert (Annotations('') == '???')", "ground_truth": "list()", "quality_analysis": {"complexity_score": 7, "left_complexity": 4, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_359", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_any_validator.py", "testname": "test_any_validator.py", "funcname": "test_acceptance_array", "imports": ["import pytest", "from _plotly_utils.basevalidators import AnyValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [0, (- 123456789), 1234567890.0, '', [np_nan(), np_inf(), 42, ''], np.array([0, (- 1), 1, np_nan(), np_inf()]), ['a', '', 'b', 'c'], (), np.array([]), ([{'x': None}, {'y': []}],), ([1, 2.2, 3], [4, 5.5, 6]), ['Hello', 0, {}, None], [np.pi, np.e, {}, None]])\ndef test_acceptance_array(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert (coerce_val.dtype == 'object')\n        for (a, b) in zip(coerce_val, val):\n            if (isinstance(a, float) and np.isnan(a) and isinstance(b, float) and np.isnan(b)):\n                continue\n            assert (a == b)\n    elif isinstance(val, (list, tuple)):\n        assert (coerce_val == list(val))\n        assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)\n        assert (validator_aok.present(coerce_val) == val)", "masked_code": "@pytest.mark.parametrize('val', [0, (- 123456789), 1234567890.0, '', [np_nan(), np_inf(), 42, ''], np.array([0, (- 1), 1, np_nan(), np_inf()]), ['a', '', 'b', 'c'], (), np.array([]), ([{'x': None}, {'y': []}],), ([1, 2.2, 3], [4, 5.5, 6]), ['Hello', 0, {}, None], [np.pi, np.e, {}, None]])\ndef test_acceptance_array(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert (coerce_val.dtype == '???')\n        for (a, b) in zip(coerce_val, val):\n            if (isinstance(a, float) and np.isnan(a) and isinstance(b, float) and np.isnan(b)):\n                continue\n            assert (a == b)\n    elif isinstance(val, (list, tuple)):\n        assert (coerce_val == list(val))\n        assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)\n        assert (validator_aok.present(coerce_val) == val)", "ground_truth": "'object'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_360", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_any_validator.py", "testname": "test_any_validator.py", "funcname": "test_acceptance_array", "imports": ["import pytest", "from _plotly_utils.basevalidators import AnyValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [0, (- 123456789), 1234567890.0, '', [np_nan(), np_inf(), 42, ''], np.array([0, (- 1), 1, np_nan(), np_inf()]), ['a', '', 'b', 'c'], (), np.array([]), ([{'x': None}, {'y': []}],), ([1, 2.2, 3], [4, 5.5, 6]), ['Hello', 0, {}, None], [np.pi, np.e, {}, None]])\ndef test_acceptance_array(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert (coerce_val.dtype == 'object')\n        for (a, b) in zip(coerce_val, val):\n            if (isinstance(a, float) and np.isnan(a) and isinstance(b, float) and np.isnan(b)):\n                continue\n            assert (a == b)\n    elif isinstance(val, (list, tuple)):\n        assert (coerce_val == list(val))\n        assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)\n        assert (validator_aok.present(coerce_val) == val)", "masked_code": "@pytest.mark.parametrize('val', [0, (- 123456789), 1234567890.0, '', [np_nan(), np_inf(), 42, ''], np.array([0, (- 1), 1, np_nan(), np_inf()]), ['a', '', 'b', 'c'], (), np.array([]), ([{'x': None}, {'y': []}],), ([1, 2.2, 3], [4, 5.5, 6]), ['Hello', 0, {}, None], [np.pi, np.e, {}, None]])\ndef test_acceptance_array(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert (coerce_val.dtype == 'object')\n        for (a, b) in zip(coerce_val, val):\n            if (isinstance(a, float) and np.isnan(a) and isinstance(b, float) and np.isnan(b)):\n                continue\n            assert (a == b)\n    elif isinstance(val, (list, tuple)):\n        assert (coerce_val == list(val))\n        assert (validator_aok.present(coerce_val) == '???')\n    else:\n        assert (coerce_val == val)\n        assert (validator_aok.present(coerce_val) == val)", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_361", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_any_validator.py", "testname": "test_any_validator.py", "funcname": "test_acceptance_array", "imports": ["import pytest", "from _plotly_utils.basevalidators import AnyValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [0, (- 123456789), 1234567890.0, '', [np_nan(), np_inf(), 42, ''], np.array([0, (- 1), 1, np_nan(), np_inf()]), ['a', '', 'b', 'c'], (), np.array([]), ([{'x': None}, {'y': []}],), ([1, 2.2, 3], [4, 5.5, 6]), ['Hello', 0, {}, None], [np.pi, np.e, {}, None]])\ndef test_acceptance_array(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert (coerce_val.dtype == 'object')\n        for (a, b) in zip(coerce_val, val):\n            if (isinstance(a, float) and np.isnan(a) and isinstance(b, float) and np.isnan(b)):\n                continue\n            assert (a == b)\n    elif isinstance(val, (list, tuple)):\n        assert (coerce_val == list(val))\n        assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)\n        assert (validator_aok.present(coerce_val) == val)", "masked_code": "@pytest.mark.parametrize('val', [0, (- 123456789), 1234567890.0, '', [np_nan(), np_inf(), 42, ''], np.array([0, (- 1), 1, np_nan(), np_inf()]), ['a', '', 'b', 'c'], (), np.array([]), ([{'x': None}, {'y': []}],), ([1, 2.2, 3], [4, 5.5, 6]), ['Hello', 0, {}, None], [np.pi, np.e, {}, None]])\ndef test_acceptance_array(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert (coerce_val.dtype == 'object')\n        for (a, b) in zip(coerce_val, val):\n            if (isinstance(a, float) and np.isnan(a) and isinstance(b, float) and np.isnan(b)):\n                continue\n            assert (a == b)\n    elif isinstance(val, (list, tuple)):\n        assert (coerce_val == list(val))\n        assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)\n        assert (validator_aok.present(coerce_val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_370", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_basetraces_validator.py", "testname": "test_basetraces_validator.py", "funcname": "test_default_is_scatter", "imports": ["import pytest", "from _plotly_utils.basevalidators import BaseDataValidator", "from plotly.graph_objs import Scatter, Box"], "code": "def test_default_is_scatter(validator):\n    val = [{}]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode is None)", "masked_code": "def test_default_is_scatter(validator):\n    val = [{}]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == '???')\n    assert (res_present[0].mode is None)", "ground_truth": "'scatter'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_372", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_basetraces_validator.py", "testname": "test_basetraces_validator.py", "funcname": "test_skip_invalid", "imports": ["import pytest", "from _plotly_utils.basevalidators import BaseDataValidator", "from plotly.graph_objs import Scatter, Box"], "code": "def test_skip_invalid(validator_nouid):\n    val = (dict(type='scatter', mode='markers', marker={'color': 255, 'bogus': (- 1)}, line=None), dict(type='box', fillcolor=None, bogus=(- 111)), dict(type='scatter', mode='lines+markers', x=[]))\n    expected = [dict(type='scatter', mode='markers', marker={'color': 255}), dict(type='box'), dict(type='scatter', mode='lines+markers', x=[])]\n    res = validator_nouid.validate_coerce(val, skip_invalid=True)\n    assert ([el.to_plotly_json() for el in res] == expected)", "masked_code": "def test_skip_invalid(validator_nouid):\n    val = (dict(type='scatter', mode='markers', marker={'color': 255, 'bogus': (- 1)}, line=None), dict(type='box', fillcolor=None, bogus=(- 111)), dict(type='scatter', mode='lines+markers', x=[]))\n    expected = [dict(type='scatter', mode='markers', marker={'color': 255}), dict(type='box'), dict(type='scatter', mode='lines+markers', x=[])]\n    res = validator_nouid.validate_coerce(val, skip_invalid=True)\n    assert ([el.to_plotly_json() for el in res] == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 1, "left_complexity": 0, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_381", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_color_validator.py", "testname": "test_color_validator.py", "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val', ['', 'YELLOW', 'rgba(0, 0, 0, 0)', 'var(--primary-color)', 'hsl(360, 100%, 100%)', 'hsla(360, 50%, 50%, 0.5)', 'hsv(120, 56%, 67%)', 'hsva(240, 30%, 45%, 0.3)'])\ndef test_acceptance(val, validator):\n    if (val == ''):\n        with pytest.raises(ValueError):\n            validator.validate_coerce(val)\n    else:\n        assert (validator.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['', 'YELLOW', 'rgba(0, 0, 0, 0)', 'var(--primary-color)', 'hsl(360, 100%, 100%)', 'hsla(360, 50%, 50%, 0.5)', 'hsv(120, 56%, 67%)', 'hsva(240, 30%, 45%, 0.3)'])\ndef test_acceptance(val, validator):\n    if (val == ''):\n        with pytest.raises(ValueError):\n            validator.validate_coerce(val)\n    else:\n        assert (validator.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_383", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_color_validator.py", "testname": "test_color_validator.py", "funcname": "test_acceptance_aok", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val', ['pink', ['blue', 'rgba(0,0,0,0)'], np.array(['blue', 'rgba(0,0,0,0)', '', 'hsl(360,100%,100%)']), ['hsl(180, 60%, 35%)', 'rgba(0,0,0,0)', 'hsv(180,50%,100%)'], np.array(['hsl(180, 60%, 35%)', 'rgba(0,0,0,0)', 'hsv(180, 50%, 100%)']), ['hsva(60,40%,90%,1.0)'], []])\ndef test_acceptance_aok(val, validator_aok):\n    if isinstance(val, np.ndarray):\n        if ('' in val):\n            with pytest.raises(ValueError):\n                validator_aok.validate_coerce(val)\n        else:\n            coerce_val = validator_aok.validate_coerce(val)\n            assert np.array_equal(coerce_val, val)\n    elif isinstance(val, list):\n        if ('' in val):\n            with pytest.raises(ValueError):\n                validator_aok.validate_coerce(val)\n        else:\n            coerce_val = validator_aok.validate_coerce(val)\n            assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (validator_aok.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['pink', ['blue', 'rgba(0,0,0,0)'], np.array(['blue', 'rgba(0,0,0,0)', '', 'hsl(360,100%,100%)']), ['hsl(180, 60%, 35%)', 'rgba(0,0,0,0)', 'hsv(180,50%,100%)'], np.array(['hsl(180, 60%, 35%)', 'rgba(0,0,0,0)', 'hsv(180, 50%, 100%)']), ['hsva(60,40%,90%,1.0)'], []])\ndef test_acceptance_aok(val, validator_aok):\n    if isinstance(val, np.ndarray):\n        if ('' in val):\n            with pytest.raises(ValueError):\n                validator_aok.validate_coerce(val)\n        else:\n            coerce_val = validator_aok.validate_coerce(val)\n            assert np.array_equal(coerce_val, val)\n    elif isinstance(val, list):\n        if ('' in val):\n            with pytest.raises(ValueError):\n                validator_aok.validate_coerce(val)\n        else:\n            coerce_val = validator_aok.validate_coerce(val)\n            assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (validator_aok.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_384", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_color_validator.py", "testname": "test_color_validator.py", "funcname": "test_acceptance_aok_2D", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val', ['purple', [['green', 'rgba(0,0,0,0)']], [['hsl(0, 0%, 50%)', 'hsla(0, 0%, 50%, 0.5)'], ['hsv(10, 100%, 10%)', 'blue']], np.array([['rgba(0,0,0,0)', 'blue'], ['hsl(0, 0%, 50%)', 'hsla(0, 0%, 50%, 0.5)']]), [[]]])\ndef test_acceptance_aok_2D(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert np.array_equal(coerce_val, val)\n    elif isinstance(val, list):\n        assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)", "masked_code": "@pytest.mark.parametrize('val', ['purple', [['green', 'rgba(0,0,0,0)']], [['hsl(0, 0%, 50%)', 'hsla(0, 0%, 50%, 0.5)'], ['hsv(10, 100%, 10%)', 'blue']], np.array([['rgba(0,0,0,0)', 'blue'], ['hsl(0, 0%, 50%)', 'hsla(0, 0%, 50%, 0.5)']]), [[]]])\ndef test_acceptance_aok_2D(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert np.array_equal(coerce_val, val)\n    elif isinstance(val, list):\n        assert (validator_aok.present(coerce_val) == '???')\n    else:\n        assert (coerce_val == val)", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_382", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_color_validator.py", "testname": "test_color_validator.py", "funcname": "test_acceptance_colorscale", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val', ['CYAN', 0, (- 17), 1000000, 'rgba(100, 200, 10, 0.5)', 'var(--secondary-color)', 'hsl(180, 60%, 35%)', 'hsla(90, 70%, 80%, 0.8)', 'hsv(180, 50%, 100%)', 'hsva(60, 40%, 90%, 1.0)'])\ndef test_acceptance_colorscale(val, validator_colorscale):\n    assert (validator_colorscale.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['CYAN', 0, (- 17), 1000000, 'rgba(100, 200, 10, 0.5)', 'var(--secondary-color)', 'hsl(180, 60%, 35%)', 'hsla(90, 70%, 80%, 0.8)', 'hsv(180, 50%, 100%)', 'hsva(60, 40%, 90%, 1.0)'])\ndef test_acceptance_colorscale(val, validator_colorscale):\n    assert (validator_colorscale.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_373", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorlist_validator.py", "testname": "test_colorlist_validator.py", "funcname": "test_acceptance_aok", "imports": ["import pytest", "import numpy as np", "from _plotly_utils.basevalidators import ColorlistValidator"], "code": "@pytest.mark.parametrize('val', [['black', 'white', 'yellow'], ['rgb(0,0,0)', 'rgba(255,255,255,0.7)', 'rgb(127,127,127)'], np.array(['hsl(200,50%,50%)', 'hsla(210,60%,60%,0.5)', 'hsv(20,100%,80%)']), ['hsv(360, 100%, 100%)', 'hsva(180, 60%, 80%, 0.8)'], ['rgb(0,0,0)', 'hsl(0, 0%, 0%)', 'blue'], np.array(['red', 'blue', 'green', 'yellow']), []])\ndef test_acceptance_aok(val, validator):\n    coerce_val = validator.validate_coerce(val)\n    assert isinstance(coerce_val, list)\n    assert (validator.present(coerce_val) == tuple(val))", "masked_code": "@pytest.mark.parametrize('val', [['black', 'white', 'yellow'], ['rgb(0,0,0)', 'rgba(255,255,255,0.7)', 'rgb(127,127,127)'], np.array(['hsl(200,50%,50%)', 'hsla(210,60%,60%,0.5)', 'hsv(20,100%,80%)']), ['hsv(360, 100%, 100%)', 'hsva(180, 60%, 80%, 0.8)'], ['rgb(0,0,0)', 'hsl(0, 0%, 0%)', 'blue'], np.array(['red', 'blue', 'green', 'yellow']), []])\ndef test_acceptance_aok(val, validator):\n    coerce_val = validator.validate_coerce(val)\n    assert isinstance(coerce_val, list)\n    assert (validator.present(coerce_val) == '???')", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_379", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "funcname": "test_acceptance_array_1", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "@pytest.mark.parametrize('val', [[[0.0, 'cyan']], [[0.2, 'rgb(0,255,255)'], [0.8, '#123ABC']], [[0, 'navy'], [0.5, 'gold'], [1.0, 'rgba(0,255,255,0.5)']], [[0.0, 'black'], [0.0, 'black'], [1.0, 'white']]])\ndef test_acceptance_array_1(val, validator):\n    assert (validator.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', [[[0.0, 'cyan']], [[0.2, 'rgb(0,255,255)'], [0.8, '#123ABC']], [[0, 'navy'], [0.5, 'gold'], [1.0, 'rgba(0,255,255,0.5)']], [[0.0, 'black'], [0.0, 'black'], [1.0, 'white']]])\ndef test_acceptance_array_1(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_380", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "funcname": "test_acceptance_array_2", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "@pytest.mark.parametrize('val', [([0, 'RED'],), [(1.0, 'rgb(0, 0, 255)'), (0.5, '#FFFFFF'), (0.8, 'Blue')], (np.array([0.25, 'Teal'], dtype='object'), (0.5, 'olive'), (0.75, 'RGBA(0,255,0,0.25)'), (1.0, 'green')), ((0, 'black'), (1, 'white'))])\ndef test_acceptance_array_2(val, validator):\n    expected = [[e[0], e[1]] for e in val]\n    coerce_val = validator.validate_coerce(val)\n    assert (coerce_val == expected)\n    expected_present = tuple([tuple(e) for e in expected])\n    assert (validator.present(coerce_val) == expected_present)", "masked_code": "@pytest.mark.parametrize('val', [([0, 'RED'],), [(1.0, 'rgb(0, 0, 255)'), (0.5, '#FFFFFF'), (0.8, 'Blue')], (np.array([0.25, 'Teal'], dtype='object'), (0.5, 'olive'), (0.75, 'RGBA(0,255,0,0.25)'), (1.0, 'green')), ((0, 'black'), (1, 'white'))])\ndef test_acceptance_array_2(val, validator):\n    expected = [[e[0], e[1]] for e in val]\n    coerce_val = validator.validate_coerce(val)\n    assert (coerce_val == expected)\n    expected_present = tuple([tuple(e) for e in expected])\n    assert (validator.present(coerce_val) == '???')", "ground_truth": "expected_present", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_374", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "funcname": "test_acceptance_named", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "def test_acceptance_named(named_colorscale, validator):\n    d = (len(named_colorscales[named_colorscale]) - 1)\n    reversed_colorscale = named_colorscales[named_colorscale][::(- 1)]\n    expected = validator.validate_coerce(((named_colorscale + '_r') if (hasattr(colors.sequential, (named_colorscale + '_r')) or hasattr(colors.diverging, (named_colorscale + '_r')) or hasattr(colors.cyclical, (named_colorscale + '_r'))) else named_colorscale))\n    reversed_name = ((named_colorscale + '_r') if (hasattr(colors.sequential, (named_colorscale + '_r')) or hasattr(colors.diverging, (named_colorscale + '_r')) or hasattr(colors.cyclical, (named_colorscale + '_r'))) else named_colorscale)\n    assert (validator.validate_coerce(reversed_name) == expected)\n    assert (validator.validate_coerce(reversed_name.upper()) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "masked_code": "def test_acceptance_named(named_colorscale, validator):\n    d = (len(named_colorscales[named_colorscale]) - 1)\n    reversed_colorscale = named_colorscales[named_colorscale][::(- 1)]\n    expected = validator.validate_coerce(((named_colorscale + '_r') if (hasattr(colors.sequential, (named_colorscale + '_r')) or hasattr(colors.diverging, (named_colorscale + '_r')) or hasattr(colors.cyclical, (named_colorscale + '_r'))) else named_colorscale))\n    reversed_name = ((named_colorscale + '_r') if (hasattr(colors.sequential, (named_colorscale + '_r')) or hasattr(colors.diverging, (named_colorscale + '_r')) or hasattr(colors.cyclical, (named_colorscale + '_r'))) else named_colorscale)\n    assert (validator.validate_coerce(reversed_name) == '???')\n    assert (validator.validate_coerce(reversed_name.upper()) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_375", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "funcname": "test_acceptance_named", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "def test_acceptance_named(named_colorscale, validator):\n    d = (len(named_colorscales[named_colorscale]) - 1)\n    reversed_colorscale = named_colorscales[named_colorscale][::(- 1)]\n    expected = validator.validate_coerce(((named_colorscale + '_r') if (hasattr(colors.sequential, (named_colorscale + '_r')) or hasattr(colors.diverging, (named_colorscale + '_r')) or hasattr(colors.cyclical, (named_colorscale + '_r'))) else named_colorscale))\n    reversed_name = ((named_colorscale + '_r') if (hasattr(colors.sequential, (named_colorscale + '_r')) or hasattr(colors.diverging, (named_colorscale + '_r')) or hasattr(colors.cyclical, (named_colorscale + '_r'))) else named_colorscale)\n    assert (validator.validate_coerce(reversed_name) == expected)\n    assert (validator.validate_coerce(reversed_name.upper()) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "masked_code": "def test_acceptance_named(named_colorscale, validator):\n    d = (len(named_colorscales[named_colorscale]) - 1)\n    reversed_colorscale = named_colorscales[named_colorscale][::(- 1)]\n    expected = validator.validate_coerce(((named_colorscale + '_r') if (hasattr(colors.sequential, (named_colorscale + '_r')) or hasattr(colors.diverging, (named_colorscale + '_r')) or hasattr(colors.cyclical, (named_colorscale + '_r'))) else named_colorscale))\n    reversed_name = ((named_colorscale + '_r') if (hasattr(colors.sequential, (named_colorscale + '_r')) or hasattr(colors.diverging, (named_colorscale + '_r')) or hasattr(colors.cyclical, (named_colorscale + '_r'))) else named_colorscale)\n    assert (validator.validate_coerce(reversed_name) == expected)\n    assert (validator.validate_coerce(reversed_name.upper()) == '???')\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "ground_truth": "expected", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_376", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "funcname": "test_acceptance_named", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "def test_acceptance_named(named_colorscale, validator):\n    d = (len(named_colorscales[named_colorscale]) - 1)\n    reversed_colorscale = named_colorscales[named_colorscale][::(- 1)]\n    expected = validator.validate_coerce(((named_colorscale + '_r') if (hasattr(colors.sequential, (named_colorscale + '_r')) or hasattr(colors.diverging, (named_colorscale + '_r')) or hasattr(colors.cyclical, (named_colorscale + '_r'))) else named_colorscale))\n    reversed_name = ((named_colorscale + '_r') if (hasattr(colors.sequential, (named_colorscale + '_r')) or hasattr(colors.diverging, (named_colorscale + '_r')) or hasattr(colors.cyclical, (named_colorscale + '_r'))) else named_colorscale)\n    assert (validator.validate_coerce(reversed_name) == expected)\n    assert (validator.validate_coerce(reversed_name.upper()) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "masked_code": "def test_acceptance_named(named_colorscale, validator):\n    d = (len(named_colorscales[named_colorscale]) - 1)\n    reversed_colorscale = named_colorscales[named_colorscale][::(- 1)]\n    expected = validator.validate_coerce(((named_colorscale + '_r') if (hasattr(colors.sequential, (named_colorscale + '_r')) or hasattr(colors.diverging, (named_colorscale + '_r')) or hasattr(colors.cyclical, (named_colorscale + '_r'))) else named_colorscale))\n    reversed_name = ((named_colorscale + '_r') if (hasattr(colors.sequential, (named_colorscale + '_r')) or hasattr(colors.diverging, (named_colorscale + '_r')) or hasattr(colors.cyclical, (named_colorscale + '_r'))) else named_colorscale)\n    assert (validator.validate_coerce(reversed_name) == expected)\n    assert (validator.validate_coerce(reversed_name.upper()) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == '???')", "ground_truth": "expected_tuples", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_377", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "funcname": "test_acceptance_sequence", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "def test_acceptance_sequence(seqence_colorscale, validator):\n    custom_seq = []\n    d = (len(seqence_colorscale) - 1)\n    for (i, x) in enumerate(seqence_colorscale):\n        pos = ((1.0 * i) / (1.0 * d))\n        custom_seq.append([pos, x])\n    expected = custom_seq\n    assert (validator.validate_coerce(custom_seq) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "masked_code": "def test_acceptance_sequence(seqence_colorscale, validator):\n    custom_seq = []\n    d = (len(seqence_colorscale) - 1)\n    for (i, x) in enumerate(seqence_colorscale):\n        pos = ((1.0 * i) / (1.0 * d))\n        custom_seq.append([pos, x])\n    expected = custom_seq\n    assert (validator.validate_coerce(custom_seq) == '???')\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_378", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "funcname": "test_acceptance_sequence", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "def test_acceptance_sequence(seqence_colorscale, validator):\n    custom_seq = []\n    d = (len(seqence_colorscale) - 1)\n    for (i, x) in enumerate(seqence_colorscale):\n        pos = ((1.0 * i) / (1.0 * d))\n        custom_seq.append([pos, x])\n    expected = custom_seq\n    assert (validator.validate_coerce(custom_seq) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "masked_code": "def test_acceptance_sequence(seqence_colorscale, validator):\n    custom_seq = []\n    d = (len(seqence_colorscale) - 1)\n    for (i, x) in enumerate(seqence_colorscale):\n        pos = ((1.0 * i) / (1.0 * d))\n        custom_seq.append([pos, x])\n    expected = custom_seq\n    assert (validator.validate_coerce(custom_seq) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == '???')", "ground_truth": "expected_tuples", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_392", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compound_validator.py", "testname": "test_compound_validator.py", "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundValidator", "from plotly.graph_objs.scatter import Marker"], "code": "def test_acceptance(validator):\n    val = Marker(color='#FF00FF', size=99.9)\n    res = validator.validate_coerce(val)\n    assert isinstance(res, Marker)\n    assert (res.color == '#FF00FF')\n    assert (res.size == 99.9)", "masked_code": "def test_acceptance(validator):\n    val = Marker(color='#FF00FF', size=99.9)\n    res = validator.validate_coerce(val)\n    assert isinstance(res, Marker)\n    assert (res.color == '???')\n    assert (res.size == 99.9)", "ground_truth": "'#FF00FF'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_393", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compound_validator.py", "testname": "test_compound_validator.py", "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundValidator", "from plotly.graph_objs.scatter import Marker"], "code": "def test_acceptance(validator):\n    val = Marker(color='#FF00FF', size=99.9)\n    res = validator.validate_coerce(val)\n    assert isinstance(res, Marker)\n    assert (res.color == '#FF00FF')\n    assert (res.size == 99.9)", "masked_code": "def test_acceptance(validator):\n    val = Marker(color='#FF00FF', size=99.9)\n    res = validator.validate_coerce(val)\n    assert isinstance(res, Marker)\n    assert (res.color == '#FF00FF')\n    assert (res.size == '???')", "ground_truth": "99.9", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_396", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compound_validator.py", "testname": "test_compound_validator.py", "funcname": "test_skip_invalid", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundValidator", "from plotly.graph_objs.scatter import Marker"], "code": "def test_skip_invalid(validator):\n    val = dict(color='', size=(- 99999), bogus='-1', colorbar={'bgcolor': '', 'bogus_inner': None}, opacity=(- 0.25))\n    expected = {}\n    res = validator.validate_coerce(val, skip_invalid=True)\n    assert (res.to_plotly_json() == expected)", "masked_code": "def test_skip_invalid(validator):\n    val = dict(color='', size=(- 99999), bogus='-1', colorbar={'bgcolor': '', 'bogus_inner': None}, opacity=(- 0.25))\n    expected = {}\n    res = validator.validate_coerce(val, skip_invalid=True)\n    assert (res.to_plotly_json() == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_397", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compound_validator.py", "testname": "test_compound_validator.py", "funcname": "test_skip_invalid_empty_object", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundValidator", "from plotly.graph_objs.scatter import Marker"], "code": "def test_skip_invalid_empty_object(validator):\n    val = dict(color=None, size=1000000000.0, colorbar={'bgcolor': None, 'bogus_inner': 'invalid'}, opacity=1)\n    expected = {'opacity': 1, 'size': 1000000000.0}\n    res = validator.validate_coerce(val, skip_invalid=True)\n    assert (res.to_plotly_json() == expected)", "masked_code": "def test_skip_invalid_empty_object(validator):\n    val = dict(color=None, size=1000000000.0, colorbar={'bgcolor': None, 'bogus_inner': 'invalid'}, opacity=1)\n    expected = {'opacity': 1, 'size': 1000000000.0}\n    res = validator.validate_coerce(val, skip_invalid=True)\n    assert (res.to_plotly_json() == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_385", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_acceptance(validator):\n    val = [Image(opacity=0, sizex=(- 999999999)), Image(x=0, opacity=1.0, sizex=1000000000, sizey=500.5), Image()]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0)\n    assert (res_present[0].sizex == (- 999999999))\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].opacity == 1.0)\n    assert (res_present[1].sizex == 1000000000)\n    assert (res_present[1].x == 0)\n    assert (res_present[1].sizey == 500.5)\n    assert isinstance(res_present[2], Image)\n    assert (res_present[2].opacity is None)\n    assert (res_present[2].sizex is None)\n    assert (res_present[2].x is None)\n    assert (res_present[2].sizey is None)", "masked_code": "def test_acceptance(validator):\n    val = [Image(opacity=0, sizex=(- 999999999)), Image(x=0, opacity=1.0, sizex=1000000000, sizey=500.5), Image()]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0)\n    assert (res_present[0].sizex == '???')\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].opacity == 1.0)\n    assert (res_present[1].sizex == 1000000000)\n    assert (res_present[1].x == 0)\n    assert (res_present[1].sizey == 500.5)\n    assert isinstance(res_present[2], Image)\n    assert (res_present[2].opacity is None)\n    assert (res_present[2].sizex is None)\n    assert (res_present[2].x is None)\n    assert (res_present[2].sizey is None)", "ground_truth": "(- 999999999)", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_386", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_acceptance(validator):\n    val = [Image(opacity=0, sizex=(- 999999999)), Image(x=0, opacity=1.0, sizex=1000000000, sizey=500.5), Image()]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0)\n    assert (res_present[0].sizex == (- 999999999))\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].opacity == 1.0)\n    assert (res_present[1].sizex == 1000000000)\n    assert (res_present[1].x == 0)\n    assert (res_present[1].sizey == 500.5)\n    assert isinstance(res_present[2], Image)\n    assert (res_present[2].opacity is None)\n    assert (res_present[2].sizex is None)\n    assert (res_present[2].x is None)\n    assert (res_present[2].sizey is None)", "masked_code": "def test_acceptance(validator):\n    val = [Image(opacity=0, sizex=(- 999999999)), Image(x=0, opacity=1.0, sizex=1000000000, sizey=500.5), Image()]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0)\n    assert (res_present[0].sizex == (- 999999999))\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].opacity == 1.0)\n    assert (res_present[1].sizex == '???')\n    assert (res_present[1].x == 0)\n    assert (res_present[1].sizey == 500.5)\n    assert isinstance(res_present[2], Image)\n    assert (res_present[2].opacity is None)\n    assert (res_present[2].sizex is None)\n    assert (res_present[2].x is None)\n    assert (res_present[2].sizey is None)", "ground_truth": "1000000000", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_387", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_acceptance(validator):\n    val = [Image(opacity=0, sizex=(- 999999999)), Image(x=0, opacity=1.0, sizex=1000000000, sizey=500.5), Image()]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0)\n    assert (res_present[0].sizex == (- 999999999))\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].opacity == 1.0)\n    assert (res_present[1].sizex == 1000000000)\n    assert (res_present[1].x == 0)\n    assert (res_present[1].sizey == 500.5)\n    assert isinstance(res_present[2], Image)\n    assert (res_present[2].opacity is None)\n    assert (res_present[2].sizex is None)\n    assert (res_present[2].x is None)\n    assert (res_present[2].sizey is None)", "masked_code": "def test_acceptance(validator):\n    val = [Image(opacity=0, sizex=(- 999999999)), Image(x=0, opacity=1.0, sizex=1000000000, sizey=500.5), Image()]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0)\n    assert (res_present[0].sizex == (- 999999999))\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].opacity == 1.0)\n    assert (res_present[1].sizex == 1000000000)\n    assert (res_present[1].x == 0)\n    assert (res_present[1].sizey == '???')\n    assert isinstance(res_present[2], Image)\n    assert (res_present[2].opacity is None)\n    assert (res_present[2].sizex is None)\n    assert (res_present[2].x is None)\n    assert (res_present[2].sizey is None)", "ground_truth": "500.5", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_388", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "funcname": "test_acceptance_dict", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_acceptance_dict(validator):\n    val = [dict(opacity=0, sizex=(- 123456789), sizey=1.1), dict(x=0, sizex=10000, opacity=0.25), dict()]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0)\n    assert (res_present[0].sizex == (- 123456789))\n    assert (res_present[0].sizey == 1.1)\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].x == 0)\n    assert (res_present[1].sizex == 10000)\n    assert (res_present[1].opacity == 0.25)\n    assert isinstance(res_present[2], Image)\n    assert (res_present[2].opacity is None)\n    assert (res_present[2].sizex is None)\n    assert (res_present[2].x is None)\n    assert (res_present[2].sizey is None)", "masked_code": "def test_acceptance_dict(validator):\n    val = [dict(opacity=0, sizex=(- 123456789), sizey=1.1), dict(x=0, sizex=10000, opacity=0.25), dict()]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0)\n    assert (res_present[0].sizex == '???')\n    assert (res_present[0].sizey == 1.1)\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].x == 0)\n    assert (res_present[1].sizex == 10000)\n    assert (res_present[1].opacity == 0.25)\n    assert isinstance(res_present[2], Image)\n    assert (res_present[2].opacity is None)\n    assert (res_present[2].sizex is None)\n    assert (res_present[2].x is None)\n    assert (res_present[2].sizey is None)", "ground_truth": "(- 123456789)", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_389", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "funcname": "test_acceptance_dict", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_acceptance_dict(validator):\n    val = [dict(opacity=0, sizex=(- 123456789), sizey=1.1), dict(x=0, sizex=10000, opacity=0.25), dict()]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0)\n    assert (res_present[0].sizex == (- 123456789))\n    assert (res_present[0].sizey == 1.1)\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].x == 0)\n    assert (res_present[1].sizex == 10000)\n    assert (res_present[1].opacity == 0.25)\n    assert isinstance(res_present[2], Image)\n    assert (res_present[2].opacity is None)\n    assert (res_present[2].sizex is None)\n    assert (res_present[2].x is None)\n    assert (res_present[2].sizey is None)", "masked_code": "def test_acceptance_dict(validator):\n    val = [dict(opacity=0, sizex=(- 123456789), sizey=1.1), dict(x=0, sizex=10000, opacity=0.25), dict()]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0)\n    assert (res_present[0].sizex == (- 123456789))\n    assert (res_present[0].sizey == '???')\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].x == 0)\n    assert (res_present[1].sizex == 10000)\n    assert (res_present[1].opacity == 0.25)\n    assert isinstance(res_present[2], Image)\n    assert (res_present[2].opacity is None)\n    assert (res_present[2].sizex is None)\n    assert (res_present[2].x is None)\n    assert (res_present[2].sizey is None)", "ground_truth": "1.1", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_390", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "funcname": "test_acceptance_dict", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_acceptance_dict(validator):\n    val = [dict(opacity=0, sizex=(- 123456789), sizey=1.1), dict(x=0, sizex=10000, opacity=0.25), dict()]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0)\n    assert (res_present[0].sizex == (- 123456789))\n    assert (res_present[0].sizey == 1.1)\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].x == 0)\n    assert (res_present[1].sizex == 10000)\n    assert (res_present[1].opacity == 0.25)\n    assert isinstance(res_present[2], Image)\n    assert (res_present[2].opacity is None)\n    assert (res_present[2].sizex is None)\n    assert (res_present[2].x is None)\n    assert (res_present[2].sizey is None)", "masked_code": "def test_acceptance_dict(validator):\n    val = [dict(opacity=0, sizex=(- 123456789), sizey=1.1), dict(x=0, sizex=10000, opacity=0.25), dict()]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0)\n    assert (res_present[0].sizex == (- 123456789))\n    assert (res_present[0].sizey == 1.1)\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].x == 0)\n    assert (res_present[1].sizex == '???')\n    assert (res_present[1].opacity == 0.25)\n    assert isinstance(res_present[2], Image)\n    assert (res_present[2].opacity is None)\n    assert (res_present[2].sizex is None)\n    assert (res_present[2].x is None)\n    assert (res_present[2].sizey is None)", "ground_truth": "10000", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_391", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "funcname": "test_skip_invalid", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_skip_invalid(validator):\n    val = [dict(opacity='', x=(- 999999), sizex=0, sizey=22), dict(x=0, bogus={'a': 0}, sizey=0, opacity=(- 1)), dict(x=1.5, sizex='invalidsizex', opacity=None)]\n    expected = [{'sizex': 0, 'x': (- 999999), 'sizey': 22}, {'sizey': 0, 'x': 0}, {'x': 1.5}]\n    res = validator.validate_coerce(val, skip_invalid=True)\n    assert ([el.to_plotly_json() for el in res] == expected)", "masked_code": "def test_skip_invalid(validator):\n    val = [dict(opacity='', x=(- 999999), sizex=0, sizey=22), dict(x=0, bogus={'a': 0}, sizey=0, opacity=(- 1)), dict(x=1.5, sizex='invalidsizex', opacity=None)]\n    expected = [{'sizex': 0, 'x': (- 999999), 'sizey': 22}, {'sizey': 0, 'x': 0}, {'x': 1.5}]\n    res = validator.validate_coerce(val, skip_invalid=True)\n    assert ([el.to_plotly_json() for el in res] == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 1, "left_complexity": 0, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_399", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_dash_validator.py", "testname": "test_dash_validator.py", "funcname": "test_acceptance_dash_lists", "imports": ["import pytest", "from _plotly_utils.basevalidators import DashValidator"], "code": "@pytest.mark.parametrize('val', ['0', '999999', '-5', '3.1415926', '1e3', '0px 0px 0px', '1000000px, 0%', '-3px, 5.2px', '100%', '1.25em 0.75em', '1,2,3,4,5,6,7,8,9,10', '2.2 2.4 2.6 2.8', '3px,, 4px'])\ndef test_acceptance_dash_lists(val, validator):\n    valid_examples = ['0px 0px 0px', '1000000px, 0%', '100%', '1,2,3,4,5,6,7,8,9,10', '2.2 2.4 2.6 2.8']\n    if (val in valid_examples):\n        assert (validator.validate_coerce(val) == val)\n    elif (val == '0'):\n        assert (validator.validate_coerce(val) == '0')\n    elif (val == '999999'):\n        assert (validator.validate_coerce(val) == '999999')\n    elif (val == '3.1415926'):\n        assert (validator.validate_coerce(val) == '3.1415926')\n    else:\n        with pytest.raises(ValueError) as e:\n            validator.validate_coerce(val)\n        assert ('Invalid value' in str(e.value))", "masked_code": "@pytest.mark.parametrize('val', ['0', '999999', '-5', '3.1415926', '1e3', '0px 0px 0px', '1000000px, 0%', '-3px, 5.2px', '100%', '1.25em 0.75em', '1,2,3,4,5,6,7,8,9,10', '2.2 2.4 2.6 2.8', '3px,, 4px'])\ndef test_acceptance_dash_lists(val, validator):\n    valid_examples = ['0px 0px 0px', '1000000px, 0%', '100%', '1,2,3,4,5,6,7,8,9,10', '2.2 2.4 2.6 2.8']\n    if (val in valid_examples):\n        assert (validator.validate_coerce(val) == '???')\n    elif (val == '0'):\n        assert (validator.validate_coerce(val) == '0')\n    elif (val == '999999'):\n        assert (validator.validate_coerce(val) == '999999')\n    elif (val == '3.1415926'):\n        assert (validator.validate_coerce(val) == '3.1415926')\n    else:\n        with pytest.raises(ValueError) as e:\n            validator.validate_coerce(val)\n        assert ('Invalid value' in str(e.value))", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_398", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_dash_validator.py", "testname": "test_dash_validator.py", "funcname": "test_acceptance_dash_types", "imports": ["import pytest", "from _plotly_utils.basevalidators import DashValidator"], "code": "@pytest.mark.parametrize('val', ['', 'longdashdot', 'dot', 'dash', 'solid', 'longdash', 'dashdot', 'solid', 'dot', ('a' * 100)])\ndef test_acceptance_dash_types(val, validator):\n    if (val in dash_types):\n        assert (validator.validate_coerce(val) == val)\n    else:\n        with pytest.raises(ValueError) as e:\n            validator.validate_coerce(val)\n        assert ('Invalid value' in str(e.value))", "masked_code": "@pytest.mark.parametrize('val', ['', 'longdashdot', 'dot', 'dash', 'solid', 'longdash', 'dashdot', 'solid', 'dot', ('a' * 100)])\ndef test_acceptance_dash_types(val, validator):\n    if (val in dash_types):\n        assert (validator.validate_coerce(val) == '???')\n    else:\n        with pytest.raises(ValueError) as e:\n            validator.validate_coerce(val)\n        assert ('Invalid value' in str(e.value))", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_12", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "funcname": "test_default_scatter", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_default_scatter():\n    assert (Data([{'type': 'scatter', 'x': [], 'y': [], 'mode': ''}]) == [{'type': 'scatter', 'x': [], 'y': [], 'mode': ''}])", "masked_code": "def test_default_scatter():\n    assert (Data([{'type': 'scatter', 'x': [], 'y': [], 'mode': ''}]) == '???')", "ground_truth": "[{'type': 'scatter', 'x': [], 'y': [], 'mode': ''}]", "quality_analysis": {"complexity_score": 33, "left_complexity": 18, "right_complexity": 15, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_16", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "funcname": "test_dict_instantiation_graph_obj_error_0", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_graph_obj_error_0():\n    assert (Data([Data([{'foo': 'bar'}])]) == [[{'foo': 'bar'}]])", "masked_code": "def test_dict_instantiation_graph_obj_error_0():\n    assert (Data([Data([{'foo': 'bar'}])]) == '???')", "ground_truth": "[[{'foo': 'bar'}]]", "quality_analysis": {"complexity_score": 24, "left_complexity": 15, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_17", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "funcname": "test_dict_instantiation_graph_obj_error_2", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_graph_obj_error_2():\n    ann = Annotations(annotationdefaults={'font': {'size': 0, 'color': ''}})\n    assert (Data([ann]) == [[]])", "masked_code": "def test_dict_instantiation_graph_obj_error_2():\n    ann = Annotations(annotationdefaults={'font': {'size': 0, 'color': ''}})\n    assert (Data([ann]) == '???')", "ground_truth": "[[]]", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_13", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "funcname": "test_dict_instantiation_key_error", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_key_error():\n    assert (Data([{'': None}]) == [{'': None}])", "masked_code": "def test_dict_instantiation_key_error():\n    assert (Data([{'': None}]) == '???')", "ground_truth": "[{'': None}]", "quality_analysis": {"complexity_score": 17, "left_complexity": 10, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_14", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "funcname": "test_dict_instantiation_key_error_2", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_key_error_2():\n    assert (Data([{'marker': ('A' * 500)}]) == [{'marker': ('A' * 500)}])", "masked_code": "def test_dict_instantiation_key_error_2():\n    assert (Data([{'marker': ('A' * 500)}]) == '???')", "ground_truth": "[{'marker': ('A' * 500)}]", "quality_analysis": {"complexity_score": 23, "left_complexity": 13, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_15", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "funcname": "test_dict_instantiation_type_error", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_type_error():\n    assert (Data([{'type': (- 123.456)}]) == [{'type': (- 123.456)}])", "masked_code": "def test_dict_instantiation_type_error():\n    assert (Data([{'type': (- 123.456)}]) == '???')", "ground_truth": "[{'type': (- 123.456)}]", "quality_analysis": {"complexity_score": 21, "left_complexity": 12, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_10", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "funcname": "test_trivial", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_trivial():\n    assert (Data('') == [])", "masked_code": "def test_trivial():\n    assert (Data('') == '???')", "ground_truth": "[]", "quality_analysis": {"complexity_score": 6, "left_complexity": 4, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_400", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_dataarray_validator.py", "testname": "test_dataarray_validator.py", "funcname": "test_validator_acceptance_simple", "imports": ["import pytest", "from _plotly_utils.basevalidators import DataArrayValidator", "import numpy as np", "import pandas as pd"], "code": "@pytest.mark.parametrize('val', [[0, (- 1), 999999999], [3.1415, (- 2.718), 0.0], [None, 'foo', '', 42], tuple(), ('', None, True, False), ['X', (- 99.9), 0, 'Y', np.nan], [np.array((- 7)), np.array(0), np.array(1.618)]])\ndef test_validator_acceptance_simple(val, validator):\n    coerce_val = validator.validate_coerce(val)\n    assert isinstance(coerce_val, list)\n    assert (validator.present(coerce_val) == tuple(val))", "masked_code": "@pytest.mark.parametrize('val', [[0, (- 1), 999999999], [3.1415, (- 2.718), 0.0], [None, 'foo', '', 42], tuple(), ('', None, True, False), ['X', (- 99.9), 0, 'Y', np.nan], [np.array((- 7)), np.array(0), np.array(1.618)]])\ndef test_validator_acceptance_simple(val, validator):\n    coerce_val = validator.validate_coerce(val)\n    assert isinstance(coerce_val, list)\n    assert (validator.present(coerce_val) == '???')", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_47", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "funcname": "test_deepcopy_figure", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_deepcopy_figure(fig1):\n    fig_copied = copy.deepcopy(fig1)\n    assert (fig_copied.to_dict() == fig1.to_dict())\n    assert (fig_copied is not fig1)\n    assert (fig_copied.layout is not fig1.layout)\n    assert (fig_copied.data is not fig1.data)", "masked_code": "def test_deepcopy_figure(fig1):\n    fig_copied = copy.deepcopy(fig1)\n    assert (fig_copied.to_dict() == '???')\n    assert (fig_copied is not fig1)\n    assert (fig_copied.layout is not fig1.layout)\n    assert (fig_copied.data is not fig1.data)", "ground_truth": "fig1.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_48", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "funcname": "test_deepcopy_figure_subplots", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    fig_copied.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "masked_code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == '???')\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    fig_copied.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "ground_truth": "fig_subplots.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_49", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "funcname": "test_deepcopy_figure_subplots", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    fig_copied.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "masked_code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == '???')\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    fig_copied.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "ground_truth": "fig_copied._grid_ref", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_50", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "funcname": "test_deepcopy_figure_subplots", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    fig_copied.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "masked_code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == '???')\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    fig_copied.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "ground_truth": "fig_copied._grid_str", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_51", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "funcname": "test_deepcopy_figure_subplots", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    fig_copied.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "masked_code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    fig_copied.add_bar(y=[(- 1000), 0, 1000], row=1, col=4)\n    assert (fig_copied.to_dict() == '???')", "ground_truth": "fig_subplots.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_52", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "funcname": "test_pickle_figure_round_trip", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_pickle_figure_round_trip(fig1):\n    fig_copied = pickle.loads(pickle.dumps(fig1))\n    assert (fig_copied.to_dict() == fig1.to_dict())", "masked_code": "def test_pickle_figure_round_trip(fig1):\n    fig_copied = pickle.loads(pickle.dumps(fig1))\n    assert (fig_copied.to_dict() == '???')", "ground_truth": "fig1.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_53", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "funcname": "test_pickle_figure_subplots_round_trip", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_pickle_figure_subplots_round_trip(fig_subplots):\n    fig_copied = pickle.loads(pickle.dumps(fig_subplots))\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    fig_subplots.add_bar(y=[float('inf'), float('-inf'), 0.0], row=4, col=4)\n    fig_copied.add_bar(y=[float('inf'), float('-inf'), 0.0], row=4, col=4)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "masked_code": "def test_pickle_figure_subplots_round_trip(fig_subplots):\n    fig_copied = pickle.loads(pickle.dumps(fig_subplots))\n    assert (fig_copied.to_dict() == '???')\n    fig_subplots.add_bar(y=[float('inf'), float('-inf'), 0.0], row=4, col=4)\n    fig_copied.add_bar(y=[float('inf'), float('-inf'), 0.0], row=4, col=4)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "ground_truth": "fig_subplots.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_54", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "funcname": "test_pickle_figure_subplots_round_trip", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_pickle_figure_subplots_round_trip(fig_subplots):\n    fig_copied = pickle.loads(pickle.dumps(fig_subplots))\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    fig_subplots.add_bar(y=[float('inf'), float('-inf'), 0.0], row=4, col=4)\n    fig_copied.add_bar(y=[float('inf'), float('-inf'), 0.0], row=4, col=4)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "masked_code": "def test_pickle_figure_subplots_round_trip(fig_subplots):\n    fig_copied = pickle.loads(pickle.dumps(fig_subplots))\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    fig_subplots.add_bar(y=[float('inf'), float('-inf'), 0.0], row=4, col=4)\n    fig_copied.add_bar(y=[float('inf'), float('-inf'), 0.0], row=4, col=4)\n    assert (fig_copied.to_dict() == '???')", "ground_truth": "fig_subplots.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_402", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_enumerated_validator.py", "testname": "test_enumerated_validator.py", "funcname": "test_acceptance", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import EnumeratedValidator", "from ...test_optional.test_utils.test_utils import np_inf"], "code": "@pytest.mark.parametrize('val', ['baz', 'bar9999', 'bar', 'foofoo'])\ndef test_acceptance(val, validator_re):\n    if (val == 'baz'):\n        assert (validator_re.validate_coerce(val) == 'baz')\n    elif (val == 'bar9999'):\n        assert (validator_re.validate_coerce(val) == 'bar9999')\n    elif (val == 'bar'):\n        with pytest.raises(ValueError):\n            validator_re.validate_coerce(val)\n    elif (val == 'foofoo'):\n        with pytest.raises(ValueError):\n            validator_re.validate_coerce(val)", "masked_code": "@pytest.mark.parametrize('val', ['baz', 'bar9999', 'bar', 'foofoo'])\ndef test_acceptance(val, validator_re):\n    if (val == 'baz'):\n        assert (validator_re.validate_coerce(val) == '???')\n    elif (val == 'bar9999'):\n        assert (validator_re.validate_coerce(val) == 'bar9999')\n    elif (val == 'bar'):\n        with pytest.raises(ValueError):\n            validator_re.validate_coerce(val)\n    elif (val == 'foofoo'):\n        with pytest.raises(ValueError):\n            validator_re.validate_coerce(val)", "ground_truth": "'baz'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_403", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_enumerated_validator.py", "testname": "test_enumerated_validator.py", "funcname": "test_acceptance_array_ok_re", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import EnumeratedValidator", "from ...test_optional.test_utils.test_utils import np_inf"], "code": "@pytest.mark.parametrize('val', ['baz', 'bar1024', '', [], ['baz'], ('foo', 'bar001', 'baz'), np.array([], dtype='object'), np.array(['baz']), np.array(['foo', 'bar1024', 'baz'])])\ndef test_acceptance_array_ok_re(val, validator_aok_re):\n    if (isinstance(val, np.ndarray) and (val.size == 0)):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif (isinstance(val, np.ndarray) and np.array_equal(val, np.array(['baz']))):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif (isinstance(val, np.ndarray) and np.array_equal(val, np.array(['foo', 'bar1024', 'baz']))):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif (val == 'baz'):\n        assert (validator_aok_re.validate_coerce(val) == 'baz')\n    elif (val == 'bar1024'):\n        assert (validator_aok_re.validate_coerce(val) == 'bar1024')\n    elif (val == ''):\n        with pytest.raises(ValueError):\n            validator_aok_re.validate_coerce(val)\n    elif (val == []):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert (coerce_val == [])\n    elif (val == ['baz']):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert (coerce_val == ['baz'])\n    elif (val == ('foo', 'bar001', 'baz')):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert (validator_aok_re.present(coerce_val) == tuple(val))", "masked_code": "@pytest.mark.parametrize('val', ['baz', 'bar1024', '', [], ['baz'], ('foo', 'bar001', 'baz'), np.array([], dtype='object'), np.array(['baz']), np.array(['foo', 'bar1024', 'baz'])])\ndef test_acceptance_array_ok_re(val, validator_aok_re):\n    if (isinstance(val, np.ndarray) and (val.size == 0)):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif (isinstance(val, np.ndarray) and np.array_equal(val, np.array(['baz']))):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif (isinstance(val, np.ndarray) and np.array_equal(val, np.array(['foo', 'bar1024', 'baz']))):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif (val == 'baz'):\n        assert (validator_aok_re.validate_coerce(val) == '???')\n    elif (val == 'bar1024'):\n        assert (validator_aok_re.validate_coerce(val) == 'bar1024')\n    elif (val == ''):\n        with pytest.raises(ValueError):\n            validator_aok_re.validate_coerce(val)\n    elif (val == []):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert (coerce_val == [])\n    elif (val == ['baz']):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert (coerce_val == ['baz'])\n    elif (val == ('foo', 'bar001', 'baz')):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert (validator_aok_re.present(coerce_val) == tuple(val))", "ground_truth": "'baz'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_404", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_enumerated_validator.py", "testname": "test_enumerated_validator.py", "funcname": "test_acceptance_array_ok_re", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import EnumeratedValidator", "from ...test_optional.test_utils.test_utils import np_inf"], "code": "@pytest.mark.parametrize('val', ['baz', 'bar1024', '', [], ['baz'], ('foo', 'bar001', 'baz'), np.array([], dtype='object'), np.array(['baz']), np.array(['foo', 'bar1024', 'baz'])])\ndef test_acceptance_array_ok_re(val, validator_aok_re):\n    if (isinstance(val, np.ndarray) and (val.size == 0)):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif (isinstance(val, np.ndarray) and np.array_equal(val, np.array(['baz']))):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif (isinstance(val, np.ndarray) and np.array_equal(val, np.array(['foo', 'bar1024', 'baz']))):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif (val == 'baz'):\n        assert (validator_aok_re.validate_coerce(val) == 'baz')\n    elif (val == 'bar1024'):\n        assert (validator_aok_re.validate_coerce(val) == 'bar1024')\n    elif (val == ''):\n        with pytest.raises(ValueError):\n            validator_aok_re.validate_coerce(val)\n    elif (val == []):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert (coerce_val == [])\n    elif (val == ['baz']):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert (coerce_val == ['baz'])\n    elif (val == ('foo', 'bar001', 'baz')):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert (validator_aok_re.present(coerce_val) == tuple(val))", "masked_code": "@pytest.mark.parametrize('val', ['baz', 'bar1024', '', [], ['baz'], ('foo', 'bar001', 'baz'), np.array([], dtype='object'), np.array(['baz']), np.array(['foo', 'bar1024', 'baz'])])\ndef test_acceptance_array_ok_re(val, validator_aok_re):\n    if (isinstance(val, np.ndarray) and (val.size == 0)):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif (isinstance(val, np.ndarray) and np.array_equal(val, np.array(['baz']))):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif (isinstance(val, np.ndarray) and np.array_equal(val, np.array(['foo', 'bar1024', 'baz']))):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif (val == 'baz'):\n        assert (validator_aok_re.validate_coerce(val) == 'baz')\n    elif (val == 'bar1024'):\n        assert (validator_aok_re.validate_coerce(val) == '???')\n    elif (val == ''):\n        with pytest.raises(ValueError):\n            validator_aok_re.validate_coerce(val)\n    elif (val == []):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert (coerce_val == [])\n    elif (val == ['baz']):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert (coerce_val == ['baz'])\n    elif (val == ('foo', 'bar001', 'baz')):\n        coerce_val = validator_aok_re.validate_coerce(val)\n        assert (validator_aok_re.present(coerce_val) == tuple(val))", "ground_truth": "'bar1024'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_401", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_enumerated_validator.py", "testname": "test_enumerated_validator.py", "funcname": "test_acceptance_no_array", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import EnumeratedValidator", "from ...test_optional.test_utils.test_utils import np_inf"], "code": "@pytest.mark.parametrize('val', ['', 'third', (- 10000), 0.0])\ndef test_acceptance_no_array(val, validator):\n    if (val == 'third'):\n        assert (validator.validate_coerce(val) == 'third')\n    elif (val == ''):\n        with pytest.raises(ValueError):\n            validator.validate_coerce(val)\n    elif (val == (- 10000)):\n        with pytest.raises(ValueError):\n            validator.validate_coerce(val)\n    elif (val == 0.0):\n        with pytest.raises(ValueError):\n            validator.validate_coerce(val)", "masked_code": "@pytest.mark.parametrize('val', ['', 'third', (- 10000), 0.0])\ndef test_acceptance_no_array(val, validator):\n    if (val == 'third'):\n        assert (validator.validate_coerce(val) == '???')\n    elif (val == ''):\n        with pytest.raises(ValueError):\n            validator.validate_coerce(val)\n    elif (val == (- 10000)):\n        with pytest.raises(ValueError):\n            validator.validate_coerce(val)\n    elif (val == 0.0):\n        with pytest.raises(ValueError):\n            validator.validate_coerce(val)", "ground_truth": "'third'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_18", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_error_bars.py", "testname": "test_error_bars.py", "funcname": "test_key_error", "imports": ["from plotly.graph_objs import ErrorX, ErrorY"], "code": "def test_key_error():\n    assert (ErrorX(value=0, typ='', color=None, array=[(- 1), 0, 1000000.0]) == {'color': None, 'typ': '', 'value': 0, 'array': [(- 1), 0, 1000000.0]})", "masked_code": "def test_key_error():\n    assert (ErrorX(value=0, typ='', color=None, array=[(- 1), 0, 1000000.0]) == '???')", "ground_truth": "{'color': None, 'typ': '', 'value': 0, 'array': [(- 1), 0, 1000000.0]}", "quality_analysis": {"complexity_score": 20, "left_complexity": 3, "right_complexity": 17, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_406", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_fig_deepcopy.py", "testname": "test_fig_deepcopy.py", "funcname": "test_deepcopy_array", "imports": ["import copy", "import pytest", "import plotly.express as px"], "code": "@pytest.mark.filterwarnings('ignore:\\\\*scattermapbox\\\\* is deprecated! Use \\\\*scattermap\\\\* instead')\ndef test_deepcopy_array():\n    import numpy as np\n    x = np.array([0, (- 1), 99999, 3.1415, 0.0])\n    y = np.array([0.0, (- 2.5), 123456.789, (- 99999), 2.718])\n    color = np.array(['A', '', 'B', 'C', 'D'])\n    fig = px.line(x=x, y=y, color=color)\n    fig_copied = copy.deepcopy(fig)\n    assert (fig_copied.to_dict() == fig.to_dict())", "masked_code": "@pytest.mark.filterwarnings('ignore:\\\\*scattermapbox\\\\* is deprecated! Use \\\\*scattermap\\\\* instead')\ndef test_deepcopy_array():\n    import numpy as np\n    x = np.array([0, (- 1), 99999, 3.1415, 0.0])\n    y = np.array([0.0, (- 2.5), 123456.789, (- 99999), 2.718])\n    color = np.array(['A', '', 'B', 'C', 'D'])\n    fig = px.line(x=x, y=y, color=color)\n    fig_copied = copy.deepcopy(fig)\n    assert (fig_copied.to_dict() == '???')", "ground_truth": "fig.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_405", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_fig_deepcopy.py", "testname": "test_fig_deepcopy.py", "funcname": "test_deepcopy_dataframe", "imports": ["import copy", "import pytest", "import plotly.express as px"], "code": "@pytest.mark.parametrize('return_type', ['pandas', 'polars', 'pyarrow'])\n@pytest.mark.filterwarnings('ignore:\\\\*scattermapbox\\\\* is deprecated! Use \\\\*scattermap\\\\* instead')\ndef test_deepcopy_dataframe(return_type):\n    tips = px.data.tips(return_type=return_type)\n    fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n    fig_copied = copy.deepcopy(fig)\n    assert (fig_copied.to_dict() == fig.to_dict())", "masked_code": "@pytest.mark.parametrize('return_type', ['pandas', 'polars', 'pyarrow'])\n@pytest.mark.filterwarnings('ignore:\\\\*scattermapbox\\\\* is deprecated! Use \\\\*scattermap\\\\* instead')\ndef test_deepcopy_dataframe(return_type):\n    tips = px.data.tips(return_type=return_type)\n    fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n    fig_copied = copy.deepcopy(fig)\n    assert (fig_copied.to_dict() == '???')", "ground_truth": "fig.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_19", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_figure.py", "testname": "test_figure.py", "funcname": "test_set_subplots", "imports": ["import plotly.graph_objects as go", "from plotly.subplots import make_subplots", "from ...utils import TestCaseNoTemplate", "import pytest"], "code": "def test_set_subplots():\n    fig0 = go.Figure()\n    fig0_sp = make_subplots(rows=3, cols=1, horizontal_spacing=0.0, vertical_spacing=0.0)\n    fig0.set_subplots(rows=3, cols=1, horizontal_spacing=0.0, vertical_spacing=0.0)\n    assert (fig0.layout == fig0_sp.layout)\n    fig1 = go.Figure()\n    with pytest.raises(ValueError, match='Horizontal spacing cannot be greater than \\\\(1 / \\\\(cols - 1\\\\)\\\\) = 0\\\\.333333\\\\.'):\n        fig1.set_subplots(rows=1, cols=4, horizontal_spacing=1.0, vertical_spacing=0.0)\n    with pytest.raises(ValueError, match='Horizontal spacing cannot be greater than \\\\(1 / \\\\(cols - 1\\\\)\\\\) = 0\\\\.333333\\\\.'):\n        make_subplots(rows=1, cols=4, horizontal_spacing=1.0, vertical_spacing=0.0)\n    fig2 = go.Figure()\n    with pytest.raises(ValueError, match='Horizontal spacing must be between 0 and 1.'):\n        fig2.set_subplots(rows=2, cols=2, horizontal_spacing=(- 0.15), vertical_spacing=(- 0.05))\n    fig1.set_subplots(1, 2)", "masked_code": "def test_set_subplots():\n    fig0 = go.Figure()\n    fig0_sp = make_subplots(rows=3, cols=1, horizontal_spacing=0.0, vertical_spacing=0.0)\n    fig0.set_subplots(rows=3, cols=1, horizontal_spacing=0.0, vertical_spacing=0.0)\n    assert (fig0.layout == '???')\n    fig1 = go.Figure()\n    with pytest.raises(ValueError, match='Horizontal spacing cannot be greater than \\\\(1 / \\\\(cols - 1\\\\)\\\\) = 0\\\\.333333\\\\.'):\n        fig1.set_subplots(rows=1, cols=4, horizontal_spacing=1.0, vertical_spacing=0.0)\n    with pytest.raises(ValueError, match='Horizontal spacing cannot be greater than \\\\(1 / \\\\(cols - 1\\\\)\\\\) = 0\\\\.333333\\\\.'):\n        make_subplots(rows=1, cols=4, horizontal_spacing=1.0, vertical_spacing=0.0)\n    fig2 = go.Figure()\n    with pytest.raises(ValueError, match='Horizontal spacing must be between 0 and 1.'):\n        fig2.set_subplots(rows=2, cols=2, horizontal_spacing=(- 0.15), vertical_spacing=(- 0.05))\n    fig1.set_subplots(1, 2)", "ground_truth": "fig0_sp.layout", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_407", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_flaglist_validator.py", "testname": "test_flaglist_validator.py", "funcname": "test_acceptance", "imports": ["import itertools", "import pytest", "from _plotly_utils.basevalidators import FlaglistValidator", "import numpy as np"], "code": "def test_acceptance(flaglist, validator):\n    special_flaglist = 'lines+markers+text'\n    empty_flaglist = ''\n    mixed_case_flaglist = 'LINES+markers+Text'\n    numeric_flaglist = 'lines+3'\n    assert (validator.validate_coerce(special_flaglist) == special_flaglist)", "masked_code": "def test_acceptance(flaglist, validator):\n    special_flaglist = 'lines+markers+text'\n    empty_flaglist = ''\n    mixed_case_flaglist = 'LINES+markers+Text'\n    numeric_flaglist = 'lines+3'\n    assert (validator.validate_coerce(special_flaglist) == '???')", "ground_truth": "special_flaglist", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_412", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_flaglist_validator.py", "testname": "test_flaglist_validator.py", "funcname": "test_acceptance_aok_scalar_extra", "imports": ["import itertools", "import pytest", "from _plotly_utils.basevalidators import FlaglistValidator", "import numpy as np"], "code": "def test_acceptance_aok_scalar_extra(extra, validator_extra_aok):\n    new_extra = True\n    assert (validator_extra_aok.validate_coerce(new_extra) == new_extra)", "masked_code": "def test_acceptance_aok_scalar_extra(extra, validator_extra_aok):\n    new_extra = True\n    assert (validator_extra_aok.validate_coerce(new_extra) == '???')", "ground_truth": "new_extra", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_411", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_flaglist_validator.py", "testname": "test_flaglist_validator.py", "funcname": "test_acceptance_aok_scalar_flaglist", "imports": ["import itertools", "import pytest", "from _plotly_utils.basevalidators import FlaglistValidator", "import numpy as np"], "code": "def test_acceptance_aok_scalar_flaglist(flaglist, validator_extra_aok):\n    all_flags = 'markers+text+lines'\n    assert (validator_extra_aok.validate_coerce(all_flags) == all_flags)", "masked_code": "def test_acceptance_aok_scalar_flaglist(flaglist, validator_extra_aok):\n    all_flags = 'markers+text+lines'\n    assert (validator_extra_aok.validate_coerce(all_flags) == '???')", "ground_truth": "all_flags", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_409", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_flaglist_validator.py", "testname": "test_flaglist_validator.py", "funcname": "test_acceptance_extra", "imports": ["import itertools", "import pytest", "from _plotly_utils.basevalidators import FlaglistValidator", "import numpy as np"], "code": "def test_acceptance_extra(extra, validator_extra):\n    new_extra = 3\n    assert (validator_extra.validate_coerce(new_extra) == new_extra)", "masked_code": "def test_acceptance_extra(extra, validator_extra):\n    new_extra = 3\n    assert (validator_extra.validate_coerce(new_extra) == '???')", "ground_truth": "new_extra", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_408", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_flaglist_validator.py", "testname": "test_flaglist_validator.py", "funcname": "test_coercion_1", "imports": ["import itertools", "import pytest", "from _plotly_utils.basevalidators import FlaglistValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('in_val,coerce_val', [('      markers   ', 'markers'), ('markers   +   text', 'markers+text'), ('lines , markers , text', 'lines+markers+text'), ('lines ,', ValueError), ('lines,,,markers', ValueError), ('LINES + MARKERS', ValueError)])\ndef test_coercion_1(in_val, coerce_val, validator):\n    if (coerce_val == ValueError):\n        with pytest.raises(ValueError):\n            validator.validate_coerce(in_val)\n    else:\n        assert (validator.validate_coerce(in_val) == coerce_val)", "masked_code": "@pytest.mark.parametrize('in_val,coerce_val', [('      markers   ', 'markers'), ('markers   +   text', 'markers+text'), ('lines , markers , text', 'lines+markers+text'), ('lines ,', ValueError), ('lines,,,markers', ValueError), ('LINES + MARKERS', ValueError)])\ndef test_coercion_1(in_val, coerce_val, validator):\n    if (coerce_val == ValueError):\n        with pytest.raises(ValueError):\n            validator.validate_coerce(in_val)\n    else:\n        assert (validator.validate_coerce(in_val) == '???')", "ground_truth": "coerce_val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_410", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_flaglist_validator.py", "testname": "test_flaglist_validator.py", "funcname": "test_coercion_2", "imports": ["import itertools", "import pytest", "from _plotly_utils.basevalidators import FlaglistValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('in_val,coerce_val', [('true  ', ValueError), (' 3 ', ValueError), ('False', ValueError), ('none    ', 'none'), ('all  ', 'all'), ('NONE', ValueError)])\ndef test_coercion_2(in_val, coerce_val, validator_extra):\n    if (coerce_val == ValueError):\n        with pytest.raises(ValueError):\n            validator_extra.validate_coerce(in_val)\n    else:\n        assert (validator_extra.validate_coerce(in_val) == coerce_val)", "masked_code": "@pytest.mark.parametrize('in_val,coerce_val', [('true  ', ValueError), (' 3 ', ValueError), ('False', ValueError), ('none    ', 'none'), ('all  ', 'all'), ('NONE', ValueError)])\ndef test_coercion_2(in_val, coerce_val, validator_extra):\n    if (coerce_val == ValueError):\n        with pytest.raises(ValueError):\n            validator_extra.validate_coerce(in_val)\n    else:\n        assert (validator_extra.validate_coerce(in_val) == '???')", "ground_truth": "coerce_val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_55", "reponame": "plotly", "testpath": "tests/test_io/test_html.py", "testname": "test_html.py", "funcname": "test_html_deterministic", "imports": ["import pytest", "import numpy as np", "import re", "import plotly.graph_objs as go", "import plotly.io as pio", "from plotly.io._utils import plotly_cdn_url", "from plotly.offline.offline import get_plotlyjs", "from plotly.io._html import _generate_sri_hash"], "code": "def test_html_deterministic(fig1):\n    div_id = 'my-custom-div-edge-case-42'\n    assert (pio.to_html(fig1, include_plotlyjs='cdn', div_id=div_id) == pio.to_html(fig1, include_plotlyjs='cdn', div_id=div_id))", "masked_code": "def test_html_deterministic(fig1):\n    div_id = 'my-custom-div-edge-case-42'\n    assert (pio.to_html(fig1, include_plotlyjs='cdn', div_id=div_id) == '???')", "ground_truth": "pio.to_html(fig1, include_plotlyjs='cdn', div_id=div_id)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_413", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_imageuri_validator.py", "testname": "test_imageuri_validator.py", "funcname": "test_validator_acceptance", "imports": ["import base64", "import os", "import pytest", "from _plotly_utils.basevalidators import ImageUriValidator", "from PIL import Image"], "code": "@pytest.mark.parametrize('val', ['', 'https://example.org/very_large_image.jpeg', ('data:image/jpeg;base64,' + ('A' * 5000)), 'data:image/png;base64,iVBORw0KGgoAAAANSU', 'ftp://example.com/some_image.bmp', ('data:image/svg+xml;base64,' + ('B' * 100))])\ndef test_validator_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['', 'https://example.org/very_large_image.jpeg', ('data:image/jpeg;base64,' + ('A' * 5000)), 'data:image/png;base64,iVBORw0KGgoAAAANSU', 'ftp://example.com/some_image.bmp', ('data:image/svg+xml;base64,' + ('B' * 100))])\ndef test_validator_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_86", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == '???')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'jpeg'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_87", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == '???')\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "1234.0", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_88", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == '???')\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "5678.0", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_89", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == '???')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'webp'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_90", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == '???')\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "(- 1)", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_91", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == '???')\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "10", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_92", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '???')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'/abs/path/to/topo.json'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_93", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == '???')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'invalid-url'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_94", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == '???')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'png'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_95", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == '???')\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "700", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_96", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == '???')\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "500", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_97", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == '???')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'webp'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_98", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == '???')\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "(- 1)", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_99", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == '???')\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "10", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_100", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '???')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'/abs/path/to/topo.json'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_101", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == '???')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'invalid-url'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_102", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == '???')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "b'RIFF'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_103", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == '???')\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "test_fig.to_dict()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_104", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == '???')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'webp'", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_105", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == '???')\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "(- 1)", "quality_analysis": {"complexity_score": 12, "left_complexity": 9, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_106", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == '???')\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "10", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_107", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '???')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'/abs/path/to/topo.json'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_108", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == 'invalid-url')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    pio.defaults.default_format = 'jpeg'\n    pio.defaults.default_width = 1234.0\n    pio.defaults.default_height = 5678.0\n    pio.defaults.default_scale = 0\n    pio.defaults.mathjax = ''\n    pio.defaults.topojson = ''\n    pio.defaults.plotlyjs = ''\n    assert (pio.defaults.default_format == 'jpeg')\n    assert (pio.defaults.default_width == 1234.0)\n    assert (pio.defaults.default_height == 5678.0)\n    assert (pio.defaults.default_scale == 0)\n    assert (pio.defaults.mathjax == '')\n    assert (pio.defaults.topojson == '')\n    assert (pio.defaults.plotlyjs == '')\n    try:\n        pio.defaults.default_format = 'webp'\n        pio.defaults.default_width = (- 1)\n        pio.defaults.default_height = 0\n        pio.defaults.default_scale = 10\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = '/abs/path/to/topo.json'\n        pio.defaults.plotlyjs = 'invalid-url'\n        assert (pio.defaults.default_format == 'webp')\n        assert (pio.defaults.default_width == (- 1))\n        assert (pio.defaults.default_height == 0)\n        assert (pio.defaults.default_scale == 10)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson == '/abs/path/to/topo.json')\n        assert (pio.defaults.plotlyjs == 'invalid-url')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'webp')\n                assert (kwargs['opts']['width'] == (- 1))\n                assert (kwargs['opts']['height'] == 0)\n                assert (kwargs['opts']['scale'] == 10)\n                assert (kwargs['topojson'] == '/abs/path/to/topo.json')\n                assert (kwargs['kopts']['plotlyjs'] == '???')\n        else:\n            assert (pio._kaleido.scope.default_format == 'webp')\n            assert (pio._kaleido.scope.default_width == (- 1))\n            assert (pio._kaleido.scope.default_height == 0)\n            assert (pio._kaleido.scope.default_scale == 10)\n            assert (pio._kaleido.scope.mathjax is None)\n            assert (pio._kaleido.scope.topojson == '/abs/path/to/topo.json')\n            assert (pio._kaleido.scope.plotlyjs == 'invalid-url')\n        pio.defaults.topojson = None\n        try:\n            result = test_fig.to_image(format='webp', validate=False)\n            assert (result[:4] == b'RIFF')\n        except Exception:\n            pass\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'invalid-url'", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_112", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_fig_to_image", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_fig_to_image():\n    'Test that fig.to_image() calls the correct underlying Kaleido function.'\n    trace1 = dict(type='scatter', y=[(- 1.11), 0, 1.11])\n    trace2 = dict(type='bar', y=[(- 100), 0, 100])\n    test_fig = go.Figure({'data': [trace1, trace2], 'layout': {'title': {'text': ''}}})\n    test_image_bytes = (b'\\x00\\xff\\x11' * 10)\n    if (kaleido_major() > 0):\n        patch_funcname = 'plotly.io._kaleido.kaleido.calc_fig_sync'\n    else:\n        patch_funcname = 'plotly.io._kaleido.scope.transform'\n    with patch(patch_funcname, return_value=test_image_bytes) as mock_calc_fig:\n        test_fig.to_image()\n        mock_calc_fig.assert_called_once()\n        (args, _) = mock_calc_fig.call_args\n        assert (args[0] == test_fig.to_dict())", "masked_code": "def test_fig_to_image():\n    'Test that fig.to_image() calls the correct underlying Kaleido function.'\n    trace1 = dict(type='scatter', y=[(- 1.11), 0, 1.11])\n    trace2 = dict(type='bar', y=[(- 100), 0, 100])\n    test_fig = go.Figure({'data': [trace1, trace2], 'layout': {'title': {'text': ''}}})\n    test_image_bytes = (b'\\x00\\xff\\x11' * 10)\n    if (kaleido_major() > 0):\n        patch_funcname = 'plotly.io._kaleido.kaleido.calc_fig_sync'\n    else:\n        patch_funcname = 'plotly.io._kaleido.scope.transform'\n    with patch(patch_funcname, return_value=test_image_bytes) as mock_calc_fig:\n        test_fig.to_image()\n        mock_calc_fig.assert_called_once()\n        (args, _) = mock_calc_fig.call_args\n        assert (args[0] == '???')", "ground_truth": "test_fig.to_dict()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_111", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "funcname": "test_fig_write_image", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_fig_write_image():\n    'Test that fig.write_image() calls the correct underlying Kaleido function.'\n    test_fig = go.Figure(fig)\n    test_image_bytes = (b'mock image data' * 100)\n    if (kaleido_major() > 0):\n        patch_funcname = 'plotly.io._kaleido.kaleido.calc_fig_sync'\n    else:\n        patch_funcname = 'plotly.io._kaleido.scope.transform'\n    with patch(patch_funcname, return_value=test_image_bytes) as mock_calc_fig:\n        test_fig.write_image('test@#path!.png')\n        mock_calc_fig.assert_called_once()\n        (args, _) = mock_calc_fig.call_args\n        assert (args[0] == test_fig.to_dict())", "masked_code": "def test_fig_write_image():\n    'Test that fig.write_image() calls the correct underlying Kaleido function.'\n    test_fig = go.Figure(fig)\n    test_image_bytes = (b'mock image data' * 100)\n    if (kaleido_major() > 0):\n        patch_funcname = 'plotly.io._kaleido.kaleido.calc_fig_sync'\n    else:\n        patch_funcname = 'plotly.io._kaleido.scope.transform'\n    with patch(patch_funcname, return_value=test_image_bytes) as mock_calc_fig:\n        test_fig.write_image('test@#path!.png')\n        mock_calc_fig.assert_called_once()\n        (args, _) = mock_calc_fig.call_args\n        assert (args[0] == '???')", "ground_truth": "test_fig.to_dict()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_181", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_marginals.py", "testname": "test_marginals.py", "funcname": "test_single_marginals", "imports": ["import plotly.express as px", "import pytest"], "code": "@pytest.mark.parametrize('px_fn', [px.histogram, px.ecdf])\n@pytest.mark.parametrize('marginal', [None, 'rug', 'histogram', 'box', 'violin'])\n@pytest.mark.parametrize('orientation', ['h', 'v'])\ndef test_single_marginals(backend, px_fn, marginal, orientation):\n    import pandas as pd\n    df = pd.DataFrame({'total_bill': [(- 1000000.0), 0, 3.14, 2.71, None, float('inf')]})\n    fig = px_fn(df, x='total_bill', y='total_bill', marginal=marginal, orientation=orientation)\n    assert (len(fig.data) == (1 + (marginal is not None)))", "masked_code": "@pytest.mark.parametrize('px_fn', [px.histogram, px.ecdf])\n@pytest.mark.parametrize('marginal', [None, 'rug', 'histogram', 'box', 'violin'])\n@pytest.mark.parametrize('orientation', ['h', 'v'])\ndef test_single_marginals(backend, px_fn, marginal, orientation):\n    import pandas as pd\n    df = pd.DataFrame({'total_bill': [(- 1000000.0), 0, 3.14, 2.71, None, float('inf')]})\n    fig = px_fn(df, x='total_bill', y='total_bill', marginal=marginal, orientation=orientation)\n    assert (len(fig.data) == '???')", "ground_truth": "(1 + (marginal is not None))", "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_180", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_marginals.py", "testname": "test_marginals.py", "funcname": "test_xy_marginals", "imports": ["import plotly.express as px", "import pytest"], "code": "@pytest.mark.parametrize('px_fn', [px.scatter, px.density_heatmap, px.density_contour])\n@pytest.mark.parametrize('marginal_x', [None, 'histogram', 'box', 'violin'])\n@pytest.mark.parametrize('marginal_y', [None, 'rug'])\ndef test_xy_marginals(backend, px_fn, marginal_x, marginal_y):\n    import pandas as pd\n    df = pd.DataFrame({'total_bill': [0, (- 10.5), 9999999, 3.14159, float('inf'), float('-inf')], 'tip': [0, (- 2.3), 888888, 2.71828, float('nan'), 0.0]})\n    fig = px_fn(df, x='total_bill', y='tip', marginal_x=marginal_x, marginal_y=marginal_y)\n    assert (len(fig.data) == ((1 + (marginal_x is not None)) + (marginal_y is not None)))", "masked_code": "@pytest.mark.parametrize('px_fn', [px.scatter, px.density_heatmap, px.density_contour])\n@pytest.mark.parametrize('marginal_x', [None, 'histogram', 'box', 'violin'])\n@pytest.mark.parametrize('marginal_y', [None, 'rug'])\ndef test_xy_marginals(backend, px_fn, marginal_x, marginal_y):\n    import pandas as pd\n    df = pd.DataFrame({'total_bill': [0, (- 10.5), 9999999, 3.14159, float('inf'), float('-inf')], 'tip': [0, (- 2.3), 888888, 2.71828, float('nan'), 0.0]})\n    fig = px_fn(df, x='total_bill', y='tip', marginal_x=marginal_x, marginal_y=marginal_y)\n    assert (len(fig.data) == '???')", "ground_truth": "((1 + (marginal_x is not None)) + (marginal_y is not None))", "quality_analysis": {"complexity_score": 18, "left_complexity": 5, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_432", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_number_validator.py", "testname": "test_number_validator.py", "funcname": "test_acceptance", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import NumberValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [(- 0.0), (- 1e+20), 1e-10, 1234567890.123, (- 999.999), 1.5, 2.0, (- 1.0), np_nan(), np_inf(), (- np_inf())])\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == approx(val, nan_ok=True))", "masked_code": "@pytest.mark.parametrize('val', [(- 0.0), (- 1e+20), 1e-10, 1234567890.123, (- 999.999), 1.5, 2.0, (- 1.0), np_nan(), np_inf(), (- np_inf())])\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "approx(val, nan_ok=True)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_436", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_number_validator.py", "testname": "test_number_validator.py", "funcname": "test_acceptance_aok_scalars", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import NumberValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [1.5, 0.0, (- 1.0), 1, 1.4999, (- 0.9999), 0.9999, 1e-08])\ndef test_acceptance_aok_scalars(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', [1.5, 0.0, (- 1.0), 1, 1.4999, (- 0.9999), 0.9999, 1e-08])\ndef test_acceptance_aok_scalars(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_435", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_number_validator.py", "testname": "test_number_validator.py", "funcname": "test_acceptance_max", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import NumberValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [2.0, 1.999, 0, (- 1), (- 9999), (2.0 - 1e-12), (- np_inf())])\ndef test_acceptance_max(val, validator_max):\n    assert (validator_max.validate_coerce(val) == approx(val))", "masked_code": "@pytest.mark.parametrize('val', [2.0, 1.999, 0, (- 1), (- 9999), (2.0 - 1e-12), (- np_inf())])\ndef test_acceptance_max(val, validator_max):\n    assert (validator_max.validate_coerce(val) == '???')", "ground_truth": "approx(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_434", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_number_validator.py", "testname": "test_number_validator.py", "funcname": "test_acceptance_min", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import NumberValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [(- 1.0), 0, 1.0, 1000000000000000.0, 0.0001, 1.01, np_inf()])\ndef test_acceptance_min(val, validator_min):\n    assert (validator_min.validate_coerce(val) == approx(val))", "masked_code": "@pytest.mark.parametrize('val', [(- 1.0), 0, 1.0, 1000000000000000.0, 0.0001, 1.01, np_inf()])\ndef test_acceptance_min(val, validator_min):\n    assert (validator_min.validate_coerce(val) == '???')", "ground_truth": "approx(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_433", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_number_validator.py", "testname": "test_number_validator.py", "funcname": "test_acceptance_min_max", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import NumberValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [(- 1.0), 0.0, 2.0, 1.5, 1.4999999, (- 0.9999999), 1.9999999, 1e-20, (100.0 % 2)])\ndef test_acceptance_min_max(val, validator_min_max):\n    assert (validator_min_max.validate_coerce(val) == approx(val))", "masked_code": "@pytest.mark.parametrize('val', [(- 1.0), 0.0, 2.0, 1.5, 1.4999999, (- 0.9999999), 1.9999999, 1e-20, (100.0 % 2)])\ndef test_acceptance_min_max(val, validator_min_max):\n    assert (validator_min_max.validate_coerce(val) == '???')", "ground_truth": "approx(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_437", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_number_validator.py", "testname": "test_number_validator.py", "funcname": "test_coercion_aok_list", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import NumberValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val,expected', [([1.5, (- 1.0)], (1.5, (- 1.0))), (np.array([1.5, 1.0]), np.array([1.5, 1.0])), (pd.Series([0.0, 1.5]), np.array([0.0, 1.5])), (pd.Index([(- 1), 1]), np.array([(- 1), 1])), (((- 1.0), 1.5, 0.0), ((- 1.0), 1.5, 0.0))])\ndef test_coercion_aok_list(val, expected, validator_aok):\n    v = validator_aok.validate_coerce(val)\n    if isinstance(val, (np.ndarray, pd.Series, pd.Index)):\n        assert np.array_equal(v, expected)\n    else:\n        assert isinstance(v, list)\n        assert (validator_aok.present(v) == tuple(val))", "masked_code": "@pytest.mark.parametrize('val,expected', [([1.5, (- 1.0)], (1.5, (- 1.0))), (np.array([1.5, 1.0]), np.array([1.5, 1.0])), (pd.Series([0.0, 1.5]), np.array([0.0, 1.5])), (pd.Index([(- 1), 1]), np.array([(- 1), 1])), (((- 1.0), 1.5, 0.0), ((- 1.0), 1.5, 0.0))])\ndef test_coercion_aok_list(val, expected, validator_aok):\n    v = validator_aok.validate_coerce(val)\n    if isinstance(val, (np.ndarray, pd.Series, pd.Index)):\n        assert np.array_equal(v, expected)\n    else:\n        assert isinstance(v, list)\n        assert (validator_aok.present(v) == '???')", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_182", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_pandas_backend.py", "testname": "test_pandas_backend.py", "funcname": "test_pandas_equiv", "imports": ["import plotly.express as px", "import numpy as np", "import pandas as pd", "import pytest"], "code": "@pytest.mark.skipif((not hasattr(pd.options.plotting, 'backend')), reason=\"Currently installed pandas doesn't support plotting backends.\")\n@pytest.mark.parametrize('pandas_fn,px_fn', [((lambda df: df.plot()), px.line), ((lambda df: df.plot.scatter('A', 'B')), (lambda df: px.scatter(df, 'A', 'B'))), ((lambda df: df.plot.line()), px.line), ((lambda df: df.plot.area()), px.area), ((lambda df: df.plot.bar()), px.bar), ((lambda df: df.plot.barh()), (lambda df: px.bar(df, orientation='h'))), ((lambda df: df.plot.box()), px.box), ((lambda df: df.plot.hist()), px.histogram), ((lambda df: df.boxplot()), px.box), ((lambda df: df.hist()), px.histogram), ((lambda df: df['A'].hist()), (lambda df: px.histogram(df['A']))), ((lambda df: df.plot(kind='line')), px.line), ((lambda df: df.plot(kind='area')), px.area), ((lambda df: df.plot(kind='bar')), px.bar), ((lambda df: df.plot(kind='box')), px.box), ((lambda df: df.plot(kind='hist')), px.histogram), ((lambda df: df.plot(kind='histogram')), px.histogram), ((lambda df: df.plot(kind='violin')), px.violin), ((lambda df: df.plot(kind='strip')), px.strip), ((lambda df: df.plot(kind='funnel')), px.funnel), ((lambda df: df.plot(kind='density_contour')), px.density_contour), ((lambda df: df.plot(kind='density_heatmap')), px.density_heatmap), ((lambda df: df.plot(kind='imshow')), px.imshow)])\ndef test_pandas_equiv(pandas_fn, px_fn):\n    pd.options.plotting.backend = 'plotly'\n    df = pd.DataFrame({'A': np.random.uniform((- 1000), 1000, size=200), 'B': np.random.randint((- 5000), 5000, size=200), 'C': np.random.randn(200), 'D': np.linspace(0, 1, 200), 'E': (((([''] * 50) + (['foobar'] * 50)) + (['baz'] * 50)) + (['qux'] * 50))}).reset_index(drop=True)\n    df.loc[(10:15, 'A')] = np.nan\n    df.loc[(20:25, 'E')] = None\n    numeric_cols = ['A', 'B', 'C', 'D']\n    fn_name_str = getattr(px_fn, '__name__', str(px_fn))\n    px_requires_numeric_only = ['line', 'area', 'bar', 'box', 'histogram', '<lambda>', 'strip', 'violin', 'funnel', 'density_contour', 'density_heatmap']\n    if (fn_name_str in px_requires_numeric_only):\n        df_numeric = df[numeric_cols]\n        fig1 = pandas_fn(df_numeric)\n        fig2 = px_fn(df_numeric)\n        assert (fig1 == fig2)\n    elif (fn_name_str == 'imshow'):\n        fig1 = pandas_fn(df)\n        fig2 = px_fn(df)\n        assert (type(fig1) == type(fig2))\n    else:\n        fig1 = pandas_fn(df)\n        fig2 = px_fn(df)\n        assert (fig1 == fig2)", "masked_code": "@pytest.mark.skipif((not hasattr(pd.options.plotting, 'backend')), reason=\"Currently installed pandas doesn't support plotting backends.\")\n@pytest.mark.parametrize('pandas_fn,px_fn', [((lambda df: df.plot()), px.line), ((lambda df: df.plot.scatter('A', 'B')), (lambda df: px.scatter(df, 'A', 'B'))), ((lambda df: df.plot.line()), px.line), ((lambda df: df.plot.area()), px.area), ((lambda df: df.plot.bar()), px.bar), ((lambda df: df.plot.barh()), (lambda df: px.bar(df, orientation='h'))), ((lambda df: df.plot.box()), px.box), ((lambda df: df.plot.hist()), px.histogram), ((lambda df: df.boxplot()), px.box), ((lambda df: df.hist()), px.histogram), ((lambda df: df['A'].hist()), (lambda df: px.histogram(df['A']))), ((lambda df: df.plot(kind='line')), px.line), ((lambda df: df.plot(kind='area')), px.area), ((lambda df: df.plot(kind='bar')), px.bar), ((lambda df: df.plot(kind='box')), px.box), ((lambda df: df.plot(kind='hist')), px.histogram), ((lambda df: df.plot(kind='histogram')), px.histogram), ((lambda df: df.plot(kind='violin')), px.violin), ((lambda df: df.plot(kind='strip')), px.strip), ((lambda df: df.plot(kind='funnel')), px.funnel), ((lambda df: df.plot(kind='density_contour')), px.density_contour), ((lambda df: df.plot(kind='density_heatmap')), px.density_heatmap), ((lambda df: df.plot(kind='imshow')), px.imshow)])\ndef test_pandas_equiv(pandas_fn, px_fn):\n    pd.options.plotting.backend = 'plotly'\n    df = pd.DataFrame({'A': np.random.uniform((- 1000), 1000, size=200), 'B': np.random.randint((- 5000), 5000, size=200), 'C': np.random.randn(200), 'D': np.linspace(0, 1, 200), 'E': (((([''] * 50) + (['foobar'] * 50)) + (['baz'] * 50)) + (['qux'] * 50))}).reset_index(drop=True)\n    df.loc[(10:15, 'A')] = np.nan\n    df.loc[(20:25, 'E')] = None\n    numeric_cols = ['A', 'B', 'C', 'D']\n    fn_name_str = getattr(px_fn, '__name__', str(px_fn))\n    px_requires_numeric_only = ['line', 'area', 'bar', 'box', 'histogram', '<lambda>', 'strip', 'violin', 'funnel', 'density_contour', 'density_heatmap']\n    if (fn_name_str in px_requires_numeric_only):\n        df_numeric = df[numeric_cols]\n        fig1 = pandas_fn(df_numeric)\n        fig2 = px_fn(df_numeric)\n        assert (fig1 == fig2)\n    elif (fn_name_str == 'imshow'):\n        fig1 = pandas_fn(df)\n        fig2 = px_fn(df)\n        assert (type(fig1) == '???')\n    else:\n        fig1 = pandas_fn(df)\n        fig2 = px_fn(df)\n        assert (fig1 == fig2)", "ground_truth": "type(fig2)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_444", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "funcname": "test_color_validator_categorical", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_color_validator_categorical(color_validator, color_categorical_pandas):\n    res = color_validator.validate_coerce(color_categorical_pandas)\n    assert (color_categorical_pandas.dtype == 'category')\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == 'object')\n    np.testing.assert_array_equal(res, np.array(color_categorical_pandas))", "masked_code": "def test_color_validator_categorical(color_validator, color_categorical_pandas):\n    res = color_validator.validate_coerce(color_categorical_pandas)\n    assert (color_categorical_pandas.dtype == '???')\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == 'object')\n    np.testing.assert_array_equal(res, np.array(color_categorical_pandas))", "ground_truth": "'category'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_445", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "funcname": "test_color_validator_categorical", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_color_validator_categorical(color_validator, color_categorical_pandas):\n    res = color_validator.validate_coerce(color_categorical_pandas)\n    assert (color_categorical_pandas.dtype == 'category')\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == 'object')\n    np.testing.assert_array_equal(res, np.array(color_categorical_pandas))", "masked_code": "def test_color_validator_categorical(color_validator, color_categorical_pandas):\n    res = color_validator.validate_coerce(color_categorical_pandas)\n    assert (color_categorical_pandas.dtype == 'category')\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, np.array(color_categorical_pandas))", "ground_truth": "'object'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_442", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "funcname": "test_color_validator_numeric", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_color_validator_numeric(color_validator, numeric_pandas):\n    res = color_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == numeric_pandas.dtype)\n    np.testing.assert_array_equal(res, numeric_pandas)", "masked_code": "def test_color_validator_numeric(color_validator, numeric_pandas):\n    res = color_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_pandas)", "ground_truth": "numeric_pandas.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_441", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "funcname": "test_data_array_validator", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_data_array_validator(data_array_validator, numeric_pandas):\n    res = data_array_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == numeric_pandas.dtype)\n    np.testing.assert_array_equal(res, numeric_pandas)", "masked_code": "def test_data_array_validator(data_array_validator, numeric_pandas):\n    res = data_array_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_pandas)", "ground_truth": "numeric_pandas.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_447", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "funcname": "test_data_array_validator_dates_dataframe", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_data_array_validator_dates_dataframe(data_array_validator, datetime_pandas, dates_array):\n    df = pd.DataFrame({'d': datetime_pandas})\n    res = data_array_validator.validate_coerce(df)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '<M8[ns]')\n    np.testing.assert_array_equal(res, dates_array.reshape(len(dates_array), 1))", "masked_code": "def test_data_array_validator_dates_dataframe(data_array_validator, datetime_pandas, dates_array):\n    df = pd.DataFrame({'d': datetime_pandas})\n    res = data_array_validator.validate_coerce(df)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, dates_array.reshape(len(dates_array), 1))", "ground_truth": "'<M8[ns]'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_446", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "funcname": "test_data_array_validator_dates_series", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_data_array_validator_dates_series(data_array_validator, datetime_pandas, dates_array):\n    res = data_array_validator.validate_coerce(datetime_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '<M8[ns]')\n    np.testing.assert_array_equal(res, dates_array)", "masked_code": "def test_data_array_validator_dates_series(data_array_validator, datetime_pandas, dates_array):\n    res = data_array_validator.validate_coerce(datetime_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, dates_array)", "ground_truth": "'<M8[ns]'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_439", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "funcname": "test_integer_validator_numeric_pandas", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_integer_validator_numeric_pandas(integer_validator, numeric_pandas):\n    res = integer_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    if (numeric_pandas.dtype.kind in ('u', 'i')):\n        assert (res.dtype == numeric_pandas.dtype)\n    else:\n        assert (res.dtype == 'int32')\n    if (numeric_pandas.dtype.kind == 'f'):\n        expected = numeric_pandas.astype('int32')\n        np.testing.assert_array_equal(res, expected)\n    else:\n        np.testing.assert_array_equal(res, numeric_pandas)", "masked_code": "def test_integer_validator_numeric_pandas(integer_validator, numeric_pandas):\n    res = integer_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    if (numeric_pandas.dtype.kind in ('u', 'i')):\n        assert (res.dtype == '???')\n    else:\n        assert (res.dtype == 'int32')\n    if (numeric_pandas.dtype.kind == 'f'):\n        expected = numeric_pandas.astype('int32')\n        np.testing.assert_array_equal(res, expected)\n    else:\n        np.testing.assert_array_equal(res, numeric_pandas)", "ground_truth": "numeric_pandas.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_440", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "funcname": "test_integer_validator_numeric_pandas", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_integer_validator_numeric_pandas(integer_validator, numeric_pandas):\n    res = integer_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    if (numeric_pandas.dtype.kind in ('u', 'i')):\n        assert (res.dtype == numeric_pandas.dtype)\n    else:\n        assert (res.dtype == 'int32')\n    if (numeric_pandas.dtype.kind == 'f'):\n        expected = numeric_pandas.astype('int32')\n        np.testing.assert_array_equal(res, expected)\n    else:\n        np.testing.assert_array_equal(res, numeric_pandas)", "masked_code": "def test_integer_validator_numeric_pandas(integer_validator, numeric_pandas):\n    res = integer_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    if (numeric_pandas.dtype.kind in ('u', 'i')):\n        assert (res.dtype == numeric_pandas.dtype)\n    else:\n        assert (res.dtype == '???')\n    if (numeric_pandas.dtype.kind == 'f'):\n        expected = numeric_pandas.astype('int32')\n        np.testing.assert_array_equal(res, expected)\n    else:\n        np.testing.assert_array_equal(res, numeric_pandas)", "ground_truth": "'int32'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_438", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "funcname": "test_numeric_validator_numeric_pandas", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_numeric_validator_numeric_pandas(number_validator, numeric_pandas):\n    res = number_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == numeric_pandas.dtype)\n    np.testing.assert_array_equal(res, numeric_pandas)", "masked_code": "def test_numeric_validator_numeric_pandas(number_validator, numeric_pandas):\n    res = number_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_pandas)", "ground_truth": "numeric_pandas.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_56", "reponame": "plotly", "testpath": "tests/test_io/test_pathlib.py", "testname": "test_pathlib.py", "funcname": "test_write_html", "imports": ["import plotly.io as pio", "from io import StringIO", "from pathlib import Path", "import re", "from unittest.mock import Mock"], "code": "def test_write_html():\n    'Verify that various methods for producing HTML have equivalent results.\\n\\n    The results will not be identical because the div id is pseudorandom. Thus\\n    we compare the results after replacing the div id.\\n\\n    We test the results of\\n    - pio.to_html\\n    - pio.write_html with a StringIO buffer\\n    - pio.write_html with a mock pathlib Path\\n    - pio.write_html with a mock file descriptor\\n    '\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert (replace_div_id(html) == replace_div_id(sio_html))\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert (replace_div_id(html) == replace_div_id(pl_html))\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    (fd_html,) = mock_file_descriptor.write.call_args[0]\n    assert (replace_div_id(html) == replace_div_id(fd_html))", "masked_code": "def test_write_html():\n    'Verify that various methods for producing HTML have equivalent results.\\n\\n    The results will not be identical because the div id is pseudorandom. Thus\\n    we compare the results after replacing the div id.\\n\\n    We test the results of\\n    - pio.to_html\\n    - pio.write_html with a StringIO buffer\\n    - pio.write_html with a mock pathlib Path\\n    - pio.write_html with a mock file descriptor\\n    '\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert (replace_div_id(html) == '???')\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert (replace_div_id(html) == replace_div_id(pl_html))\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    (fd_html,) = mock_file_descriptor.write.call_args[0]\n    assert (replace_div_id(html) == replace_div_id(fd_html))", "ground_truth": "replace_div_id(sio_html)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_57", "reponame": "plotly", "testpath": "tests/test_io/test_pathlib.py", "testname": "test_pathlib.py", "funcname": "test_write_html", "imports": ["import plotly.io as pio", "from io import StringIO", "from pathlib import Path", "import re", "from unittest.mock import Mock"], "code": "def test_write_html():\n    'Verify that various methods for producing HTML have equivalent results.\\n\\n    The results will not be identical because the div id is pseudorandom. Thus\\n    we compare the results after replacing the div id.\\n\\n    We test the results of\\n    - pio.to_html\\n    - pio.write_html with a StringIO buffer\\n    - pio.write_html with a mock pathlib Path\\n    - pio.write_html with a mock file descriptor\\n    '\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert (replace_div_id(html) == replace_div_id(sio_html))\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert (replace_div_id(html) == replace_div_id(pl_html))\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    (fd_html,) = mock_file_descriptor.write.call_args[0]\n    assert (replace_div_id(html) == replace_div_id(fd_html))", "masked_code": "def test_write_html():\n    'Verify that various methods for producing HTML have equivalent results.\\n\\n    The results will not be identical because the div id is pseudorandom. Thus\\n    we compare the results after replacing the div id.\\n\\n    We test the results of\\n    - pio.to_html\\n    - pio.write_html with a StringIO buffer\\n    - pio.write_html with a mock pathlib Path\\n    - pio.write_html with a mock file descriptor\\n    '\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert (replace_div_id(html) == replace_div_id(sio_html))\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert (replace_div_id(html) == '???')\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    (fd_html,) = mock_file_descriptor.write.call_args[0]\n    assert (replace_div_id(html) == replace_div_id(fd_html))", "ground_truth": "replace_div_id(pl_html)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_58", "reponame": "plotly", "testpath": "tests/test_io/test_pathlib.py", "testname": "test_pathlib.py", "funcname": "test_write_html", "imports": ["import plotly.io as pio", "from io import StringIO", "from pathlib import Path", "import re", "from unittest.mock import Mock"], "code": "def test_write_html():\n    'Verify that various methods for producing HTML have equivalent results.\\n\\n    The results will not be identical because the div id is pseudorandom. Thus\\n    we compare the results after replacing the div id.\\n\\n    We test the results of\\n    - pio.to_html\\n    - pio.write_html with a StringIO buffer\\n    - pio.write_html with a mock pathlib Path\\n    - pio.write_html with a mock file descriptor\\n    '\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert (replace_div_id(html) == replace_div_id(sio_html))\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert (replace_div_id(html) == replace_div_id(pl_html))\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    (fd_html,) = mock_file_descriptor.write.call_args[0]\n    assert (replace_div_id(html) == replace_div_id(fd_html))", "masked_code": "def test_write_html():\n    'Verify that various methods for producing HTML have equivalent results.\\n\\n    The results will not be identical because the div id is pseudorandom. Thus\\n    we compare the results after replacing the div id.\\n\\n    We test the results of\\n    - pio.to_html\\n    - pio.write_html with a StringIO buffer\\n    - pio.write_html with a mock pathlib Path\\n    - pio.write_html with a mock file descriptor\\n    '\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert (replace_div_id(html) == replace_div_id(sio_html))\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert (replace_div_id(html) == replace_div_id(pl_html))\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    (fd_html,) = mock_file_descriptor.write.call_args[0]\n    assert (replace_div_id(html) == '???')", "ground_truth": "replace_div_id(fd_html)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_23", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "funcname": "test_nested_attr", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_attr(self):\n    assert (self.scatter.marker.colorbar.title.font.family is None)\n    self.scatter.marker.colorbar.title.font.family = 'Arial'\n    assert (self.scatter.marker.colorbar.title.font.family == 'Arial')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "masked_code": "def test_nested_attr(self):\n    assert (self.scatter.marker.colorbar.title.font.family is None)\n    self.scatter.marker.colorbar.title.font.family = 'Arial'\n    assert (self.scatter.marker.colorbar.title.font.family == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "ground_truth": "'Arial'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestAssignmentPrimitive"}
{"task_id": "plotly_24", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "funcname": "test_nested_item", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_item(self):\n    assert (self.scatter['marker']['colorbar']['title']['font']['family'] is None)\n    self.scatter['marker']['colorbar']['title']['font']['family'] = 'Arial'\n    assert (self.scatter['marker']['colorbar']['title']['font']['family'] == 'Arial')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "masked_code": "def test_nested_item(self):\n    assert (self.scatter['marker']['colorbar']['title']['font']['family'] is None)\n    self.scatter['marker']['colorbar']['title']['font']['family'] = 'Arial'\n    assert (self.scatter['marker']['colorbar']['title']['font']['family'] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "ground_truth": "'Arial'", "quality_analysis": {"complexity_score": 23, "left_complexity": 22, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestAssignmentPrimitive"}
{"task_id": "plotly_25", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "funcname": "test_nested_item_dots", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_item_dots(self):\n    assert (self.scatter['marker.colorbar.title.font.family'] is None)\n    self.scatter['marker.colorbar.title.font.family'] = 'Arial'\n    assert (self.scatter['marker.colorbar.title.font.family'] == 'Arial')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "masked_code": "def test_nested_item_dots(self):\n    assert (self.scatter['marker.colorbar.title.font.family'] is None)\n    self.scatter['marker.colorbar.title.font.family'] = 'Arial'\n    assert (self.scatter['marker.colorbar.title.font.family'] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "ground_truth": "'Arial'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestAssignmentPrimitive"}
{"task_id": "plotly_26", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "funcname": "test_nested_item_tuple", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_item_tuple(self):\n    assert (self.scatter['marker.colorbar.title.font.family'] is None)\n    self.scatter[('marker', 'colorbar', 'title.font', 'family')] = 'Arial'\n    assert (self.scatter[('marker', 'colorbar', 'title.font', 'family')] == 'Arial')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "masked_code": "def test_nested_item_tuple(self):\n    assert (self.scatter['marker.colorbar.title.font.family'] is None)\n    self.scatter[('marker', 'colorbar', 'title.font', 'family')] = 'Arial'\n    assert (self.scatter[('marker', 'colorbar', 'title.font', 'family')] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "ground_truth": "'Arial'", "quality_analysis": {"complexity_score": 12, "left_complexity": 11, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestAssignmentPrimitive"}
{"task_id": "plotly_27", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "funcname": "test_nested_update", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_update(self):\n    self.scatter.update(marker={'colorbar': {'title': {'font': {'family': 'Arial'}}}})\n    assert (self.scatter[('marker', 'colorbar', 'title', 'font', 'family')] == 'Arial')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "masked_code": "def test_nested_update(self):\n    self.scatter.update(marker={'colorbar': {'title': {'font': {'family': 'Arial'}}}})\n    assert (self.scatter[('marker', 'colorbar', 'title', 'font', 'family')] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "ground_truth": "'Arial'", "quality_analysis": {"complexity_score": 13, "left_complexity": 12, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestAssignmentPrimitive"}
{"task_id": "plotly_28", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "funcname": "test_nested_update_dots", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_update_dots(self):\n    assert (self.scatter['marker.colorbar.title.font.family'] is None)\n    self.scatter.update({'marker.colorbar.title.font.family': 'Arial'})\n    assert (self.scatter['marker.colorbar.title.font.family'] == 'Arial')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "masked_code": "def test_nested_update_dots(self):\n    assert (self.scatter['marker.colorbar.title.font.family'] is None)\n    self.scatter.update({'marker.colorbar.title.font.family': 'Arial'})\n    assert (self.scatter['marker.colorbar.title.font.family'] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "ground_truth": "'Arial'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestAssignmentPrimitive"}
{"task_id": "plotly_29", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "funcname": "test_nested_update_underscores", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_update_underscores(self):\n    assert (self.scatter['error_x.type'] is None)\n    self.scatter.update({'error_x_type': 'percent'})\n    assert (self.scatter['error_x_type'] == 'percent')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested_error_x)\n    assert (d1 == d2)", "masked_code": "def test_nested_update_underscores(self):\n    assert (self.scatter['error_x.type'] is None)\n    self.scatter.update({'error_x_type': 'percent'})\n    assert (self.scatter['error_x_type'] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested_error_x)\n    assert (d1 == d2)", "ground_truth": "'percent'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestAssignmentPrimitive"}
{"task_id": "plotly_21", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "funcname": "test_toplevel_attr", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_toplevel_attr(self):\n    assert (self.scatter.fillcolor is None)\n    self.scatter.fillcolor = '#FF0000'\n    assert (self.scatter.fillcolor == '#FF0000')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_toplevel)\n    assert (d1 == d2)", "masked_code": "def test_toplevel_attr(self):\n    assert (self.scatter.fillcolor is None)\n    self.scatter.fillcolor = '#FF0000'\n    assert (self.scatter.fillcolor == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_toplevel)\n    assert (d1 == d2)", "ground_truth": "'#FF0000'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestAssignmentPrimitive"}
{"task_id": "plotly_22", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "funcname": "test_toplevel_item", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_toplevel_item(self):\n    assert (self.scatter['fillcolor'] is None)\n    self.scatter['fillcolor'] = '#FF0000'\n    assert (self.scatter['fillcolor'] == '#FF0000')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_toplevel)\n    assert (d1 == d2)", "masked_code": "def test_toplevel_item(self):\n    assert (self.scatter['fillcolor'] is None)\n    self.scatter['fillcolor'] = '#FF0000'\n    assert (self.scatter['fillcolor'] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_toplevel)\n    assert (d1 == d2)", "ground_truth": "'#FF0000'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestAssignmentPrimitive"}
{"task_id": "plotly_35", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_row_col_subplot_addressing.py", "testname": "test_row_col_subplot_addressing.py", "funcname": "test_get_subplot_coordinates", "imports": ["import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from plotly.basedatatypes import _indexing_combinations", "import pytest", "from itertools import product"], "code": "def test_get_subplot_coordinates(subplot_fig_fixture):\n    large_nrows = 6\n    large_ncols = 7\n    fig = make_subplots(large_nrows, large_ncols)\n    coords = fig._get_subplot_coordinates()\n    coords = fig._get_subplot_coordinates()\n    coords_set = set(coords)\n    expected_coords = set(((r, c) for r in range(1, (large_nrows + 1)) for c in range(1, (large_ncols + 1))))\n    assert (coords_set == expected_coords)\n    assert ((1, 1) in coords_set)\n    assert ((large_nrows, large_ncols) in coords_set)\n    assert (len(coords_set) == (large_nrows * large_ncols))", "masked_code": "def test_get_subplot_coordinates(subplot_fig_fixture):\n    large_nrows = 6\n    large_ncols = 7\n    fig = make_subplots(large_nrows, large_ncols)\n    coords = fig._get_subplot_coordinates()\n    coords = fig._get_subplot_coordinates()\n    coords_set = set(coords)\n    expected_coords = set(((r, c) for r in range(1, (large_nrows + 1)) for c in range(1, (large_ncols + 1))))\n    assert (coords_set == expected_coords)\n    assert ((1, 1) in coords_set)\n    assert ((large_nrows, large_ncols) in coords_set)\n    assert (len(coords_set) == '???')", "ground_truth": "(large_nrows * large_ncols)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_36", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_row_col_subplot_addressing.py", "testname": "test_row_col_subplot_addressing.py", "funcname": "test_indexing_combinations_edge_cases", "imports": ["import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from plotly.basedatatypes import _indexing_combinations", "import pytest", "from itertools import product"], "code": "def test_indexing_combinations_edge_cases():\n    assert isinstance(_indexing_combinations([[]], [[1]]), zip)\n    with pytest.raises(ValueError):\n        _ = _indexing_combinations([[1.5, (- 2)], [0, 2.5]], [[1.5, (- 2)]])\n    result = _indexing_combinations([[(- 1), (- 1), 2], [3.3, 4.4]], [[(- 1), (- 1), 2], [3.3, 4.4]])\n    assert isinstance(result, zip)\n    assert (list(result) == [((- 1), 3.3), ((- 1), 4.4)])\n    res_empty = _indexing_combinations([[]], [[1]])\n    assert (list(res_empty) == [])\n    res = _indexing_combinations([[(- 3), (- 2)], [0]], [[(- 3), (- 2)], [0]])\n    assert (list(res) == [((- 3), 0)])", "masked_code": "def test_indexing_combinations_edge_cases():\n    assert isinstance(_indexing_combinations([[]], [[1]]), zip)\n    with pytest.raises(ValueError):\n        _ = _indexing_combinations([[1.5, (- 2)], [0, 2.5]], [[1.5, (- 2)]])\n    result = _indexing_combinations([[(- 1), (- 1), 2], [3.3, 4.4]], [[(- 1), (- 1), 2], [3.3, 4.4]])\n    assert isinstance(result, zip)\n    assert (list(result) == '???')\n    res_empty = _indexing_combinations([[]], [[1]])\n    assert (list(res_empty) == [])\n    res = _indexing_combinations([[(- 3), (- 2)], [0]], [[(- 3), (- 2)], [0]])\n    assert (list(res) == [((- 3), 0)])", "ground_truth": "[((- 1), 3.3), ((- 1), 4.4)]", "quality_analysis": {"complexity_score": 18, "left_complexity": 4, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_30", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_scatter.py", "testname": "test_scatter.py", "funcname": "test_trivial", "imports": ["from plotly.graph_objs import Scatter"], "code": "def test_trivial():\n    x_data = [0, (- 100), 1000000000000.0, 2.5, (- 3.1)]\n    y_data = [0.0, (- 50), 1000000000.0, 4, (- 7)]\n    s = Scatter(x=x_data, y=y_data, name='', visible=False, text='')\n    print(s)\n    assert (s.to_plotly_json() == {'type': 'scatter', 'x': x_data, 'y': y_data, 'name': '', 'visible': False, 'text': ''})", "masked_code": "def test_trivial():\n    x_data = [0, (- 100), 1000000000000.0, 2.5, (- 3.1)]\n    y_data = [0.0, (- 50), 1000000000.0, 4, (- 7)]\n    s = Scatter(x=x_data, y=y_data, name='', visible=False, text='')\n    print(s)\n    assert (s.to_plotly_json() == '???')", "ground_truth": "{'type': 'scatter', 'x': x_data, 'y': y_data, 'name': '', 'visible': False, 'text': ''}", "quality_analysis": {"complexity_score": 18, "left_complexity": 3, "right_complexity": 15, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_82", "reponame": "plotly", "testpath": "tests/test_optional/test_graph_objs/test_skipped_b64_keys.py", "testname": "test_skipped_b64_keys.py", "funcname": "test_np_geojson", "imports": ["import json", "from unittest import TestCase", "import numpy as np", "from ...test_optional.optional_utils import NumpyTestUtilsMixin", "import plotly.graph_objs as go"], "code": "def test_np_geojson(self):\n    normal_coordinates = [[[0, 0], [(- 120.5), 85.354], [1000000.0, (- 1000000.0)], [42, (- 42)], []]]\n    numpy_coordinates = np.array(normal_coordinates, dtype=object)\n    data = [{'type': 'choropleth', 'locations': ['XX'], 'featureidkey': 'properties.id', 'z': np.array([(- 5.5), 0, 999999999]), 'geojson': {'type': 'Feature', 'properties': {'id': 'XX'}, 'geometry': {'type': 'Polygon', 'coordinates': numpy_coordinates}}}]\n    fig = go.Figure(data=data)\n    assert (json.loads(fig.to_json())['data'][0]['geojson']['geometry']['coordinates'] == normal_coordinates)", "masked_code": "def test_np_geojson(self):\n    normal_coordinates = [[[0, 0], [(- 120.5), 85.354], [1000000.0, (- 1000000.0)], [42, (- 42)], []]]\n    numpy_coordinates = np.array(normal_coordinates, dtype=object)\n    data = [{'type': 'choropleth', 'locations': ['XX'], 'featureidkey': 'properties.id', 'z': np.array([(- 5.5), 0, 999999999]), 'geojson': {'type': 'Feature', 'properties': {'id': 'XX'}, 'geometry': {'type': 'Polygon', 'coordinates': numpy_coordinates}}}]\n    fig = go.Figure(data=data)\n    assert (json.loads(fig.to_json())['data'][0]['geojson']['geometry']['coordinates'] == '???')", "ground_truth": "normal_coordinates", "quality_analysis": {"complexity_score": 27, "left_complexity": 26, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestShouldNotUseBase64InUnsupportedKeys"}
{"task_id": "plotly_83", "reponame": "plotly", "testpath": "tests/test_optional/test_graph_objs/test_skipped_b64_keys.py", "testname": "test_skipped_b64_keys.py", "funcname": "test_np_layers", "imports": ["import json", "from unittest import TestCase", "import numpy as np", "from ...test_optional.optional_utils import NumpyTestUtilsMixin", "import plotly.graph_objs as go"], "code": "def test_np_layers(self):\n    layout = {'mapbox': {'layers': [{'sourcetype': 'geojson', 'type': 'line', 'line': {'dash': np.array([(- 3.75), 0.0, 1000000])}, 'source': {'type': 'FeatureCollection', 'features': [{'type': 'Feature', 'geometry': {'type': 'LineString', 'coordinates': np.array([[(- 180), 90.0], [180, (- 90.0)], [0, 0]])}}]}}], 'center': {'lon': 180, 'lat': (- 90)}}}\n    data = [{'type': 'scattermap'}]\n    fig = go.Figure(data=data, layout=layout)\n    assert (fig.layout['mapbox']['layers'][0]['line']['dash'] == ((- 3.75), 0.0, 1000000)).all()\n    assert (json.loads(fig.to_json())['layout']['mapbox']['layers'][0]['source']['features'][0]['geometry']['coordinates'] == [[(- 180), 90.0], [180, (- 90.0)], [0, 0]])", "masked_code": "def test_np_layers(self):\n    layout = {'mapbox': {'layers': [{'sourcetype': 'geojson', 'type': 'line', 'line': {'dash': np.array([(- 3.75), 0.0, 1000000])}, 'source': {'type': 'FeatureCollection', 'features': [{'type': 'Feature', 'geometry': {'type': 'LineString', 'coordinates': np.array([[(- 180), 90.0], [180, (- 90.0)], [0, 0]])}}]}}], 'center': {'lon': 180, 'lat': (- 90)}}}\n    data = [{'type': 'scattermap'}]\n    fig = go.Figure(data=data, layout=layout)\n    assert (fig.layout['mapbox']['layers'][0]['line']['dash'] == ((- 3.75), 0.0, 1000000)).all()\n    assert (json.loads(fig.to_json())['layout']['mapbox']['layers'][0]['source']['features'][0]['geometry']['coordinates'] == '???')", "ground_truth": "[[(- 180), 90.0], [180, (- 90.0)], [0, 0]]", "quality_analysis": {"complexity_score": 60, "left_complexity": 42, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestShouldNotUseBase64InUnsupportedKeys"}
{"task_id": "plotly_84", "reponame": "plotly", "testpath": "tests/test_optional/test_graph_objs/test_skipped_b64_keys.py", "testname": "test_skipped_b64_keys.py", "funcname": "test_np_range", "imports": ["import json", "from unittest import TestCase", "import numpy as np", "from ...test_optional.optional_utils import NumpyTestUtilsMixin", "import plotly.graph_objs as go"], "code": "def test_np_range(self):\n    layout = {'xaxis': {'range': np.array([(- 1000.5), 1000])}}\n    fig = go.Figure(data=[{'type': 'scatter'}], layout=layout)\n    assert (json.loads(fig.to_json())['layout']['xaxis']['range'] == [(- 1000.5), 1000])", "masked_code": "def test_np_range(self):\n    layout = {'xaxis': {'range': np.array([(- 1000.5), 1000])}}\n    fig = go.Figure(data=[{'type': 'scatter'}], layout=layout)\n    assert (json.loads(fig.to_json())['layout']['xaxis']['range'] == '???')", "ground_truth": "[(- 1000.5), 1000]", "quality_analysis": {"complexity_score": 24, "left_complexity": 18, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestShouldNotUseBase64InUnsupportedKeys"}
{"task_id": "plotly_448", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', ['abc123', (- 42), 0, ('LARGE_STRING_' * 100), '', ' ', None, 15000000000.0, '\\xa0', '\\n', '\\t'])\ndef test_acceptance(val, validator):\n    expected = (val if (val is None) else (str(val) if (not isinstance(val, str)) else val))\n    assert (validator.validate_coerce(val) == expected)", "masked_code": "@pytest.mark.parametrize('val', ['abc123', (- 42), 0, ('LARGE_STRING_' * 100), '', ' ', None, 15000000000.0, '\\xa0', '\\n', '\\t'])\ndef test_acceptance(val, validator):\n    expected = (val if (val is None) else (str(val) if (not isinstance(val, str)) else val))\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_453", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "funcname": "test_acceptance_aok_list", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', [['foo', 'BAR', 'baz', 'extra', '123'], np.array(['test', 'value', '', '0', 'abc'], dtype='object'), ['non-empty', ('LARGE_STRING_' * 10)], ['foo', None, 'bar', '\\xa0', ''], ['BAR', '', 'baz', 'foo']])\ndef test_acceptance_aok_list(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif isinstance(val, list):\n        assert (validator_aok.present(val) == tuple(val))\n    else:\n        assert (coerce_val == val)", "masked_code": "@pytest.mark.parametrize('val', [['foo', 'BAR', 'baz', 'extra', '123'], np.array(['test', 'value', '', '0', 'abc'], dtype='object'), ['non-empty', ('LARGE_STRING_' * 10)], ['foo', None, 'bar', '\\xa0', ''], ['BAR', '', 'baz', 'foo']])\ndef test_acceptance_aok_list(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif isinstance(val, list):\n        assert (validator_aok.present(val) == '???')\n    else:\n        assert (coerce_val == val)", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_452", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "funcname": "test_acceptance_aok_scalars", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', ['foo', 'BAR', '', 'baz', '', ('LARGE_STRING_' * 50)])\ndef test_acceptance_aok_scalars(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['foo', 'BAR', '', 'baz', '', ('LARGE_STRING_' * 50)])\ndef test_acceptance_aok_scalars(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_450", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "funcname": "test_acceptance_no_blanks", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', ['foo', '   ', '\\xa0', '0', 'non-empty'])\ndef test_acceptance_no_blanks(val, validator_no_blanks):\n    assert (validator_no_blanks.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['foo', '   ', '\\xa0', '0', 'non-empty'])\ndef test_acceptance_no_blanks(val, validator_no_blanks):\n    assert (validator_no_blanks.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_454", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "funcname": "test_acceptance_no_blanks_aok", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', ['not_blank', ['non-empty', 'space'], np.array(['symbol', 'name', ''], dtype='object'), ['foo', 'bar', 'baz', 'qux']])\ndef test_acceptance_no_blanks_aok(val, validator_no_blanks_aok):\n    coerce_val = validator_no_blanks_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif isinstance(val, list):\n        assert (validator_no_blanks_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)", "masked_code": "@pytest.mark.parametrize('val', ['not_blank', ['non-empty', 'space'], np.array(['symbol', 'name', ''], dtype='object'), ['foo', 'bar', 'baz', 'qux']])\ndef test_acceptance_no_blanks_aok(val, validator_no_blanks_aok):\n    coerce_val = validator_no_blanks_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif isinstance(val, list):\n        assert (validator_no_blanks_aok.present(coerce_val) == '???')\n    else:\n        assert (coerce_val == val)", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_451", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "funcname": "test_acceptance_strict", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', ['foo', '   ', '0', 'non-empty', '\\xa0'])\ndef test_acceptance_strict(val, validator_strict):\n    assert (validator_strict.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['foo', '   ', '0', 'non-empty', '\\xa0'])\ndef test_acceptance_strict(val, validator_strict):\n    assert (validator_strict.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_449", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "funcname": "test_acceptance_values", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', ['BAR', '', 'foo'])\ndef test_acceptance_values(val, validator_values):\n    assert (validator_values.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['BAR', '', 'foo'])\ndef test_acceptance_values(val, validator_values):\n    assert (validator_values.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_455", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_subplotid_validator.py", "testname": "test_subplotid_validator.py", "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import SubplotidValidator", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', ['geo', 'geo2', 'geo3', 'geo10', 'geo99999', 'geo1234567890', 'geo7', 'geo345'])\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['geo', 'geo2', 'geo3', 'geo10', 'geo99999', 'geo1234567890', 'geo7', 'geo345'])\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_38", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "funcname": "test_exclude_empty_subplots", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_exclude_empty_subplots():\n    for (k, fun, d, fun2, d2) in [('shapes', go.Figure.add_shape, dict(type='circle', x0=(- 1000000.0), x1=1000000.0, y0=(- 1000000000.0), y1=1000000000.0), go.Figure.add_annotation, dict(x=0, y=0, text='')), ('annotations', go.Figure.add_annotation, dict(x=(- 99999), y=0.0, text='Edge'), go.Figure.add_layout_image, dict(x=3.3, y=4.4, sizex=0, sizey=(- 1), source=None)), ('images', go.Figure.add_layout_image, dict(x=100000.0, y=100000.0, sizex=10000000000.0, sizey=1e-05, source='edgecase'), go.Figure.add_shape, dict(type='circle', x0=0, x1=0, y0=0, y1=0))]:\n        fig = make_subplots(2, 2)\n        fig.add_trace(go.Scatter(x=[0, (- 1), 10000000000.0], y=[0, (- 5), 10000000000.0]), row=1, col=1)\n        fig.add_trace(go.Scatter(x=[], y=[]), row=2, col=2)\n        fun2(fig, d2, row=1, col=2)\n        fun(fig, d, row='all', col='all', exclude_empty_subplots='edge_truthy_case')\n        assert (len(fig.layout[k]) == 3)\n        assert ((fig.layout[k][0]['xref'] == 'x') and (fig.layout[k][0]['yref'] == 'y'))\n        assert ((fig.layout[k][1]['xref'] == 'x2') and (fig.layout[k][1]['yref'] == 'y2'))\n        assert ((fig.layout[k][2]['xref'] == 'x4') and (fig.layout[k][2]['yref'] == 'y4'))", "masked_code": "def test_exclude_empty_subplots():\n    for (k, fun, d, fun2, d2) in [('shapes', go.Figure.add_shape, dict(type='circle', x0=(- 1000000.0), x1=1000000.0, y0=(- 1000000000.0), y1=1000000000.0), go.Figure.add_annotation, dict(x=0, y=0, text='')), ('annotations', go.Figure.add_annotation, dict(x=(- 99999), y=0.0, text='Edge'), go.Figure.add_layout_image, dict(x=3.3, y=4.4, sizex=0, sizey=(- 1), source=None)), ('images', go.Figure.add_layout_image, dict(x=100000.0, y=100000.0, sizex=10000000000.0, sizey=1e-05, source='edgecase'), go.Figure.add_shape, dict(type='circle', x0=0, x1=0, y0=0, y1=0))]:\n        fig = make_subplots(2, 2)\n        fig.add_trace(go.Scatter(x=[0, (- 1), 10000000000.0], y=[0, (- 5), 10000000000.0]), row=1, col=1)\n        fig.add_trace(go.Scatter(x=[], y=[]), row=2, col=2)\n        fun2(fig, d2, row=1, col=2)\n        fun(fig, d, row='all', col='all', exclude_empty_subplots='edge_truthy_case')\n        assert (len(fig.layout[k]) == '???')\n        assert ((fig.layout[k][0]['xref'] == 'x') and (fig.layout[k][0]['yref'] == 'y'))\n        assert ((fig.layout[k][1]['xref'] == 'x2') and (fig.layout[k][1]['yref'] == 'y2'))\n        assert ((fig.layout[k][2]['xref'] == 'x4') and (fig.layout[k][2]['yref'] == 'y4'))", "ground_truth": "3", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_39", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "funcname": "test_no_exclude_empty_subplots", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_no_exclude_empty_subplots():\n    for (k, fun, d, fun2, d2) in [('shapes', go.Figure.add_shape, dict(type='circle', x0=(- 1000000.0), x1=1000000.0, y0=(- 1000000000.0), y1=1000000000.0), go.Figure.add_annotation, dict(x=0, y=0, text='')), ('annotations', go.Figure.add_annotation, dict(x=(- 99999), y=0.0, text='Edge'), go.Figure.add_layout_image, dict(x=3.3, y=4.4, sizex=0, sizey=(- 1), source=None)), ('images', go.Figure.add_layout_image, dict(x=100000.0, y=100000.0, sizex=10000000000.0, sizey=1e-05, source='edgecase'), go.Figure.add_shape, dict(type='circle', x0=0, x1=0, y0=0, y1=0))]:\n        fig = make_subplots(2, 2)\n        fig.add_trace(go.Scatter(x=[0, (- 1), 10000000000.0], y=[0, (- 5), 10000000000.0]), row=1, col=1)\n        fig.add_trace(go.Scatter(x=[], y=[]), row=2, col=2)\n        fun2(fig, d2, row=1, col=2)\n        fun(fig, d, row='all', col='all', exclude_empty_subplots=None)\n        assert (len(fig.layout[k]) == 4)\n        assert ((fig.layout[k][0]['xref'] == 'x') and (fig.layout[k][0]['yref'] == 'y'))\n        assert ((fig.layout[k][1]['xref'] == 'x2') and (fig.layout[k][1]['yref'] == 'y2'))\n        assert ((fig.layout[k][2]['xref'] == 'x3') and (fig.layout[k][2]['yref'] == 'y3'))\n        assert ((fig.layout[k][3]['xref'] == 'x4') and (fig.layout[k][3]['yref'] == 'y4'))", "masked_code": "def test_no_exclude_empty_subplots():\n    for (k, fun, d, fun2, d2) in [('shapes', go.Figure.add_shape, dict(type='circle', x0=(- 1000000.0), x1=1000000.0, y0=(- 1000000000.0), y1=1000000000.0), go.Figure.add_annotation, dict(x=0, y=0, text='')), ('annotations', go.Figure.add_annotation, dict(x=(- 99999), y=0.0, text='Edge'), go.Figure.add_layout_image, dict(x=3.3, y=4.4, sizex=0, sizey=(- 1), source=None)), ('images', go.Figure.add_layout_image, dict(x=100000.0, y=100000.0, sizex=10000000000.0, sizey=1e-05, source='edgecase'), go.Figure.add_shape, dict(type='circle', x0=0, x1=0, y0=0, y1=0))]:\n        fig = make_subplots(2, 2)\n        fig.add_trace(go.Scatter(x=[0, (- 1), 10000000000.0], y=[0, (- 5), 10000000000.0]), row=1, col=1)\n        fig.add_trace(go.Scatter(x=[], y=[]), row=2, col=2)\n        fun2(fig, d2, row=1, col=2)\n        fun(fig, d, row='all', col='all', exclude_empty_subplots=None)\n        assert (len(fig.layout[k]) == '???')\n        assert ((fig.layout[k][0]['xref'] == 'x') and (fig.layout[k][0]['yref'] == 'y'))\n        assert ((fig.layout[k][1]['xref'] == 'x2') and (fig.layout[k][1]['yref'] == 'y2'))\n        assert ((fig.layout[k][2]['xref'] == 'x3') and (fig.layout[k][2]['yref'] == 'y3'))\n        assert ((fig.layout[k][3]['xref'] == 'x4') and (fig.layout[k][3]['yref'] == 'y4'))", "ground_truth": "4", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_42", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "funcname": "test_supplied_yref_on_multi_plot_subplot", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots with edge specs'\n    fig = make_subplots(rows=2, cols=2, shared_yaxes=True, specs=[[{'secondary_y': True}, {'secondary_y': True}], [None, {'type': 'polar'}]])\n    fig.add_trace(go.Scatter(x=[(- 1000000.0), 0, 1000000.0], y=[0, 0, 0]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[0, 0, 0], y=[(- 99999), 0, 99999], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[None, 1, None], y=[(- 1), 0, 1]), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[100.0, (- 100.0)], y=[1e-09, (- 1e-09)], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=(- 10), row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1e-05, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "masked_code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots with edge specs'\n    fig = make_subplots(rows=2, cols=2, shared_yaxes=True, specs=[[{'secondary_y': True}, {'secondary_y': True}], [None, {'type': 'polar'}]])\n    fig.add_trace(go.Scatter(x=[(- 1000000.0), 0, 1000000.0], y=[0, 0, 0]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[0, 0, 0], y=[(- 99999), 0, 99999], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[None, 1, None], y=[(- 1), 0, 1]), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[100.0, (- 100.0)], y=[1e-09, (- 1e-09)], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=(- 10), row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1e-05, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == '???')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "ground_truth": "'y2'", "quality_analysis": {"complexity_score": 15, "left_complexity": 14, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_43", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "funcname": "test_supplied_yref_on_multi_plot_subplot", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots with edge specs'\n    fig = make_subplots(rows=2, cols=2, shared_yaxes=True, specs=[[{'secondary_y': True}, {'secondary_y': True}], [None, {'type': 'polar'}]])\n    fig.add_trace(go.Scatter(x=[(- 1000000.0), 0, 1000000.0], y=[0, 0, 0]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[0, 0, 0], y=[(- 99999), 0, 99999], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[None, 1, None], y=[(- 1), 0, 1]), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[100.0, (- 100.0)], y=[1e-09, (- 1e-09)], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=(- 10), row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1e-05, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "masked_code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots with edge specs'\n    fig = make_subplots(rows=2, cols=2, shared_yaxes=True, specs=[[{'secondary_y': True}, {'secondary_y': True}], [None, {'type': 'polar'}]])\n    fig.add_trace(go.Scatter(x=[(- 1000000.0), 0, 1000000.0], y=[0, 0, 0]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[0, 0, 0], y=[(- 99999), 0, 99999], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[None, 1, None], y=[(- 1), 0, 1]), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[100.0, (- 100.0)], y=[1e-09, (- 1e-09)], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=(- 10), row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1e-05, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == '???')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "ground_truth": "'x domain'", "quality_analysis": {"complexity_score": 15, "left_complexity": 14, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_44", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "funcname": "test_supplied_yref_on_multi_plot_subplot", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots with edge specs'\n    fig = make_subplots(rows=2, cols=2, shared_yaxes=True, specs=[[{'secondary_y': True}, {'secondary_y': True}], [None, {'type': 'polar'}]])\n    fig.add_trace(go.Scatter(x=[(- 1000000.0), 0, 1000000.0], y=[0, 0, 0]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[0, 0, 0], y=[(- 99999), 0, 99999], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[None, 1, None], y=[(- 1), 0, 1]), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[100.0, (- 100.0)], y=[1e-09, (- 1e-09)], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=(- 10), row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1e-05, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "masked_code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots with edge specs'\n    fig = make_subplots(rows=2, cols=2, shared_yaxes=True, specs=[[{'secondary_y': True}, {'secondary_y': True}], [None, {'type': 'polar'}]])\n    fig.add_trace(go.Scatter(x=[(- 1000000.0), 0, 1000000.0], y=[0, 0, 0]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[0, 0, 0], y=[(- 99999), 0, 99999], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[None, 1, None], y=[(- 1), 0, 1]), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[100.0, (- 100.0)], y=[1e-09, (- 1e-09)], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=(- 10), row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1e-05, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == '???')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "ground_truth": "'y4'", "quality_analysis": {"complexity_score": 15, "left_complexity": 14, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_45", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "funcname": "test_supplied_yref_on_multi_plot_subplot", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots with edge specs'\n    fig = make_subplots(rows=2, cols=2, shared_yaxes=True, specs=[[{'secondary_y': True}, {'secondary_y': True}], [None, {'type': 'polar'}]])\n    fig.add_trace(go.Scatter(x=[(- 1000000.0), 0, 1000000.0], y=[0, 0, 0]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[0, 0, 0], y=[(- 99999), 0, 99999], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[None, 1, None], y=[(- 1), 0, 1]), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[100.0, (- 100.0)], y=[1e-09, (- 1e-09)], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=(- 10), row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1e-05, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "masked_code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots with edge specs'\n    fig = make_subplots(rows=2, cols=2, shared_yaxes=True, specs=[[{'secondary_y': True}, {'secondary_y': True}], [None, {'type': 'polar'}]])\n    fig.add_trace(go.Scatter(x=[(- 1000000.0), 0, 1000000.0], y=[0, 0, 0]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[0, 0, 0], y=[(- 99999), 0, 99999], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[None, 1, None], y=[(- 1), 0, 1]), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[100.0, (- 100.0)], y=[1e-09, (- 1e-09)], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=(- 10), row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1e-05, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == '???')", "ground_truth": "'x2 domain'", "quality_analysis": {"complexity_score": 15, "left_complexity": 14, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_41", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "funcname": "test_supplied_yref_on_non_subplot_figure_object", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_supplied_yref_on_non_subplot_figure_object():\n    'test a non-subplot figure object from go.Figure, edge-case x/y/None title'\n    trace1 = go.Scatter(x=[], y=[])\n    trace2 = go.Scatter(x=[1000000000.0, (- 2e-09)], y=[(- 10), 10], yaxis='y2')\n    data = [trace1, trace2]\n    layout = go.Layout(yaxis=dict(title=None), yaxis2=dict(title='Test', overlaying='y', side='left'))\n    fig = go.Figure(data=data, layout=layout)\n    fig.add_hline(y=0, yref='y2', secondary_y=False)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')", "masked_code": "def test_supplied_yref_on_non_subplot_figure_object():\n    'test a non-subplot figure object from go.Figure, edge-case x/y/None title'\n    trace1 = go.Scatter(x=[], y=[])\n    trace2 = go.Scatter(x=[1000000000.0, (- 2e-09)], y=[(- 10), 10], yaxis='y2')\n    data = [trace1, trace2]\n    layout = go.Layout(yaxis=dict(title=None), yaxis2=dict(title='Test', overlaying='y', side='left'))\n    fig = go.Figure(data=data, layout=layout)\n    fig.add_hline(y=0, yref='y2', secondary_y=False)\n    assert (fig.layout['shapes'][0]['yref'] == '???')", "ground_truth": "'y2'", "quality_analysis": {"complexity_score": 15, "left_complexity": 14, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_40", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "funcname": "test_supplied_yref_on_single_plot_subplot", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_supplied_yref_on_single_plot_subplot():\n    'test a (1,1) subplot figure object with edge-case y values'\n    fig = make_subplots(1, 1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3, 4], y=[0, (- 10), 100000.0, 1e-08]))\n    fig.add_trace(go.Scatter(x=['a', 'b', 'c', 'd'], y=[0, 0, 0, 0], yaxis='y2'))\n    fig.update_layout(yaxis=dict(title='yaxis1 title', range=[(- 100), 100000000.0]), yaxis2=dict(title='', overlaying='y', side='right'))\n    fig.add_hline(y=(- 99999.999), yref='y2', secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')", "masked_code": "def test_supplied_yref_on_single_plot_subplot():\n    'test a (1,1) subplot figure object with edge-case y values'\n    fig = make_subplots(1, 1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3, 4], y=[0, (- 10), 100000.0, 1e-08]))\n    fig.add_trace(go.Scatter(x=['a', 'b', 'c', 'd'], y=[0, 0, 0, 0], yaxis='y2'))\n    fig.update_layout(yaxis=dict(title='yaxis1 title', range=[(- 100), 100000000.0]), yaxis2=dict(title='', overlaying='y', side='right'))\n    fig.add_hline(y=(- 99999.999), yref='y2', secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == '???')", "ground_truth": "'y2'", "quality_analysis": {"complexity_score": 15, "left_complexity": 14, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_46", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_traces.py", "testname": "test_update_traces.py", "funcname": "test_select_traces_integer", "imports": ["from unittest import TestCase", "import inspect", "import copy", "import pytest", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from functools import reduce"], "code": "def test_select_traces_integer(select_traces_fixture):\n    fig = select_traces_fixture\n    tr = list(fig.select_traces(selector=2))\n    assert (len(tr) == 1)\n    assert (tr[0].y[0] == 3)\n    _ = list(fig.select_traces(selector=(- 6)))[0]\n    tr = list(fig.select_traces(selector=0))\n    assert (tr[0].y[1] == 0)\n    tr = list(fig.select_traces(selector=(- 1)))[0]\n    assert (tr.y[1] == 20)\n    tr = list(fig.select_traces(selector=0, row=2, col=3))[0]\n    assert (tr.y[1] == 0)", "masked_code": "def test_select_traces_integer(select_traces_fixture):\n    fig = select_traces_fixture\n    tr = list(fig.select_traces(selector=2))\n    assert (len(tr) == 1)\n    assert (tr[0].y[0] == '???')\n    _ = list(fig.select_traces(selector=(- 6)))[0]\n    tr = list(fig.select_traces(selector=0))\n    assert (tr[0].y[1] == 0)\n    tr = list(fig.select_traces(selector=(- 1)))[0]\n    assert (tr.y[1] == 20)\n    tr = list(fig.select_traces(selector=0, row=2, col=3))[0]\n    assert (tr.y[1] == 0)", "ground_truth": "3", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_352", "reponame": "plotly", "testpath": "tests/test_optional/test_utils/test_utils.py", "testname": "test_utils.py", "funcname": "test_figure_json_encoding", "imports": ["import datetime", "import math", "import decimal", "from datetime import datetime as dt", "from unittest import TestCase", "import pytest", "from packaging.version import Version", "import numpy as np", "import pandas as pd", "import pytz", "from pandas.testing import assert_series_equal", "import json as _json", "import os", "import base64", "from plotly import optional_imports, utils", "import plotly.graph_objects as go", "from plotly.graph_objs import Scatter, Scatter3d, Figure, Data", "from plotly.utils import get_by_path", "from PIL import Image"], "code": "def test_figure_json_encoding(self):\n    df = pd.DataFrame(columns=['Value'], data=[0, (- 1), 10000000000.0, 3.14159])\n    s1 = Scatter3d(x=[0, (- 999), 9999999999], y=np.array([0.0, (- 999.99), np_nan(), dt(2024, 1, 1)]), z=['', 'Z', dt(2024, 1, 1), dt(2024, 1, 1, 23, 59, 59, 999999)])\n    s2 = Scatter(x=df['Value'])\n    data = Data([s1, s2])\n    figure = Figure(data=data)\n    js1 = _json.dumps(s1, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    js2 = _json.dumps(s2, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    assert (js1 == '{\"type\": \"scatter3d\", \"x\": [0, -999, 9999999999], \"y\": [0.0, -999.99, null, \"2024-01-01T00:00:00\"], \"z\": [\"\", \"Z\", \"2024-01-01T00:00:00\", \"2024-01-01T23:59:59.999999\"]}')\n    assert (js2 == '{\"type\": \"scatter\", \"x\": [0.0, -1.0, 10000000000.0, 3.14159]}')\n    _json.dumps(data, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    _json.dumps(figure, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    np_array = np.array([0.0, (- 999.99), np_nan(), dt(2024, 1, 1)])\n    y_orig = np.array([0.0, (- 999.99), np_nan(), dt(2024, 1, 1)])\n    for k in range(len(np_array)):\n        if (k == 2):\n            assert (np.isnan(y_orig[k]) and np.isnan(np_array[k]))\n        else:\n            assert (y_orig[k] == np_array[k])\n    assert (set(data[0]['z']) == set(['', 'Z', dt(2024, 1, 1), dt(2024, 1, 1, 23, 59, 59, 999999)]))", "masked_code": "def test_figure_json_encoding(self):\n    df = pd.DataFrame(columns=['Value'], data=[0, (- 1), 10000000000.0, 3.14159])\n    s1 = Scatter3d(x=[0, (- 999), 9999999999], y=np.array([0.0, (- 999.99), np_nan(), dt(2024, 1, 1)]), z=['', 'Z', dt(2024, 1, 1), dt(2024, 1, 1, 23, 59, 59, 999999)])\n    s2 = Scatter(x=df['Value'])\n    data = Data([s1, s2])\n    figure = Figure(data=data)\n    js1 = _json.dumps(s1, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    js2 = _json.dumps(s2, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    assert (js1 == '{\"type\": \"scatter3d\", \"x\": [0, -999, 9999999999], \"y\": [0.0, -999.99, null, \"2024-01-01T00:00:00\"], \"z\": [\"\", \"Z\", \"2024-01-01T00:00:00\", \"2024-01-01T23:59:59.999999\"]}')\n    assert (js2 == '{\"type\": \"scatter\", \"x\": [0.0, -1.0, 10000000000.0, 3.14159]}')\n    _json.dumps(data, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    _json.dumps(figure, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    np_array = np.array([0.0, (- 999.99), np_nan(), dt(2024, 1, 1)])\n    y_orig = np.array([0.0, (- 999.99), np_nan(), dt(2024, 1, 1)])\n    for k in range(len(np_array)):\n        if (k == 2):\n            assert (np.isnan(y_orig[k]) and np.isnan(np_array[k]))\n        else:\n            assert (y_orig[k] == np_array[k])\n    assert (set(data[0]['z']) == '???')", "ground_truth": "set(['', 'Z', dt(2024, 1, 1), dt(2024, 1, 1, 23, 59, 59, 999999)])", "quality_analysis": {"complexity_score": 35, "left_complexity": 12, "right_complexity": 23, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestJSONEncoder"}
{"task_id": "plotly_353", "reponame": "plotly", "testpath": "tests/test_optional/test_utils/test_utils.py", "testname": "test_utils.py", "funcname": "test_figure_json_encoding", "imports": ["import datetime", "import math", "import decimal", "from datetime import datetime as dt", "from unittest import TestCase", "import pytest", "from packaging.version import Version", "import numpy as np", "import pandas as pd", "import pytz", "from pandas.testing import assert_series_equal", "import json as _json", "import os", "import base64", "from plotly import optional_imports, utils", "import plotly.graph_objects as go", "from plotly.graph_objs import Scatter, Scatter3d, Figure, Data", "from plotly.utils import get_by_path", "from PIL import Image"], "code": "def test_figure_json_encoding(self):\n    df = pd.DataFrame(columns=['Value'], data=[0, (- 1), 10000000000.0, 3.14159])\n    s1 = Scatter3d(x=[0, (- 999), 9999999999], y=np.array([0.0, (- 999.99), np_nan(), dt(2024, 1, 1)]), z=['', 'Z', dt(2024, 1, 1), dt(2024, 1, 1, 23, 59, 59, 999999)])\n    s2 = Scatter(x=df['Value'])\n    data = Data([s1, s2])\n    figure = Figure(data=data)\n    js1 = _json.dumps(s1, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    js2 = _json.dumps(s2, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    assert (js1 == '{\"type\": \"scatter3d\", \"x\": [0, -999, 9999999999], \"y\": [0.0, -999.99, null, \"2024-01-01T00:00:00\"], \"z\": [\"\", \"Z\", \"2024-01-01T00:00:00\", \"2024-01-01T23:59:59.999999\"]}')\n    assert (js2 == '{\"type\": \"scatter\", \"x\": [0.0, -1.0, 10000000000.0, 3.14159]}')\n    _json.dumps(data, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    _json.dumps(figure, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    np_array = np.array([0.0, (- 999.99), np_nan(), dt(2024, 1, 1)])\n    y_orig = np.array([0.0, (- 999.99), np_nan(), dt(2024, 1, 1)])\n    for k in range(len(np_array)):\n        if (k == 2):\n            assert (np.isnan(y_orig[k]) and np.isnan(np_array[k]))\n        else:\n            assert (y_orig[k] == np_array[k])\n    assert (set(data[0]['z']) == set(['', 'Z', dt(2024, 1, 1), dt(2024, 1, 1, 23, 59, 59, 999999)]))", "masked_code": "def test_figure_json_encoding(self):\n    df = pd.DataFrame(columns=['Value'], data=[0, (- 1), 10000000000.0, 3.14159])\n    s1 = Scatter3d(x=[0, (- 999), 9999999999], y=np.array([0.0, (- 999.99), np_nan(), dt(2024, 1, 1)]), z=['', 'Z', dt(2024, 1, 1), dt(2024, 1, 1, 23, 59, 59, 999999)])\n    s2 = Scatter(x=df['Value'])\n    data = Data([s1, s2])\n    figure = Figure(data=data)\n    js1 = _json.dumps(s1, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    js2 = _json.dumps(s2, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    assert (js1 == '{\"type\": \"scatter3d\", \"x\": [0, -999, 9999999999], \"y\": [0.0, -999.99, null, \"2024-01-01T00:00:00\"], \"z\": [\"\", \"Z\", \"2024-01-01T00:00:00\", \"2024-01-01T23:59:59.999999\"]}')\n    assert (js2 == '{\"type\": \"scatter\", \"x\": [0.0, -1.0, 10000000000.0, 3.14159]}')\n    _json.dumps(data, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    _json.dumps(figure, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    np_array = np.array([0.0, (- 999.99), np_nan(), dt(2024, 1, 1)])\n    y_orig = np.array([0.0, (- 999.99), np_nan(), dt(2024, 1, 1)])\n    for k in range(len(np_array)):\n        if (k == 2):\n            assert (np.isnan(y_orig[k]) and np.isnan(np_array[k]))\n        else:\n            assert (y_orig[k] == '???')\n    assert (set(data[0]['z']) == set(['', 'Z', dt(2024, 1, 1), dt(2024, 1, 1, 23, 59, 59, 999999)]))", "ground_truth": "np_array[k]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}, "classname": "TestJSONEncoder"}
{"task_id": "plotly_460", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_xarray_input.py", "testname": "test_xarray_input.py", "funcname": "test_color_validator_numeric", "imports": ["import pytest", "import numpy as np", "import xarray", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_color_validator_numeric(color_validator, numeric_xarray):\n    res = color_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == numeric_xarray.dtype)\n    np.testing.assert_array_equal(res, numeric_xarray)", "masked_code": "def test_color_validator_numeric(color_validator, numeric_xarray):\n    res = color_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_xarray)", "ground_truth": "numeric_xarray.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_459", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_xarray_input.py", "testname": "test_xarray_input.py", "funcname": "test_data_array_validator", "imports": ["import pytest", "import numpy as np", "import xarray", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_data_array_validator(data_array_validator, numeric_xarray):\n    res = data_array_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == numeric_xarray.dtype)\n    np.testing.assert_array_equal(res, numeric_xarray)", "masked_code": "def test_data_array_validator(data_array_validator, numeric_xarray):\n    res = data_array_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_xarray)", "ground_truth": "numeric_xarray.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_457", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_xarray_input.py", "testname": "test_xarray_input.py", "funcname": "test_integer_validator_numeric_xarray", "imports": ["import pytest", "import numpy as np", "import xarray", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_integer_validator_numeric_xarray(integer_validator, numeric_xarray):\n    res = integer_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    if (numeric_xarray.dtype.kind in ('u', 'i')):\n        assert (res.dtype == numeric_xarray.dtype)\n    else:\n        assert (res.dtype == 'int32')\n    if (numeric_xarray.dtype.kind == 'f'):\n        expected = np.array(np.trunc(numeric_xarray.values).astype('int32'))\n        np.testing.assert_array_equal(res, expected)\n    elif (numeric_xarray.dtype.kind in ('i', 'u')):\n        np.testing.assert_array_equal(res, numeric_xarray)\n    else:\n        np.testing.assert_array_equal(res, numeric_xarray)", "masked_code": "def test_integer_validator_numeric_xarray(integer_validator, numeric_xarray):\n    res = integer_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    if (numeric_xarray.dtype.kind in ('u', 'i')):\n        assert (res.dtype == '???')\n    else:\n        assert (res.dtype == 'int32')\n    if (numeric_xarray.dtype.kind == 'f'):\n        expected = np.array(np.trunc(numeric_xarray.values).astype('int32'))\n        np.testing.assert_array_equal(res, expected)\n    elif (numeric_xarray.dtype.kind in ('i', 'u')):\n        np.testing.assert_array_equal(res, numeric_xarray)\n    else:\n        np.testing.assert_array_equal(res, numeric_xarray)", "ground_truth": "numeric_xarray.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_458", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_xarray_input.py", "testname": "test_xarray_input.py", "funcname": "test_integer_validator_numeric_xarray", "imports": ["import pytest", "import numpy as np", "import xarray", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_integer_validator_numeric_xarray(integer_validator, numeric_xarray):\n    res = integer_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    if (numeric_xarray.dtype.kind in ('u', 'i')):\n        assert (res.dtype == numeric_xarray.dtype)\n    else:\n        assert (res.dtype == 'int32')\n    if (numeric_xarray.dtype.kind == 'f'):\n        expected = np.array(np.trunc(numeric_xarray.values).astype('int32'))\n        np.testing.assert_array_equal(res, expected)\n    elif (numeric_xarray.dtype.kind in ('i', 'u')):\n        np.testing.assert_array_equal(res, numeric_xarray)\n    else:\n        np.testing.assert_array_equal(res, numeric_xarray)", "masked_code": "def test_integer_validator_numeric_xarray(integer_validator, numeric_xarray):\n    res = integer_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    if (numeric_xarray.dtype.kind in ('u', 'i')):\n        assert (res.dtype == numeric_xarray.dtype)\n    else:\n        assert (res.dtype == '???')\n    if (numeric_xarray.dtype.kind == 'f'):\n        expected = np.array(np.trunc(numeric_xarray.values).astype('int32'))\n        np.testing.assert_array_equal(res, expected)\n    elif (numeric_xarray.dtype.kind in ('i', 'u')):\n        np.testing.assert_array_equal(res, numeric_xarray)\n    else:\n        np.testing.assert_array_equal(res, numeric_xarray)", "ground_truth": "'int32'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
{"task_id": "plotly_456", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_xarray_input.py", "testname": "test_xarray_input.py", "funcname": "test_numeric_validator_numeric_xarray", "imports": ["import pytest", "import numpy as np", "import xarray", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_numeric_validator_numeric_xarray(number_validator, numeric_xarray):\n    res = number_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == numeric_xarray.dtype)\n    np.testing.assert_array_equal(res, numeric_xarray)", "masked_code": "def test_numeric_validator_numeric_xarray(number_validator, numeric_xarray):\n    res = number_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_xarray)", "ground_truth": "numeric_xarray.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}, "classname": null}
