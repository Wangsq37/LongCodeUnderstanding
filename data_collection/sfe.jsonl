{"task_id": "sfe_0", "reponame": "sfe", "testpath": "tests/test_assembly.py", "testname": "test_assembly.py", "classname": null, "funcname": "test_multimesh", "imports": ["from unittest import TestCase, main", "import pytest", "import numpy as np", "from numpy.testing import assert_equal, assert_almost_equal, assert_array_almost_equal", "from skfem import TrilinearForm, BilinearForm, LinearForm, Functional, asm, solve, condense", "from skfem.element import ElementQuad1, ElementQuadS2, ElementHex1, ElementHexS2, ElementTetP0, ElementTetP1, ElementTetP2, ElementTriP1, ElementQuad2, ElementTriMorley, ElementVectorH1, ElementQuadP, ElementHex2, ElementTriArgyris, ElementTriP2, ElementTriDG, ElementQuadDG, ElementHexDG, ElementTetDG, ElementTriHermite, ElementVector, ElementTriRT1, ElementTriRT2, ElementTriBDM1, ElementQuadRT1, ElementTetRT1, ElementHexRT1, ElementTriN1, ElementTriP0, ElementTetN0, ElementQuadN1, ElementQuad0, ElementTriN2, ElementTetN1", "from skfem.mesh import MeshQuad, MeshHex, MeshTet, MeshTri, MeshQuad2, MeshTri2, MeshTet2, MeshHex2, MeshTri1DG, MeshQuad1DG, MeshHex1DG", "from skfem.assembly import FacetBasis, Basis", "from skfem.utils import projection", "from skfem.models import laplace, unit_load, mass", "from skfem.helpers import grad, dot, ddot, sym_grad, curl", "from skfem.models import linear_stress"], "code": "def test_multimesh():\n    m1 = MeshTri().refined()\n    m2 = MeshQuad().refined().translated((1.0, 0.0))\n    m3 = MeshTri().refined().translated((2.0, 0.0))\n    M = ((m1 @ m2) @ m3)\n    assert (len(M) == 3)\n    E = [ElementTriP1(), ElementQuad1(), ElementTriP1()]\n    basis = list(map(Basis, M, E))\n    Mm = asm(mass, basis)\n    assert (Mm.shape[0] == (3 * 7))", "masked_code": "def test_multimesh():\n    m1 = MeshTri().refined()\n    m2 = MeshQuad().refined().translated((1.0, 0.0))\n    m3 = MeshTri().refined().translated((2.0, 0.0))\n    M = ((m1 @ m2) @ m3)\n    assert (len(M) == '???')\n    E = [ElementTriP1(), ElementQuad1(), ElementTriP1()]\n    basis = list(map(Basis, M, E))\n    Mm = asm(mass, basis)\n    assert (Mm.shape[0] == (3 * 7))", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "sfe_1", "reponame": "sfe", "testpath": "tests/test_assembly.py", "testname": "test_assembly.py", "classname": null, "funcname": "test_multimesh", "imports": ["from unittest import TestCase, main", "import pytest", "import numpy as np", "from numpy.testing import assert_equal, assert_almost_equal, assert_array_almost_equal", "from skfem import TrilinearForm, BilinearForm, LinearForm, Functional, asm, solve, condense", "from skfem.element import ElementQuad1, ElementQuadS2, ElementHex1, ElementHexS2, ElementTetP0, ElementTetP1, ElementTetP2, ElementTriP1, ElementQuad2, ElementTriMorley, ElementVectorH1, ElementQuadP, ElementHex2, ElementTriArgyris, ElementTriP2, ElementTriDG, ElementQuadDG, ElementHexDG, ElementTetDG, ElementTriHermite, ElementVector, ElementTriRT1, ElementTriRT2, ElementTriBDM1, ElementQuadRT1, ElementTetRT1, ElementHexRT1, ElementTriN1, ElementTriP0, ElementTetN0, ElementQuadN1, ElementQuad0, ElementTriN2, ElementTetN1", "from skfem.mesh import MeshQuad, MeshHex, MeshTet, MeshTri, MeshQuad2, MeshTri2, MeshTet2, MeshHex2, MeshTri1DG, MeshQuad1DG, MeshHex1DG", "from skfem.assembly import FacetBasis, Basis", "from skfem.utils import projection", "from skfem.models import laplace, unit_load, mass", "from skfem.helpers import grad, dot, ddot, sym_grad, curl", "from skfem.models import linear_stress"], "code": "def test_multimesh():\n    m1 = MeshTri().refined()\n    m2 = MeshQuad().refined().translated((1.0, 0.0))\n    m3 = MeshTri().refined().translated((2.0, 0.0))\n    M = ((m1 @ m2) @ m3)\n    assert (len(M) == 3)\n    E = [ElementTriP1(), ElementQuad1(), ElementTriP1()]\n    basis = list(map(Basis, M, E))\n    Mm = asm(mass, basis)\n    assert (Mm.shape[0] == (3 * 7))", "masked_code": "def test_multimesh():\n    m1 = MeshTri().refined()\n    m2 = MeshQuad().refined().translated((1.0, 0.0))\n    m3 = MeshTri().refined().translated((2.0, 0.0))\n    M = ((m1 @ m2) @ m3)\n    assert (len(M) == 3)\n    E = [ElementTriP1(), ElementQuad1(), ElementTriP1()]\n    basis = list(map(Basis, M, E))\n    Mm = asm(mass, basis)\n    assert (Mm.shape[0] == '???')", "ground_truth": "(3 * 7)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "sfe_2", "reponame": "sfe", "testpath": "tests/test_basis.py", "testname": "test_basis.py", "classname": null, "funcname": "test_oriented_saveload", "imports": ["import pickle", "from unittest import TestCase", "from pathlib import Path", "import pytest", "import numpy as np", "from numpy.testing import assert_allclose, assert_almost_equal, assert_array_equal", "from skfem import BilinearForm, LinearForm, asm, solve, condense, projection", "from skfem.mesh import Mesh, MeshTri, MeshTet, MeshHex, MeshQuad, MeshLine1, MeshWedge1", "from skfem.assembly import CellBasis, FacetBasis, Dofs, Functional, InteriorFacetBasis", "from skfem.mapping import MappingIsoparametric", "from skfem.element import ElementVectorH1, ElementTriP2, ElementTriP1, ElementTetP2, ElementHexS2, ElementHex2, ElementQuad2, ElementLineP2, ElementTriP0, ElementLineP0, ElementQuad1, ElementQuad0, ElementTetP1, ElementTetP0, ElementHex1, ElementHex0, ElementLineP1, ElementLineMini, ElementWedge1, ElementTriRT0, ElementQuadRT0, ElementTriP1", "from skfem.helpers import dot, grad", "from skfem.utils import enforce", "from skfem.io.meshio import to_meshio, from_meshio", "from skfem.models.poisson import laplace"], "code": "@pytest.mark.parametrize('m', [MeshLine1(), MeshTri(), MeshQuad(), MeshTet(), MeshHex()])\ndef test_oriented_saveload(m: Mesh):\n    m = m.refined(4)\n    m = m.with_boundaries({'mid': m.facets_around([5])})\n    assert (len(m.boundaries['mid'].ori) == m.refdom.nfacets)\n    M = from_meshio(to_meshio(m))\n    assert_array_equal(m.boundaries['mid'].ori, M.boundaries['mid'].ori)", "masked_code": "@pytest.mark.parametrize('m', [MeshLine1(), MeshTri(), MeshQuad(), MeshTet(), MeshHex()])\ndef test_oriented_saveload(m: Mesh):\n    m = m.refined(4)\n    m = m.with_boundaries({'mid': m.facets_around([5])})\n    assert (len(m.boundaries['mid'].ori) == '???')\n    M = from_meshio(to_meshio(m))\n    assert_array_equal(m.boundaries['mid'].ori, M.boundaries['mid'].ori)", "ground_truth": "m.refdom.nfacets", "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "sfe_3", "reponame": "sfe", "testpath": "tests/test_basis.py", "testname": "test_basis.py", "classname": null, "funcname": "test_with_elements", "imports": ["import pickle", "from unittest import TestCase", "from pathlib import Path", "import pytest", "import numpy as np", "from numpy.testing import assert_allclose, assert_almost_equal, assert_array_equal", "from skfem import BilinearForm, LinearForm, asm, solve, condense, projection", "from skfem.mesh import Mesh, MeshTri, MeshTet, MeshHex, MeshQuad, MeshLine1, MeshWedge1", "from skfem.assembly import CellBasis, FacetBasis, Dofs, Functional, InteriorFacetBasis", "from skfem.mapping import MappingIsoparametric", "from skfem.element import ElementVectorH1, ElementTriP2, ElementTriP1, ElementTetP2, ElementHexS2, ElementHex2, ElementQuad2, ElementLineP2, ElementTriP0, ElementLineP0, ElementQuad1, ElementQuad0, ElementTetP1, ElementTetP0, ElementHex1, ElementHex0, ElementLineP1, ElementLineMini, ElementWedge1, ElementTriRT0, ElementQuadRT0, ElementTriP1", "from skfem.helpers import dot, grad", "from skfem.utils import enforce", "from skfem.io.meshio import to_meshio, from_meshio", "from skfem.models.poisson import laplace"], "code": "def test_with_elements():\n    mesh = MeshTri().refined(3).with_subdomains({'a': (lambda x: (x[0] < 0.5))})\n    basis = CellBasis(mesh, ElementTriP0())\n    basis_half = basis.with_elements('a')\n    assert (basis.mesh == basis_half.mesh)\n    assert (basis.elem == basis_half.elem)\n    assert (basis.mapping == basis_half.mapping)\n    assert (basis.quadrature == basis_half.quadrature)\n    assert all((basis_half.tind == basis.mesh.normalize_elements('a')))", "masked_code": "def test_with_elements():\n    mesh = MeshTri().refined(3).with_subdomains({'a': (lambda x: (x[0] < 0.5))})\n    basis = CellBasis(mesh, ElementTriP0())\n    basis_half = basis.with_elements('a')\n    assert (basis.mesh == '???')\n    assert (basis.elem == basis_half.elem)\n    assert (basis.mapping == basis_half.mapping)\n    assert (basis.quadrature == basis_half.quadrature)\n    assert all((basis_half.tind == basis.mesh.normalize_elements('a')))", "ground_truth": "basis_half.mesh", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "sfe_4", "reponame": "sfe", "testpath": "tests/test_basis.py", "testname": "test_basis.py", "classname": null, "funcname": "test_with_elements", "imports": ["import pickle", "from unittest import TestCase", "from pathlib import Path", "import pytest", "import numpy as np", "from numpy.testing import assert_allclose, assert_almost_equal, assert_array_equal", "from skfem import BilinearForm, LinearForm, asm, solve, condense, projection", "from skfem.mesh import Mesh, MeshTri, MeshTet, MeshHex, MeshQuad, MeshLine1, MeshWedge1", "from skfem.assembly import CellBasis, FacetBasis, Dofs, Functional, InteriorFacetBasis", "from skfem.mapping import MappingIsoparametric", "from skfem.element import ElementVectorH1, ElementTriP2, ElementTriP1, ElementTetP2, ElementHexS2, ElementHex2, ElementQuad2, ElementLineP2, ElementTriP0, ElementLineP0, ElementQuad1, ElementQuad0, ElementTetP1, ElementTetP0, ElementHex1, ElementHex0, ElementLineP1, ElementLineMini, ElementWedge1, ElementTriRT0, ElementQuadRT0, ElementTriP1", "from skfem.helpers import dot, grad", "from skfem.utils import enforce", "from skfem.io.meshio import to_meshio, from_meshio", "from skfem.models.poisson import laplace"], "code": "def test_with_elements():\n    mesh = MeshTri().refined(3).with_subdomains({'a': (lambda x: (x[0] < 0.5))})\n    basis = CellBasis(mesh, ElementTriP0())\n    basis_half = basis.with_elements('a')\n    assert (basis.mesh == basis_half.mesh)\n    assert (basis.elem == basis_half.elem)\n    assert (basis.mapping == basis_half.mapping)\n    assert (basis.quadrature == basis_half.quadrature)\n    assert all((basis_half.tind == basis.mesh.normalize_elements('a')))", "masked_code": "def test_with_elements():\n    mesh = MeshTri().refined(3).with_subdomains({'a': (lambda x: (x[0] < 0.5))})\n    basis = CellBasis(mesh, ElementTriP0())\n    basis_half = basis.with_elements('a')\n    assert (basis.mesh == basis_half.mesh)\n    assert (basis.elem == '???')\n    assert (basis.mapping == basis_half.mapping)\n    assert (basis.quadrature == basis_half.quadrature)\n    assert all((basis_half.tind == basis.mesh.normalize_elements('a')))", "ground_truth": "basis_half.elem", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "sfe_5", "reponame": "sfe", "testpath": "tests/test_basis.py", "testname": "test_basis.py", "classname": null, "funcname": "test_with_elements", "imports": ["import pickle", "from unittest import TestCase", "from pathlib import Path", "import pytest", "import numpy as np", "from numpy.testing import assert_allclose, assert_almost_equal, assert_array_equal", "from skfem import BilinearForm, LinearForm, asm, solve, condense, projection", "from skfem.mesh import Mesh, MeshTri, MeshTet, MeshHex, MeshQuad, MeshLine1, MeshWedge1", "from skfem.assembly import CellBasis, FacetBasis, Dofs, Functional, InteriorFacetBasis", "from skfem.mapping import MappingIsoparametric", "from skfem.element import ElementVectorH1, ElementTriP2, ElementTriP1, ElementTetP2, ElementHexS2, ElementHex2, ElementQuad2, ElementLineP2, ElementTriP0, ElementLineP0, ElementQuad1, ElementQuad0, ElementTetP1, ElementTetP0, ElementHex1, ElementHex0, ElementLineP1, ElementLineMini, ElementWedge1, ElementTriRT0, ElementQuadRT0, ElementTriP1", "from skfem.helpers import dot, grad", "from skfem.utils import enforce", "from skfem.io.meshio import to_meshio, from_meshio", "from skfem.models.poisson import laplace"], "code": "def test_with_elements():\n    mesh = MeshTri().refined(3).with_subdomains({'a': (lambda x: (x[0] < 0.5))})\n    basis = CellBasis(mesh, ElementTriP0())\n    basis_half = basis.with_elements('a')\n    assert (basis.mesh == basis_half.mesh)\n    assert (basis.elem == basis_half.elem)\n    assert (basis.mapping == basis_half.mapping)\n    assert (basis.quadrature == basis_half.quadrature)\n    assert all((basis_half.tind == basis.mesh.normalize_elements('a')))", "masked_code": "def test_with_elements():\n    mesh = MeshTri().refined(3).with_subdomains({'a': (lambda x: (x[0] < 0.5))})\n    basis = CellBasis(mesh, ElementTriP0())\n    basis_half = basis.with_elements('a')\n    assert (basis.mesh == basis_half.mesh)\n    assert (basis.elem == basis_half.elem)\n    assert (basis.mapping == '???')\n    assert (basis.quadrature == basis_half.quadrature)\n    assert all((basis_half.tind == basis.mesh.normalize_elements('a')))", "ground_truth": "basis_half.mapping", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "sfe_6", "reponame": "sfe", "testpath": "tests/test_basis.py", "testname": "test_basis.py", "classname": null, "funcname": "test_with_elements", "imports": ["import pickle", "from unittest import TestCase", "from pathlib import Path", "import pytest", "import numpy as np", "from numpy.testing import assert_allclose, assert_almost_equal, assert_array_equal", "from skfem import BilinearForm, LinearForm, asm, solve, condense, projection", "from skfem.mesh import Mesh, MeshTri, MeshTet, MeshHex, MeshQuad, MeshLine1, MeshWedge1", "from skfem.assembly import CellBasis, FacetBasis, Dofs, Functional, InteriorFacetBasis", "from skfem.mapping import MappingIsoparametric", "from skfem.element import ElementVectorH1, ElementTriP2, ElementTriP1, ElementTetP2, ElementHexS2, ElementHex2, ElementQuad2, ElementLineP2, ElementTriP0, ElementLineP0, ElementQuad1, ElementQuad0, ElementTetP1, ElementTetP0, ElementHex1, ElementHex0, ElementLineP1, ElementLineMini, ElementWedge1, ElementTriRT0, ElementQuadRT0, ElementTriP1", "from skfem.helpers import dot, grad", "from skfem.utils import enforce", "from skfem.io.meshio import to_meshio, from_meshio", "from skfem.models.poisson import laplace"], "code": "def test_with_elements():\n    mesh = MeshTri().refined(3).with_subdomains({'a': (lambda x: (x[0] < 0.5))})\n    basis = CellBasis(mesh, ElementTriP0())\n    basis_half = basis.with_elements('a')\n    assert (basis.mesh == basis_half.mesh)\n    assert (basis.elem == basis_half.elem)\n    assert (basis.mapping == basis_half.mapping)\n    assert (basis.quadrature == basis_half.quadrature)\n    assert all((basis_half.tind == basis.mesh.normalize_elements('a')))", "masked_code": "def test_with_elements():\n    mesh = MeshTri().refined(3).with_subdomains({'a': (lambda x: (x[0] < 0.5))})\n    basis = CellBasis(mesh, ElementTriP0())\n    basis_half = basis.with_elements('a')\n    assert (basis.mesh == basis_half.mesh)\n    assert (basis.elem == basis_half.elem)\n    assert (basis.mapping == basis_half.mapping)\n    assert (basis.quadrature == '???')\n    assert all((basis_half.tind == basis.mesh.normalize_elements('a')))", "ground_truth": "basis_half.quadrature", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "sfe_7", "reponame": "sfe", "testpath": "tests/test_mesh.py", "testname": "test_mesh.py", "classname": null, "funcname": "test_incidence", "imports": ["from unittest import TestCase", "from pathlib import Path", "import numpy as np", "import pytest", "from scipy.spatial import Delaunay", "from numpy.testing import assert_array_equal, assert_almost_equal", "from skfem.mesh import Mesh, MeshHex, MeshLine, MeshQuad, MeshTet, MeshTri, MeshTet1, MeshHex1, MeshLine1DG, MeshQuad1DG, MeshTri1DG, MeshTri2, MeshQuad2, MeshTet2, MeshHex2", "from skfem.assembly import Basis, LinearForm, Functional, FacetBasis", "from skfem.element import ElementTetP1, ElementTriP0, ElementQuad0, ElementHex0, ElementTriP1", "from skfem.utils import projection", "from skfem.io.meshio import to_meshio, from_meshio", "from skfem.helpers import dot"], "code": "@pytest.mark.parametrize('mesh', [MeshTri().refined(3), MeshTet().refined(3), MeshQuad().refined(3), MeshHex().refined(3)])\ndef test_incidence(mesh):\n    p2t = mesh.p2t\n    for itr in range(0, 50, 3):\n        assert (np.sum((mesh.t == itr).any(axis=0)) == len(p2t[(:, itr)].data))\n    p2f = mesh.p2f\n    for itr in range(0, 50, 3):\n        assert (np.sum((mesh.facets == itr).any(axis=0)) == len(p2f[(:, itr)].data))\n    if isinstance(mesh, (MeshTet1, MeshHex1)):\n        p2e = mesh.p2e\n        for itr in range(0, 50, 3):\n            assert (np.sum((mesh.edges == itr).any(axis=0)) == len(p2e[(:, itr)].data))\n        e2t = mesh.e2t\n        for itr in range(0, 50, 3):\n            e = mesh.edges[(:, itr)]\n            datalen = np.sum(((mesh.t == e[0]).any(axis=0) & (mesh.t == e[1]).any(axis=0)))\n            assert (datalen == len(e2t[(:, itr)].data))", "masked_code": "@pytest.mark.parametrize('mesh', [MeshTri().refined(3), MeshTet().refined(3), MeshQuad().refined(3), MeshHex().refined(3)])\ndef test_incidence(mesh):\n    p2t = mesh.p2t\n    for itr in range(0, 50, 3):\n        assert (np.sum((mesh.t == itr).any(axis=0)) == '???')\n    p2f = mesh.p2f\n    for itr in range(0, 50, 3):\n        assert (np.sum((mesh.facets == itr).any(axis=0)) == len(p2f[(:, itr)].data))\n    if isinstance(mesh, (MeshTet1, MeshHex1)):\n        p2e = mesh.p2e\n        for itr in range(0, 50, 3):\n            assert (np.sum((mesh.edges == itr).any(axis=0)) == len(p2e[(:, itr)].data))\n        e2t = mesh.e2t\n        for itr in range(0, 50, 3):\n            e = mesh.edges[(:, itr)]\n            datalen = np.sum(((mesh.t == e[0]).any(axis=0) & (mesh.t == e[1]).any(axis=0)))\n            assert (datalen == len(e2t[(:, itr)].data))", "ground_truth": "len(p2t[(:, itr)].data)", "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "sfe_8", "reponame": "sfe", "testpath": "tests/test_mesh.py", "testname": "test_mesh.py", "classname": null, "funcname": "test_incidence", "imports": ["from unittest import TestCase", "from pathlib import Path", "import numpy as np", "import pytest", "from scipy.spatial import Delaunay", "from numpy.testing import assert_array_equal, assert_almost_equal", "from skfem.mesh import Mesh, MeshHex, MeshLine, MeshQuad, MeshTet, MeshTri, MeshTet1, MeshHex1, MeshLine1DG, MeshQuad1DG, MeshTri1DG, MeshTri2, MeshQuad2, MeshTet2, MeshHex2", "from skfem.assembly import Basis, LinearForm, Functional, FacetBasis", "from skfem.element import ElementTetP1, ElementTriP0, ElementQuad0, ElementHex0, ElementTriP1", "from skfem.utils import projection", "from skfem.io.meshio import to_meshio, from_meshio", "from skfem.helpers import dot"], "code": "@pytest.mark.parametrize('mesh', [MeshTri().refined(3), MeshTet().refined(3), MeshQuad().refined(3), MeshHex().refined(3)])\ndef test_incidence(mesh):\n    p2t = mesh.p2t\n    for itr in range(0, 50, 3):\n        assert (np.sum((mesh.t == itr).any(axis=0)) == len(p2t[(:, itr)].data))\n    p2f = mesh.p2f\n    for itr in range(0, 50, 3):\n        assert (np.sum((mesh.facets == itr).any(axis=0)) == len(p2f[(:, itr)].data))\n    if isinstance(mesh, (MeshTet1, MeshHex1)):\n        p2e = mesh.p2e\n        for itr in range(0, 50, 3):\n            assert (np.sum((mesh.edges == itr).any(axis=0)) == len(p2e[(:, itr)].data))\n        e2t = mesh.e2t\n        for itr in range(0, 50, 3):\n            e = mesh.edges[(:, itr)]\n            datalen = np.sum(((mesh.t == e[0]).any(axis=0) & (mesh.t == e[1]).any(axis=0)))\n            assert (datalen == len(e2t[(:, itr)].data))", "masked_code": "@pytest.mark.parametrize('mesh', [MeshTri().refined(3), MeshTet().refined(3), MeshQuad().refined(3), MeshHex().refined(3)])\ndef test_incidence(mesh):\n    p2t = mesh.p2t\n    for itr in range(0, 50, 3):\n        assert (np.sum((mesh.t == itr).any(axis=0)) == len(p2t[(:, itr)].data))\n    p2f = mesh.p2f\n    for itr in range(0, 50, 3):\n        assert (np.sum((mesh.facets == itr).any(axis=0)) == '???')\n    if isinstance(mesh, (MeshTet1, MeshHex1)):\n        p2e = mesh.p2e\n        for itr in range(0, 50, 3):\n            assert (np.sum((mesh.edges == itr).any(axis=0)) == len(p2e[(:, itr)].data))\n        e2t = mesh.e2t\n        for itr in range(0, 50, 3):\n            e = mesh.edges[(:, itr)]\n            datalen = np.sum(((mesh.t == e[0]).any(axis=0) & (mesh.t == e[1]).any(axis=0)))\n            assert (datalen == len(e2t[(:, itr)].data))", "ground_truth": "len(p2f[(:, itr)].data)", "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "sfe_9", "reponame": "sfe", "testpath": "tests/test_mesh.py", "testname": "test_mesh.py", "classname": null, "funcname": "test_incidence", "imports": ["from unittest import TestCase", "from pathlib import Path", "import numpy as np", "import pytest", "from scipy.spatial import Delaunay", "from numpy.testing import assert_array_equal, assert_almost_equal", "from skfem.mesh import Mesh, MeshHex, MeshLine, MeshQuad, MeshTet, MeshTri, MeshTet1, MeshHex1, MeshLine1DG, MeshQuad1DG, MeshTri1DG, MeshTri2, MeshQuad2, MeshTet2, MeshHex2", "from skfem.assembly import Basis, LinearForm, Functional, FacetBasis", "from skfem.element import ElementTetP1, ElementTriP0, ElementQuad0, ElementHex0, ElementTriP1", "from skfem.utils import projection", "from skfem.io.meshio import to_meshio, from_meshio", "from skfem.helpers import dot"], "code": "@pytest.mark.parametrize('mesh', [MeshTri().refined(3), MeshTet().refined(3), MeshQuad().refined(3), MeshHex().refined(3)])\ndef test_incidence(mesh):\n    p2t = mesh.p2t\n    for itr in range(0, 50, 3):\n        assert (np.sum((mesh.t == itr).any(axis=0)) == len(p2t[(:, itr)].data))\n    p2f = mesh.p2f\n    for itr in range(0, 50, 3):\n        assert (np.sum((mesh.facets == itr).any(axis=0)) == len(p2f[(:, itr)].data))\n    if isinstance(mesh, (MeshTet1, MeshHex1)):\n        p2e = mesh.p2e\n        for itr in range(0, 50, 3):\n            assert (np.sum((mesh.edges == itr).any(axis=0)) == len(p2e[(:, itr)].data))\n        e2t = mesh.e2t\n        for itr in range(0, 50, 3):\n            e = mesh.edges[(:, itr)]\n            datalen = np.sum(((mesh.t == e[0]).any(axis=0) & (mesh.t == e[1]).any(axis=0)))\n            assert (datalen == len(e2t[(:, itr)].data))", "masked_code": "@pytest.mark.parametrize('mesh', [MeshTri().refined(3), MeshTet().refined(3), MeshQuad().refined(3), MeshHex().refined(3)])\ndef test_incidence(mesh):\n    p2t = mesh.p2t\n    for itr in range(0, 50, 3):\n        assert (np.sum((mesh.t == itr).any(axis=0)) == len(p2t[(:, itr)].data))\n    p2f = mesh.p2f\n    for itr in range(0, 50, 3):\n        assert (np.sum((mesh.facets == itr).any(axis=0)) == len(p2f[(:, itr)].data))\n    if isinstance(mesh, (MeshTet1, MeshHex1)):\n        p2e = mesh.p2e\n        for itr in range(0, 50, 3):\n            assert (np.sum((mesh.edges == itr).any(axis=0)) == '???')\n        e2t = mesh.e2t\n        for itr in range(0, 50, 3):\n            e = mesh.edges[(:, itr)]\n            datalen = np.sum(((mesh.t == e[0]).any(axis=0) & (mesh.t == e[1]).any(axis=0)))\n            assert (datalen == len(e2t[(:, itr)].data))", "ground_truth": "len(p2e[(:, itr)].data)", "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "sfe_10", "reponame": "sfe", "testpath": "tests/test_mesh.py", "testname": "test_mesh.py", "classname": null, "funcname": "test_hole_orientation", "imports": ["from unittest import TestCase", "from pathlib import Path", "import numpy as np", "import pytest", "from scipy.spatial import Delaunay", "from numpy.testing import assert_array_equal, assert_almost_equal", "from skfem.mesh import Mesh, MeshHex, MeshLine, MeshQuad, MeshTet, MeshTri, MeshTet1, MeshHex1, MeshLine1DG, MeshQuad1DG, MeshTri1DG, MeshTri2, MeshQuad2, MeshTet2, MeshHex2", "from skfem.assembly import Basis, LinearForm, Functional, FacetBasis", "from skfem.element import ElementTetP1, ElementTriP0, ElementQuad0, ElementHex0, ElementTriP1", "from skfem.utils import projection", "from skfem.io.meshio import to_meshio, from_meshio", "from skfem.helpers import dot"], "code": "def test_hole_orientation():\n    m = MeshTri.load((MESH_PATH / 'annulus.msh'))\n    mig = MeshTri.load((MESH_PATH / 'annulus.msh'), ignore_orientation=True)\n    fbasisint = FacetBasis(m, ElementTriP1(), facets='inter')\n    fbasisext = FacetBasis(m, ElementTriP1(), facets='exter')\n    fbasisintig = FacetBasis(mig, ElementTriP1(), facets='inter')\n    fbasisextig = FacetBasis(mig, ElementTriP1(), facets='exter')\n    assert (str(type(m.boundaries['inter'])) == \"<class 'skfem.generic_utils.OrientedBoundary'>\")\n    np.testing.assert_almost_equal(fbasisint.normals, fbasisintig.normals)\n    np.testing.assert_almost_equal(fbasisext.normals, fbasisextig.normals)", "masked_code": "def test_hole_orientation():\n    m = MeshTri.load((MESH_PATH / 'annulus.msh'))\n    mig = MeshTri.load((MESH_PATH / 'annulus.msh'), ignore_orientation=True)\n    fbasisint = FacetBasis(m, ElementTriP1(), facets='inter')\n    fbasisext = FacetBasis(m, ElementTriP1(), facets='exter')\n    fbasisintig = FacetBasis(mig, ElementTriP1(), facets='inter')\n    fbasisextig = FacetBasis(mig, ElementTriP1(), facets='exter')\n    assert (str(type(m.boundaries['inter'])) == '???')\n    np.testing.assert_almost_equal(fbasisint.normals, fbasisintig.normals)\n    np.testing.assert_almost_equal(fbasisext.normals, fbasisextig.normals)", "ground_truth": "\"<class 'skfem.generic_utils.OrientedBoundary'>\"", "quality_analysis": {"complexity_score": 13, "left_complexity": 12, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
