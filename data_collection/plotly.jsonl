{"task_id": "plotly_0", "reponame": "plotly", "testpath": "tests/test_core/test_figure_messages/test_add_traces.py", "testname": "test_add_traces.py", "classname": null, "funcname": "test_add_trace_exclude_empty_subplots", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from unittest.mock import MagicMock"], "code": "def test_add_trace_exclude_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[5, 1, 2]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[2, 1, (- 7)]), row=2, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[0, 1, (- 1)]), row='all', col='all', exclude_empty_subplots=True)\n    assert (len(fig.data) == 4)\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x4') and (fig.data[3]['yaxis'] == 'y4'))", "masked_code": "def test_add_trace_exclude_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[5, 1, 2]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[2, 1, (- 7)]), row=2, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[0, 1, (- 1)]), row='all', col='all', exclude_empty_subplots=True)\n    assert (len(fig.data) == '???')\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x4') and (fig.data[3]['yaxis'] == 'y4'))", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_1", "reponame": "plotly", "testpath": "tests/test_core/test_figure_messages/test_add_traces.py", "testname": "test_add_traces.py", "classname": null, "funcname": "test_add_trace_no_exclude_empty_subplots", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from unittest.mock import MagicMock"], "code": "def test_add_trace_no_exclude_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[5, 1, 2]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[2, 1, (- 7)]), row=2, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[0, 1, (- 1)]), row='all', col='all')\n    assert (len(fig.data) == 6)\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x2') and (fig.data[3]['yaxis'] == 'y2'))\n    assert ((fig.data[4]['xaxis'] == 'x3') and (fig.data[4]['yaxis'] == 'y3'))\n    assert ((fig.data[5]['xaxis'] == 'x4') and (fig.data[5]['yaxis'] == 'y4'))", "masked_code": "def test_add_trace_no_exclude_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[5, 1, 2]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[2, 1, (- 7)]), row=2, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[0, 1, (- 1)]), row='all', col='all')\n    assert (len(fig.data) == '???')\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x2') and (fig.data[3]['yaxis'] == 'y2'))\n    assert ((fig.data[4]['xaxis'] == 'x3') and (fig.data[4]['yaxis'] == 'y3'))\n    assert ((fig.data[5]['xaxis'] == 'x4') and (fig.data[5]['yaxis'] == 'y4'))", "ground_truth": "6", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_2", "reponame": "plotly", "testpath": "tests/test_core/test_figure_messages/test_add_traces.py", "testname": "test_add_traces.py", "classname": null, "funcname": "test_add_trace_exclude_totally_empty_subplots", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from unittest.mock import MagicMock"], "code": "def test_add_trace_exclude_totally_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[5, 1, 2]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[2, 1, (- 7)]), row=2, col=2)\n    fig.add_shape(dict(type='rect', x0=0, x1=1, y0=0, y1=1), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[0, 1, (- 1)]), row='all', col='all', exclude_empty_subplots=['anything', 'truthy'])\n    assert (len(fig.data) == 5)\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x2') and (fig.data[3]['yaxis'] == 'y2'))\n    assert ((fig.data[4]['xaxis'] == 'x4') and (fig.data[4]['yaxis'] == 'y4'))", "masked_code": "def test_add_trace_exclude_totally_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[5, 1, 2]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[2, 1, (- 7)]), row=2, col=2)\n    fig.add_shape(dict(type='rect', x0=0, x1=1, y0=0, y1=1), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[0, 1, (- 1)]), row='all', col='all', exclude_empty_subplots=['anything', 'truthy'])\n    assert (len(fig.data) == '???')\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x2') and (fig.data[3]['yaxis'] == 'y2'))\n    assert ((fig.data[4]['xaxis'] == 'x4') and (fig.data[4]['yaxis'] == 'y4'))", "ground_truth": "5", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_3", "reponame": "plotly", "testpath": "tests/test_core/test_figure_messages/test_add_traces.py", "testname": "test_add_traces.py", "classname": null, "funcname": "test_add_trace_no_exclude_totally_empty_subplots", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from unittest.mock import MagicMock"], "code": "def test_add_trace_no_exclude_totally_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[5, 1, 2]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[2, 1, (- 7)]), row=2, col=2)\n    fig.add_shape(dict(type='rect', x0=0, x1=1, y0=0, y1=1), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[0, 1, (- 1)]), row='all', col='all')\n    assert (len(fig.data) == 6)\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x2') and (fig.data[3]['yaxis'] == 'y2'))\n    assert ((fig.data[4]['xaxis'] == 'x3') and (fig.data[4]['yaxis'] == 'y3'))\n    assert ((fig.data[5]['xaxis'] == 'x4') and (fig.data[5]['yaxis'] == 'y4'))", "masked_code": "def test_add_trace_no_exclude_totally_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[5, 1, 2]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[2, 1, (- 7)]), row=2, col=2)\n    fig.add_shape(dict(type='rect', x0=0, x1=1, y0=0, y1=1), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[0, 1, (- 1)]), row='all', col='all')\n    assert (len(fig.data) == '???')\n    assert ((fig.data[2]['xaxis'] == 'x') and (fig.data[2]['yaxis'] == 'y'))\n    assert ((fig.data[3]['xaxis'] == 'x2') and (fig.data[3]['yaxis'] == 'y2'))\n    assert ((fig.data[4]['xaxis'] == 'x3') and (fig.data[4]['yaxis'] == 'y3'))\n    assert ((fig.data[5]['xaxis'] == 'x4') and (fig.data[5]['yaxis'] == 'y4'))", "ground_truth": "6", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_4", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_annotations.py", "testname": "test_annotations.py", "classname": null, "funcname": "test_trivial", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_trivial():\n    assert (Annotations() == list())", "masked_code": "def test_trivial():\n    assert (Annotations() == '???')", "ground_truth": "list()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_5", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_annotations.py", "testname": "test_annotations.py", "classname": null, "funcname": "test_weird_instantiation", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_weird_instantiation():\n    assert (Annotations({}) == list())", "masked_code": "def test_weird_instantiation():\n    assert (Annotations({}) == '???')", "ground_truth": "list()", "quality_analysis": {"complexity_score": 9, "left_complexity": 6, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_6", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_annotations.py", "testname": "test_annotations.py", "classname": null, "funcname": "test_dict_instantiation_key_error", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_key_error():\n    assert (Annotations([{'not-a-key': 'anything'}]) == [{'not-a-key': 'anything'}])", "masked_code": "def test_dict_instantiation_key_error():\n    assert (Annotations([{'not-a-key': 'anything'}]) == '???')", "ground_truth": "[{'not-a-key': 'anything'}]", "quality_analysis": {"complexity_score": 17, "left_complexity": 10, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_7", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_annotations.py", "testname": "test_annotations.py", "classname": null, "funcname": "test_dict_instantiation_key_error_2", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_key_error_2():\n    assert (Annotations([{'font': 'not-a-dict'}]) == [{'font': 'not-a-dict'}])", "masked_code": "def test_dict_instantiation_key_error_2():\n    assert (Annotations([{'font': 'not-a-dict'}]) == '???')", "ground_truth": "[{'font': 'not-a-dict'}]", "quality_analysis": {"complexity_score": 17, "left_complexity": 10, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_8", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_annotations.py", "testname": "test_annotations.py", "classname": null, "funcname": "test_dict_instantiation_graph_obj_error_0", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_graph_obj_error_0():\n    assert (Annotations([Data()]) == [[]])", "masked_code": "def test_dict_instantiation_graph_obj_error_0():\n    assert (Annotations([Data()]) == '???')", "ground_truth": "[[]]", "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_9", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_annotations.py", "testname": "test_annotations.py", "classname": null, "funcname": "test_dict_instantiation_graph_obj_error_2", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_graph_obj_error_2():\n    assert (Annotations([Annotations()]) == [[]])", "masked_code": "def test_dict_instantiation_graph_obj_error_2():\n    assert (Annotations([Annotations()]) == '???')", "ground_truth": "[[]]", "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_10", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "classname": null, "funcname": "test_trivial", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_trivial():\n    assert (Data() == list())", "masked_code": "def test_trivial():\n    assert (Data() == '???')", "ground_truth": "list()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_11", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "classname": null, "funcname": "test_weird_instantiation", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_weird_instantiation():\n    assert (Data({}) == [])", "masked_code": "def test_weird_instantiation():\n    assert (Data({}) == '???')", "ground_truth": "[]", "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_12", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "classname": null, "funcname": "test_default_scatter", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_default_scatter():\n    assert (Data([{}]) == list([{}]))", "masked_code": "def test_default_scatter():\n    assert (Data([{}]) == '???')", "ground_truth": "list([{}])", "quality_analysis": {"complexity_score": 16, "left_complexity": 8, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_13", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "classname": null, "funcname": "test_dict_instantiation_key_error", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_key_error():\n    assert (Data([{'not-a-key': 'anything'}]) == [{'not-a-key': 'anything'}])", "masked_code": "def test_dict_instantiation_key_error():\n    assert (Data([{'not-a-key': 'anything'}]) == '???')", "ground_truth": "[{'not-a-key': 'anything'}]", "quality_analysis": {"complexity_score": 17, "left_complexity": 10, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_14", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "classname": null, "funcname": "test_dict_instantiation_key_error_2", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_key_error_2():\n    assert (Data([{'marker': 'not-a-dict'}]) == [{'marker': 'not-a-dict'}])", "masked_code": "def test_dict_instantiation_key_error_2():\n    assert (Data([{'marker': 'not-a-dict'}]) == '???')", "ground_truth": "[{'marker': 'not-a-dict'}]", "quality_analysis": {"complexity_score": 17, "left_complexity": 10, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_15", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "classname": null, "funcname": "test_dict_instantiation_type_error", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_type_error():\n    assert (Data([{'type': 'invalid_type'}]) == [{'type': 'invalid_type'}])", "masked_code": "def test_dict_instantiation_type_error():\n    assert (Data([{'type': 'invalid_type'}]) == '???')", "ground_truth": "[{'type': 'invalid_type'}]", "quality_analysis": {"complexity_score": 17, "left_complexity": 10, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_16", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "classname": null, "funcname": "test_dict_instantiation_graph_obj_error_0", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_graph_obj_error_0():\n    assert (Data([Data()]) == [[]])", "masked_code": "def test_dict_instantiation_graph_obj_error_0():\n    assert (Data([Data()]) == '???')", "ground_truth": "[[]]", "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_17", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_data.py", "testname": "test_data.py", "classname": null, "funcname": "test_dict_instantiation_graph_obj_error_2", "imports": ["from plotly.graph_objs import Annotations, Data"], "code": "def test_dict_instantiation_graph_obj_error_2():\n    assert (Data([Annotations()]) == [[]])", "masked_code": "def test_dict_instantiation_graph_obj_error_2():\n    assert (Data([Annotations()]) == '???')", "ground_truth": "[[]]", "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_18", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_error_bars.py", "testname": "test_error_bars.py", "classname": null, "funcname": "test_key_error", "imports": ["from plotly.graph_objs import ErrorX, ErrorY"], "code": "def test_key_error():\n    assert (ErrorX(value=0.1, typ='percent', color='red') == {'color': 'red', 'typ': 'percent', 'value': 0.1})", "masked_code": "def test_key_error():\n    assert (ErrorX(value=0.1, typ='percent', color='red') == '???')", "ground_truth": "{'color': 'red', 'typ': 'percent', 'value': 0.1}", "quality_analysis": {"complexity_score": 12, "left_complexity": 3, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_19", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_figure.py", "testname": "test_figure.py", "classname": null, "funcname": "test_set_subplots", "imports": ["import plotly.graph_objects as go", "from plotly.subplots import make_subplots", "from ...utils import TestCaseNoTemplate", "import pytest"], "code": "def test_set_subplots():\n    fig0 = go.Figure()\n    fig0_sp = make_subplots(2, 2)\n    fig0.set_subplots(2, 2)\n    assert (fig0.layout == fig0_sp.layout)\n    fig1 = go.Figure()\n    fig1.set_subplots(rows=2, cols=2, horizontal_spacing=0.25, vertical_spacing=0.1)\n    fig1_sp = make_subplots(rows=2, cols=2, horizontal_spacing=0.25, vertical_spacing=0.1)\n    assert (fig1.layout == fig1_sp.layout)\n    with pytest.raises(ValueError, match='^This figure already has subplots\\\\.$'):\n        fig1.set_subplots(2, 3)", "masked_code": "def test_set_subplots():\n    fig0 = go.Figure()\n    fig0_sp = make_subplots(2, 2)\n    fig0.set_subplots(2, 2)\n    assert (fig0.layout == '???')\n    fig1 = go.Figure()\n    fig1.set_subplots(rows=2, cols=2, horizontal_spacing=0.25, vertical_spacing=0.1)\n    fig1_sp = make_subplots(rows=2, cols=2, horizontal_spacing=0.25, vertical_spacing=0.1)\n    assert (fig1.layout == fig1_sp.layout)\n    with pytest.raises(ValueError, match='^This figure already has subplots\\\\.$'):\n        fig1.set_subplots(2, 3)", "ground_truth": "fig0_sp.layout", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_20", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_figure.py", "testname": "test_figure.py", "classname": null, "funcname": "test_set_subplots", "imports": ["import plotly.graph_objects as go", "from plotly.subplots import make_subplots", "from ...utils import TestCaseNoTemplate", "import pytest"], "code": "def test_set_subplots():\n    fig0 = go.Figure()\n    fig0_sp = make_subplots(2, 2)\n    fig0.set_subplots(2, 2)\n    assert (fig0.layout == fig0_sp.layout)\n    fig1 = go.Figure()\n    fig1.set_subplots(rows=2, cols=2, horizontal_spacing=0.25, vertical_spacing=0.1)\n    fig1_sp = make_subplots(rows=2, cols=2, horizontal_spacing=0.25, vertical_spacing=0.1)\n    assert (fig1.layout == fig1_sp.layout)\n    with pytest.raises(ValueError, match='^This figure already has subplots\\\\.$'):\n        fig1.set_subplots(2, 3)", "masked_code": "def test_set_subplots():\n    fig0 = go.Figure()\n    fig0_sp = make_subplots(2, 2)\n    fig0.set_subplots(2, 2)\n    assert (fig0.layout == fig0_sp.layout)\n    fig1 = go.Figure()\n    fig1.set_subplots(rows=2, cols=2, horizontal_spacing=0.25, vertical_spacing=0.1)\n    fig1_sp = make_subplots(rows=2, cols=2, horizontal_spacing=0.25, vertical_spacing=0.1)\n    assert (fig1.layout == '???')\n    with pytest.raises(ValueError, match='^This figure already has subplots\\\\.$'):\n        fig1.set_subplots(2, 3)", "ground_truth": "fig1_sp.layout", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_21", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "classname": "TestAssignmentPrimitive", "funcname": "test_toplevel_attr", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_toplevel_attr(self):\n    assert (self.scatter.fillcolor is None)\n    self.scatter.fillcolor = 'green'\n    assert (self.scatter.fillcolor == 'green')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_toplevel)\n    assert (d1 == d2)", "masked_code": "def test_toplevel_attr(self):\n    assert (self.scatter.fillcolor is None)\n    self.scatter.fillcolor = 'green'\n    assert (self.scatter.fillcolor == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_toplevel)\n    assert (d1 == d2)", "ground_truth": "'green'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_22", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "classname": "TestAssignmentPrimitive", "funcname": "test_toplevel_item", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_toplevel_item(self):\n    assert (self.scatter['fillcolor'] is None)\n    self.scatter['fillcolor'] = 'green'\n    assert (self.scatter['fillcolor'] == 'green')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_toplevel)\n    assert (d1 == d2)", "masked_code": "def test_toplevel_item(self):\n    assert (self.scatter['fillcolor'] is None)\n    self.scatter['fillcolor'] = 'green'\n    assert (self.scatter['fillcolor'] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_toplevel)\n    assert (d1 == d2)", "ground_truth": "'green'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_23", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "classname": "TestAssignmentPrimitive", "funcname": "test_nested_attr", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_attr(self):\n    assert (self.scatter.marker.colorbar.title.font.family is None)\n    self.scatter.marker.colorbar.title.font.family = 'courier'\n    assert (self.scatter.marker.colorbar.title.font.family == 'courier')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "masked_code": "def test_nested_attr(self):\n    assert (self.scatter.marker.colorbar.title.font.family is None)\n    self.scatter.marker.colorbar.title.font.family = 'courier'\n    assert (self.scatter.marker.colorbar.title.font.family == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "ground_truth": "'courier'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_24", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "classname": "TestAssignmentPrimitive", "funcname": "test_nested_item", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_item(self):\n    assert (self.scatter['marker']['colorbar']['title']['font']['family'] is None)\n    self.scatter['marker']['colorbar']['title']['font']['family'] = 'courier'\n    assert (self.scatter['marker']['colorbar']['title']['font']['family'] == 'courier')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "masked_code": "def test_nested_item(self):\n    assert (self.scatter['marker']['colorbar']['title']['font']['family'] is None)\n    self.scatter['marker']['colorbar']['title']['font']['family'] = 'courier'\n    assert (self.scatter['marker']['colorbar']['title']['font']['family'] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "ground_truth": "'courier'", "quality_analysis": {"complexity_score": 23, "left_complexity": 22, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_25", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "classname": "TestAssignmentPrimitive", "funcname": "test_nested_item_dots", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_item_dots(self):\n    assert (self.scatter['marker.colorbar.title.font.family'] is None)\n    self.scatter['marker.colorbar.title.font.family'] = 'courier'\n    assert (self.scatter['marker.colorbar.title.font.family'] == 'courier')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "masked_code": "def test_nested_item_dots(self):\n    assert (self.scatter['marker.colorbar.title.font.family'] is None)\n    self.scatter['marker.colorbar.title.font.family'] = 'courier'\n    assert (self.scatter['marker.colorbar.title.font.family'] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "ground_truth": "'courier'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_26", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "classname": "TestAssignmentPrimitive", "funcname": "test_nested_item_tuple", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_item_tuple(self):\n    assert (self.scatter['marker.colorbar.title.font.family'] is None)\n    self.scatter[('marker', 'colorbar', 'title.font', 'family')] = 'courier'\n    assert (self.scatter[('marker', 'colorbar', 'title.font', 'family')] == 'courier')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "masked_code": "def test_nested_item_tuple(self):\n    assert (self.scatter['marker.colorbar.title.font.family'] is None)\n    self.scatter[('marker', 'colorbar', 'title.font', 'family')] = 'courier'\n    assert (self.scatter[('marker', 'colorbar', 'title.font', 'family')] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "ground_truth": "'courier'", "quality_analysis": {"complexity_score": 12, "left_complexity": 11, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_27", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "classname": "TestAssignmentPrimitive", "funcname": "test_nested_update", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_update(self):\n    self.scatter.update(marker={'colorbar': {'title': {'font': {'family': 'courier'}}}})\n    assert (self.scatter[('marker', 'colorbar', 'title', 'font', 'family')] == 'courier')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "masked_code": "def test_nested_update(self):\n    self.scatter.update(marker={'colorbar': {'title': {'font': {'family': 'courier'}}}})\n    assert (self.scatter[('marker', 'colorbar', 'title', 'font', 'family')] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "ground_truth": "'courier'", "quality_analysis": {"complexity_score": 13, "left_complexity": 12, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_28", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "classname": "TestAssignmentPrimitive", "funcname": "test_nested_update_dots", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_update_dots(self):\n    assert (self.scatter['marker.colorbar.title.font.family'] is None)\n    self.scatter.update({'marker.colorbar.title.font.family': 'courier'})\n    assert (self.scatter['marker.colorbar.title.font.family'] == 'courier')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "masked_code": "def test_nested_update_dots(self):\n    assert (self.scatter['marker.colorbar.title.font.family'] is None)\n    self.scatter.update({'marker.colorbar.title.font.family': 'courier'})\n    assert (self.scatter['marker.colorbar.title.font.family'] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested)\n    assert (d1 == d2)", "ground_truth": "'courier'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_29", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_property_assignment.py", "testname": "test_property_assignment.py", "classname": "TestAssignmentPrimitive", "funcname": "test_nested_update_underscores", "imports": ["from unittest import TestCase", "import plotly.graph_objs as go", "from ...utils import strip_dict_params"], "code": "def test_nested_update_underscores(self):\n    assert (self.scatter['error_x.type'] is None)\n    self.scatter.update({'error_x_type': 'percent'})\n    assert (self.scatter['error_x_type'] == 'percent')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested_error_x)\n    assert (d1 == d2)", "masked_code": "def test_nested_update_underscores(self):\n    assert (self.scatter['error_x.type'] is None)\n    self.scatter.update({'error_x_type': 'percent'})\n    assert (self.scatter['error_x_type'] == '???')\n    (d1, d2) = strip_dict_params(self.scatter, self.expected_nested_error_x)\n    assert (d1 == d2)", "ground_truth": "'percent'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_30", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_scatter.py", "testname": "test_scatter.py", "classname": null, "funcname": "test_trivial", "imports": ["from plotly.graph_objs import Scatter"], "code": "def test_trivial():\n    print(Scatter())\n    assert (Scatter().to_plotly_json() == dict(type='scatter'))", "masked_code": "def test_trivial():\n    print(Scatter())\n    assert (Scatter().to_plotly_json() == '???')", "ground_truth": "dict(type='scatter')", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_31", "reponame": "plotly", "testpath": "tests/test_core/test_graph_objs/test_validate.py", "testname": "test_validate.py", "classname": null, "funcname": "test_validate_false", "imports": ["import plotly.graph_objs as go", "import json", "import pytest", "import plotly.io as pio"], "code": "def test_validate_false():\n    template = pio.templates.default\n    try:\n        pio.templates.default = None\n        fig = go.Figure(_validate=False, **build_invalid_fig())\n        assert (json.loads(fig.to_json()) == expected_invalid_dict)\n        with pytest.raises(ValueError):\n            go.Figure(_validate=True, **build_invalid_fig())\n    finally:\n        pio.templates.default = template", "masked_code": "def test_validate_false():\n    template = pio.templates.default\n    try:\n        pio.templates.default = None\n        fig = go.Figure(_validate=False, **build_invalid_fig())\n        assert (json.loads(fig.to_json()) == '???')\n        with pytest.raises(ValueError):\n            go.Figure(_validate=True, **build_invalid_fig())\n    finally:\n        pio.templates.default = template", "ground_truth": "expected_invalid_dict", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_32", "reponame": "plotly", "testpath": "tests/test_core/test_subplots/test_find_nonempty_subplots.py", "testname": "test_find_nonempty_subplots.py", "classname": null, "funcname": "test_choose_correct_non_empty_subplots", "imports": ["import plotly.graph_objects as go", "from plotly.subplots import make_subplots", "from itertools import combinations, product", "from functools import reduce"], "code": "def test_choose_correct_non_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2], y=[3, 4]), row=1, col=1)\n    fig.add_shape(dict(type='rect', x0=1, x1=2, y0=3, y1=4), row=1, col=2)\n    fig.add_annotation(dict(text='A', x=1, y=2), row=2, col=1)\n    fig.add_layout_image(dict(source='test', x=1, y=2, sizex=0.5, sizey=0.5), row=2, col=2)\n    all_subplots = get_non_empty_subplots(fig, 'all')\n    selectors = all_combos(['traces', 'shapes', 'annotations', 'images'])\n    subplot_combos = all_combos(all_subplots)\n    assert (len(selectors) == len(subplot_combos))\n    for (s, spc) in zip(selectors, subplot_combos):\n        sps = tuple(get_non_empty_subplots(fig, s))\n        assert (sps == spc)", "masked_code": "def test_choose_correct_non_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2], y=[3, 4]), row=1, col=1)\n    fig.add_shape(dict(type='rect', x0=1, x1=2, y0=3, y1=4), row=1, col=2)\n    fig.add_annotation(dict(text='A', x=1, y=2), row=2, col=1)\n    fig.add_layout_image(dict(source='test', x=1, y=2, sizex=0.5, sizey=0.5), row=2, col=2)\n    all_subplots = get_non_empty_subplots(fig, 'all')\n    selectors = all_combos(['traces', 'shapes', 'annotations', 'images'])\n    subplot_combos = all_combos(all_subplots)\n    assert (len(selectors) == '???')\n    for (s, spc) in zip(selectors, subplot_combos):\n        sps = tuple(get_non_empty_subplots(fig, s))\n        assert (sps == spc)", "ground_truth": "len(subplot_combos)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_33", "reponame": "plotly", "testpath": "tests/test_core/test_subplots/test_make_subplots.py", "testname": "test_make_subplots.py", "classname": "TestMakeSubplots", "funcname": "test_if_passed_figure", "imports": ["from unittest import TestCase", "import pytest", "from plotly.graph_objs import Annotation, Annotations, Data, Figure, Font, Layout, layout, Scene, XAxis, YAxis", "import plotly.tools as tls", "from plotly import subplots"], "code": "def test_if_passed_figure(self):\n    fig = Figure()\n    figsp = subplots.make_subplots(2, 2, figure=fig)\n    assert (id(fig) == id(figsp))\n    fig2sp = subplots.make_subplots(2, 2)\n    assert (id(fig2sp) != id(figsp))\n    assert (fig2sp.layout == figsp.layout)", "masked_code": "def test_if_passed_figure(self):\n    fig = Figure()\n    figsp = subplots.make_subplots(2, 2, figure=fig)\n    assert (id(fig) == '???')\n    fig2sp = subplots.make_subplots(2, 2)\n    assert (id(fig2sp) != id(figsp))\n    assert (fig2sp.layout == figsp.layout)", "ground_truth": "id(figsp)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_34", "reponame": "plotly", "testpath": "tests/test_core/test_subplots/test_make_subplots.py", "testname": "test_make_subplots.py", "classname": "TestMakeSubplots", "funcname": "test_if_passed_figure", "imports": ["from unittest import TestCase", "import pytest", "from plotly.graph_objs import Annotation, Annotations, Data, Figure, Font, Layout, layout, Scene, XAxis, YAxis", "import plotly.tools as tls", "from plotly import subplots"], "code": "def test_if_passed_figure(self):\n    fig = Figure()\n    figsp = subplots.make_subplots(2, 2, figure=fig)\n    assert (id(fig) == id(figsp))\n    fig2sp = subplots.make_subplots(2, 2)\n    assert (id(fig2sp) != id(figsp))\n    assert (fig2sp.layout == figsp.layout)", "masked_code": "def test_if_passed_figure(self):\n    fig = Figure()\n    figsp = subplots.make_subplots(2, 2, figure=fig)\n    assert (id(fig) == id(figsp))\n    fig2sp = subplots.make_subplots(2, 2)\n    assert (id(fig2sp) != id(figsp))\n    assert (fig2sp.layout == '???')", "ground_truth": "figsp.layout", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_35", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_row_col_subplot_addressing.py", "testname": "test_row_col_subplot_addressing.py", "classname": null, "funcname": "test_get_subplot_coordinates", "imports": ["import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from plotly.basedatatypes import _indexing_combinations", "import pytest", "from itertools import product"], "code": "def test_get_subplot_coordinates(subplot_fig_fixture):\n    assert (set(subplot_fig_fixture._get_subplot_coordinates()) == set([(r, c) for r in range(1, (NROWS + 1)) for c in range(1, (NCOLS + 1))]))", "masked_code": "def test_get_subplot_coordinates(subplot_fig_fixture):\n    assert (set(subplot_fig_fixture._get_subplot_coordinates()) == '???')", "ground_truth": "set([(r, c) for r in range(1, (NROWS + 1)) for c in range(1, (NCOLS + 1))])", "quality_analysis": {"complexity_score": 9, "left_complexity": 6, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_36", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_row_col_subplot_addressing.py", "testname": "test_row_col_subplot_addressing.py", "classname": null, "funcname": "test_indexing_combinations_edge_cases", "imports": ["import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from plotly.basedatatypes import _indexing_combinations", "import pytest", "from itertools import product"], "code": "def test_indexing_combinations_edge_cases():\n    assert (_indexing_combinations([], []) == [])\n    with pytest.raises(ValueError):\n        _ = _indexing_combinations([[1, 2], [3, 4, 5]], [[1, 2]])", "masked_code": "def test_indexing_combinations_edge_cases():\n    assert (_indexing_combinations([], []) == '???')\n    with pytest.raises(ValueError):\n        _ = _indexing_combinations([[1, 2], [3, 4, 5]], [[1, 2]])", "ground_truth": "[]", "quality_analysis": {"complexity_score": 9, "left_complexity": 7, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_37", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_row_col_subplot_addressing.py", "testname": "test_row_col_subplot_addressing.py", "classname": null, "funcname": "test_indexing_combinations", "imports": ["import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from plotly.basedatatypes import _indexing_combinations", "import pytest", "from itertools import product"], "code": "@pytest.mark.parametrize('test_input,expected', [(dict(dims=['all', 'all'], alls=[all_rows, all_cols], product=False), set(zip(all_rows, all_cols))), (dict(dims=['all', 'all'], alls=[all_rows, all_cols], product=True), set([(r, c) for r in all_rows for c in all_cols])), (dict(dims=['all', [2, 4, 5]], alls=[all_rows, all_cols], product=False), set(zip(all_rows, [2, 4, 5]))), (dict(dims=['all', [2, 4, 5]], alls=[all_rows, all_cols], product=True), set([(r, c) for r in all_rows for c in [2, 4, 5]])), (dict(dims=['all', 3], alls=[all_rows, all_cols], product=False), set([(all_rows[0], 3)])), (dict(dims=['all', 3], alls=[all_rows, all_cols], product=True), set([(r, c) for r in all_rows for c in [3]])), (dict(dims=[[1, 3], 'all'], alls=[all_rows, all_cols], product=False), set(zip([1, 3], all_cols))), (dict(dims=[[1, 3], 'all'], alls=[all_rows, all_cols], product=True), set([(r, c) for r in [1, 3] for c in all_cols])), (dict(dims=[[1, 3], [2, 4, 5]], alls=[all_rows, all_cols], product=False), set(zip([1, 3], [2, 4, 5]))), (dict(dims=[[1, 3], [2, 4, 5]], alls=[all_rows, all_cols], product=True), set([(r, c) for r in [1, 3] for c in [2, 4, 5]])), (dict(dims=[[1, 3], 3], alls=[all_rows, all_cols], product=False), set([(1, 3)])), (dict(dims=[[1, 3], 3], alls=[all_rows, all_cols], product=True), set([(r, c) for r in [1, 3] for c in [3]])), (dict(dims=[2, 'all'], alls=[all_rows, all_cols], product=False), set([(2, all_cols[0])])), (dict(dims=[2, 'all'], alls=[all_rows, all_cols], product=True), set([(r, c) for r in [2] for c in all_cols])), (dict(dims=[2, [2, 4, 5]], alls=[all_rows, all_cols], product=False), set([(2, 2)])), (dict(dims=[2, [2, 4, 5]], alls=[all_rows, all_cols], product=True), set([(r, c) for r in [2] for c in [2, 4, 5]])), (dict(dims=[2, 3], alls=[all_rows, all_cols], product=False), set([(2, 3)])), (dict(dims=[2, 3], alls=[all_rows, all_cols], product=True), set([(2, 3)]))])\ndef test_indexing_combinations(test_input, expected):\n    assert (set(_indexing_combinations(**test_input)) == expected)", "masked_code": "@pytest.mark.parametrize('test_input,expected', [(dict(dims=['all', 'all'], alls=[all_rows, all_cols], product=False), set(zip(all_rows, all_cols))), (dict(dims=['all', 'all'], alls=[all_rows, all_cols], product=True), set([(r, c) for r in all_rows for c in all_cols])), (dict(dims=['all', [2, 4, 5]], alls=[all_rows, all_cols], product=False), set(zip(all_rows, [2, 4, 5]))), (dict(dims=['all', [2, 4, 5]], alls=[all_rows, all_cols], product=True), set([(r, c) for r in all_rows for c in [2, 4, 5]])), (dict(dims=['all', 3], alls=[all_rows, all_cols], product=False), set([(all_rows[0], 3)])), (dict(dims=['all', 3], alls=[all_rows, all_cols], product=True), set([(r, c) for r in all_rows for c in [3]])), (dict(dims=[[1, 3], 'all'], alls=[all_rows, all_cols], product=False), set(zip([1, 3], all_cols))), (dict(dims=[[1, 3], 'all'], alls=[all_rows, all_cols], product=True), set([(r, c) for r in [1, 3] for c in all_cols])), (dict(dims=[[1, 3], [2, 4, 5]], alls=[all_rows, all_cols], product=False), set(zip([1, 3], [2, 4, 5]))), (dict(dims=[[1, 3], [2, 4, 5]], alls=[all_rows, all_cols], product=True), set([(r, c) for r in [1, 3] for c in [2, 4, 5]])), (dict(dims=[[1, 3], 3], alls=[all_rows, all_cols], product=False), set([(1, 3)])), (dict(dims=[[1, 3], 3], alls=[all_rows, all_cols], product=True), set([(r, c) for r in [1, 3] for c in [3]])), (dict(dims=[2, 'all'], alls=[all_rows, all_cols], product=False), set([(2, all_cols[0])])), (dict(dims=[2, 'all'], alls=[all_rows, all_cols], product=True), set([(r, c) for r in [2] for c in all_cols])), (dict(dims=[2, [2, 4, 5]], alls=[all_rows, all_cols], product=False), set([(2, 2)])), (dict(dims=[2, [2, 4, 5]], alls=[all_rows, all_cols], product=True), set([(r, c) for r in [2] for c in [2, 4, 5]])), (dict(dims=[2, 3], alls=[all_rows, all_cols], product=False), set([(2, 3)])), (dict(dims=[2, 3], alls=[all_rows, all_cols], product=True), set([(2, 3)]))])\ndef test_indexing_combinations(test_input, expected):\n    assert (set(_indexing_combinations(**test_input)) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_38", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "classname": null, "funcname": "test_exclude_empty_subplots", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_exclude_empty_subplots():\n    for (k, fun, d, fun2, d2) in [('shapes', go.Figure.add_shape, dict(type='rect', x0=1.5, x1=2.5, y0=3.5, y1=4.5), go.Figure.add_annotation, dict(x=1, y=2, text='A')), ('annotations', go.Figure.add_annotation, dict(x=1, y=2, text='A'), go.Figure.add_layout_image, dict(x=3, y=4, sizex=2, sizey=3, source='test')), ('images', go.Figure.add_layout_image, dict(x=3, y=4, sizex=2, sizey=3, source='test'), go.Figure.add_shape, dict(type='rect', x0=1.5, x1=2.5, y0=3.5, y1=4.5))]:\n        fig = make_subplots(2, 2)\n        fig.add_trace(go.Scatter(x=[1, 2, 3], y=[5, 1, 2]), row=1, col=1)\n        fig.add_trace(go.Scatter(x=[1, 2, 3], y=[2, 1, (- 7)]), row=2, col=2)\n        fun2(fig, d2, row=1, col=2)\n        fun(fig, d, row='all', col='all', exclude_empty_subplots='anything_truthy')\n        assert (len(fig.layout[k]) == 3)\n        assert ((fig.layout[k][0]['xref'] == 'x') and (fig.layout[k][0]['yref'] == 'y'))\n        assert ((fig.layout[k][1]['xref'] == 'x2') and (fig.layout[k][1]['yref'] == 'y2'))\n        assert ((fig.layout[k][2]['xref'] == 'x4') and (fig.layout[k][2]['yref'] == 'y4'))", "masked_code": "def test_exclude_empty_subplots():\n    for (k, fun, d, fun2, d2) in [('shapes', go.Figure.add_shape, dict(type='rect', x0=1.5, x1=2.5, y0=3.5, y1=4.5), go.Figure.add_annotation, dict(x=1, y=2, text='A')), ('annotations', go.Figure.add_annotation, dict(x=1, y=2, text='A'), go.Figure.add_layout_image, dict(x=3, y=4, sizex=2, sizey=3, source='test')), ('images', go.Figure.add_layout_image, dict(x=3, y=4, sizex=2, sizey=3, source='test'), go.Figure.add_shape, dict(type='rect', x0=1.5, x1=2.5, y0=3.5, y1=4.5))]:\n        fig = make_subplots(2, 2)\n        fig.add_trace(go.Scatter(x=[1, 2, 3], y=[5, 1, 2]), row=1, col=1)\n        fig.add_trace(go.Scatter(x=[1, 2, 3], y=[2, 1, (- 7)]), row=2, col=2)\n        fun2(fig, d2, row=1, col=2)\n        fun(fig, d, row='all', col='all', exclude_empty_subplots='anything_truthy')\n        assert (len(fig.layout[k]) == '???')\n        assert ((fig.layout[k][0]['xref'] == 'x') and (fig.layout[k][0]['yref'] == 'y'))\n        assert ((fig.layout[k][1]['xref'] == 'x2') and (fig.layout[k][1]['yref'] == 'y2'))\n        assert ((fig.layout[k][2]['xref'] == 'x4') and (fig.layout[k][2]['yref'] == 'y4'))", "ground_truth": "3", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_39", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "classname": null, "funcname": "test_no_exclude_empty_subplots", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_no_exclude_empty_subplots():\n    for (k, fun, d, fun2, d2) in [('shapes', go.Figure.add_shape, dict(type='rect', x0=1.5, x1=2.5, y0=3.5, y1=4.5), go.Figure.add_annotation, dict(x=1, y=2, text='A')), ('annotations', go.Figure.add_annotation, dict(x=1, y=2, text='A'), go.Figure.add_layout_image, dict(x=3, y=4, sizex=2, sizey=3, source='test')), ('images', go.Figure.add_layout_image, dict(x=3, y=4, sizex=2, sizey=3, source='test'), go.Figure.add_shape, dict(type='rect', x0=1.5, x1=2.5, y0=3.5, y1=4.5))]:\n        fig = make_subplots(2, 2)\n        fig.add_trace(go.Scatter(x=[1, 2, 3], y=[5, 1, 2]), row=1, col=1)\n        fig.add_trace(go.Scatter(x=[1, 2, 3], y=[2, 1, (- 7)]), row=2, col=2)\n        fun2(fig, d2, row=1, col=2)\n        fun(fig, d, row='all', col='all', exclude_empty_subplots=False)\n        assert (len(fig.layout[k]) == 4)\n        assert ((fig.layout[k][0]['xref'] == 'x') and (fig.layout[k][0]['yref'] == 'y'))\n        assert ((fig.layout[k][1]['xref'] == 'x2') and (fig.layout[k][1]['yref'] == 'y2'))\n        assert ((fig.layout[k][2]['xref'] == 'x3') and (fig.layout[k][2]['yref'] == 'y3'))\n        assert ((fig.layout[k][3]['xref'] == 'x4') and (fig.layout[k][3]['yref'] == 'y4'))", "masked_code": "def test_no_exclude_empty_subplots():\n    for (k, fun, d, fun2, d2) in [('shapes', go.Figure.add_shape, dict(type='rect', x0=1.5, x1=2.5, y0=3.5, y1=4.5), go.Figure.add_annotation, dict(x=1, y=2, text='A')), ('annotations', go.Figure.add_annotation, dict(x=1, y=2, text='A'), go.Figure.add_layout_image, dict(x=3, y=4, sizex=2, sizey=3, source='test')), ('images', go.Figure.add_layout_image, dict(x=3, y=4, sizex=2, sizey=3, source='test'), go.Figure.add_shape, dict(type='rect', x0=1.5, x1=2.5, y0=3.5, y1=4.5))]:\n        fig = make_subplots(2, 2)\n        fig.add_trace(go.Scatter(x=[1, 2, 3], y=[5, 1, 2]), row=1, col=1)\n        fig.add_trace(go.Scatter(x=[1, 2, 3], y=[2, 1, (- 7)]), row=2, col=2)\n        fun2(fig, d2, row=1, col=2)\n        fun(fig, d, row='all', col='all', exclude_empty_subplots=False)\n        assert (len(fig.layout[k]) == '???')\n        assert ((fig.layout[k][0]['xref'] == 'x') and (fig.layout[k][0]['yref'] == 'y'))\n        assert ((fig.layout[k][1]['xref'] == 'x2') and (fig.layout[k][1]['yref'] == 'y2'))\n        assert ((fig.layout[k][2]['xref'] == 'x3') and (fig.layout[k][2]['yref'] == 'y3'))\n        assert ((fig.layout[k][3]['xref'] == 'x4') and (fig.layout[k][3]['yref'] == 'y4'))", "ground_truth": "4", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_40", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "classname": null, "funcname": "test_supplied_yref_on_single_plot_subplot", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_supplied_yref_on_single_plot_subplot():\n    'test a (1,1) subplot figure object'\n    fig = make_subplots(1, 1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3, 4], y=[1, 2, 2, 1]))\n    fig.add_trace(go.Scatter(x=[1, 2, 3, 4], y=[4, 3, 2, 1], yaxis='y2'))\n    fig.update_layout(yaxis=dict(title='yaxis1 title'), yaxis2=dict(title='yaxis2 title', overlaying='y', side='right'))\n    fig.add_hline(y=3, yref='y2', secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')", "masked_code": "def test_supplied_yref_on_single_plot_subplot():\n    'test a (1,1) subplot figure object'\n    fig = make_subplots(1, 1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3, 4], y=[1, 2, 2, 1]))\n    fig.add_trace(go.Scatter(x=[1, 2, 3, 4], y=[4, 3, 2, 1], yaxis='y2'))\n    fig.update_layout(yaxis=dict(title='yaxis1 title'), yaxis2=dict(title='yaxis2 title', overlaying='y', side='right'))\n    fig.add_hline(y=3, yref='y2', secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == '???')", "ground_truth": "'y2'", "quality_analysis": {"complexity_score": 15, "left_complexity": 14, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_41", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "classname": null, "funcname": "test_supplied_yref_on_non_subplot_figure_object", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_supplied_yref_on_non_subplot_figure_object():\n    'test a non-subplot figure object from go.Figure'\n    trace1 = go.Scatter(x=[1, 2, 3, 4], y=[1, 2, 2, 1])\n    trace2 = go.Scatter(x=[1, 2, 3, 4], y=[4, 3, 2, 1], yaxis='y2')\n    data = [trace1, trace2]\n    layout = go.Layout(yaxis=dict(title='yaxis1 title'), yaxis2=dict(title='yaxis2 title', overlaying='y', side='right'))\n    fig = go.Figure(data=data, layout=layout)\n    fig.add_hline(y=3, yref='y2', secondary_y=False)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')", "masked_code": "def test_supplied_yref_on_non_subplot_figure_object():\n    'test a non-subplot figure object from go.Figure'\n    trace1 = go.Scatter(x=[1, 2, 3, 4], y=[1, 2, 2, 1])\n    trace2 = go.Scatter(x=[1, 2, 3, 4], y=[4, 3, 2, 1], yaxis='y2')\n    data = [trace1, trace2]\n    layout = go.Layout(yaxis=dict(title='yaxis1 title'), yaxis2=dict(title='yaxis2 title', overlaying='y', side='right'))\n    fig = go.Figure(data=data, layout=layout)\n    fig.add_hline(y=3, yref='y2', secondary_y=False)\n    assert (fig.layout['shapes'][0]['yref'] == '???')", "ground_truth": "'y2'", "quality_analysis": {"complexity_score": 15, "left_complexity": 14, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_42", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "classname": null, "funcname": "test_supplied_yref_on_multi_plot_subplot", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots'\n    fig = make_subplots(rows=1, cols=2, shared_yaxes=False, specs=[[{'secondary_y': True}, {'secondary_y': True}]])\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[3, 2, 1], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3], yaxis='y'), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 1, 2], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=2, row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "masked_code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots'\n    fig = make_subplots(rows=1, cols=2, shared_yaxes=False, specs=[[{'secondary_y': True}, {'secondary_y': True}]])\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[3, 2, 1], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3], yaxis='y'), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 1, 2], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=2, row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == '???')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "ground_truth": "'y2'", "quality_analysis": {"complexity_score": 15, "left_complexity": 14, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_43", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "classname": null, "funcname": "test_supplied_yref_on_multi_plot_subplot", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots'\n    fig = make_subplots(rows=1, cols=2, shared_yaxes=False, specs=[[{'secondary_y': True}, {'secondary_y': True}]])\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[3, 2, 1], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3], yaxis='y'), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 1, 2], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=2, row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "masked_code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots'\n    fig = make_subplots(rows=1, cols=2, shared_yaxes=False, specs=[[{'secondary_y': True}, {'secondary_y': True}]])\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[3, 2, 1], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3], yaxis='y'), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 1, 2], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=2, row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == '???')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "ground_truth": "'x domain'", "quality_analysis": {"complexity_score": 15, "left_complexity": 14, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_44", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "classname": null, "funcname": "test_supplied_yref_on_multi_plot_subplot", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots'\n    fig = make_subplots(rows=1, cols=2, shared_yaxes=False, specs=[[{'secondary_y': True}, {'secondary_y': True}]])\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[3, 2, 1], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3], yaxis='y'), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 1, 2], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=2, row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "masked_code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots'\n    fig = make_subplots(rows=1, cols=2, shared_yaxes=False, specs=[[{'secondary_y': True}, {'secondary_y': True}]])\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[3, 2, 1], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3], yaxis='y'), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 1, 2], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=2, row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == '???')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "ground_truth": "'y4'", "quality_analysis": {"complexity_score": 15, "left_complexity": 14, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_45", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_annotations.py", "testname": "test_update_annotations.py", "classname": null, "funcname": "test_supplied_yref_on_multi_plot_subplot", "imports": ["import types", "from unittest import TestCase", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "import pytest"], "code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots'\n    fig = make_subplots(rows=1, cols=2, shared_yaxes=False, specs=[[{'secondary_y': True}, {'secondary_y': True}]])\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[3, 2, 1], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3], yaxis='y'), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 1, 2], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=2, row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == 'x2 domain')", "masked_code": "def test_supplied_yref_on_multi_plot_subplot():\n    'test multiple subploted figure object with subplots.make_subplots'\n    fig = make_subplots(rows=1, cols=2, shared_yaxes=False, specs=[[{'secondary_y': True}, {'secondary_y': True}]])\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3]), row=1, col=1)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[3, 2, 1], yaxis='y2'), row=1, col=1, secondary_y=True)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 2, 3], yaxis='y'), row=1, col=2)\n    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[1, 1, 2], yaxis='y2'), row=1, col=2, secondary_y=True)\n    fig.add_hline(y=2, row=1, col=1, secondary_y=True)\n    fig.add_hline(y=1, row=1, col=2, secondary_y=True)\n    assert (fig.layout['shapes'][0]['yref'] == 'y2')\n    assert (fig.layout['shapes'][0]['xref'] == 'x domain')\n    assert (fig.layout['shapes'][1]['yref'] == 'y4')\n    assert (fig.layout['shapes'][1]['xref'] == '???')", "ground_truth": "'x2 domain'", "quality_analysis": {"complexity_score": 15, "left_complexity": 14, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_46", "reponame": "plotly", "testpath": "tests/test_core/test_update_objects/test_update_traces.py", "testname": "test_update_traces.py", "classname": null, "funcname": "test_select_traces_integer", "imports": ["from unittest import TestCase", "import inspect", "import copy", "import pytest", "import plotly.graph_objs as go", "from plotly.subplots import make_subplots", "from functools import reduce"], "code": "def test_select_traces_integer(select_traces_fixture):\n    fig = select_traces_fixture\n    tr = list(fig.select_traces(selector=0))\n    assert (len(tr) == 1)\n    assert (tr[0].y[1] == 0)\n    tr = list(fig.select_traces(selector=(- 1)))[0]\n    assert (tr.y[1] == 20)\n    tr = list(fig.select_traces(selector=(- 1), row=2, col=3))[0]\n    assert (tr.y[1] == 2)\n    with pytest.raises(IndexError):\n        tr = list(fig.select_traces(selector=6))[0]", "masked_code": "def test_select_traces_integer(select_traces_fixture):\n    fig = select_traces_fixture\n    tr = list(fig.select_traces(selector=0))\n    assert (len(tr) == 1)\n    assert (tr[0].y[1] == 0)\n    tr = list(fig.select_traces(selector=(- 1)))[0]\n    assert (tr.y[1] == '???')\n    tr = list(fig.select_traces(selector=(- 1), row=2, col=3))[0]\n    assert (tr.y[1] == 2)\n    with pytest.raises(IndexError):\n        tr = list(fig.select_traces(selector=6))[0]", "ground_truth": "20", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_47", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "classname": null, "funcname": "test_deepcopy_figure", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_deepcopy_figure(fig1):\n    fig_copied = copy.deepcopy(fig1)\n    assert (fig_copied.to_dict() == fig1.to_dict())\n    assert (fig_copied is not fig1)\n    assert (fig_copied.layout is not fig1.layout)\n    assert (fig_copied.data is not fig1.data)", "masked_code": "def test_deepcopy_figure(fig1):\n    fig_copied = copy.deepcopy(fig1)\n    assert (fig_copied.to_dict() == '???')\n    assert (fig_copied is not fig1)\n    assert (fig_copied.layout is not fig1.layout)\n    assert (fig_copied.data is not fig1.data)", "ground_truth": "fig1.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_48", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "classname": null, "funcname": "test_deepcopy_figure_subplots", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[0, 0, 1], row=1, col=2)\n    fig_copied.add_bar(y=[0, 0, 1], row=1, col=2)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "masked_code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == '???')\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[0, 0, 1], row=1, col=2)\n    fig_copied.add_bar(y=[0, 0, 1], row=1, col=2)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "ground_truth": "fig_subplots.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_49", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "classname": null, "funcname": "test_deepcopy_figure_subplots", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[0, 0, 1], row=1, col=2)\n    fig_copied.add_bar(y=[0, 0, 1], row=1, col=2)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "masked_code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == '???')\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[0, 0, 1], row=1, col=2)\n    fig_copied.add_bar(y=[0, 0, 1], row=1, col=2)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "ground_truth": "fig_copied._grid_ref", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_50", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "classname": null, "funcname": "test_deepcopy_figure_subplots", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[0, 0, 1], row=1, col=2)\n    fig_copied.add_bar(y=[0, 0, 1], row=1, col=2)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "masked_code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == '???')\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[0, 0, 1], row=1, col=2)\n    fig_copied.add_bar(y=[0, 0, 1], row=1, col=2)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "ground_truth": "fig_copied._grid_str", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_51", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "classname": null, "funcname": "test_deepcopy_figure_subplots", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[0, 0, 1], row=1, col=2)\n    fig_copied.add_bar(y=[0, 0, 1], row=1, col=2)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "masked_code": "def test_deepcopy_figure_subplots(fig_subplots):\n    fig_copied = copy.deepcopy(fig_subplots)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    assert (fig_subplots._grid_ref == fig_copied._grid_ref)\n    assert (fig_subplots._grid_str == fig_copied._grid_str)\n    assert (fig_copied is not fig_subplots)\n    assert (fig_copied.layout is not fig_subplots.layout)\n    assert (fig_copied.data is not fig_subplots.data)\n    fig_subplots.add_bar(y=[0, 0, 1], row=1, col=2)\n    fig_copied.add_bar(y=[0, 0, 1], row=1, col=2)\n    assert (fig_copied.to_dict() == '???')", "ground_truth": "fig_subplots.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_52", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "classname": null, "funcname": "test_pickle_figure_round_trip", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_pickle_figure_round_trip(fig1):\n    fig_copied = pickle.loads(pickle.dumps(fig1))\n    assert (fig_copied.to_dict() == fig1.to_dict())", "masked_code": "def test_pickle_figure_round_trip(fig1):\n    fig_copied = pickle.loads(pickle.dumps(fig1))\n    assert (fig_copied.to_dict() == '???')", "ground_truth": "fig1.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_53", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "classname": null, "funcname": "test_pickle_figure_subplots_round_trip", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_pickle_figure_subplots_round_trip(fig_subplots):\n    fig_copied = pickle.loads(pickle.dumps(fig_subplots))\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    fig_subplots.add_bar(y=[0, 0, 1], row=1, col=2)\n    fig_copied.add_bar(y=[0, 0, 1], row=1, col=2)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "masked_code": "def test_pickle_figure_subplots_round_trip(fig_subplots):\n    fig_copied = pickle.loads(pickle.dumps(fig_subplots))\n    assert (fig_copied.to_dict() == '???')\n    fig_subplots.add_bar(y=[0, 0, 1], row=1, col=2)\n    fig_copied.add_bar(y=[0, 0, 1], row=1, col=2)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "ground_truth": "fig_subplots.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_54", "reponame": "plotly", "testpath": "tests/test_io/test_deepcopy_pickle.py", "testname": "test_deepcopy_pickle.py", "classname": null, "funcname": "test_pickle_figure_subplots_round_trip", "imports": ["import pytest", "import copy", "import pickle", "from plotly.tools import make_subplots", "import plotly.graph_objs as go"], "code": "def test_pickle_figure_subplots_round_trip(fig_subplots):\n    fig_copied = pickle.loads(pickle.dumps(fig_subplots))\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    fig_subplots.add_bar(y=[0, 0, 1], row=1, col=2)\n    fig_copied.add_bar(y=[0, 0, 1], row=1, col=2)\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())", "masked_code": "def test_pickle_figure_subplots_round_trip(fig_subplots):\n    fig_copied = pickle.loads(pickle.dumps(fig_subplots))\n    assert (fig_copied.to_dict() == fig_subplots.to_dict())\n    fig_subplots.add_bar(y=[0, 0, 1], row=1, col=2)\n    fig_copied.add_bar(y=[0, 0, 1], row=1, col=2)\n    assert (fig_copied.to_dict() == '???')", "ground_truth": "fig_subplots.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_55", "reponame": "plotly", "testpath": "tests/test_io/test_html.py", "testname": "test_html.py", "classname": null, "funcname": "test_html_deterministic", "imports": ["import pytest", "import numpy as np", "import re", "import plotly.graph_objs as go", "import plotly.io as pio", "from plotly.io._utils import plotly_cdn_url", "from plotly.offline.offline import get_plotlyjs", "from plotly.io._html import _generate_sri_hash"], "code": "def test_html_deterministic(fig1):\n    div_id = 'plotly-root'\n    assert (pio.to_html(fig1, include_plotlyjs='cdn', div_id=div_id) == pio.to_html(fig1, include_plotlyjs='cdn', div_id=div_id))", "masked_code": "def test_html_deterministic(fig1):\n    div_id = 'plotly-root'\n    assert (pio.to_html(fig1, include_plotlyjs='cdn', div_id=div_id) == '???')", "ground_truth": "pio.to_html(fig1, include_plotlyjs='cdn', div_id=div_id)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_56", "reponame": "plotly", "testpath": "tests/test_io/test_pathlib.py", "testname": "test_pathlib.py", "classname": null, "funcname": "test_write_html", "imports": ["import plotly.io as pio", "from io import StringIO", "from pathlib import Path", "import re", "from unittest.mock import Mock"], "code": "def test_write_html():\n    'Verify that various methods for producing HTML have equivalent results.\\n\\n    The results will not be identical because the div id is pseudorandom. Thus\\n    we compare the results after replacing the div id.\\n\\n    We test the results of\\n    - pio.to_html\\n    - pio.write_html with a StringIO buffer\\n    - pio.write_html with a mock pathlib Path\\n    - pio.write_html with a mock file descriptor\\n    '\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert (replace_div_id(html) == replace_div_id(sio_html))\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert (replace_div_id(html) == replace_div_id(pl_html))\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    (fd_html,) = mock_file_descriptor.write.call_args[0]\n    assert (replace_div_id(html) == replace_div_id(fd_html))", "masked_code": "def test_write_html():\n    'Verify that various methods for producing HTML have equivalent results.\\n\\n    The results will not be identical because the div id is pseudorandom. Thus\\n    we compare the results after replacing the div id.\\n\\n    We test the results of\\n    - pio.to_html\\n    - pio.write_html with a StringIO buffer\\n    - pio.write_html with a mock pathlib Path\\n    - pio.write_html with a mock file descriptor\\n    '\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert (replace_div_id(html) == '???')\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert (replace_div_id(html) == replace_div_id(pl_html))\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    (fd_html,) = mock_file_descriptor.write.call_args[0]\n    assert (replace_div_id(html) == replace_div_id(fd_html))", "ground_truth": "replace_div_id(sio_html)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_57", "reponame": "plotly", "testpath": "tests/test_io/test_pathlib.py", "testname": "test_pathlib.py", "classname": null, "funcname": "test_write_html", "imports": ["import plotly.io as pio", "from io import StringIO", "from pathlib import Path", "import re", "from unittest.mock import Mock"], "code": "def test_write_html():\n    'Verify that various methods for producing HTML have equivalent results.\\n\\n    The results will not be identical because the div id is pseudorandom. Thus\\n    we compare the results after replacing the div id.\\n\\n    We test the results of\\n    - pio.to_html\\n    - pio.write_html with a StringIO buffer\\n    - pio.write_html with a mock pathlib Path\\n    - pio.write_html with a mock file descriptor\\n    '\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert (replace_div_id(html) == replace_div_id(sio_html))\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert (replace_div_id(html) == replace_div_id(pl_html))\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    (fd_html,) = mock_file_descriptor.write.call_args[0]\n    assert (replace_div_id(html) == replace_div_id(fd_html))", "masked_code": "def test_write_html():\n    'Verify that various methods for producing HTML have equivalent results.\\n\\n    The results will not be identical because the div id is pseudorandom. Thus\\n    we compare the results after replacing the div id.\\n\\n    We test the results of\\n    - pio.to_html\\n    - pio.write_html with a StringIO buffer\\n    - pio.write_html with a mock pathlib Path\\n    - pio.write_html with a mock file descriptor\\n    '\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert (replace_div_id(html) == replace_div_id(sio_html))\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert (replace_div_id(html) == '???')\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    (fd_html,) = mock_file_descriptor.write.call_args[0]\n    assert (replace_div_id(html) == replace_div_id(fd_html))", "ground_truth": "replace_div_id(pl_html)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_58", "reponame": "plotly", "testpath": "tests/test_io/test_pathlib.py", "testname": "test_pathlib.py", "classname": null, "funcname": "test_write_html", "imports": ["import plotly.io as pio", "from io import StringIO", "from pathlib import Path", "import re", "from unittest.mock import Mock"], "code": "def test_write_html():\n    'Verify that various methods for producing HTML have equivalent results.\\n\\n    The results will not be identical because the div id is pseudorandom. Thus\\n    we compare the results after replacing the div id.\\n\\n    We test the results of\\n    - pio.to_html\\n    - pio.write_html with a StringIO buffer\\n    - pio.write_html with a mock pathlib Path\\n    - pio.write_html with a mock file descriptor\\n    '\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert (replace_div_id(html) == replace_div_id(sio_html))\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert (replace_div_id(html) == replace_div_id(pl_html))\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    (fd_html,) = mock_file_descriptor.write.call_args[0]\n    assert (replace_div_id(html) == replace_div_id(fd_html))", "masked_code": "def test_write_html():\n    'Verify that various methods for producing HTML have equivalent results.\\n\\n    The results will not be identical because the div id is pseudorandom. Thus\\n    we compare the results after replacing the div id.\\n\\n    We test the results of\\n    - pio.to_html\\n    - pio.write_html with a StringIO buffer\\n    - pio.write_html with a mock pathlib Path\\n    - pio.write_html with a mock file descriptor\\n    '\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert (replace_div_id(html) == replace_div_id(sio_html))\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert (replace_div_id(html) == replace_div_id(pl_html))\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    (fd_html,) = mock_file_descriptor.write.call_args[0]\n    assert (replace_div_id(html) == '???')", "ground_truth": "replace_div_id(fd_html)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_59", "reponame": "plotly", "testpath": "tests/test_io/test_renderers.py", "testname": "test_renderers.py", "classname": null, "funcname": "test_colab_renderer_show", "imports": ["import json", "import threading", "import time", "import pytest", "import requests", "import numpy as np", "import webbrowser", "import plotly.graph_objs as go", "import plotly.io as pio", "from plotly.offline import get_plotlyjs", "from plotly.io._utils import plotly_cdn_url", "from plotly.io._html import _generate_sri_hash", "import unittest.mock as mock", "from unittest.mock import MagicMock"], "code": "def test_colab_renderer_show(fig1):\n    pio.renderers.default = 'colab'\n    with mock.patch('IPython.display.display') as mock_display:\n        pio.show(fig1)\n    mock_call_args = mock_display.call_args\n    mock_arg1 = mock_call_args[0][0]\n    assert (list(mock_arg1) == ['text/html'])\n    html = mock_arg1['text/html']\n    assert_full_html(html)\n    assert_html_renderer_connected(html)\n    mock_kwargs = mock_call_args[1]\n    assert (mock_kwargs == {'raw': True})", "masked_code": "def test_colab_renderer_show(fig1):\n    pio.renderers.default = 'colab'\n    with mock.patch('IPython.display.display') as mock_display:\n        pio.show(fig1)\n    mock_call_args = mock_display.call_args\n    mock_arg1 = mock_call_args[0][0]\n    assert (list(mock_arg1) == '???')\n    html = mock_arg1['text/html']\n    assert_full_html(html)\n    assert_html_renderer_connected(html)\n    mock_kwargs = mock_call_args[1]\n    assert (mock_kwargs == {'raw': True})", "ground_truth": "['text/html']", "quality_analysis": {"complexity_score": 7, "left_complexity": 4, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_60", "reponame": "plotly", "testpath": "tests/test_io/test_renderers.py", "testname": "test_renderers.py", "classname": null, "funcname": "test_notebook_connected_show", "imports": ["import json", "import threading", "import time", "import pytest", "import requests", "import numpy as np", "import webbrowser", "import plotly.graph_objs as go", "import plotly.io as pio", "from plotly.offline import get_plotlyjs", "from plotly.io._utils import plotly_cdn_url", "from plotly.io._html import _generate_sri_hash", "import unittest.mock as mock", "from unittest.mock import MagicMock"], "code": "@pytest.mark.parametrize('name,connected', [('notebook', False), ('notebook_connected', True), ('kaggle', True)])\ndef test_notebook_connected_show(fig1, name, connected):\n    pio.renderers.default = name\n    with mock.patch('IPython.display.display_html') as mock_display_html:\n        with mock.patch('IPython.display.display') as mock_display:\n            pio.show(fig1)\n    mock_call_args_html = mock_display_html.call_args\n    mock_arg1_html = mock_call_args_html[0][0]\n    bundle_display_html = mock_arg1_html\n    if connected:\n        assert_html_renderer_connected(bundle_display_html)\n    else:\n        assert_offline(bundle_display_html)\n    mock_call_args = mock_display.call_args\n    mock_arg1 = mock_call_args[0][0]\n    assert (list(mock_arg1) == ['text/html'])\n    bundle_html = mock_arg1['text/html']\n    assert_not_full_html(bundle_html)\n    mock_kwargs = mock_call_args[1]\n    assert (mock_kwargs == {'raw': True})", "masked_code": "@pytest.mark.parametrize('name,connected', [('notebook', False), ('notebook_connected', True), ('kaggle', True)])\ndef test_notebook_connected_show(fig1, name, connected):\n    pio.renderers.default = name\n    with mock.patch('IPython.display.display_html') as mock_display_html:\n        with mock.patch('IPython.display.display') as mock_display:\n            pio.show(fig1)\n    mock_call_args_html = mock_display_html.call_args\n    mock_arg1_html = mock_call_args_html[0][0]\n    bundle_display_html = mock_arg1_html\n    if connected:\n        assert_html_renderer_connected(bundle_display_html)\n    else:\n        assert_offline(bundle_display_html)\n    mock_call_args = mock_display.call_args\n    mock_arg1 = mock_call_args[0][0]\n    assert (list(mock_arg1) == '???')\n    bundle_html = mock_arg1['text/html']\n    assert_not_full_html(bundle_html)\n    mock_kwargs = mock_call_args[1]\n    assert (mock_kwargs == {'raw': True})", "ground_truth": "['text/html']", "quality_analysis": {"complexity_score": 7, "left_complexity": 4, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_61", "reponame": "plotly", "testpath": "tests/test_io/test_renderers.py", "testname": "test_renderers.py", "classname": null, "funcname": "test_browser_renderer_show", "imports": ["import json", "import threading", "import time", "import pytest", "import requests", "import numpy as np", "import webbrowser", "import plotly.graph_objs as go", "import plotly.io as pio", "from plotly.offline import get_plotlyjs", "from plotly.io._utils import plotly_cdn_url", "from plotly.io._html import _generate_sri_hash", "import unittest.mock as mock", "from unittest.mock import MagicMock"], "code": "@pytest.mark.parametrize('renderer', ['browser', 'chrome', 'chromium', 'firefox'])\ndef test_browser_renderer_show(fig1, renderer):\n    pio.renderers.default = renderer\n    renderer_obj = pio.renderers[renderer]\n    using = renderer_obj.using\n    if (not isinstance(renderer_obj.using, tuple)):\n        using = (using,)\n    mock_get = MagicMock(name='test get')\n    mock_browser = MagicMock(name='test browser')\n    mock_get.return_value = mock_browser\n    request_responses = []\n\n    def perform_request(url):\n        request_responses.append(requests.get(url))\n\n    def open_url(url, new=0, autoraise=True):\n        print('open url')\n        request_thread = threading.Thread(target=(lambda : perform_request(url)))\n        request_thread.daemon = True\n        request_thread.start()\n    mock_browser.open.side_effect = open_url\n    with mock.patch('webbrowser.get', mock_get):\n        pio.show(fig1)\n    mock_get.assert_any_call(using[0])\n    mock_call_args = mock_browser.open.call_args\n    mock_arg1 = mock_call_args[0][0]\n    mock_arg1.startswith('http://127.0.0.1:')\n    mock_kwargs = mock_call_args[1]\n    assert (mock_kwargs == dict(new=renderer_obj.new, autoraise=renderer_obj.autoraise))\n    tries = 0\n    while ((tries < 5) and (not request_responses)):\n        time.sleep(0.5)\n    assert (len(request_responses) == 1)\n    response = request_responses[0]\n    assert (response.status_code == 200)\n    html = response.content.decode('utf8')\n    assert_full_html(html)\n    assert_offline(html)", "masked_code": "@pytest.mark.parametrize('renderer', ['browser', 'chrome', 'chromium', 'firefox'])\ndef test_browser_renderer_show(fig1, renderer):\n    pio.renderers.default = renderer\n    renderer_obj = pio.renderers[renderer]\n    using = renderer_obj.using\n    if (not isinstance(renderer_obj.using, tuple)):\n        using = (using,)\n    mock_get = MagicMock(name='test get')\n    mock_browser = MagicMock(name='test browser')\n    mock_get.return_value = mock_browser\n    request_responses = []\n\n    def perform_request(url):\n        request_responses.append(requests.get(url))\n\n    def open_url(url, new=0, autoraise=True):\n        print('open url')\n        request_thread = threading.Thread(target=(lambda : perform_request(url)))\n        request_thread.daemon = True\n        request_thread.start()\n    mock_browser.open.side_effect = open_url\n    with mock.patch('webbrowser.get', mock_get):\n        pio.show(fig1)\n    mock_get.assert_any_call(using[0])\n    mock_call_args = mock_browser.open.call_args\n    mock_arg1 = mock_call_args[0][0]\n    mock_arg1.startswith('http://127.0.0.1:')\n    mock_kwargs = mock_call_args[1]\n    assert (mock_kwargs == dict(new=renderer_obj.new, autoraise=renderer_obj.autoraise))\n    tries = 0\n    while ((tries < 5) and (not request_responses)):\n        time.sleep(0.5)\n    assert (len(request_responses) == 1)\n    response = request_responses[0]\n    assert (response.status_code == '???')\n    html = response.content.decode('utf8')\n    assert_full_html(html)\n    assert_offline(html)", "ground_truth": "200", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_62", "reponame": "plotly", "testpath": "tests/test_io/test_renderers.py", "testname": "test_renderers.py", "classname": null, "funcname": "test_repr_html", "imports": ["import json", "import threading", "import time", "import pytest", "import requests", "import numpy as np", "import webbrowser", "import plotly.graph_objs as go", "import plotly.io as pio", "from plotly.offline import get_plotlyjs", "from plotly.io._utils import plotly_cdn_url", "from plotly.io._html import _generate_sri_hash", "import unittest.mock as mock", "from unittest.mock import MagicMock"], "code": "@pytest.mark.parametrize('renderer', (plotly_mimetype_renderers + ['notebook', 'notebook_connected', 'browser', 'notebook+plotly_mimetype']))\ndef test_repr_html(renderer):\n    pio.renderers.default = renderer\n    fig = go.Figure()\n    fig.update_layout(template=None)\n    str_html = fig._repr_html_()\n    bundle = fig._repr_mimebundle_()\n    id_html = str_html.split('document.getElementById(\"')[1].split('\")')[0]\n    id_pattern = 'cd462b94-79ce-42a2-887f-2650a761a144'\n    plotlyjs_content = get_plotlyjs()\n    sri_hash = _generate_sri_hash(plotlyjs_content)\n    template = (((('<div>                        <script type=\"text/javascript\">window.PlotlyConfig = {MathJaxConfig: \\'local\\'};</script>\\n        <script charset=\"utf-8\" src=\"' + plotly_cdn_url()) + '\" integrity=\"') + sri_hash) + '\" crossorigin=\"anonymous\"></script>                <div id=\"cd462b94-79ce-42a2-887f-2650a761a144\" class=\"plotly-graph-div\" style=\"height:100%; width:100%;\"></div>            <script type=\"text/javascript\">                window.PLOTLYENV=window.PLOTLYENV || {};                                if (document.getElementById(\"cd462b94-79ce-42a2-887f-2650a761a144\")) {                    Plotly.newPlot(                        \"cd462b94-79ce-42a2-887f-2650a761a144\",                        [],                        {\"template\":{}},                        {\"responsive\": true}                    )                };            </script>        </div>')\n    if ('text/html' in bundle):\n        str_bundle = bundle['text/html']\n        id_bundle = str_bundle.split('document.getElementById(\"')[1].split('\")')[0]\n        assert (str_html.replace(id_html, '') == str_bundle.replace(id_bundle, ''))\n    else:\n        assert (str_html.replace(id_html, '') == template.replace(id_pattern, ''))", "masked_code": "@pytest.mark.parametrize('renderer', (plotly_mimetype_renderers + ['notebook', 'notebook_connected', 'browser', 'notebook+plotly_mimetype']))\ndef test_repr_html(renderer):\n    pio.renderers.default = renderer\n    fig = go.Figure()\n    fig.update_layout(template=None)\n    str_html = fig._repr_html_()\n    bundle = fig._repr_mimebundle_()\n    id_html = str_html.split('document.getElementById(\"')[1].split('\")')[0]\n    id_pattern = 'cd462b94-79ce-42a2-887f-2650a761a144'\n    plotlyjs_content = get_plotlyjs()\n    sri_hash = _generate_sri_hash(plotlyjs_content)\n    template = (((('<div>                        <script type=\"text/javascript\">window.PlotlyConfig = {MathJaxConfig: \\'local\\'};</script>\\n        <script charset=\"utf-8\" src=\"' + plotly_cdn_url()) + '\" integrity=\"') + sri_hash) + '\" crossorigin=\"anonymous\"></script>                <div id=\"cd462b94-79ce-42a2-887f-2650a761a144\" class=\"plotly-graph-div\" style=\"height:100%; width:100%;\"></div>            <script type=\"text/javascript\">                window.PLOTLYENV=window.PLOTLYENV || {};                                if (document.getElementById(\"cd462b94-79ce-42a2-887f-2650a761a144\")) {                    Plotly.newPlot(                        \"cd462b94-79ce-42a2-887f-2650a761a144\",                        [],                        {\"template\":{}},                        {\"responsive\": true}                    )                };            </script>        </div>')\n    if ('text/html' in bundle):\n        str_bundle = bundle['text/html']\n        id_bundle = str_bundle.split('document.getElementById(\"')[1].split('\")')[0]\n        assert (str_html.replace(id_html, '') == '???')\n    else:\n        assert (str_html.replace(id_html, '') == template.replace(id_pattern, ''))", "ground_truth": "str_bundle.replace(id_bundle, '')", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_63", "reponame": "plotly", "testpath": "tests/test_io/test_renderers.py", "testname": "test_renderers.py", "classname": null, "funcname": "test_repr_html", "imports": ["import json", "import threading", "import time", "import pytest", "import requests", "import numpy as np", "import webbrowser", "import plotly.graph_objs as go", "import plotly.io as pio", "from plotly.offline import get_plotlyjs", "from plotly.io._utils import plotly_cdn_url", "from plotly.io._html import _generate_sri_hash", "import unittest.mock as mock", "from unittest.mock import MagicMock"], "code": "@pytest.mark.parametrize('renderer', (plotly_mimetype_renderers + ['notebook', 'notebook_connected', 'browser', 'notebook+plotly_mimetype']))\ndef test_repr_html(renderer):\n    pio.renderers.default = renderer\n    fig = go.Figure()\n    fig.update_layout(template=None)\n    str_html = fig._repr_html_()\n    bundle = fig._repr_mimebundle_()\n    id_html = str_html.split('document.getElementById(\"')[1].split('\")')[0]\n    id_pattern = 'cd462b94-79ce-42a2-887f-2650a761a144'\n    plotlyjs_content = get_plotlyjs()\n    sri_hash = _generate_sri_hash(plotlyjs_content)\n    template = (((('<div>                        <script type=\"text/javascript\">window.PlotlyConfig = {MathJaxConfig: \\'local\\'};</script>\\n        <script charset=\"utf-8\" src=\"' + plotly_cdn_url()) + '\" integrity=\"') + sri_hash) + '\" crossorigin=\"anonymous\"></script>                <div id=\"cd462b94-79ce-42a2-887f-2650a761a144\" class=\"plotly-graph-div\" style=\"height:100%; width:100%;\"></div>            <script type=\"text/javascript\">                window.PLOTLYENV=window.PLOTLYENV || {};                                if (document.getElementById(\"cd462b94-79ce-42a2-887f-2650a761a144\")) {                    Plotly.newPlot(                        \"cd462b94-79ce-42a2-887f-2650a761a144\",                        [],                        {\"template\":{}},                        {\"responsive\": true}                    )                };            </script>        </div>')\n    if ('text/html' in bundle):\n        str_bundle = bundle['text/html']\n        id_bundle = str_bundle.split('document.getElementById(\"')[1].split('\")')[0]\n        assert (str_html.replace(id_html, '') == str_bundle.replace(id_bundle, ''))\n    else:\n        assert (str_html.replace(id_html, '') == template.replace(id_pattern, ''))", "masked_code": "@pytest.mark.parametrize('renderer', (plotly_mimetype_renderers + ['notebook', 'notebook_connected', 'browser', 'notebook+plotly_mimetype']))\ndef test_repr_html(renderer):\n    pio.renderers.default = renderer\n    fig = go.Figure()\n    fig.update_layout(template=None)\n    str_html = fig._repr_html_()\n    bundle = fig._repr_mimebundle_()\n    id_html = str_html.split('document.getElementById(\"')[1].split('\")')[0]\n    id_pattern = 'cd462b94-79ce-42a2-887f-2650a761a144'\n    plotlyjs_content = get_plotlyjs()\n    sri_hash = _generate_sri_hash(plotlyjs_content)\n    template = (((('<div>                        <script type=\"text/javascript\">window.PlotlyConfig = {MathJaxConfig: \\'local\\'};</script>\\n        <script charset=\"utf-8\" src=\"' + plotly_cdn_url()) + '\" integrity=\"') + sri_hash) + '\" crossorigin=\"anonymous\"></script>                <div id=\"cd462b94-79ce-42a2-887f-2650a761a144\" class=\"plotly-graph-div\" style=\"height:100%; width:100%;\"></div>            <script type=\"text/javascript\">                window.PLOTLYENV=window.PLOTLYENV || {};                                if (document.getElementById(\"cd462b94-79ce-42a2-887f-2650a761a144\")) {                    Plotly.newPlot(                        \"cd462b94-79ce-42a2-887f-2650a761a144\",                        [],                        {\"template\":{}},                        {\"responsive\": true}                    )                };            </script>        </div>')\n    if ('text/html' in bundle):\n        str_bundle = bundle['text/html']\n        id_bundle = str_bundle.split('document.getElementById(\"')[1].split('\")')[0]\n        assert (str_html.replace(id_html, '') == str_bundle.replace(id_bundle, ''))\n    else:\n        assert (str_html.replace(id_html, '') == '???')", "ground_truth": "template.replace(id_pattern, '')", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_64", "reponame": "plotly", "testpath": "tests/test_io/test_renderers.py", "testname": "test_renderers.py", "classname": null, "funcname": "test_repr_mimebundle", "imports": ["import json", "import threading", "import time", "import pytest", "import requests", "import numpy as np", "import webbrowser", "import plotly.graph_objs as go", "import plotly.io as pio", "from plotly.offline import get_plotlyjs", "from plotly.io._utils import plotly_cdn_url", "from plotly.io._html import _generate_sri_hash", "import unittest.mock as mock", "from unittest.mock import MagicMock"], "code": "@pytest.mark.parametrize('renderer_str', all_renderers_without_orca)\ndef test_repr_mimebundle(renderer_str):\n    pio.renderers.default = renderer_str\n    fig = go.Figure()\n    fig.update_layout(template=None)\n    bundle = fig._repr_mimebundle_()\n    renderer = pio.renderers[renderer_str]\n    from plotly.io._renderers import MimetypeRenderer\n    if isinstance(renderer, MimetypeRenderer):\n        ref_bundle = renderer.to_mimebundle(fig.to_dict())\n        for key in bundle:\n            if ('getElementById' in bundle[key]):\n                id1 = bundle[key].split('document.getElementById(\"')[1].split('\")')[0]\n                id2 = ref_bundle[key].split('document.getElementById(\"')[1].split('\")')[0]\n                assert (bundle[key].replace(id1, '') == ref_bundle[key].replace(id2, ''))\n    else:\n        assert (bundle == {})", "masked_code": "@pytest.mark.parametrize('renderer_str', all_renderers_without_orca)\ndef test_repr_mimebundle(renderer_str):\n    pio.renderers.default = renderer_str\n    fig = go.Figure()\n    fig.update_layout(template=None)\n    bundle = fig._repr_mimebundle_()\n    renderer = pio.renderers[renderer_str]\n    from plotly.io._renderers import MimetypeRenderer\n    if isinstance(renderer, MimetypeRenderer):\n        ref_bundle = renderer.to_mimebundle(fig.to_dict())\n        for key in bundle:\n            if ('getElementById' in bundle[key]):\n                id1 = bundle[key].split('document.getElementById(\"')[1].split('\")')[0]\n                id2 = ref_bundle[key].split('document.getElementById(\"')[1].split('\")')[0]\n                assert (bundle[key].replace(id1, '') == '???')\n    else:\n        assert (bundle == {})", "ground_truth": "ref_bundle[key].replace(id2, '')", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_65", "reponame": "plotly", "testpath": "tests/test_io/test_renderers.py", "testname": "test_renderers.py", "classname": null, "funcname": "test_repr_mimebundle_mixed_renderer", "imports": ["import json", "import threading", "import time", "import pytest", "import requests", "import numpy as np", "import webbrowser", "import plotly.graph_objs as go", "import plotly.io as pio", "from plotly.offline import get_plotlyjs", "from plotly.io._utils import plotly_cdn_url", "from plotly.io._html import _generate_sri_hash", "import unittest.mock as mock", "from unittest.mock import MagicMock"], "code": "def test_repr_mimebundle_mixed_renderer(fig1):\n    pio.renderers.default = 'notebook+plotly_mimetype'\n    assert (set(fig1._repr_mimebundle_().keys()) == set({'application/vnd.plotly.v1+json', 'text/html'}))", "masked_code": "def test_repr_mimebundle_mixed_renderer(fig1):\n    pio.renderers.default = 'notebook+plotly_mimetype'\n    assert (set(fig1._repr_mimebundle_().keys()) == '???')", "ground_truth": "set({'application/vnd.plotly.v1+json', 'text/html'})", "quality_analysis": {"complexity_score": 9, "left_complexity": 6, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_66", "reponame": "plotly", "testpath": "tests/test_io/test_to_from_json.py", "testname": "test_to_from_json.py", "classname": null, "funcname": "test_to_json", "imports": ["import plotly.graph_objs as go", "import plotly.io as pio", "import pytest", "import plotly", "import numpy as np", "import json", "import os", "import tempfile", "from unittest.mock import MagicMock", "from pathlib import Path"], "code": "def test_to_json(fig1):\n    assert (pio.to_json(fig1, remove_uids=False) == json.dumps(fig1, **opts))", "masked_code": "def test_to_json(fig1):\n    assert (pio.to_json(fig1, remove_uids=False) == '???')", "ground_truth": "json.dumps(fig1, **opts)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_67", "reponame": "plotly", "testpath": "tests/test_io/test_to_from_json.py", "testname": "test_to_from_json.py", "classname": null, "funcname": "test_to_json_remove_uids", "imports": ["import plotly.graph_objs as go", "import plotly.io as pio", "import pytest", "import plotly", "import numpy as np", "import json", "import os", "import tempfile", "from unittest.mock import MagicMock", "from pathlib import Path"], "code": "def test_to_json_remove_uids(fig1):\n    dict1 = fig1.to_dict()\n    for trace in dict1['data']:\n        trace.pop('uid', None)\n    assert (pio.to_json(fig1) == json.dumps(dict1, **opts))", "masked_code": "def test_to_json_remove_uids(fig1):\n    dict1 = fig1.to_dict()\n    for trace in dict1['data']:\n        trace.pop('uid', None)\n    assert (pio.to_json(fig1) == '???')", "ground_truth": "json.dumps(dict1, **opts)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_68", "reponame": "plotly", "testpath": "tests/test_io/test_to_from_json.py", "testname": "test_to_from_json.py", "classname": null, "funcname": "test_to_json_validate_false", "imports": ["import plotly.graph_objs as go", "import plotly.io as pio", "import pytest", "import plotly", "import numpy as np", "import json", "import os", "import tempfile", "from unittest.mock import MagicMock", "from pathlib import Path"], "code": "def test_to_json_validate_false(fig1):\n    dict1 = fig1.to_dict()\n    dict1['layout']['bogus'] = 37\n    assert (pio.to_json(dict1, validate=False) == json.dumps(dict1, **opts))", "masked_code": "def test_to_json_validate_false(fig1):\n    dict1 = fig1.to_dict()\n    dict1['layout']['bogus'] = 37\n    assert (pio.to_json(dict1, validate=False) == '???')", "ground_truth": "json.dumps(dict1, **opts)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_69", "reponame": "plotly", "testpath": "tests/test_io/test_to_from_json.py", "testname": "test_to_from_json.py", "classname": null, "funcname": "test_to_json_pretty_print", "imports": ["import plotly.graph_objs as go", "import plotly.io as pio", "import pytest", "import plotly", "import numpy as np", "import json", "import os", "import tempfile", "from unittest.mock import MagicMock", "from pathlib import Path"], "code": "def test_to_json_pretty_print(fig1):\n    assert (pio.to_json(fig1, remove_uids=False, pretty=True) == json.dumps(fig1, **pretty_opts))", "masked_code": "def test_to_json_pretty_print(fig1):\n    assert (pio.to_json(fig1, remove_uids=False, pretty=True) == '???')", "ground_truth": "json.dumps(fig1, **pretty_opts)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_70", "reponame": "plotly", "testpath": "tests/test_io/test_to_from_json.py", "testname": "test_to_from_json.py", "classname": null, "funcname": "test_from_json", "imports": ["import plotly.graph_objs as go", "import plotly.io as pio", "import pytest", "import plotly", "import numpy as np", "import json", "import os", "import tempfile", "from unittest.mock import MagicMock", "from pathlib import Path"], "code": "def test_from_json(fig1):\n    fig1_json = json.dumps(fig1, **opts)\n    fig1_loaded = pio.from_json(fig1_json)\n    assert isinstance(fig1_loaded, go.Figure)\n    assert (pio.to_json(fig1_loaded) == pio.to_json(fig1.to_dict()))", "masked_code": "def test_from_json(fig1):\n    fig1_json = json.dumps(fig1, **opts)\n    fig1_loaded = pio.from_json(fig1_json)\n    assert isinstance(fig1_loaded, go.Figure)\n    assert (pio.to_json(fig1_loaded) == '???')", "ground_truth": "pio.to_json(fig1.to_dict())", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_71", "reponame": "plotly", "testpath": "tests/test_io/test_to_from_json.py", "testname": "test_to_from_json.py", "classname": null, "funcname": "test_from_json_output_type", "imports": ["import plotly.graph_objs as go", "import plotly.io as pio", "import pytest", "import plotly", "import numpy as np", "import json", "import os", "import tempfile", "from unittest.mock import MagicMock", "from pathlib import Path"], "code": "@pytest.mark.parametrize('fig_type_spec,fig_type', [('Figure', go.Figure), (go.Figure, go.Figure), ('FigureWidget', go.FigureWidget), (go.FigureWidget, go.FigureWidget)])\ndef test_from_json_output_type(fig1, fig_type_spec, fig_type):\n    fig1_json = json.dumps(fig1, **opts)\n    fig1_loaded = pio.from_json(fig1_json, output_type=fig_type_spec)\n    assert isinstance(fig1_loaded, fig_type)\n    assert (pio.to_json(fig1_loaded) == pio.to_json(fig1.to_dict()))", "masked_code": "@pytest.mark.parametrize('fig_type_spec,fig_type', [('Figure', go.Figure), (go.Figure, go.Figure), ('FigureWidget', go.FigureWidget), (go.FigureWidget, go.FigureWidget)])\ndef test_from_json_output_type(fig1, fig_type_spec, fig_type):\n    fig1_json = json.dumps(fig1, **opts)\n    fig1_loaded = pio.from_json(fig1_json, output_type=fig_type_spec)\n    assert isinstance(fig1_loaded, fig_type)\n    assert (pio.to_json(fig1_loaded) == '???')", "ground_truth": "pio.to_json(fig1.to_dict())", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_72", "reponame": "plotly", "testpath": "tests/test_io/test_to_from_json.py", "testname": "test_to_from_json.py", "classname": null, "funcname": "test_from_json_skip_invalid", "imports": ["import plotly.graph_objs as go", "import plotly.io as pio", "import pytest", "import plotly", "import numpy as np", "import json", "import os", "import tempfile", "from unittest.mock import MagicMock", "from pathlib import Path"], "code": "def test_from_json_skip_invalid(fig1):\n    dict1 = fig1.to_dict()\n    dict1['data'][0]['marker']['bogus'] = 123\n    dict1['data'][0]['marker']['size'] = (- 1)\n    bad_json = json.dumps(dict1, **opts)\n    fig1_loaded = pio.from_json(bad_json, skip_invalid=True)\n    assert (pio.to_json(fig1_loaded) == pio.to_json(fig1.to_dict()))", "masked_code": "def test_from_json_skip_invalid(fig1):\n    dict1 = fig1.to_dict()\n    dict1['data'][0]['marker']['bogus'] = 123\n    dict1['data'][0]['marker']['size'] = (- 1)\n    bad_json = json.dumps(dict1, **opts)\n    fig1_loaded = pio.from_json(bad_json, skip_invalid=True)\n    assert (pio.to_json(fig1_loaded) == '???')", "ground_truth": "pio.to_json(fig1.to_dict())", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_73", "reponame": "plotly", "testpath": "tests/test_io/test_to_from_json.py", "testname": "test_to_from_json.py", "classname": null, "funcname": "test_read_json_from_filelike", "imports": ["import plotly.graph_objs as go", "import plotly.io as pio", "import pytest", "import plotly", "import numpy as np", "import json", "import os", "import tempfile", "from unittest.mock import MagicMock", "from pathlib import Path"], "code": "@pytest.mark.parametrize('fig_type_spec,fig_type', [('Figure', go.Figure), (go.Figure, go.Figure), ('FigureWidget', go.FigureWidget), (go.FigureWidget, go.FigureWidget)])\ndef test_read_json_from_filelike(fig1, fig_type_spec, fig_type):\n    filemock = MagicMock()\n    del filemock.read_text\n    filemock.read.return_value = pio.to_json(fig1)\n    fig1_loaded = pio.read_json(filemock, output_type=fig_type_spec)\n    assert isinstance(fig1_loaded, fig_type)\n    assert (pio.to_json(fig1_loaded) == pio.to_json(fig1.to_dict()))", "masked_code": "@pytest.mark.parametrize('fig_type_spec,fig_type', [('Figure', go.Figure), (go.Figure, go.Figure), ('FigureWidget', go.FigureWidget), (go.FigureWidget, go.FigureWidget)])\ndef test_read_json_from_filelike(fig1, fig_type_spec, fig_type):\n    filemock = MagicMock()\n    del filemock.read_text\n    filemock.read.return_value = pio.to_json(fig1)\n    fig1_loaded = pio.read_json(filemock, output_type=fig_type_spec)\n    assert isinstance(fig1_loaded, fig_type)\n    assert (pio.to_json(fig1_loaded) == '???')", "ground_truth": "pio.to_json(fig1.to_dict())", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_74", "reponame": "plotly", "testpath": "tests/test_io/test_to_from_json.py", "testname": "test_to_from_json.py", "classname": null, "funcname": "test_read_json_from_pathlib", "imports": ["import plotly.graph_objs as go", "import plotly.io as pio", "import pytest", "import plotly", "import numpy as np", "import json", "import os", "import tempfile", "from unittest.mock import MagicMock", "from pathlib import Path"], "code": "@pytest.mark.parametrize('fig_type_spec,fig_type', [('Figure', go.Figure), (go.Figure, go.Figure), ('FigureWidget', go.FigureWidget), (go.FigureWidget, go.FigureWidget)])\ndef test_read_json_from_pathlib(fig1, fig_type_spec, fig_type):\n    filemock = MagicMock(spec=Path)\n    filemock.read_text.return_value = pio.to_json(fig1)\n    fig1_loaded = pio.read_json(filemock, output_type=fig_type_spec)\n    assert isinstance(fig1_loaded, fig_type)\n    assert (pio.to_json(fig1_loaded) == pio.to_json(fig1.to_dict()))", "masked_code": "@pytest.mark.parametrize('fig_type_spec,fig_type', [('Figure', go.Figure), (go.Figure, go.Figure), ('FigureWidget', go.FigureWidget), (go.FigureWidget, go.FigureWidget)])\ndef test_read_json_from_pathlib(fig1, fig_type_spec, fig_type):\n    filemock = MagicMock(spec=Path)\n    filemock.read_text.return_value = pio.to_json(fig1)\n    fig1_loaded = pio.read_json(filemock, output_type=fig_type_spec)\n    assert isinstance(fig1_loaded, fig_type)\n    assert (pio.to_json(fig1_loaded) == '???')", "ground_truth": "pio.to_json(fig1.to_dict())", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_75", "reponame": "plotly", "testpath": "tests/test_io/test_to_from_json.py", "testname": "test_to_from_json.py", "classname": null, "funcname": "test_read_json_from_file_string", "imports": ["import plotly.graph_objs as go", "import plotly.io as pio", "import pytest", "import plotly", "import numpy as np", "import json", "import os", "import tempfile", "from unittest.mock import MagicMock", "from pathlib import Path"], "code": "@pytest.mark.parametrize('fig_type_spec,fig_type', [('Figure', go.Figure), (go.Figure, go.Figure), ('FigureWidget', go.FigureWidget), (go.FigureWidget, go.FigureWidget)])\ndef test_read_json_from_file_string(fig1, fig_type_spec, fig_type):\n    with tempfile.TemporaryDirectory() as dir_name:\n        path = os.path.join(dir_name, 'fig1.json')\n        with open(path, 'w') as f:\n            f.write(pio.to_json(fig1))\n        fig1_loaded = pio.read_json(path, output_type=fig_type_spec)\n        assert isinstance(fig1_loaded, fig_type)\n        assert (pio.to_json(fig1_loaded) == pio.to_json(fig1.to_dict()))", "masked_code": "@pytest.mark.parametrize('fig_type_spec,fig_type', [('Figure', go.Figure), (go.Figure, go.Figure), ('FigureWidget', go.FigureWidget), (go.FigureWidget, go.FigureWidget)])\ndef test_read_json_from_file_string(fig1, fig_type_spec, fig_type):\n    with tempfile.TemporaryDirectory() as dir_name:\n        path = os.path.join(dir_name, 'fig1.json')\n        with open(path, 'w') as f:\n            f.write(pio.to_json(fig1))\n        fig1_loaded = pio.read_json(path, output_type=fig_type_spec)\n        assert isinstance(fig1_loaded, fig_type)\n        assert (pio.to_json(fig1_loaded) == '???')", "ground_truth": "pio.to_json(fig1.to_dict())", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_76", "reponame": "plotly", "testpath": "tests/test_optional/test_autoshapes/test_annotated_shapes.py", "testname": "test_annotated_shapes.py", "classname": null, "funcname": "test_add_shape_no_annotation", "imports": ["import plotly.graph_objects as go", "from plotly.subplots import make_subplots", "from itertools import product", "import os", "import pytest", "import json", "from .common import _cmp_partial_dict"], "code": "def test_add_shape_no_annotation(multi_plot_fixture):\n    multi_plot_fixture.add_hline(y=2, row='all', col='all')\n    assert (len(multi_plot_fixture.layout.annotations) == 0)\n    assert (len(multi_plot_fixture.layout.shapes) == 4)", "masked_code": "def test_add_shape_no_annotation(multi_plot_fixture):\n    multi_plot_fixture.add_hline(y=2, row='all', col='all')\n    assert (len(multi_plot_fixture.layout.annotations) == 0)\n    assert (len(multi_plot_fixture.layout.shapes) == '???')", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_77", "reponame": "plotly", "testpath": "tests/test_optional/test_figure_factory/test_figure_factory.py", "testname": "test_figure_factory.py", "classname": "TestTernarycontour", "funcname": "test_optional_arguments", "imports": ["from plotly import optional_imports", "from plotly.graph_objs import graph_objs as go", "from plotly.exceptions import PlotlyError", "import plotly.figure_factory as ff", "from ...test_optional.optional_utils import NumpyTestUtilsMixin", "from ...test_optional.test_utils.test_utils import np_inf", "import numpy as np", "from ...utils import TestCaseNoTemplate", "from scipy.spatial import Delaunay", "import pandas as pd"], "code": "def test_optional_arguments(self):\n    (a, b) = np.mgrid[(0:1:20j, 0:1:20j)]\n    mask = ((a + b) <= 1.0)\n    a = a[mask].ravel()\n    b = b[mask].ravel()\n    c = ((1 - a) - b)\n    z = ((a * b) * c)\n    ncontours = 7\n    args = [dict(showmarkers=False, showscale=False), dict(showmarkers=True, showscale=False), dict(showmarkers=False, showscale=True), dict(showmarkers=True, showscale=True)]\n    for arg_set in args:\n        fig = ff.create_ternary_contour(np.stack((a, b, c)), z, interp_mode='cartesian', ncontours=ncontours, **arg_set)\n        print(len(fig.data))\n        assert (len(fig.data) == ((ncontours + 2) + arg_set['showscale']))", "masked_code": "def test_optional_arguments(self):\n    (a, b) = np.mgrid[(0:1:20j, 0:1:20j)]\n    mask = ((a + b) <= 1.0)\n    a = a[mask].ravel()\n    b = b[mask].ravel()\n    c = ((1 - a) - b)\n    z = ((a * b) * c)\n    ncontours = 7\n    args = [dict(showmarkers=False, showscale=False), dict(showmarkers=True, showscale=False), dict(showmarkers=False, showscale=True), dict(showmarkers=True, showscale=True)]\n    for arg_set in args:\n        fig = ff.create_ternary_contour(np.stack((a, b, c)), z, interp_mode='cartesian', ncontours=ncontours, **arg_set)\n        print(len(fig.data))\n        assert (len(fig.data) == '???')", "ground_truth": "((ncontours + 2) + arg_set['showscale'])", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_78", "reponame": "plotly", "testpath": "tests/test_optional/test_figure_factory/test_figure_factory.py", "testname": "test_figure_factory.py", "classname": "TestHexbinMapbox", "funcname": "test_aggregation", "imports": ["from plotly import optional_imports", "from plotly.graph_objs import graph_objs as go", "from plotly.exceptions import PlotlyError", "import plotly.figure_factory as ff", "from ...test_optional.optional_utils import NumpyTestUtilsMixin", "from ...test_optional.test_utils.test_utils import np_inf", "import numpy as np", "from ...utils import TestCaseNoTemplate", "from scipy.spatial import Delaunay", "import pandas as pd"], "code": "def test_aggregation(self):\n    lat = [0, 1, 1, 2, 4, 5, 1, 2, 4, 5, 2, 3, 2, 1, 5, 3, 5]\n    lon = [1, 2, 3, 3, 0, 4, 5, 0, 5, 3, 1, 5, 4, 0, 1, 2, 5]\n    color = np.ones(len(lat))\n    fig1 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=1)\n    actual_geojson = {'type': 'FeatureCollection', 'features': [{'type': 'Feature', 'id': '-8.726646259971648e-11,-0.031886255679892235', 'geometry': {'type': 'Polygon', 'coordinates': [[[(- 5e-09), (- 4.7083909316316985)], [2.4999999999999996, (- 3.268549270944215)], [2.4999999999999996, (- 0.38356933397072673)], [(- 5e-09), 1.0597430482129082], [(- 2.50000001), (- 0.38356933397072673)], [(- 2.50000001), (- 3.268549270944215)], [(- 5e-09), (- 4.7083909316316985)]]]}}, {'type': 'Feature', 'id': '-8.726646259971648e-11,0.1192636916419258', 'geometry': {'type': 'Polygon', 'coordinates': [[[(- 5e-09), 3.9434377827164666], [2.4999999999999996, 5.381998306154031], [2.4999999999999996, 8.248045720432454], [(- 5e-09), 9.673766164509932], [(- 2.50000001), 8.248045720432454], [(- 2.50000001), 5.381998306154031], [(- 5e-09), 3.9434377827164666]]]}}, {'type': 'Feature', 'id': '0.08726646268698293,-0.031886255679892235', 'geometry': {'type': 'Polygon', 'coordinates': [[[5.0000000049999995, (- 4.7083909316316985)], [7.500000009999999, (- 3.268549270944215)], [7.500000009999999, (- 0.38356933397072673)], [5.0000000049999995, 1.0597430482129082], [2.5, (- 0.38356933397072673)], [2.5, (- 3.268549270944215)], [5.0000000049999995, (- 4.7083909316316985)]]]}}, {'type': 'Feature', 'id': '0.08726646268698293,0.1192636916419258', 'geometry': {'type': 'Polygon', 'coordinates': [[[5.0000000049999995, 3.9434377827164666], [7.500000009999999, 5.381998306154031], [7.500000009999999, 8.248045720432454], [5.0000000049999995, 9.673766164509932], [2.5, 8.248045720432454], [2.5, 5.381998306154031], [5.0000000049999995, 3.9434377827164666]]]}}, {'type': 'Feature', 'id': '0.04363323129985823,0.04368871798101678', 'geometry': {'type': 'Polygon', 'coordinates': [[[2.4999999999999996, (- 0.38356933397072673)], [5.0000000049999995, 1.0597430482129082], [5.0000000049999995, 3.9434377827164666], [2.4999999999999996, 5.381998306154031], [(- 5.0000001310894304e-09), 3.9434377827164666], [(- 5.0000001310894304e-09), 1.0597430482129082], [2.4999999999999996, (- 0.38356933397072673)]]]}}]}\n    actual_agg = [2.0, 2.0, 1.0, 3.0, 9.0]\n    self.compare_dict_values(fig1.data[0].geojson, actual_geojson)\n    assert np.array_equal(fig1.data[0].z, actual_agg)\n    fig2 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=1, color=color, agg_func=np.mean)\n    assert np.array_equal(fig2.data[0].z, np.ones(5))\n    fig3 = ff.create_hexbin_mapbox(lat=np.random.randn(1000), lon=np.random.randn(1000), nx_hexagon=20)\n    assert (fig3.data[0].z.sum() == 1000)", "masked_code": "def test_aggregation(self):\n    lat = [0, 1, 1, 2, 4, 5, 1, 2, 4, 5, 2, 3, 2, 1, 5, 3, 5]\n    lon = [1, 2, 3, 3, 0, 4, 5, 0, 5, 3, 1, 5, 4, 0, 1, 2, 5]\n    color = np.ones(len(lat))\n    fig1 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=1)\n    actual_geojson = {'type': 'FeatureCollection', 'features': [{'type': 'Feature', 'id': '-8.726646259971648e-11,-0.031886255679892235', 'geometry': {'type': 'Polygon', 'coordinates': [[[(- 5e-09), (- 4.7083909316316985)], [2.4999999999999996, (- 3.268549270944215)], [2.4999999999999996, (- 0.38356933397072673)], [(- 5e-09), 1.0597430482129082], [(- 2.50000001), (- 0.38356933397072673)], [(- 2.50000001), (- 3.268549270944215)], [(- 5e-09), (- 4.7083909316316985)]]]}}, {'type': 'Feature', 'id': '-8.726646259971648e-11,0.1192636916419258', 'geometry': {'type': 'Polygon', 'coordinates': [[[(- 5e-09), 3.9434377827164666], [2.4999999999999996, 5.381998306154031], [2.4999999999999996, 8.248045720432454], [(- 5e-09), 9.673766164509932], [(- 2.50000001), 8.248045720432454], [(- 2.50000001), 5.381998306154031], [(- 5e-09), 3.9434377827164666]]]}}, {'type': 'Feature', 'id': '0.08726646268698293,-0.031886255679892235', 'geometry': {'type': 'Polygon', 'coordinates': [[[5.0000000049999995, (- 4.7083909316316985)], [7.500000009999999, (- 3.268549270944215)], [7.500000009999999, (- 0.38356933397072673)], [5.0000000049999995, 1.0597430482129082], [2.5, (- 0.38356933397072673)], [2.5, (- 3.268549270944215)], [5.0000000049999995, (- 4.7083909316316985)]]]}}, {'type': 'Feature', 'id': '0.08726646268698293,0.1192636916419258', 'geometry': {'type': 'Polygon', 'coordinates': [[[5.0000000049999995, 3.9434377827164666], [7.500000009999999, 5.381998306154031], [7.500000009999999, 8.248045720432454], [5.0000000049999995, 9.673766164509932], [2.5, 8.248045720432454], [2.5, 5.381998306154031], [5.0000000049999995, 3.9434377827164666]]]}}, {'type': 'Feature', 'id': '0.04363323129985823,0.04368871798101678', 'geometry': {'type': 'Polygon', 'coordinates': [[[2.4999999999999996, (- 0.38356933397072673)], [5.0000000049999995, 1.0597430482129082], [5.0000000049999995, 3.9434377827164666], [2.4999999999999996, 5.381998306154031], [(- 5.0000001310894304e-09), 3.9434377827164666], [(- 5.0000001310894304e-09), 1.0597430482129082], [2.4999999999999996, (- 0.38356933397072673)]]]}}]}\n    actual_agg = [2.0, 2.0, 1.0, 3.0, 9.0]\n    self.compare_dict_values(fig1.data[0].geojson, actual_geojson)\n    assert np.array_equal(fig1.data[0].z, actual_agg)\n    fig2 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=1, color=color, agg_func=np.mean)\n    assert np.array_equal(fig2.data[0].z, np.ones(5))\n    fig3 = ff.create_hexbin_mapbox(lat=np.random.randn(1000), lon=np.random.randn(1000), nx_hexagon=20)\n    assert (fig3.data[0].z.sum() == '???')", "ground_truth": "1000", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_79", "reponame": "plotly", "testpath": "tests/test_optional/test_figure_factory/test_figure_factory.py", "testname": "test_figure_factory.py", "classname": "TestHexbinMapbox", "funcname": "test_build_dataframe", "imports": ["from plotly import optional_imports", "from plotly.graph_objs import graph_objs as go", "from plotly.exceptions import PlotlyError", "import plotly.figure_factory as ff", "from ...test_optional.optional_utils import NumpyTestUtilsMixin", "from ...test_optional.test_utils.test_utils import np_inf", "import numpy as np", "from ...utils import TestCaseNoTemplate", "from scipy.spatial import Delaunay", "import pandas as pd"], "code": "def test_build_dataframe(self):\n    np.random.seed(0)\n    N = 10000\n    nx_hexagon = 20\n    n_frames = 3\n    lat = np.random.randn(N)\n    lon = np.random.randn(N)\n    color = np.ones(N)\n    frame = np.random.randint(0, n_frames, N)\n    df = pd.DataFrame(np.c_[(lat, lon, color, frame)], columns=['Latitude', 'Longitude', 'Metric', 'Frame'])\n    fig1 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon)\n    fig2 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon)\n    assert isinstance(fig1, go.Figure)\n    assert (len(fig1.data) == 1)\n    self.assert_dict_equal(fig1.to_plotly_json()['data'][0], fig2.to_plotly_json()['data'][0])\n    fig3 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum, min_count=0)\n    fig4 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum)\n    fig5 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon, color='Metric', agg_func=np.sum)\n    self.assert_dict_equal(fig1.to_plotly_json()['data'][0], fig3.to_plotly_json()['data'][0])\n    self.assert_dict_equal(fig4.to_plotly_json()['data'][0], fig5.to_plotly_json()['data'][0])\n    fig6 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon, color='Metric', agg_func=np.sum, animation_frame='Frame')\n    fig7 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum, animation_frame=frame)\n    assert (len(fig6.frames) == n_frames)\n    assert (len(fig7.frames) == n_frames)\n    assert (fig6.data[0].geojson == fig1.data[0].geojson)", "masked_code": "def test_build_dataframe(self):\n    np.random.seed(0)\n    N = 10000\n    nx_hexagon = 20\n    n_frames = 3\n    lat = np.random.randn(N)\n    lon = np.random.randn(N)\n    color = np.ones(N)\n    frame = np.random.randint(0, n_frames, N)\n    df = pd.DataFrame(np.c_[(lat, lon, color, frame)], columns=['Latitude', 'Longitude', 'Metric', 'Frame'])\n    fig1 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon)\n    fig2 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon)\n    assert isinstance(fig1, go.Figure)\n    assert (len(fig1.data) == 1)\n    self.assert_dict_equal(fig1.to_plotly_json()['data'][0], fig2.to_plotly_json()['data'][0])\n    fig3 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum, min_count=0)\n    fig4 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum)\n    fig5 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon, color='Metric', agg_func=np.sum)\n    self.assert_dict_equal(fig1.to_plotly_json()['data'][0], fig3.to_plotly_json()['data'][0])\n    self.assert_dict_equal(fig4.to_plotly_json()['data'][0], fig5.to_plotly_json()['data'][0])\n    fig6 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon, color='Metric', agg_func=np.sum, animation_frame='Frame')\n    fig7 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum, animation_frame=frame)\n    assert (len(fig6.frames) == '???')\n    assert (len(fig7.frames) == n_frames)\n    assert (fig6.data[0].geojson == fig1.data[0].geojson)", "ground_truth": "n_frames", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_80", "reponame": "plotly", "testpath": "tests/test_optional/test_figure_factory/test_figure_factory.py", "testname": "test_figure_factory.py", "classname": "TestHexbinMapbox", "funcname": "test_build_dataframe", "imports": ["from plotly import optional_imports", "from plotly.graph_objs import graph_objs as go", "from plotly.exceptions import PlotlyError", "import plotly.figure_factory as ff", "from ...test_optional.optional_utils import NumpyTestUtilsMixin", "from ...test_optional.test_utils.test_utils import np_inf", "import numpy as np", "from ...utils import TestCaseNoTemplate", "from scipy.spatial import Delaunay", "import pandas as pd"], "code": "def test_build_dataframe(self):\n    np.random.seed(0)\n    N = 10000\n    nx_hexagon = 20\n    n_frames = 3\n    lat = np.random.randn(N)\n    lon = np.random.randn(N)\n    color = np.ones(N)\n    frame = np.random.randint(0, n_frames, N)\n    df = pd.DataFrame(np.c_[(lat, lon, color, frame)], columns=['Latitude', 'Longitude', 'Metric', 'Frame'])\n    fig1 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon)\n    fig2 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon)\n    assert isinstance(fig1, go.Figure)\n    assert (len(fig1.data) == 1)\n    self.assert_dict_equal(fig1.to_plotly_json()['data'][0], fig2.to_plotly_json()['data'][0])\n    fig3 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum, min_count=0)\n    fig4 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum)\n    fig5 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon, color='Metric', agg_func=np.sum)\n    self.assert_dict_equal(fig1.to_plotly_json()['data'][0], fig3.to_plotly_json()['data'][0])\n    self.assert_dict_equal(fig4.to_plotly_json()['data'][0], fig5.to_plotly_json()['data'][0])\n    fig6 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon, color='Metric', agg_func=np.sum, animation_frame='Frame')\n    fig7 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum, animation_frame=frame)\n    assert (len(fig6.frames) == n_frames)\n    assert (len(fig7.frames) == n_frames)\n    assert (fig6.data[0].geojson == fig1.data[0].geojson)", "masked_code": "def test_build_dataframe(self):\n    np.random.seed(0)\n    N = 10000\n    nx_hexagon = 20\n    n_frames = 3\n    lat = np.random.randn(N)\n    lon = np.random.randn(N)\n    color = np.ones(N)\n    frame = np.random.randint(0, n_frames, N)\n    df = pd.DataFrame(np.c_[(lat, lon, color, frame)], columns=['Latitude', 'Longitude', 'Metric', 'Frame'])\n    fig1 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon)\n    fig2 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon)\n    assert isinstance(fig1, go.Figure)\n    assert (len(fig1.data) == 1)\n    self.assert_dict_equal(fig1.to_plotly_json()['data'][0], fig2.to_plotly_json()['data'][0])\n    fig3 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum, min_count=0)\n    fig4 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum)\n    fig5 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon, color='Metric', agg_func=np.sum)\n    self.assert_dict_equal(fig1.to_plotly_json()['data'][0], fig3.to_plotly_json()['data'][0])\n    self.assert_dict_equal(fig4.to_plotly_json()['data'][0], fig5.to_plotly_json()['data'][0])\n    fig6 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon, color='Metric', agg_func=np.sum, animation_frame='Frame')\n    fig7 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum, animation_frame=frame)\n    assert (len(fig6.frames) == n_frames)\n    assert (len(fig7.frames) == '???')\n    assert (fig6.data[0].geojson == fig1.data[0].geojson)", "ground_truth": "n_frames", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_81", "reponame": "plotly", "testpath": "tests/test_optional/test_figure_factory/test_figure_factory.py", "testname": "test_figure_factory.py", "classname": "TestHexbinMapbox", "funcname": "test_build_dataframe", "imports": ["from plotly import optional_imports", "from plotly.graph_objs import graph_objs as go", "from plotly.exceptions import PlotlyError", "import plotly.figure_factory as ff", "from ...test_optional.optional_utils import NumpyTestUtilsMixin", "from ...test_optional.test_utils.test_utils import np_inf", "import numpy as np", "from ...utils import TestCaseNoTemplate", "from scipy.spatial import Delaunay", "import pandas as pd"], "code": "def test_build_dataframe(self):\n    np.random.seed(0)\n    N = 10000\n    nx_hexagon = 20\n    n_frames = 3\n    lat = np.random.randn(N)\n    lon = np.random.randn(N)\n    color = np.ones(N)\n    frame = np.random.randint(0, n_frames, N)\n    df = pd.DataFrame(np.c_[(lat, lon, color, frame)], columns=['Latitude', 'Longitude', 'Metric', 'Frame'])\n    fig1 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon)\n    fig2 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon)\n    assert isinstance(fig1, go.Figure)\n    assert (len(fig1.data) == 1)\n    self.assert_dict_equal(fig1.to_plotly_json()['data'][0], fig2.to_plotly_json()['data'][0])\n    fig3 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum, min_count=0)\n    fig4 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum)\n    fig5 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon, color='Metric', agg_func=np.sum)\n    self.assert_dict_equal(fig1.to_plotly_json()['data'][0], fig3.to_plotly_json()['data'][0])\n    self.assert_dict_equal(fig4.to_plotly_json()['data'][0], fig5.to_plotly_json()['data'][0])\n    fig6 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon, color='Metric', agg_func=np.sum, animation_frame='Frame')\n    fig7 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum, animation_frame=frame)\n    assert (len(fig6.frames) == n_frames)\n    assert (len(fig7.frames) == n_frames)\n    assert (fig6.data[0].geojson == fig1.data[0].geojson)", "masked_code": "def test_build_dataframe(self):\n    np.random.seed(0)\n    N = 10000\n    nx_hexagon = 20\n    n_frames = 3\n    lat = np.random.randn(N)\n    lon = np.random.randn(N)\n    color = np.ones(N)\n    frame = np.random.randint(0, n_frames, N)\n    df = pd.DataFrame(np.c_[(lat, lon, color, frame)], columns=['Latitude', 'Longitude', 'Metric', 'Frame'])\n    fig1 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon)\n    fig2 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon)\n    assert isinstance(fig1, go.Figure)\n    assert (len(fig1.data) == 1)\n    self.assert_dict_equal(fig1.to_plotly_json()['data'][0], fig2.to_plotly_json()['data'][0])\n    fig3 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum, min_count=0)\n    fig4 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum)\n    fig5 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon, color='Metric', agg_func=np.sum)\n    self.assert_dict_equal(fig1.to_plotly_json()['data'][0], fig3.to_plotly_json()['data'][0])\n    self.assert_dict_equal(fig4.to_plotly_json()['data'][0], fig5.to_plotly_json()['data'][0])\n    fig6 = ff.create_hexbin_mapbox(data_frame=df, lat='Latitude', lon='Longitude', nx_hexagon=nx_hexagon, color='Metric', agg_func=np.sum, animation_frame='Frame')\n    fig7 = ff.create_hexbin_mapbox(lat=lat, lon=lon, nx_hexagon=nx_hexagon, color=color, agg_func=np.sum, animation_frame=frame)\n    assert (len(fig6.frames) == n_frames)\n    assert (len(fig7.frames) == n_frames)\n    assert (fig6.data[0].geojson == '???')", "ground_truth": "fig1.data[0].geojson", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_82", "reponame": "plotly", "testpath": "tests/test_optional/test_graph_objs/test_skipped_b64_keys.py", "testname": "test_skipped_b64_keys.py", "classname": "TestShouldNotUseBase64InUnsupportedKeys", "funcname": "test_np_geojson", "imports": ["import json", "from unittest import TestCase", "import numpy as np", "from ...test_optional.optional_utils import NumpyTestUtilsMixin", "import plotly.graph_objs as go"], "code": "def test_np_geojson(self):\n    normal_coordinates = [[[(- 87), 35], [(- 87), 30], [(- 85), 30], [(- 85), 35]]]\n    numpy_coordinates = np.array(normal_coordinates)\n    data = [{'type': 'choropleth', 'locations': ['AL'], 'featureidkey': 'properties.id', 'z': np.array([10]), 'geojson': {'type': 'Feature', 'properties': {'id': 'AL'}, 'geometry': {'type': 'Polygon', 'coordinates': numpy_coordinates}}}]\n    fig = go.Figure(data=data)\n    assert (json.loads(fig.to_json())['data'][0]['geojson']['geometry']['coordinates'] == normal_coordinates)", "masked_code": "def test_np_geojson(self):\n    normal_coordinates = [[[(- 87), 35], [(- 87), 30], [(- 85), 30], [(- 85), 35]]]\n    numpy_coordinates = np.array(normal_coordinates)\n    data = [{'type': 'choropleth', 'locations': ['AL'], 'featureidkey': 'properties.id', 'z': np.array([10]), 'geojson': {'type': 'Feature', 'properties': {'id': 'AL'}, 'geometry': {'type': 'Polygon', 'coordinates': numpy_coordinates}}}]\n    fig = go.Figure(data=data)\n    assert (json.loads(fig.to_json())['data'][0]['geojson']['geometry']['coordinates'] == '???')", "ground_truth": "normal_coordinates", "quality_analysis": {"complexity_score": 27, "left_complexity": 26, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_83", "reponame": "plotly", "testpath": "tests/test_optional/test_graph_objs/test_skipped_b64_keys.py", "testname": "test_skipped_b64_keys.py", "classname": "TestShouldNotUseBase64InUnsupportedKeys", "funcname": "test_np_layers", "imports": ["import json", "from unittest import TestCase", "import numpy as np", "from ...test_optional.optional_utils import NumpyTestUtilsMixin", "import plotly.graph_objs as go"], "code": "def test_np_layers(self):\n    layout = {'mapbox': {'layers': [{'sourcetype': 'geojson', 'type': 'line', 'line': {'dash': np.array([2.5, 1])}, 'source': {'type': 'FeatureCollection', 'features': [{'type': 'Feature', 'geometry': {'type': 'LineString', 'coordinates': np.array([[0.25, 52], [0.75, 50]])}}]}}], 'center': {'lon': 0.5, 'lat': 51}}}\n    data = [{'type': 'scattermap'}]\n    fig = go.Figure(data=data, layout=layout)\n    assert (fig.layout['mapbox']['layers'][0]['line']['dash'] == (2.5, 1)).all()\n    assert (json.loads(fig.to_json())['layout']['mapbox']['layers'][0]['source']['features'][0]['geometry']['coordinates'] == [[0.25, 52], [0.75, 50]])", "masked_code": "def test_np_layers(self):\n    layout = {'mapbox': {'layers': [{'sourcetype': 'geojson', 'type': 'line', 'line': {'dash': np.array([2.5, 1])}, 'source': {'type': 'FeatureCollection', 'features': [{'type': 'Feature', 'geometry': {'type': 'LineString', 'coordinates': np.array([[0.25, 52], [0.75, 50]])}}]}}], 'center': {'lon': 0.5, 'lat': 51}}}\n    data = [{'type': 'scattermap'}]\n    fig = go.Figure(data=data, layout=layout)\n    assert (fig.layout['mapbox']['layers'][0]['line']['dash'] == (2.5, 1)).all()\n    assert (json.loads(fig.to_json())['layout']['mapbox']['layers'][0]['source']['features'][0]['geometry']['coordinates'] == '???')", "ground_truth": "[[0.25, 52], [0.75, 50]]", "quality_analysis": {"complexity_score": 52, "left_complexity": 42, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_84", "reponame": "plotly", "testpath": "tests/test_optional/test_graph_objs/test_skipped_b64_keys.py", "testname": "test_skipped_b64_keys.py", "classname": "TestShouldNotUseBase64InUnsupportedKeys", "funcname": "test_np_range", "imports": ["import json", "from unittest import TestCase", "import numpy as np", "from ...test_optional.optional_utils import NumpyTestUtilsMixin", "import plotly.graph_objs as go"], "code": "def test_np_range(self):\n    layout = {'xaxis': {'range': np.array([0, 1])}}\n    fig = go.Figure(data=[{'type': 'scatter'}], layout=layout)\n    assert (json.loads(fig.to_json())['layout']['xaxis']['range'] == [0, 1])", "masked_code": "def test_np_range(self):\n    layout = {'xaxis': {'range': np.array([0, 1])}}\n    fig = go.Figure(data=[{'type': 'scatter'}], layout=layout)\n    assert (json.loads(fig.to_json())['layout']['xaxis']['range'] == '???')", "ground_truth": "[0, 1]", "quality_analysis": {"complexity_score": 22, "left_complexity": 18, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_85", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_kaleido_fulljson", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_kaleido_fulljson():\n    empty_fig = dict(data=[], layout={})\n    result = pio.full_figure_for_development(empty_fig, warn=False, as_dict=True)\n    assert (result['layout']['calendar'] == 'gregorian')", "masked_code": "def test_kaleido_fulljson():\n    empty_fig = dict(data=[], layout={})\n    result = pio.full_figure_for_development(empty_fig, warn=False, as_dict=True)\n    assert (result['layout']['calendar'] == '???')", "ground_truth": "'gregorian'", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_86", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == '???')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'png'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_87", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == '???')\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "700", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_88", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == '???')\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "500", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_89", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == '???')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'svg'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_90", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == '???')\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "701", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_91", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == '???')\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "501", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_92", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == '???')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_93", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == '???')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'path/to/topojson/files/'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_94", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == '???')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'https://cdn.plot.ly/plotly-3.0.0.js'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_95", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == '???')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'png'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_96", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == '???')\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "700", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_97", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == '???')\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "500", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_98", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == '???')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'svg'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_99", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == '???')\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "701", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_100", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == '???')\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "501", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_101", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == '???')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_102", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == '???')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'path/to/topojson/files/'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_103", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == '???')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'https://cdn.plot.ly/plotly-3.0.0.js'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_104", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == '???')\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "test_fig.to_dict()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_105", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == '???')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'svg'", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_106", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == '???')\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "701", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_107", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == '???')\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "501", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_108", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == '???')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'path/to/topojson/files/'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_109", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == '???')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_110", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_defaults", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "masked_code": "def test_defaults():\n    'Test that image output defaults can be set using pio.defaults.*'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    assert (pio.defaults.default_format == 'png')\n    assert (pio.defaults.default_width == 700)\n    assert (pio.defaults.default_height == 500)\n    assert (pio.defaults.default_scale == 1)\n    assert (pio.defaults.mathjax is None)\n    assert (pio.defaults.topojson is None)\n    assert (pio.defaults.plotlyjs is None)\n    try:\n        pio.defaults.default_format = 'svg'\n        pio.defaults.default_width = 701\n        pio.defaults.default_height = 501\n        pio.defaults.default_scale = 2\n        pio.defaults.mathjax = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js'\n        pio.defaults.topojson = 'path/to/topojson/files/'\n        pio.defaults.plotlyjs = 'https://cdn.plot.ly/plotly-3.0.0.js'\n        assert (pio.defaults.default_format == 'svg')\n        assert (pio.defaults.default_width == 701)\n        assert (pio.defaults.default_height == 501)\n        assert (pio.defaults.default_scale == 2)\n        assert (pio.defaults.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n        assert (pio.defaults.topojson == 'path/to/topojson/files/')\n        assert (pio.defaults.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        if (kaleido_major() > 0):\n            with patch('plotly.io._kaleido.kaleido.calc_fig_sync', return_value=test_image_bytes) as mock_calc_fig:\n                result = pio.to_image(test_fig, validate=False)\n                mock_calc_fig.assert_called_once()\n                (args, kwargs) = mock_calc_fig.call_args\n                assert (args[0] == test_fig.to_dict())\n                assert (kwargs['opts']['format'] == 'svg')\n                assert (kwargs['opts']['width'] == 701)\n                assert (kwargs['opts']['height'] == 501)\n                assert (kwargs['opts']['scale'] == 2)\n                assert (kwargs['topojson'] == 'path/to/topojson/files/')\n                assert (kwargs['kopts']['mathjax'] == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n                assert (kwargs['kopts']['plotlyjs'] == '???')\n        else:\n            assert (pio._kaleido.scope.default_format == 'svg')\n            assert (pio._kaleido.scope.default_width == 701)\n            assert (pio._kaleido.scope.default_height == 501)\n            assert (pio._kaleido.scope.default_scale == 2)\n            assert (pio._kaleido.scope.mathjax == 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js')\n            assert (pio._kaleido.scope.topojson == 'path/to/topojson/files/')\n            assert (pio._kaleido.scope.plotlyjs == 'https://cdn.plot.ly/plotly-3.0.0.js')\n        pio.defaults.topojson = None\n        result = test_fig.to_image(format='svg', validate=False)\n        assert result.startswith(b'<svg')\n    finally:\n        pio.defaults.default_format = 'png'\n        pio.defaults.default_width = 700\n        pio.defaults.default_height = 500\n        pio.defaults.default_scale = 1\n        pio.defaults.mathjax = None\n        pio.defaults.topojson = None\n        pio.defaults.plotlyjs = None\n        assert (pio.defaults.default_format == 'png')\n        assert (pio.defaults.default_width == 700)\n        assert (pio.defaults.default_height == 500)\n        assert (pio.defaults.default_scale == 1)\n        assert (pio.defaults.mathjax is None)\n        assert (pio.defaults.topojson is None)\n        assert (pio.defaults.plotlyjs is None)", "ground_truth": "'https://cdn.plot.ly/plotly-3.0.0.js'", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_111", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_fig_write_image", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_fig_write_image():\n    'Test that fig.write_image() calls the correct underlying Kaleido function.'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    if (kaleido_major() > 0):\n        patch_funcname = 'plotly.io._kaleido.kaleido.calc_fig_sync'\n    else:\n        patch_funcname = 'plotly.io._kaleido.scope.transform'\n    with patch(patch_funcname, return_value=test_image_bytes) as mock_calc_fig:\n        test_fig.write_image('test_path.png')\n        mock_calc_fig.assert_called_once()\n        (args, _) = mock_calc_fig.call_args\n        assert (args[0] == test_fig.to_dict())", "masked_code": "def test_fig_write_image():\n    'Test that fig.write_image() calls the correct underlying Kaleido function.'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    if (kaleido_major() > 0):\n        patch_funcname = 'plotly.io._kaleido.kaleido.calc_fig_sync'\n    else:\n        patch_funcname = 'plotly.io._kaleido.scope.transform'\n    with patch(patch_funcname, return_value=test_image_bytes) as mock_calc_fig:\n        test_fig.write_image('test_path.png')\n        mock_calc_fig.assert_called_once()\n        (args, _) = mock_calc_fig.call_args\n        assert (args[0] == '???')", "ground_truth": "test_fig.to_dict()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_112", "reponame": "plotly", "testpath": "tests/test_optional/test_kaleido/test_kaleido.py", "testname": "test_kaleido.py", "classname": null, "funcname": "test_fig_to_image", "imports": ["import base64", "from contextlib import redirect_stdout", "from io import BytesIO, StringIO", "from pathlib import Path", "import tempfile", "from unittest.mock import patch", "from pdfrw import PdfReader", "from PIL import Image", "import plotly.graph_objects as go", "import plotly.io as pio", "from plotly.io.kaleido import kaleido_available, kaleido_major", "import pytest"], "code": "def test_fig_to_image():\n    'Test that fig.to_image() calls the correct underlying Kaleido function.'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    if (kaleido_major() > 0):\n        patch_funcname = 'plotly.io._kaleido.kaleido.calc_fig_sync'\n    else:\n        patch_funcname = 'plotly.io._kaleido.scope.transform'\n    with patch(patch_funcname, return_value=test_image_bytes) as mock_calc_fig:\n        test_fig.to_image()\n        mock_calc_fig.assert_called_once()\n        (args, _) = mock_calc_fig.call_args\n        assert (args[0] == test_fig.to_dict())", "masked_code": "def test_fig_to_image():\n    'Test that fig.to_image() calls the correct underlying Kaleido function.'\n    test_fig = go.Figure(fig)\n    test_image_bytes = b'mock image data'\n    if (kaleido_major() > 0):\n        patch_funcname = 'plotly.io._kaleido.kaleido.calc_fig_sync'\n    else:\n        patch_funcname = 'plotly.io._kaleido.scope.transform'\n    with patch(patch_funcname, return_value=test_image_bytes) as mock_calc_fig:\n        test_fig.to_image()\n        mock_calc_fig.assert_called_once()\n        (args, _) = mock_calc_fig.call_args\n        assert (args[0] == '???')", "ground_truth": "test_fig.to_dict()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_113", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "masked_code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == '???')\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "ground_truth": "(0.0, 1.0)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_114", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "masked_code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == '???')\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "ground_truth": "(0.0, 1.0)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_115", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "masked_code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == '???')\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "ground_truth": "approx(0.02)", "quality_analysis": {"complexity_score": 18, "left_complexity": 14, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_116", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "masked_code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == '???')\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "ground_truth": "approx(0.03)", "quality_analysis": {"complexity_score": 18, "left_complexity": 14, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_117", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "masked_code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == '???')\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "ground_truth": "approx(0.02)", "quality_analysis": {"complexity_score": 18, "left_complexity": 14, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_118", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "masked_code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == '???')\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "ground_truth": "approx(0.07)", "quality_analysis": {"complexity_score": 18, "left_complexity": 14, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_119", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "masked_code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == '???')\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "ground_truth": "approx(0.09)", "quality_analysis": {"complexity_score": 18, "left_complexity": 14, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_120", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "masked_code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == '???')\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "ground_truth": "approx(0.08)", "quality_analysis": {"complexity_score": 18, "left_complexity": 14, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_121", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "masked_code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == '???')\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "ground_truth": "approx(0.09)", "quality_analysis": {"complexity_score": 18, "left_complexity": 14, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_122", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))", "masked_code": "def test_facets(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.scatter(df, x='total_bill', y='tip')\n    assert ('xaxis2' not in fig.layout)\n    assert ('yaxis2' not in fig.layout)\n    assert (fig.layout.xaxis.domain == (0.0, 1.0))\n    assert (fig.layout.yaxis.domain == (0.0, 1.0))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker')\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.03))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.02))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.07))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='smoker', facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == approx(0.08))\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, facet_col_spacing=0.09, facet_row_spacing=0.08)\n    assert ((fig.layout.xaxis4.domain[0] - fig.layout.xaxis.domain[1]) == approx(0.09))\n    assert ((fig.layout.yaxis4.domain[0] - fig.layout.yaxis.domain[1]) == '???')", "ground_truth": "approx(0.08)", "quality_analysis": {"complexity_score": 18, "left_complexity": 14, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_123", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets_with_marginals", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == 8)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "masked_code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == '???')\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == 8)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_124", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets_with_marginals", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == 8)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "masked_code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == '???')\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == 8)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_125", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets_with_marginals", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == 8)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "masked_code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == '???')\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == 8)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_126", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets_with_marginals", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == 8)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "masked_code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == '???')\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "ground_truth": "8", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_127", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets_with_marginals", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == 8)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "masked_code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == 8)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == '???')\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_128", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets_with_marginals", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == 8)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "masked_code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == 8)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == '???')\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_129", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_facets.py", "testname": "test_facets.py", "classname": null, "funcname": "test_facets_with_marginals", "imports": ["import plotly.express as px", "from pytest import approx", "import pytest", "import random"], "code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == 8)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "masked_code": "def test_facets_with_marginals(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.histogram(df, x='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_col='sex', marginal='rug')\n    assert (len(fig.data) == 2)\n    fig = px.histogram(df, y='total_bill', facet_row='sex', marginal='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='day', facet_col_wrap=2, marginal_x='rug')\n    assert (len(fig.data) == 8)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_x='rug')\n    assert (len(fig.data) == 2)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='total_bill', y='tip', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == '???')\n    fig = px.scatter(df, x='total_bill', y='tip', facet_row='sex', facet_col='sex', marginal_y='rug', marginal_x='rug')\n    assert (len(fig.data) == 2)", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_130", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_zmax", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_zmax():\n    for zmax in [100, [100], (100,), [100, 100, 100], (100, 100, 100), (100, 100, 100, 255)]:\n        fig = px.imshow(img_rgb, zmax=zmax, binary_string=False)\n        assert (fig.data[0]['zmax'] == (100, 100, 100, 255))", "masked_code": "def test_zmax():\n    for zmax in [100, [100], (100,), [100, 100, 100], (100, 100, 100), (100, 100, 100, 255)]:\n        fig = px.imshow(img_rgb, zmax=zmax, binary_string=False)\n        assert (fig.data[0]['zmax'] == '???')", "ground_truth": "(100, 100, 100, 255)", "quality_analysis": {"complexity_score": 16, "left_complexity": 10, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_131", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_automatic_zmax_from_dtype", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_automatic_zmax_from_dtype():\n    dtypes_dict = {np.uint8: ((2 ** 8) - 1), np.uint16: ((2 ** 16) - 1), float: 1, bool: 255}\n    for (key, val) in dtypes_dict.items():\n        img = np.array([0, 1], dtype=key)\n        img = np.dstack(((img,) * 3))\n        fig = px.imshow(img, binary_string=False)\n        if (key in [np.uint8, bool]):\n            assert (fig.data[0]['zmax'] is None)\n        else:\n            assert (fig.data[0]['zmax'] == (val, val, val, 255))", "masked_code": "def test_automatic_zmax_from_dtype():\n    dtypes_dict = {np.uint8: ((2 ** 8) - 1), np.uint16: ((2 ** 16) - 1), float: 1, bool: 255}\n    for (key, val) in dtypes_dict.items():\n        img = np.array([0, 1], dtype=key)\n        img = np.dstack(((img,) * 3))\n        fig = px.imshow(img, binary_string=False)\n        if (key in [np.uint8, bool]):\n            assert (fig.data[0]['zmax'] is None)\n        else:\n            assert (fig.data[0]['zmax'] == '???')", "ground_truth": "(val, val, val, 255)", "quality_analysis": {"complexity_score": 16, "left_complexity": 10, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_132", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_origin", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('binary_string', [False, True])\n@pytest.mark.parametrize('binary_format', ['png', 'jpg'])\ndef test_origin(binary_string, binary_format):\n    for (i, img) in enumerate([img_rgb, img_gray]):\n        fig = px.imshow(img, origin='lower', binary_string=binary_string, binary_format=binary_format)\n        assert (fig.layout.yaxis.autorange is True)\n        if (binary_string and (i == 0) and (binary_format == 'png')):\n            assert np.all((img[::(- 1)] == decode_image_string(fig.data[0].source)))\n        if binary_string:\n            if (binary_format == 'jpg'):\n                assert (fig.data[0].source[:15] == 'data:image/jpeg')\n            else:\n                assert (fig.data[0].source[:14] == 'data:image/png')\n    fig = px.imshow(img_rgb, binary_string=binary_string)\n    assert (fig.layout.yaxis.autorange is None)\n    fig = px.imshow(img_gray, binary_string=binary_string)\n    if binary_string:\n        assert (fig.layout.yaxis.autorange is None)\n    else:\n        assert (fig.layout.yaxis.autorange == 'reversed')", "masked_code": "@pytest.mark.parametrize('binary_string', [False, True])\n@pytest.mark.parametrize('binary_format', ['png', 'jpg'])\ndef test_origin(binary_string, binary_format):\n    for (i, img) in enumerate([img_rgb, img_gray]):\n        fig = px.imshow(img, origin='lower', binary_string=binary_string, binary_format=binary_format)\n        assert (fig.layout.yaxis.autorange is True)\n        if (binary_string and (i == 0) and (binary_format == 'png')):\n            assert np.all((img[::(- 1)] == decode_image_string(fig.data[0].source)))\n        if binary_string:\n            if (binary_format == 'jpg'):\n                assert (fig.data[0].source[:15] == 'data:image/jpeg')\n            else:\n                assert (fig.data[0].source[:14] == 'data:image/png')\n    fig = px.imshow(img_rgb, binary_string=binary_string)\n    assert (fig.layout.yaxis.autorange is None)\n    fig = px.imshow(img_gray, binary_string=binary_string)\n    if binary_string:\n        assert (fig.layout.yaxis.autorange is None)\n    else:\n        assert (fig.layout.yaxis.autorange == '???')", "ground_truth": "'reversed'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_133", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_origin", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('binary_string', [False, True])\n@pytest.mark.parametrize('binary_format', ['png', 'jpg'])\ndef test_origin(binary_string, binary_format):\n    for (i, img) in enumerate([img_rgb, img_gray]):\n        fig = px.imshow(img, origin='lower', binary_string=binary_string, binary_format=binary_format)\n        assert (fig.layout.yaxis.autorange is True)\n        if (binary_string and (i == 0) and (binary_format == 'png')):\n            assert np.all((img[::(- 1)] == decode_image_string(fig.data[0].source)))\n        if binary_string:\n            if (binary_format == 'jpg'):\n                assert (fig.data[0].source[:15] == 'data:image/jpeg')\n            else:\n                assert (fig.data[0].source[:14] == 'data:image/png')\n    fig = px.imshow(img_rgb, binary_string=binary_string)\n    assert (fig.layout.yaxis.autorange is None)\n    fig = px.imshow(img_gray, binary_string=binary_string)\n    if binary_string:\n        assert (fig.layout.yaxis.autorange is None)\n    else:\n        assert (fig.layout.yaxis.autorange == 'reversed')", "masked_code": "@pytest.mark.parametrize('binary_string', [False, True])\n@pytest.mark.parametrize('binary_format', ['png', 'jpg'])\ndef test_origin(binary_string, binary_format):\n    for (i, img) in enumerate([img_rgb, img_gray]):\n        fig = px.imshow(img, origin='lower', binary_string=binary_string, binary_format=binary_format)\n        assert (fig.layout.yaxis.autorange is True)\n        if (binary_string and (i == 0) and (binary_format == 'png')):\n            assert np.all((img[::(- 1)] == decode_image_string(fig.data[0].source)))\n        if binary_string:\n            if (binary_format == 'jpg'):\n                assert (fig.data[0].source[:15] == '???')\n            else:\n                assert (fig.data[0].source[:14] == 'data:image/png')\n    fig = px.imshow(img_rgb, binary_string=binary_string)\n    assert (fig.layout.yaxis.autorange is None)\n    fig = px.imshow(img_gray, binary_string=binary_string)\n    if binary_string:\n        assert (fig.layout.yaxis.autorange is None)\n    else:\n        assert (fig.layout.yaxis.autorange == 'reversed')", "ground_truth": "'data:image/jpeg'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_134", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_origin", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('binary_string', [False, True])\n@pytest.mark.parametrize('binary_format', ['png', 'jpg'])\ndef test_origin(binary_string, binary_format):\n    for (i, img) in enumerate([img_rgb, img_gray]):\n        fig = px.imshow(img, origin='lower', binary_string=binary_string, binary_format=binary_format)\n        assert (fig.layout.yaxis.autorange is True)\n        if (binary_string and (i == 0) and (binary_format == 'png')):\n            assert np.all((img[::(- 1)] == decode_image_string(fig.data[0].source)))\n        if binary_string:\n            if (binary_format == 'jpg'):\n                assert (fig.data[0].source[:15] == 'data:image/jpeg')\n            else:\n                assert (fig.data[0].source[:14] == 'data:image/png')\n    fig = px.imshow(img_rgb, binary_string=binary_string)\n    assert (fig.layout.yaxis.autorange is None)\n    fig = px.imshow(img_gray, binary_string=binary_string)\n    if binary_string:\n        assert (fig.layout.yaxis.autorange is None)\n    else:\n        assert (fig.layout.yaxis.autorange == 'reversed')", "masked_code": "@pytest.mark.parametrize('binary_string', [False, True])\n@pytest.mark.parametrize('binary_format', ['png', 'jpg'])\ndef test_origin(binary_string, binary_format):\n    for (i, img) in enumerate([img_rgb, img_gray]):\n        fig = px.imshow(img, origin='lower', binary_string=binary_string, binary_format=binary_format)\n        assert (fig.layout.yaxis.autorange is True)\n        if (binary_string and (i == 0) and (binary_format == 'png')):\n            assert np.all((img[::(- 1)] == decode_image_string(fig.data[0].source)))\n        if binary_string:\n            if (binary_format == 'jpg'):\n                assert (fig.data[0].source[:15] == 'data:image/jpeg')\n            else:\n                assert (fig.data[0].source[:14] == '???')\n    fig = px.imshow(img_rgb, binary_string=binary_string)\n    assert (fig.layout.yaxis.autorange is None)\n    fig = px.imshow(img_gray, binary_string=binary_string)\n    if binary_string:\n        assert (fig.layout.yaxis.autorange is None)\n    else:\n        assert (fig.layout.yaxis.autorange == 'reversed')", "ground_truth": "'data:image/png'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_135", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_colorscale", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_colorscale():\n    fig = px.imshow(img_gray)\n    plasma_first_color = px.colors.sequential.Plasma[0]\n    assert (fig.layout.coloraxis1.colorscale[0] == (0.0, plasma_first_color))\n    fig = px.imshow(img_gray, color_continuous_scale='Viridis')\n    assert (fig.layout.coloraxis1.colorscale[0] == (0.0, '#440154'))", "masked_code": "def test_colorscale():\n    fig = px.imshow(img_gray)\n    plasma_first_color = px.colors.sequential.Plasma[0]\n    assert (fig.layout.coloraxis1.colorscale[0] == '???')\n    fig = px.imshow(img_gray, color_continuous_scale='Viridis')\n    assert (fig.layout.coloraxis1.colorscale[0] == (0.0, '#440154'))", "ground_truth": "(0.0, plasma_first_color)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_136", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_colorscale", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_colorscale():\n    fig = px.imshow(img_gray)\n    plasma_first_color = px.colors.sequential.Plasma[0]\n    assert (fig.layout.coloraxis1.colorscale[0] == (0.0, plasma_first_color))\n    fig = px.imshow(img_gray, color_continuous_scale='Viridis')\n    assert (fig.layout.coloraxis1.colorscale[0] == (0.0, '#440154'))", "masked_code": "def test_colorscale():\n    fig = px.imshow(img_gray)\n    plasma_first_color = px.colors.sequential.Plasma[0]\n    assert (fig.layout.coloraxis1.colorscale[0] == (0.0, plasma_first_color))\n    fig = px.imshow(img_gray, color_continuous_scale='Viridis')\n    assert (fig.layout.coloraxis1.colorscale[0] == '???')", "ground_truth": "(0.0, '#440154')", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_137", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_nan_inf_data", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_nan_inf_data(binary_string):\n    imgs = [np.ones((20, 20)), (255 * np.ones((20, 20)))]\n    zmaxs = [1, 255]\n    for (zmax, img) in zip(zmaxs, imgs):\n        img[0] = 0\n        img[10:12] = np_nan()\n        fig = px.imshow(np.dstack(((img,) * 3)), binary_string=binary_string, contrast_rescaling='minxmax')\n        if (not binary_string):\n            assert (fig.data[0]['zmax'] == (zmax, zmax, zmax, 255))\n        else:\n            assert (fig.data[0]['zmax'] is None)", "masked_code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_nan_inf_data(binary_string):\n    imgs = [np.ones((20, 20)), (255 * np.ones((20, 20)))]\n    zmaxs = [1, 255]\n    for (zmax, img) in zip(zmaxs, imgs):\n        img[0] = 0\n        img[10:12] = np_nan()\n        fig = px.imshow(np.dstack(((img,) * 3)), binary_string=binary_string, contrast_rescaling='minxmax')\n        if (not binary_string):\n            assert (fig.data[0]['zmax'] == '???')\n        else:\n            assert (fig.data[0]['zmax'] is None)", "ground_truth": "(zmax, zmax, zmax, 255)", "quality_analysis": {"complexity_score": 16, "left_complexity": 10, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_138", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_zmax_floats", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_zmax_floats():\n    imgs = [np.ones((5, 5, 3)), (1.02 * np.ones((5, 5, 3))), (2 * np.ones((5, 5, 3))), (1000 * np.ones((5, 5, 3)))]\n    zmaxs = [1, 1, 255, 65535]\n    for (zmax, img) in zip(zmaxs, imgs):\n        fig = px.imshow(img, binary_string=False)\n        assert (fig.data[0]['zmax'] == (zmax, zmax, zmax, 255))\n    imgs = [np.ones((5, 5)), (1.02 * np.ones((5, 5))), (2 * np.ones((5, 5))), (1000 * np.ones((5, 5)))]\n    for (zmax, img) in zip(zmaxs, imgs):\n        fig = px.imshow(img)\n        assert (fig.data[0]['zmax'] is None)", "masked_code": "def test_zmax_floats():\n    imgs = [np.ones((5, 5, 3)), (1.02 * np.ones((5, 5, 3))), (2 * np.ones((5, 5, 3))), (1000 * np.ones((5, 5, 3)))]\n    zmaxs = [1, 1, 255, 65535]\n    for (zmax, img) in zip(zmaxs, imgs):\n        fig = px.imshow(img, binary_string=False)\n        assert (fig.data[0]['zmax'] == '???')\n    imgs = [np.ones((5, 5)), (1.02 * np.ones((5, 5))), (2 * np.ones((5, 5))), (1000 * np.ones((5, 5)))]\n    for (zmax, img) in zip(zmaxs, imgs):\n        fig = px.imshow(img)\n        assert (fig.data[0]['zmax'] is None)", "ground_truth": "(zmax, zmax, zmax, 255)", "quality_analysis": {"complexity_score": 16, "left_complexity": 10, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_139", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_zmin_zmax_range_color", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_zmin_zmax_range_color():\n    img = (img_gray / 100.0)\n    fig = px.imshow(img)\n    fig1 = px.imshow(img, zmin=0.2, zmax=0.8)\n    fig2 = px.imshow(img, range_color=[0.2, 0.8])\n    assert (fig1 == fig2)\n    fig = px.imshow(img, zmin=0.3, zmax=0.9, range_color=[0.2, 0.8])\n    assert (fig.layout.coloraxis.cmin == 0.2)\n    assert (fig.layout.coloraxis.cmax == 0.8)\n    fig = px.imshow(img, zmax=0.8)\n    assert (fig.layout.coloraxis.cmin == 0.0)\n    assert (fig.layout.coloraxis.cmax == 0.8)", "masked_code": "def test_zmin_zmax_range_color():\n    img = (img_gray / 100.0)\n    fig = px.imshow(img)\n    fig1 = px.imshow(img, zmin=0.2, zmax=0.8)\n    fig2 = px.imshow(img, range_color=[0.2, 0.8])\n    assert (fig1 == fig2)\n    fig = px.imshow(img, zmin=0.3, zmax=0.9, range_color=[0.2, 0.8])\n    assert (fig.layout.coloraxis.cmin == '???')\n    assert (fig.layout.coloraxis.cmax == 0.8)\n    fig = px.imshow(img, zmax=0.8)\n    assert (fig.layout.coloraxis.cmin == 0.0)\n    assert (fig.layout.coloraxis.cmax == 0.8)", "ground_truth": "0.2", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_140", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_zmin_zmax_range_color", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_zmin_zmax_range_color():\n    img = (img_gray / 100.0)\n    fig = px.imshow(img)\n    fig1 = px.imshow(img, zmin=0.2, zmax=0.8)\n    fig2 = px.imshow(img, range_color=[0.2, 0.8])\n    assert (fig1 == fig2)\n    fig = px.imshow(img, zmin=0.3, zmax=0.9, range_color=[0.2, 0.8])\n    assert (fig.layout.coloraxis.cmin == 0.2)\n    assert (fig.layout.coloraxis.cmax == 0.8)\n    fig = px.imshow(img, zmax=0.8)\n    assert (fig.layout.coloraxis.cmin == 0.0)\n    assert (fig.layout.coloraxis.cmax == 0.8)", "masked_code": "def test_zmin_zmax_range_color():\n    img = (img_gray / 100.0)\n    fig = px.imshow(img)\n    fig1 = px.imshow(img, zmin=0.2, zmax=0.8)\n    fig2 = px.imshow(img, range_color=[0.2, 0.8])\n    assert (fig1 == fig2)\n    fig = px.imshow(img, zmin=0.3, zmax=0.9, range_color=[0.2, 0.8])\n    assert (fig.layout.coloraxis.cmin == 0.2)\n    assert (fig.layout.coloraxis.cmax == '???')\n    fig = px.imshow(img, zmax=0.8)\n    assert (fig.layout.coloraxis.cmin == 0.0)\n    assert (fig.layout.coloraxis.cmax == 0.8)", "ground_truth": "0.8", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_141", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_zmin_zmax_range_color", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_zmin_zmax_range_color():\n    img = (img_gray / 100.0)\n    fig = px.imshow(img)\n    fig1 = px.imshow(img, zmin=0.2, zmax=0.8)\n    fig2 = px.imshow(img, range_color=[0.2, 0.8])\n    assert (fig1 == fig2)\n    fig = px.imshow(img, zmin=0.3, zmax=0.9, range_color=[0.2, 0.8])\n    assert (fig.layout.coloraxis.cmin == 0.2)\n    assert (fig.layout.coloraxis.cmax == 0.8)\n    fig = px.imshow(img, zmax=0.8)\n    assert (fig.layout.coloraxis.cmin == 0.0)\n    assert (fig.layout.coloraxis.cmax == 0.8)", "masked_code": "def test_zmin_zmax_range_color():\n    img = (img_gray / 100.0)\n    fig = px.imshow(img)\n    fig1 = px.imshow(img, zmin=0.2, zmax=0.8)\n    fig2 = px.imshow(img, range_color=[0.2, 0.8])\n    assert (fig1 == fig2)\n    fig = px.imshow(img, zmin=0.3, zmax=0.9, range_color=[0.2, 0.8])\n    assert (fig.layout.coloraxis.cmin == 0.2)\n    assert (fig.layout.coloraxis.cmax == 0.8)\n    fig = px.imshow(img, zmax=0.8)\n    assert (fig.layout.coloraxis.cmin == 0.0)\n    assert (fig.layout.coloraxis.cmax == '???')", "ground_truth": "0.8", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_142", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_xarray", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_imshow_xarray(binary_string):\n    img = np.random.random((20, 30))\n    da = xr.DataArray(img, dims=['dim_rows', 'dim_cols'])\n    fig = px.imshow(da, binary_string=binary_string)\n    assert (fig.layout.xaxis.title.text == 'dim_cols')\n    assert (fig.layout.yaxis.title.text == 'dim_rows')\n    if (not binary_string):\n        assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_cols'])))", "masked_code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_imshow_xarray(binary_string):\n    img = np.random.random((20, 30))\n    da = xr.DataArray(img, dims=['dim_rows', 'dim_cols'])\n    fig = px.imshow(da, binary_string=binary_string)\n    assert (fig.layout.xaxis.title.text == '???')\n    assert (fig.layout.yaxis.title.text == 'dim_rows')\n    if (not binary_string):\n        assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_cols'])))", "ground_truth": "'dim_cols'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_143", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_xarray", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_imshow_xarray(binary_string):\n    img = np.random.random((20, 30))\n    da = xr.DataArray(img, dims=['dim_rows', 'dim_cols'])\n    fig = px.imshow(da, binary_string=binary_string)\n    assert (fig.layout.xaxis.title.text == 'dim_cols')\n    assert (fig.layout.yaxis.title.text == 'dim_rows')\n    if (not binary_string):\n        assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_cols'])))", "masked_code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_imshow_xarray(binary_string):\n    img = np.random.random((20, 30))\n    da = xr.DataArray(img, dims=['dim_rows', 'dim_cols'])\n    fig = px.imshow(da, binary_string=binary_string)\n    assert (fig.layout.xaxis.title.text == 'dim_cols')\n    assert (fig.layout.yaxis.title.text == '???')\n    if (not binary_string):\n        assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_cols'])))", "ground_truth": "'dim_rows'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_144", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_xarray_slicethrough", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_xarray_slicethrough():\n    img = np.random.random((8, 9, 10))\n    da = xr.DataArray(img, dims=['dim_0', 'dim_1', 'dim_2'])\n    fig = px.imshow(da, animation_frame='dim_0')\n    assert (fig.layout.xaxis.title.text == 'dim_2')\n    assert (fig.layout.yaxis.title.text == 'dim_1')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_2'])))", "masked_code": "def test_imshow_xarray_slicethrough():\n    img = np.random.random((8, 9, 10))\n    da = xr.DataArray(img, dims=['dim_0', 'dim_1', 'dim_2'])\n    fig = px.imshow(da, animation_frame='dim_0')\n    assert (fig.layout.xaxis.title.text == '???')\n    assert (fig.layout.yaxis.title.text == 'dim_1')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_2'])))", "ground_truth": "'dim_2'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_145", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_xarray_slicethrough", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_xarray_slicethrough():\n    img = np.random.random((8, 9, 10))\n    da = xr.DataArray(img, dims=['dim_0', 'dim_1', 'dim_2'])\n    fig = px.imshow(da, animation_frame='dim_0')\n    assert (fig.layout.xaxis.title.text == 'dim_2')\n    assert (fig.layout.yaxis.title.text == 'dim_1')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_2'])))", "masked_code": "def test_imshow_xarray_slicethrough():\n    img = np.random.random((8, 9, 10))\n    da = xr.DataArray(img, dims=['dim_0', 'dim_1', 'dim_2'])\n    fig = px.imshow(da, animation_frame='dim_0')\n    assert (fig.layout.xaxis.title.text == 'dim_2')\n    assert (fig.layout.yaxis.title.text == '???')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_2'])))", "ground_truth": "'dim_1'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_146", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_xarray_facet_col_string", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_xarray_facet_col_string():\n    img = np.random.random((3, 4, 5))\n    da = xr.DataArray(img, dims=['str_dim', 'dim_1', 'dim_2'], coords={'str_dim': ['A', 'B', 'C']})\n    fig = px.imshow(da, facet_col='str_dim')\n    assert (fig.layout.xaxis.title.text == 'dim_2')\n    assert (fig.layout.yaxis.title.text == 'dim_1')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_2'])))", "masked_code": "def test_imshow_xarray_facet_col_string():\n    img = np.random.random((3, 4, 5))\n    da = xr.DataArray(img, dims=['str_dim', 'dim_1', 'dim_2'], coords={'str_dim': ['A', 'B', 'C']})\n    fig = px.imshow(da, facet_col='str_dim')\n    assert (fig.layout.xaxis.title.text == '???')\n    assert (fig.layout.yaxis.title.text == 'dim_1')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_2'])))", "ground_truth": "'dim_2'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_147", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_xarray_facet_col_string", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_xarray_facet_col_string():\n    img = np.random.random((3, 4, 5))\n    da = xr.DataArray(img, dims=['str_dim', 'dim_1', 'dim_2'], coords={'str_dim': ['A', 'B', 'C']})\n    fig = px.imshow(da, facet_col='str_dim')\n    assert (fig.layout.xaxis.title.text == 'dim_2')\n    assert (fig.layout.yaxis.title.text == 'dim_1')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_2'])))", "masked_code": "def test_imshow_xarray_facet_col_string():\n    img = np.random.random((3, 4, 5))\n    da = xr.DataArray(img, dims=['str_dim', 'dim_1', 'dim_2'], coords={'str_dim': ['A', 'B', 'C']})\n    fig = px.imshow(da, facet_col='str_dim')\n    assert (fig.layout.xaxis.title.text == 'dim_2')\n    assert (fig.layout.yaxis.title.text == '???')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_2'])))", "ground_truth": "'dim_1'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_148", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_xarray_animation_frame_string", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_xarray_animation_frame_string():\n    img = np.random.random((3, 4, 5))\n    da = xr.DataArray(img, dims=['str_dim', 'dim_1', 'dim_2'], coords={'str_dim': ['A', 'B', 'C']})\n    fig = px.imshow(da, animation_frame='str_dim')\n    assert (fig.layout.xaxis.title.text == 'dim_2')\n    assert (fig.layout.yaxis.title.text == 'dim_1')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_2'])))", "masked_code": "def test_imshow_xarray_animation_frame_string():\n    img = np.random.random((3, 4, 5))\n    da = xr.DataArray(img, dims=['str_dim', 'dim_1', 'dim_2'], coords={'str_dim': ['A', 'B', 'C']})\n    fig = px.imshow(da, animation_frame='str_dim')\n    assert (fig.layout.xaxis.title.text == '???')\n    assert (fig.layout.yaxis.title.text == 'dim_1')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_2'])))", "ground_truth": "'dim_2'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_149", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_xarray_animation_frame_string", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_xarray_animation_frame_string():\n    img = np.random.random((3, 4, 5))\n    da = xr.DataArray(img, dims=['str_dim', 'dim_1', 'dim_2'], coords={'str_dim': ['A', 'B', 'C']})\n    fig = px.imshow(da, animation_frame='str_dim')\n    assert (fig.layout.xaxis.title.text == 'dim_2')\n    assert (fig.layout.yaxis.title.text == 'dim_1')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_2'])))", "masked_code": "def test_imshow_xarray_animation_frame_string():\n    img = np.random.random((3, 4, 5))\n    da = xr.DataArray(img, dims=['str_dim', 'dim_1', 'dim_2'], coords={'str_dim': ['A', 'B', 'C']})\n    fig = px.imshow(da, animation_frame='str_dim')\n    assert (fig.layout.xaxis.title.text == 'dim_2')\n    assert (fig.layout.yaxis.title.text == '???')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_2'])))", "ground_truth": "'dim_1'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_150", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_xarray_animation_facet_slicethrough", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_xarray_animation_facet_slicethrough():\n    img = np.random.random((3, 4, 5, 6))\n    da = xr.DataArray(img, dims=['dim_0', 'dim_1', 'dim_2', 'dim_3'])\n    fig = px.imshow(da, facet_col='dim_0', animation_frame='dim_1')\n    assert (fig.layout.xaxis.title.text == 'dim_3')\n    assert (fig.layout.yaxis.title.text == 'dim_2')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_3'])))", "masked_code": "def test_imshow_xarray_animation_facet_slicethrough():\n    img = np.random.random((3, 4, 5, 6))\n    da = xr.DataArray(img, dims=['dim_0', 'dim_1', 'dim_2', 'dim_3'])\n    fig = px.imshow(da, facet_col='dim_0', animation_frame='dim_1')\n    assert (fig.layout.xaxis.title.text == '???')\n    assert (fig.layout.yaxis.title.text == 'dim_2')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_3'])))", "ground_truth": "'dim_3'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_151", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_xarray_animation_facet_slicethrough", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_xarray_animation_facet_slicethrough():\n    img = np.random.random((3, 4, 5, 6))\n    da = xr.DataArray(img, dims=['dim_0', 'dim_1', 'dim_2', 'dim_3'])\n    fig = px.imshow(da, facet_col='dim_0', animation_frame='dim_1')\n    assert (fig.layout.xaxis.title.text == 'dim_3')\n    assert (fig.layout.yaxis.title.text == 'dim_2')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_3'])))", "masked_code": "def test_imshow_xarray_animation_facet_slicethrough():\n    img = np.random.random((3, 4, 5, 6))\n    da = xr.DataArray(img, dims=['dim_0', 'dim_1', 'dim_2', 'dim_3'])\n    fig = px.imshow(da, facet_col='dim_0', animation_frame='dim_1')\n    assert (fig.layout.xaxis.title.text == 'dim_3')\n    assert (fig.layout.yaxis.title.text == '???')\n    assert np.all((np.array(fig.data[0].x) == np.array(da.coords['dim_3'])))", "ground_truth": "'dim_2'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_152", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_labels_and_ranges", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_labels_and_ranges():\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]])\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.layout.yaxis.title.text is None)\n    assert (fig.layout.coloraxis.colorbar.title.text is None)\n    assert (fig.data[0].x is None)\n    assert (fig.data[0].y is None)\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a', 'b'], y=['c', 'd', 'e'], labels=dict(x='the x', y='the y', color='the color'))\n    assert (fig.layout.xaxis.title.text == 'the x')\n    assert (fig.layout.yaxis.title.text == 'the y')\n    assert (fig.layout.coloraxis.colorbar.title.text == 'the color')\n    assert (fig.data[0].x[0] == 'a')\n    assert (fig.data[0].y[0] == 'c')\n    with pytest.raises(ValueError):\n        fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    fig = px.imshow(img, x=['a', 'b'])\n    assert (fig.data[0].x == ('a', 'b'))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        fig = px.imshow(img, x=['a', 'b'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    base = datetime.datetime(2000, 1, 1)\n    fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])\n    assert (fig.data[0].x == (datetime.datetime(2000, 1, 1, 0, 0), datetime.datetime(2000, 1, 1, 1, 0)))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        base = datetime.datetime(2000, 1, 1)\n        fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])", "masked_code": "def test_imshow_labels_and_ranges():\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]])\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.layout.yaxis.title.text is None)\n    assert (fig.layout.coloraxis.colorbar.title.text is None)\n    assert (fig.data[0].x is None)\n    assert (fig.data[0].y is None)\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a', 'b'], y=['c', 'd', 'e'], labels=dict(x='the x', y='the y', color='the color'))\n    assert (fig.layout.xaxis.title.text == '???')\n    assert (fig.layout.yaxis.title.text == 'the y')\n    assert (fig.layout.coloraxis.colorbar.title.text == 'the color')\n    assert (fig.data[0].x[0] == 'a')\n    assert (fig.data[0].y[0] == 'c')\n    with pytest.raises(ValueError):\n        fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    fig = px.imshow(img, x=['a', 'b'])\n    assert (fig.data[0].x == ('a', 'b'))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        fig = px.imshow(img, x=['a', 'b'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    base = datetime.datetime(2000, 1, 1)\n    fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])\n    assert (fig.data[0].x == (datetime.datetime(2000, 1, 1, 0, 0), datetime.datetime(2000, 1, 1, 1, 0)))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        base = datetime.datetime(2000, 1, 1)\n        fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])", "ground_truth": "'the x'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_153", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_labels_and_ranges", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_labels_and_ranges():\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]])\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.layout.yaxis.title.text is None)\n    assert (fig.layout.coloraxis.colorbar.title.text is None)\n    assert (fig.data[0].x is None)\n    assert (fig.data[0].y is None)\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a', 'b'], y=['c', 'd', 'e'], labels=dict(x='the x', y='the y', color='the color'))\n    assert (fig.layout.xaxis.title.text == 'the x')\n    assert (fig.layout.yaxis.title.text == 'the y')\n    assert (fig.layout.coloraxis.colorbar.title.text == 'the color')\n    assert (fig.data[0].x[0] == 'a')\n    assert (fig.data[0].y[0] == 'c')\n    with pytest.raises(ValueError):\n        fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    fig = px.imshow(img, x=['a', 'b'])\n    assert (fig.data[0].x == ('a', 'b'))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        fig = px.imshow(img, x=['a', 'b'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    base = datetime.datetime(2000, 1, 1)\n    fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])\n    assert (fig.data[0].x == (datetime.datetime(2000, 1, 1, 0, 0), datetime.datetime(2000, 1, 1, 1, 0)))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        base = datetime.datetime(2000, 1, 1)\n        fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])", "masked_code": "def test_imshow_labels_and_ranges():\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]])\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.layout.yaxis.title.text is None)\n    assert (fig.layout.coloraxis.colorbar.title.text is None)\n    assert (fig.data[0].x is None)\n    assert (fig.data[0].y is None)\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a', 'b'], y=['c', 'd', 'e'], labels=dict(x='the x', y='the y', color='the color'))\n    assert (fig.layout.xaxis.title.text == 'the x')\n    assert (fig.layout.yaxis.title.text == '???')\n    assert (fig.layout.coloraxis.colorbar.title.text == 'the color')\n    assert (fig.data[0].x[0] == 'a')\n    assert (fig.data[0].y[0] == 'c')\n    with pytest.raises(ValueError):\n        fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    fig = px.imshow(img, x=['a', 'b'])\n    assert (fig.data[0].x == ('a', 'b'))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        fig = px.imshow(img, x=['a', 'b'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    base = datetime.datetime(2000, 1, 1)\n    fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])\n    assert (fig.data[0].x == (datetime.datetime(2000, 1, 1, 0, 0), datetime.datetime(2000, 1, 1, 1, 0)))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        base = datetime.datetime(2000, 1, 1)\n        fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])", "ground_truth": "'the y'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_154", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_labels_and_ranges", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_labels_and_ranges():\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]])\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.layout.yaxis.title.text is None)\n    assert (fig.layout.coloraxis.colorbar.title.text is None)\n    assert (fig.data[0].x is None)\n    assert (fig.data[0].y is None)\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a', 'b'], y=['c', 'd', 'e'], labels=dict(x='the x', y='the y', color='the color'))\n    assert (fig.layout.xaxis.title.text == 'the x')\n    assert (fig.layout.yaxis.title.text == 'the y')\n    assert (fig.layout.coloraxis.colorbar.title.text == 'the color')\n    assert (fig.data[0].x[0] == 'a')\n    assert (fig.data[0].y[0] == 'c')\n    with pytest.raises(ValueError):\n        fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    fig = px.imshow(img, x=['a', 'b'])\n    assert (fig.data[0].x == ('a', 'b'))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        fig = px.imshow(img, x=['a', 'b'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    base = datetime.datetime(2000, 1, 1)\n    fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])\n    assert (fig.data[0].x == (datetime.datetime(2000, 1, 1, 0, 0), datetime.datetime(2000, 1, 1, 1, 0)))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        base = datetime.datetime(2000, 1, 1)\n        fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])", "masked_code": "def test_imshow_labels_and_ranges():\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]])\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.layout.yaxis.title.text is None)\n    assert (fig.layout.coloraxis.colorbar.title.text is None)\n    assert (fig.data[0].x is None)\n    assert (fig.data[0].y is None)\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a', 'b'], y=['c', 'd', 'e'], labels=dict(x='the x', y='the y', color='the color'))\n    assert (fig.layout.xaxis.title.text == 'the x')\n    assert (fig.layout.yaxis.title.text == 'the y')\n    assert (fig.layout.coloraxis.colorbar.title.text == '???')\n    assert (fig.data[0].x[0] == 'a')\n    assert (fig.data[0].y[0] == 'c')\n    with pytest.raises(ValueError):\n        fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    fig = px.imshow(img, x=['a', 'b'])\n    assert (fig.data[0].x == ('a', 'b'))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        fig = px.imshow(img, x=['a', 'b'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    base = datetime.datetime(2000, 1, 1)\n    fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])\n    assert (fig.data[0].x == (datetime.datetime(2000, 1, 1, 0, 0), datetime.datetime(2000, 1, 1, 1, 0)))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        base = datetime.datetime(2000, 1, 1)\n        fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])", "ground_truth": "'the color'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_155", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_labels_and_ranges", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_labels_and_ranges():\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]])\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.layout.yaxis.title.text is None)\n    assert (fig.layout.coloraxis.colorbar.title.text is None)\n    assert (fig.data[0].x is None)\n    assert (fig.data[0].y is None)\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a', 'b'], y=['c', 'd', 'e'], labels=dict(x='the x', y='the y', color='the color'))\n    assert (fig.layout.xaxis.title.text == 'the x')\n    assert (fig.layout.yaxis.title.text == 'the y')\n    assert (fig.layout.coloraxis.colorbar.title.text == 'the color')\n    assert (fig.data[0].x[0] == 'a')\n    assert (fig.data[0].y[0] == 'c')\n    with pytest.raises(ValueError):\n        fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    fig = px.imshow(img, x=['a', 'b'])\n    assert (fig.data[0].x == ('a', 'b'))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        fig = px.imshow(img, x=['a', 'b'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    base = datetime.datetime(2000, 1, 1)\n    fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])\n    assert (fig.data[0].x == (datetime.datetime(2000, 1, 1, 0, 0), datetime.datetime(2000, 1, 1, 1, 0)))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        base = datetime.datetime(2000, 1, 1)\n        fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])", "masked_code": "def test_imshow_labels_and_ranges():\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]])\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.layout.yaxis.title.text is None)\n    assert (fig.layout.coloraxis.colorbar.title.text is None)\n    assert (fig.data[0].x is None)\n    assert (fig.data[0].y is None)\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a', 'b'], y=['c', 'd', 'e'], labels=dict(x='the x', y='the y', color='the color'))\n    assert (fig.layout.xaxis.title.text == 'the x')\n    assert (fig.layout.yaxis.title.text == 'the y')\n    assert (fig.layout.coloraxis.colorbar.title.text == 'the color')\n    assert (fig.data[0].x[0] == 'a')\n    assert (fig.data[0].y[0] == 'c')\n    with pytest.raises(ValueError):\n        fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    fig = px.imshow(img, x=['a', 'b'])\n    assert (fig.data[0].x == '???')\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        fig = px.imshow(img, x=['a', 'b'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    base = datetime.datetime(2000, 1, 1)\n    fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])\n    assert (fig.data[0].x == (datetime.datetime(2000, 1, 1, 0, 0), datetime.datetime(2000, 1, 1, 1, 0)))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        base = datetime.datetime(2000, 1, 1)\n        fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])", "ground_truth": "('a', 'b')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_156", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_labels_and_ranges", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_labels_and_ranges():\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]])\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.layout.yaxis.title.text is None)\n    assert (fig.layout.coloraxis.colorbar.title.text is None)\n    assert (fig.data[0].x is None)\n    assert (fig.data[0].y is None)\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a', 'b'], y=['c', 'd', 'e'], labels=dict(x='the x', y='the y', color='the color'))\n    assert (fig.layout.xaxis.title.text == 'the x')\n    assert (fig.layout.yaxis.title.text == 'the y')\n    assert (fig.layout.coloraxis.colorbar.title.text == 'the color')\n    assert (fig.data[0].x[0] == 'a')\n    assert (fig.data[0].y[0] == 'c')\n    with pytest.raises(ValueError):\n        fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    fig = px.imshow(img, x=['a', 'b'])\n    assert (fig.data[0].x == ('a', 'b'))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        fig = px.imshow(img, x=['a', 'b'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    base = datetime.datetime(2000, 1, 1)\n    fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])\n    assert (fig.data[0].x == (datetime.datetime(2000, 1, 1, 0, 0), datetime.datetime(2000, 1, 1, 1, 0)))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        base = datetime.datetime(2000, 1, 1)\n        fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])", "masked_code": "def test_imshow_labels_and_ranges():\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]])\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.layout.yaxis.title.text is None)\n    assert (fig.layout.coloraxis.colorbar.title.text is None)\n    assert (fig.data[0].x is None)\n    assert (fig.data[0].y is None)\n    fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a', 'b'], y=['c', 'd', 'e'], labels=dict(x='the x', y='the y', color='the color'))\n    assert (fig.layout.xaxis.title.text == 'the x')\n    assert (fig.layout.yaxis.title.text == 'the y')\n    assert (fig.layout.coloraxis.colorbar.title.text == 'the color')\n    assert (fig.data[0].x[0] == 'a')\n    assert (fig.data[0].y[0] == 'c')\n    with pytest.raises(ValueError):\n        fig = px.imshow([[1, 2], [3, 4], [5, 6]], x=['a'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    fig = px.imshow(img, x=['a', 'b'])\n    assert (fig.data[0].x == ('a', 'b'))\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        fig = px.imshow(img, x=['a', 'b'])\n    img = np.ones((2, 2), dtype=np.uint8)\n    base = datetime.datetime(2000, 1, 1)\n    fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])\n    assert (fig.data[0].x == '???')\n    with pytest.raises(ValueError):\n        img = np.ones((2, 2, 3), dtype=np.uint8)\n        base = datetime.datetime(2000, 1, 1)\n        fig = px.imshow(img, x=[base, (base + datetime.timedelta(hours=1))])", "ground_truth": "(datetime.datetime(2000, 1, 1, 0, 0), datetime.datetime(2000, 1, 1, 1, 0))", "quality_analysis": {"complexity_score": 20, "left_complexity": 2, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_157", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_ranges_image_trace", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_ranges_image_trace():\n    fig = px.imshow(img_rgb, x=[1, 11, 21])\n    assert (fig.data[0].dx == 10)\n    assert (fig.data[0].x0 == 1)\n    fig = px.imshow(img_rgb, x=[21, 11, 1])\n    assert (fig.data[0].dx == (- 10))\n    assert (fig.data[0].x0 == 21)\n    assert (fig.layout.xaxis.autorange == 'reversed')", "masked_code": "def test_imshow_ranges_image_trace():\n    fig = px.imshow(img_rgb, x=[1, 11, 21])\n    assert (fig.data[0].dx == '???')\n    assert (fig.data[0].x0 == 1)\n    fig = px.imshow(img_rgb, x=[21, 11, 1])\n    assert (fig.data[0].dx == (- 10))\n    assert (fig.data[0].x0 == 21)\n    assert (fig.layout.xaxis.autorange == 'reversed')", "ground_truth": "10", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_158", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_ranges_image_trace", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_ranges_image_trace():\n    fig = px.imshow(img_rgb, x=[1, 11, 21])\n    assert (fig.data[0].dx == 10)\n    assert (fig.data[0].x0 == 1)\n    fig = px.imshow(img_rgb, x=[21, 11, 1])\n    assert (fig.data[0].dx == (- 10))\n    assert (fig.data[0].x0 == 21)\n    assert (fig.layout.xaxis.autorange == 'reversed')", "masked_code": "def test_imshow_ranges_image_trace():\n    fig = px.imshow(img_rgb, x=[1, 11, 21])\n    assert (fig.data[0].dx == 10)\n    assert (fig.data[0].x0 == 1)\n    fig = px.imshow(img_rgb, x=[21, 11, 1])\n    assert (fig.data[0].dx == '???')\n    assert (fig.data[0].x0 == 21)\n    assert (fig.layout.xaxis.autorange == 'reversed')", "ground_truth": "(- 10)", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_159", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_ranges_image_trace", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_ranges_image_trace():\n    fig = px.imshow(img_rgb, x=[1, 11, 21])\n    assert (fig.data[0].dx == 10)\n    assert (fig.data[0].x0 == 1)\n    fig = px.imshow(img_rgb, x=[21, 11, 1])\n    assert (fig.data[0].dx == (- 10))\n    assert (fig.data[0].x0 == 21)\n    assert (fig.layout.xaxis.autorange == 'reversed')", "masked_code": "def test_imshow_ranges_image_trace():\n    fig = px.imshow(img_rgb, x=[1, 11, 21])\n    assert (fig.data[0].dx == 10)\n    assert (fig.data[0].x0 == 1)\n    fig = px.imshow(img_rgb, x=[21, 11, 1])\n    assert (fig.data[0].dx == (- 10))\n    assert (fig.data[0].x0 == '???')\n    assert (fig.layout.xaxis.autorange == 'reversed')", "ground_truth": "21", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_160", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_ranges_image_trace", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_ranges_image_trace():\n    fig = px.imshow(img_rgb, x=[1, 11, 21])\n    assert (fig.data[0].dx == 10)\n    assert (fig.data[0].x0 == 1)\n    fig = px.imshow(img_rgb, x=[21, 11, 1])\n    assert (fig.data[0].dx == (- 10))\n    assert (fig.data[0].x0 == 21)\n    assert (fig.layout.xaxis.autorange == 'reversed')", "masked_code": "def test_imshow_ranges_image_trace():\n    fig = px.imshow(img_rgb, x=[1, 11, 21])\n    assert (fig.data[0].dx == 10)\n    assert (fig.data[0].x0 == 1)\n    fig = px.imshow(img_rgb, x=[21, 11, 1])\n    assert (fig.data[0].dx == (- 10))\n    assert (fig.data[0].x0 == 21)\n    assert (fig.layout.xaxis.autorange == '???')", "ground_truth": "'reversed'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_161", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_dataframe", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "masked_code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == '???')\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "ground_truth": "df.columns[0]", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_162", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_dataframe", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "masked_code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == '???')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "ground_truth": "'nation'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_163", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_dataframe", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "masked_code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == '???')\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "ground_truth": "df.index[0]", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_164", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_dataframe", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "masked_code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == '???')\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "ground_truth": "df.columns[0]", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_165", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_dataframe", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "masked_code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == '???')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "ground_truth": "'gold'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_166", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_dataframe", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "masked_code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == '???')\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "ground_truth": "df.columns.name", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_167", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_dataframe", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "masked_code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == '???')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "ground_truth": "'medal'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_168", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_dataframe", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "masked_code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == '???')\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "ground_truth": "df.index[0]", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_169", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_dataframe", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "masked_code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == '???')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "ground_truth": "'South Korea'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_170", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_dataframe", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "masked_code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == '???')\n    assert (fig.layout.yaxis.title.text == 'nation')", "ground_truth": "df.index.name", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_171", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_dataframe", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == 'nation')", "masked_code": "def test_imshow_dataframe():\n    df = px.data.medals_wide(indexed=False)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'nation')\n    assert (fig.layout.xaxis.title.text is None)\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 0)\n    assert (fig.layout.yaxis.title.text is None)\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df)\n    assert (fig.data[0].x[0] == df.columns[0])\n    assert (fig.data[0].x[0] == 'gold')\n    assert (fig.layout.xaxis.title.text == df.columns.name)\n    assert (fig.layout.xaxis.title.text == 'medal')\n    assert (fig.data[0].y[0] == df.index[0])\n    assert (fig.data[0].y[0] == 'South Korea')\n    assert (fig.layout.yaxis.title.text == df.index.name)\n    assert (fig.layout.yaxis.title.text == '???')", "ground_truth": "'nation'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_172", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_hovertemplate", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_imshow_hovertemplate(binary_string):\n    fig = px.imshow(img_rgb, binary_string=binary_string)\n    assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<br>color: [%{z[0]}, %{z[1]}, %{z[2]}]<extra></extra>')\n    fig = px.imshow(img_gray, binary_string=binary_string)\n    if binary_string:\n        assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<extra></extra>')\n    else:\n        assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<br>color: %{z}<extra></extra>')", "masked_code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_imshow_hovertemplate(binary_string):\n    fig = px.imshow(img_rgb, binary_string=binary_string)\n    assert (fig.data[0].hovertemplate == '???')\n    fig = px.imshow(img_gray, binary_string=binary_string)\n    if binary_string:\n        assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<extra></extra>')\n    else:\n        assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<br>color: %{z}<extra></extra>')", "ground_truth": "'x: %{x}<br>y: %{y}<br>color: [%{z[0]}, %{z[1]}, %{z[2]}]<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_173", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_hovertemplate", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_imshow_hovertemplate(binary_string):\n    fig = px.imshow(img_rgb, binary_string=binary_string)\n    assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<br>color: [%{z[0]}, %{z[1]}, %{z[2]}]<extra></extra>')\n    fig = px.imshow(img_gray, binary_string=binary_string)\n    if binary_string:\n        assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<extra></extra>')\n    else:\n        assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<br>color: %{z}<extra></extra>')", "masked_code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_imshow_hovertemplate(binary_string):\n    fig = px.imshow(img_rgb, binary_string=binary_string)\n    assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<br>color: [%{z[0]}, %{z[1]}, %{z[2]}]<extra></extra>')\n    fig = px.imshow(img_gray, binary_string=binary_string)\n    if binary_string:\n        assert (fig.data[0].hovertemplate == '???')\n    else:\n        assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<br>color: %{z}<extra></extra>')", "ground_truth": "'x: %{x}<br>y: %{y}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_174", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_imshow_hovertemplate", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_imshow_hovertemplate(binary_string):\n    fig = px.imshow(img_rgb, binary_string=binary_string)\n    assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<br>color: [%{z[0]}, %{z[1]}, %{z[2]}]<extra></extra>')\n    fig = px.imshow(img_gray, binary_string=binary_string)\n    if binary_string:\n        assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<extra></extra>')\n    else:\n        assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<br>color: %{z}<extra></extra>')", "masked_code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_imshow_hovertemplate(binary_string):\n    fig = px.imshow(img_rgb, binary_string=binary_string)\n    assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<br>color: [%{z[0]}, %{z[1]}, %{z[2]}]<extra></extra>')\n    fig = px.imshow(img_gray, binary_string=binary_string)\n    if binary_string:\n        assert (fig.data[0].hovertemplate == 'x: %{x}<br>y: %{y}<extra></extra>')\n    else:\n        assert (fig.data[0].hovertemplate == '???')", "ground_truth": "'x: %{x}<br>y: %{y}<br>color: %{z}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_175", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_facet_col", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('facet_col', [0, 1, 2, (- 1)])\n@pytest.mark.parametrize('binary_string', [False, True])\ndef test_facet_col(facet_col, binary_string):\n    img = np.random.randint(255, size=(10, 9, 8))\n    facet_col_wrap = 3\n    fig = px.imshow(img, facet_col=facet_col, facet_col_wrap=facet_col_wrap, binary_string=binary_string)\n    nslices = img.shape[facet_col]\n    ncols = int(facet_col_wrap)\n    nrows = (((nslices // ncols) + 1) if (nslices % ncols) else (nslices // ncols))\n    nmax = (ncols * nrows)\n    assert (('yaxis%d' % nmax) in fig.layout)\n    assert (('yaxis%d' % (nmax + 1)) not in fig.layout)\n    assert (len(fig.data) == nslices)", "masked_code": "@pytest.mark.parametrize('facet_col', [0, 1, 2, (- 1)])\n@pytest.mark.parametrize('binary_string', [False, True])\ndef test_facet_col(facet_col, binary_string):\n    img = np.random.randint(255, size=(10, 9, 8))\n    facet_col_wrap = 3\n    fig = px.imshow(img, facet_col=facet_col, facet_col_wrap=facet_col_wrap, binary_string=binary_string)\n    nslices = img.shape[facet_col]\n    ncols = int(facet_col_wrap)\n    nrows = (((nslices // ncols) + 1) if (nslices % ncols) else (nslices // ncols))\n    nmax = (ncols * nrows)\n    assert (('yaxis%d' % nmax) in fig.layout)\n    assert (('yaxis%d' % (nmax + 1)) not in fig.layout)\n    assert (len(fig.data) == '???')", "ground_truth": "nslices", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_176", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_animation_frame_grayscale", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('animation_frame', [0, 1, 2, (- 1)])\n@pytest.mark.parametrize('binary_string', [False, True])\ndef test_animation_frame_grayscale(animation_frame, binary_string):\n    img = np.random.randint(255, size=(10, 9, 8)).astype(np.uint8)\n    fig = px.imshow(img, animation_frame=animation_frame, binary_string=binary_string)\n    nslices = img.shape[animation_frame]\n    assert (len(fig.frames) == nslices)", "masked_code": "@pytest.mark.parametrize('animation_frame', [0, 1, 2, (- 1)])\n@pytest.mark.parametrize('binary_string', [False, True])\ndef test_animation_frame_grayscale(animation_frame, binary_string):\n    img = np.random.randint(255, size=(10, 9, 8)).astype(np.uint8)\n    fig = px.imshow(img, animation_frame=animation_frame, binary_string=binary_string)\n    nslices = img.shape[animation_frame]\n    assert (len(fig.frames) == '???')", "ground_truth": "nslices", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_177", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_animation_frame_rgb", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('animation_frame', [0, 1, 2])\n@pytest.mark.parametrize('binary_string', [False, True])\ndef test_animation_frame_rgb(animation_frame, binary_string):\n    img = np.random.randint(255, size=(10, 9, 8, 3)).astype(np.uint8)\n    fig = px.imshow(img, animation_frame=animation_frame, binary_string=binary_string)\n    nslices = img.shape[animation_frame]\n    assert (len(fig.frames) == nslices)", "masked_code": "@pytest.mark.parametrize('animation_frame', [0, 1, 2])\n@pytest.mark.parametrize('binary_string', [False, True])\ndef test_animation_frame_rgb(animation_frame, binary_string):\n    img = np.random.randint(255, size=(10, 9, 8, 3)).astype(np.uint8)\n    fig = px.imshow(img, animation_frame=animation_frame, binary_string=binary_string)\n    nslices = img.shape[animation_frame]\n    assert (len(fig.frames) == '???')", "ground_truth": "nslices", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_178", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_animation_and_facet", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_animation_and_facet(binary_string):\n    img = np.random.randint(255, size=(10, 9, 8, 7)).astype(np.uint8)\n    fig = px.imshow(img, animation_frame=0, facet_col=1, binary_string=binary_string)\n    nslices = img.shape[0]\n    assert (len(fig.frames) == nslices)\n    assert (len(fig.data) == img.shape[1])", "masked_code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_animation_and_facet(binary_string):\n    img = np.random.randint(255, size=(10, 9, 8, 7)).astype(np.uint8)\n    fig = px.imshow(img, animation_frame=0, facet_col=1, binary_string=binary_string)\n    nslices = img.shape[0]\n    assert (len(fig.frames) == '???')\n    assert (len(fig.data) == img.shape[1])", "ground_truth": "nslices", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_179", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_imshow.py", "testname": "test_imshow.py", "classname": null, "funcname": "test_animation_and_facet", "imports": ["import plotly.express as px", "import numpy as np", "import pytest", "import xarray as xr", "from PIL import Image", "from io import BytesIO", "import base64", "import datetime", "from plotly.express.imshow_utils import rescale_intensity", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_animation_and_facet(binary_string):\n    img = np.random.randint(255, size=(10, 9, 8, 7)).astype(np.uint8)\n    fig = px.imshow(img, animation_frame=0, facet_col=1, binary_string=binary_string)\n    nslices = img.shape[0]\n    assert (len(fig.frames) == nslices)\n    assert (len(fig.data) == img.shape[1])", "masked_code": "@pytest.mark.parametrize('binary_string', [False, True])\ndef test_animation_and_facet(binary_string):\n    img = np.random.randint(255, size=(10, 9, 8, 7)).astype(np.uint8)\n    fig = px.imshow(img, animation_frame=0, facet_col=1, binary_string=binary_string)\n    nslices = img.shape[0]\n    assert (len(fig.frames) == nslices)\n    assert (len(fig.data) == '???')", "ground_truth": "img.shape[1]", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_180", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_marginals.py", "testname": "test_marginals.py", "classname": null, "funcname": "test_xy_marginals", "imports": ["import plotly.express as px", "import pytest"], "code": "@pytest.mark.parametrize('px_fn', [px.scatter, px.density_heatmap, px.density_contour])\n@pytest.mark.parametrize('marginal_x', [None, 'histogram', 'box', 'violin'])\n@pytest.mark.parametrize('marginal_y', [None, 'rug'])\ndef test_xy_marginals(backend, px_fn, marginal_x, marginal_y):\n    df = px.data.tips(return_type=backend)\n    fig = px_fn(df, x='total_bill', y='tip', marginal_x=marginal_x, marginal_y=marginal_y)\n    assert (len(fig.data) == ((1 + (marginal_x is not None)) + (marginal_y is not None)))", "masked_code": "@pytest.mark.parametrize('px_fn', [px.scatter, px.density_heatmap, px.density_contour])\n@pytest.mark.parametrize('marginal_x', [None, 'histogram', 'box', 'violin'])\n@pytest.mark.parametrize('marginal_y', [None, 'rug'])\ndef test_xy_marginals(backend, px_fn, marginal_x, marginal_y):\n    df = px.data.tips(return_type=backend)\n    fig = px_fn(df, x='total_bill', y='tip', marginal_x=marginal_x, marginal_y=marginal_y)\n    assert (len(fig.data) == '???')", "ground_truth": "((1 + (marginal_x is not None)) + (marginal_y is not None))", "quality_analysis": {"complexity_score": 18, "left_complexity": 5, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_181", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_marginals.py", "testname": "test_marginals.py", "classname": null, "funcname": "test_single_marginals", "imports": ["import plotly.express as px", "import pytest"], "code": "@pytest.mark.parametrize('px_fn', [px.histogram, px.ecdf])\n@pytest.mark.parametrize('marginal', [None, 'rug', 'histogram', 'box', 'violin'])\n@pytest.mark.parametrize('orientation', ['h', 'v'])\ndef test_single_marginals(backend, px_fn, marginal, orientation):\n    df = px.data.tips(return_type=backend)\n    fig = px_fn(df, x='total_bill', y='total_bill', marginal=marginal, orientation=orientation)\n    assert (len(fig.data) == (1 + (marginal is not None)))", "masked_code": "@pytest.mark.parametrize('px_fn', [px.histogram, px.ecdf])\n@pytest.mark.parametrize('marginal', [None, 'rug', 'histogram', 'box', 'violin'])\n@pytest.mark.parametrize('orientation', ['h', 'v'])\ndef test_single_marginals(backend, px_fn, marginal, orientation):\n    df = px.data.tips(return_type=backend)\n    fig = px_fn(df, x='total_bill', y='total_bill', marginal=marginal, orientation=orientation)\n    assert (len(fig.data) == '???')", "ground_truth": "(1 + (marginal is not None))", "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_182", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_pandas_backend.py", "testname": "test_pandas_backend.py", "classname": null, "funcname": "test_pandas_equiv", "imports": ["import plotly.express as px", "import numpy as np", "import pandas as pd", "import pytest"], "code": "@pytest.mark.skipif((not hasattr(pd.options.plotting, 'backend')), reason=\"Currently installed pandas doesn't support plotting backends.\")\n@pytest.mark.parametrize('pandas_fn,px_fn', [((lambda df: df.plot()), px.line), ((lambda df: df.plot.scatter('A', 'B')), (lambda df: px.scatter(df, 'A', 'B'))), ((lambda df: df.plot.line()), px.line), ((lambda df: df.plot.area()), px.area), ((lambda df: df.plot.bar()), px.bar), ((lambda df: df.plot.barh()), (lambda df: px.bar(df, orientation='h'))), ((lambda df: df.plot.box()), px.box), ((lambda df: df.plot.hist()), px.histogram), ((lambda df: df.boxplot()), px.box), ((lambda df: df.hist()), px.histogram), ((lambda df: df['A'].hist()), (lambda df: px.histogram(df['A']))), ((lambda df: df.plot(kind='line')), px.line), ((lambda df: df.plot(kind='area')), px.area), ((lambda df: df.plot(kind='bar')), px.bar), ((lambda df: df.plot(kind='box')), px.box), ((lambda df: df.plot(kind='hist')), px.histogram), ((lambda df: df.plot(kind='histogram')), px.histogram), ((lambda df: df.plot(kind='violin')), px.violin), ((lambda df: df.plot(kind='strip')), px.strip), ((lambda df: df.plot(kind='funnel')), px.funnel), ((lambda df: df.plot(kind='density_contour')), px.density_contour), ((lambda df: df.plot(kind='density_heatmap')), px.density_heatmap), ((lambda df: df.plot(kind='imshow')), px.imshow)])\ndef test_pandas_equiv(pandas_fn, px_fn):\n    pd.options.plotting.backend = 'plotly'\n    df = pd.DataFrame(np.random.randn(100, 4), columns=list('ABCD')).cumsum()\n    assert (pandas_fn(df) == px_fn(df))", "masked_code": "@pytest.mark.skipif((not hasattr(pd.options.plotting, 'backend')), reason=\"Currently installed pandas doesn't support plotting backends.\")\n@pytest.mark.parametrize('pandas_fn,px_fn', [((lambda df: df.plot()), px.line), ((lambda df: df.plot.scatter('A', 'B')), (lambda df: px.scatter(df, 'A', 'B'))), ((lambda df: df.plot.line()), px.line), ((lambda df: df.plot.area()), px.area), ((lambda df: df.plot.bar()), px.bar), ((lambda df: df.plot.barh()), (lambda df: px.bar(df, orientation='h'))), ((lambda df: df.plot.box()), px.box), ((lambda df: df.plot.hist()), px.histogram), ((lambda df: df.boxplot()), px.box), ((lambda df: df.hist()), px.histogram), ((lambda df: df['A'].hist()), (lambda df: px.histogram(df['A']))), ((lambda df: df.plot(kind='line')), px.line), ((lambda df: df.plot(kind='area')), px.area), ((lambda df: df.plot(kind='bar')), px.bar), ((lambda df: df.plot(kind='box')), px.box), ((lambda df: df.plot(kind='hist')), px.histogram), ((lambda df: df.plot(kind='histogram')), px.histogram), ((lambda df: df.plot(kind='violin')), px.violin), ((lambda df: df.plot(kind='strip')), px.strip), ((lambda df: df.plot(kind='funnel')), px.funnel), ((lambda df: df.plot(kind='density_contour')), px.density_contour), ((lambda df: df.plot(kind='density_heatmap')), px.density_heatmap), ((lambda df: df.plot(kind='imshow')), px.imshow)])\ndef test_pandas_equiv(pandas_fn, px_fn):\n    pd.options.plotting.backend = 'plotly'\n    df = pd.DataFrame(np.random.randn(100, 4), columns=list('ABCD')).cumsum()\n    assert (pandas_fn(df) == '???')", "ground_truth": "px_fn(df)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_183", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_scatter", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_scatter(backend):\n    iris = nw.from_native(px.data.iris(return_type=backend))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length')\n    assert (fig.data[0].type == 'scatter')\n    assert np.all((fig.data[0].x == iris.get_column('sepal_width').to_numpy()))\n    assert np.all((fig.data[0].y == iris.get_column('sepal_length').to_numpy()))\n    assert (fig.data[0].mode == 'markers')", "masked_code": "def test_scatter(backend):\n    iris = nw.from_native(px.data.iris(return_type=backend))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length')\n    assert (fig.data[0].type == '???')\n    assert np.all((fig.data[0].x == iris.get_column('sepal_width').to_numpy()))\n    assert np.all((fig.data[0].y == iris.get_column('sepal_length').to_numpy()))\n    assert (fig.data[0].mode == 'markers')", "ground_truth": "'scatter'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_184", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_scatter", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_scatter(backend):\n    iris = nw.from_native(px.data.iris(return_type=backend))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length')\n    assert (fig.data[0].type == 'scatter')\n    assert np.all((fig.data[0].x == iris.get_column('sepal_width').to_numpy()))\n    assert np.all((fig.data[0].y == iris.get_column('sepal_length').to_numpy()))\n    assert (fig.data[0].mode == 'markers')", "masked_code": "def test_scatter(backend):\n    iris = nw.from_native(px.data.iris(return_type=backend))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length')\n    assert (fig.data[0].type == 'scatter')\n    assert np.all((fig.data[0].x == iris.get_column('sepal_width').to_numpy()))\n    assert np.all((fig.data[0].y == iris.get_column('sepal_length').to_numpy()))\n    assert (fig.data[0].mode == '???')", "ground_truth": "'markers'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_185", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_custom_data_scatter", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_custom_data_scatter(backend):\n    iris = nw.from_native(px.data.iris(return_type=backend))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', color='species')\n    assert (fig.data[0].customdata is None)\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', color='species', hover_data=['petal_length', 'petal_width'])\n    for data in fig.data:\n        assert np.all(np.in1d(data.customdata[(:, 1)], iris.get_column('petal_width').to_numpy()))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width'], custom_data=['species_id', 'species'])\n    assert np.all((fig.data[0].customdata[(:, 0)] == iris.get_column('species_id').to_numpy()))\n    assert (fig.data[0].customdata.shape[1] == 4)\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width', 'species_id'], custom_data=['species_id', 'species'])\n    assert np.all((fig.data[0].customdata[(:, 0)] == iris.get_column('species_id').to_numpy()))\n    assert (fig.data[0].customdata.shape[1] == 4)\n    assert (fig.data[0].hovertemplate == 'sepal_width=%{x}<br>sepal_length=%{y}<br>petal_length=%{customdata[2]}<br>petal_width=%{customdata[3]}<br>species_id=%{customdata[0]}<extra></extra>')", "masked_code": "def test_custom_data_scatter(backend):\n    iris = nw.from_native(px.data.iris(return_type=backend))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', color='species')\n    assert (fig.data[0].customdata is None)\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', color='species', hover_data=['petal_length', 'petal_width'])\n    for data in fig.data:\n        assert np.all(np.in1d(data.customdata[(:, 1)], iris.get_column('petal_width').to_numpy()))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width'], custom_data=['species_id', 'species'])\n    assert np.all((fig.data[0].customdata[(:, 0)] == iris.get_column('species_id').to_numpy()))\n    assert (fig.data[0].customdata.shape[1] == '???')\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width', 'species_id'], custom_data=['species_id', 'species'])\n    assert np.all((fig.data[0].customdata[(:, 0)] == iris.get_column('species_id').to_numpy()))\n    assert (fig.data[0].customdata.shape[1] == 4)\n    assert (fig.data[0].hovertemplate == 'sepal_width=%{x}<br>sepal_length=%{y}<br>petal_length=%{customdata[2]}<br>petal_width=%{customdata[3]}<br>species_id=%{customdata[0]}<extra></extra>')", "ground_truth": "4", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_186", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_custom_data_scatter", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_custom_data_scatter(backend):\n    iris = nw.from_native(px.data.iris(return_type=backend))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', color='species')\n    assert (fig.data[0].customdata is None)\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', color='species', hover_data=['petal_length', 'petal_width'])\n    for data in fig.data:\n        assert np.all(np.in1d(data.customdata[(:, 1)], iris.get_column('petal_width').to_numpy()))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width'], custom_data=['species_id', 'species'])\n    assert np.all((fig.data[0].customdata[(:, 0)] == iris.get_column('species_id').to_numpy()))\n    assert (fig.data[0].customdata.shape[1] == 4)\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width', 'species_id'], custom_data=['species_id', 'species'])\n    assert np.all((fig.data[0].customdata[(:, 0)] == iris.get_column('species_id').to_numpy()))\n    assert (fig.data[0].customdata.shape[1] == 4)\n    assert (fig.data[0].hovertemplate == 'sepal_width=%{x}<br>sepal_length=%{y}<br>petal_length=%{customdata[2]}<br>petal_width=%{customdata[3]}<br>species_id=%{customdata[0]}<extra></extra>')", "masked_code": "def test_custom_data_scatter(backend):\n    iris = nw.from_native(px.data.iris(return_type=backend))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', color='species')\n    assert (fig.data[0].customdata is None)\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', color='species', hover_data=['petal_length', 'petal_width'])\n    for data in fig.data:\n        assert np.all(np.in1d(data.customdata[(:, 1)], iris.get_column('petal_width').to_numpy()))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width'], custom_data=['species_id', 'species'])\n    assert np.all((fig.data[0].customdata[(:, 0)] == iris.get_column('species_id').to_numpy()))\n    assert (fig.data[0].customdata.shape[1] == 4)\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width', 'species_id'], custom_data=['species_id', 'species'])\n    assert np.all((fig.data[0].customdata[(:, 0)] == iris.get_column('species_id').to_numpy()))\n    assert (fig.data[0].customdata.shape[1] == '???')\n    assert (fig.data[0].hovertemplate == 'sepal_width=%{x}<br>sepal_length=%{y}<br>petal_length=%{customdata[2]}<br>petal_width=%{customdata[3]}<br>species_id=%{customdata[0]}<extra></extra>')", "ground_truth": "4", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_187", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_custom_data_scatter", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_custom_data_scatter(backend):\n    iris = nw.from_native(px.data.iris(return_type=backend))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', color='species')\n    assert (fig.data[0].customdata is None)\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', color='species', hover_data=['petal_length', 'petal_width'])\n    for data in fig.data:\n        assert np.all(np.in1d(data.customdata[(:, 1)], iris.get_column('petal_width').to_numpy()))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width'], custom_data=['species_id', 'species'])\n    assert np.all((fig.data[0].customdata[(:, 0)] == iris.get_column('species_id').to_numpy()))\n    assert (fig.data[0].customdata.shape[1] == 4)\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width', 'species_id'], custom_data=['species_id', 'species'])\n    assert np.all((fig.data[0].customdata[(:, 0)] == iris.get_column('species_id').to_numpy()))\n    assert (fig.data[0].customdata.shape[1] == 4)\n    assert (fig.data[0].hovertemplate == 'sepal_width=%{x}<br>sepal_length=%{y}<br>petal_length=%{customdata[2]}<br>petal_width=%{customdata[3]}<br>species_id=%{customdata[0]}<extra></extra>')", "masked_code": "def test_custom_data_scatter(backend):\n    iris = nw.from_native(px.data.iris(return_type=backend))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', color='species')\n    assert (fig.data[0].customdata is None)\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', color='species', hover_data=['petal_length', 'petal_width'])\n    for data in fig.data:\n        assert np.all(np.in1d(data.customdata[(:, 1)], iris.get_column('petal_width').to_numpy()))\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width'], custom_data=['species_id', 'species'])\n    assert np.all((fig.data[0].customdata[(:, 0)] == iris.get_column('species_id').to_numpy()))\n    assert (fig.data[0].customdata.shape[1] == 4)\n    fig = px.scatter(iris.to_native(), x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width', 'species_id'], custom_data=['species_id', 'species'])\n    assert np.all((fig.data[0].customdata[(:, 0)] == iris.get_column('species_id').to_numpy()))\n    assert (fig.data[0].customdata.shape[1] == 4)\n    assert (fig.data[0].hovertemplate == '???')", "ground_truth": "'sepal_width=%{x}<br>sepal_length=%{y}<br>petal_length=%{customdata[2]}<br>petal_width=%{customdata[3]}<br>species_id=%{customdata[0]}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_188", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_labels", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_labels(backend):\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.scatter(tips.to_native(), x='total_bill', y='tip', facet_row='time', facet_col='day', color='size', symbol='sex', labels={c: c.upper() for c in tips.columns})\n    assert ('SEX' in fig.data[0].hovertemplate)\n    assert ('TOTAL_BILL' in fig.data[0].hovertemplate)\n    assert ('SIZE' in fig.data[0].hovertemplate)\n    assert ('DAY' in fig.data[0].hovertemplate)\n    assert ('TIME' in fig.data[0].hovertemplate)\n    assert fig.layout.legend.title.text.startswith('SEX')\n    assert (fig.layout.xaxis.title.text == 'TOTAL_BILL')\n    assert (fig.layout.coloraxis.colorbar.title.text == 'SIZE')\n    assert fig.layout.annotations[0].text.startswith('DAY')\n    assert fig.layout.annotations[4].text.startswith('TIME')", "masked_code": "def test_labels(backend):\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.scatter(tips.to_native(), x='total_bill', y='tip', facet_row='time', facet_col='day', color='size', symbol='sex', labels={c: c.upper() for c in tips.columns})\n    assert ('SEX' in fig.data[0].hovertemplate)\n    assert ('TOTAL_BILL' in fig.data[0].hovertemplate)\n    assert ('SIZE' in fig.data[0].hovertemplate)\n    assert ('DAY' in fig.data[0].hovertemplate)\n    assert ('TIME' in fig.data[0].hovertemplate)\n    assert fig.layout.legend.title.text.startswith('SEX')\n    assert (fig.layout.xaxis.title.text == '???')\n    assert (fig.layout.coloraxis.colorbar.title.text == 'SIZE')\n    assert fig.layout.annotations[0].text.startswith('DAY')\n    assert fig.layout.annotations[4].text.startswith('TIME')", "ground_truth": "'TOTAL_BILL'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_189", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_labels", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_labels(backend):\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.scatter(tips.to_native(), x='total_bill', y='tip', facet_row='time', facet_col='day', color='size', symbol='sex', labels={c: c.upper() for c in tips.columns})\n    assert ('SEX' in fig.data[0].hovertemplate)\n    assert ('TOTAL_BILL' in fig.data[0].hovertemplate)\n    assert ('SIZE' in fig.data[0].hovertemplate)\n    assert ('DAY' in fig.data[0].hovertemplate)\n    assert ('TIME' in fig.data[0].hovertemplate)\n    assert fig.layout.legend.title.text.startswith('SEX')\n    assert (fig.layout.xaxis.title.text == 'TOTAL_BILL')\n    assert (fig.layout.coloraxis.colorbar.title.text == 'SIZE')\n    assert fig.layout.annotations[0].text.startswith('DAY')\n    assert fig.layout.annotations[4].text.startswith('TIME')", "masked_code": "def test_labels(backend):\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.scatter(tips.to_native(), x='total_bill', y='tip', facet_row='time', facet_col='day', color='size', symbol='sex', labels={c: c.upper() for c in tips.columns})\n    assert ('SEX' in fig.data[0].hovertemplate)\n    assert ('TOTAL_BILL' in fig.data[0].hovertemplate)\n    assert ('SIZE' in fig.data[0].hovertemplate)\n    assert ('DAY' in fig.data[0].hovertemplate)\n    assert ('TIME' in fig.data[0].hovertemplate)\n    assert fig.layout.legend.title.text.startswith('SEX')\n    assert (fig.layout.xaxis.title.text == 'TOTAL_BILL')\n    assert (fig.layout.coloraxis.colorbar.title.text == '???')\n    assert fig.layout.annotations[0].text.startswith('DAY')\n    assert fig.layout.annotations[4].text.startswith('TIME')", "ground_truth": "'SIZE'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_190", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_line_mode", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize(['extra_kwargs', 'expected_mode'], [({}, 'lines'), ({'markers': True}, 'lines+markers'), ({'text': 'continent'}, 'lines+markers+text')])\ndef test_line_mode(backend, extra_kwargs, expected_mode):\n    gapminder = px.data.gapminder(return_type=backend)\n    fig = px.line(gapminder, x='year', y='pop', color='country', **extra_kwargs)\n    assert (fig.data[0].mode == expected_mode)", "masked_code": "@pytest.mark.parametrize(['extra_kwargs', 'expected_mode'], [({}, 'lines'), ({'markers': True}, 'lines+markers'), ({'text': 'continent'}, 'lines+markers+text')])\ndef test_line_mode(backend, extra_kwargs, expected_mode):\n    gapminder = px.data.gapminder(return_type=backend)\n    fig = px.line(gapminder, x='year', y='pop', color='country', **extra_kwargs)\n    assert (fig.data[0].mode == '???')", "ground_truth": "expected_mode", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_191", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == '???')\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "pio.templates[pio.templates.default]", "quality_analysis": {"complexity_score": 9, "left_complexity": 2, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_192", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == '???')\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "pio.templates['seaborn']", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_193", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == '???')\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "pio.templates['ggplot2']", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_194", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == '???')\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "pio.templates['seaborn']", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_195", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == '???')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "go.layout.Template(data_scatter=[{}])", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_196", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == '???')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "'red'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_197", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == '???')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "'blue'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_198", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == '???')\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "px.colors.qualitative.D3[0]", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_199", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == '???')\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "px.colors.qualitative.D3[1]", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_200", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == '???')\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "pio.templates['seaborn'].layout.colorway[0]", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_201", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == '???')\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "pio.templates['seaborn'].layout.colorway[1]", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_202", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == '???')\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "pio.templates['ggplot2'].layout.colorway[0]", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_203", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == '???')\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "pio.templates['ggplot2'].layout.colorway[1]", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_204", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_templates", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == 60)\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_templates(backend):\n    try:\n        import plotly.graph_objects as go\n        tips = px.data.tips(return_type=backend)\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates[pio.templates.default])\n        pio.templates.default = 'seaborn'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['seaborn'])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter()\n        assert (fig.layout.template == pio.templates['ggplot2'])\n        fig = px.scatter(template='seaborn')\n        assert (fig.layout.template == pio.templates['seaborn'])\n        fig = px.scatter(template={})\n        assert (fig.layout.template == go.layout.Template(data_scatter=[{}]))\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict(layout_colorway=['red', 'blue']))\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.data[1].marker.color == 'blue')\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex', template=dict())\n        assert (fig.data[0].marker.color == px.colors.qualitative.D3[0])\n        assert (fig.data[1].marker.color == px.colors.qualitative.D3[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['seaborn'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['seaborn'].layout.colorway[1])\n        pio.templates.default = 'seaborn'\n        px.defaults.template = 'ggplot2'\n        fig = px.scatter(tips, x='total_bill', y='tip', color='sex')\n        assert (fig.data[0].marker.color == pio.templates['ggplot2'].layout.colorway[0])\n        assert (fig.data[1].marker.color == pio.templates['ggplot2'].layout.colorway[1])\n        fig = px.scatter(title='yo')\n        assert (fig.layout.margin.t is None)\n        fig = px.scatter()\n        assert (fig.layout.margin.t == '???')\n        fig = px.scatter(template=dict(layout_margin_t=2))\n        assert (fig.layout.margin.t is None)\n        pio.templates.default = 'none'\n        px.defaults.template = None\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram')\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_yaxis_showgrid=False))\n        assert fig.layout.xaxis2.showgrid\n        assert fig.layout.xaxis3.showgrid\n        assert (fig.layout.yaxis2.showgrid is None)\n        assert (fig.layout.yaxis3.showgrid is None)\n        fig = px.scatter(tips, x='total_bill', y='tip', marginal_x='histogram', marginal_y='histogram', template=dict(layout_xaxis_showgrid=False))\n        assert (fig.layout.xaxis2.showgrid is None)\n        assert (fig.layout.xaxis3.showgrid is None)\n        assert fig.layout.yaxis2.showgrid\n        assert fig.layout.yaxis3.showgrid\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "60", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_205", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_defaults", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_defaults():\n    px.defaults.labels = dict(x='hey x')\n    px.defaults.category_orders = dict(color=['b', 'a'])\n    px.defaults.color_discrete_map = dict(b='red')\n    fig = px.scatter(x=[1, 2], y=[1, 2], color=['a', 'b'])\n    try:\n        assert (fig.data[0].name == 'b')\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.layout.xaxis.title.text == 'hey x')\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_defaults():\n    px.defaults.labels = dict(x='hey x')\n    px.defaults.category_orders = dict(color=['b', 'a'])\n    px.defaults.color_discrete_map = dict(b='red')\n    fig = px.scatter(x=[1, 2], y=[1, 2], color=['a', 'b'])\n    try:\n        assert (fig.data[0].name == 'b')\n        assert (fig.data[0].marker.color == '???')\n        assert (fig.layout.xaxis.title.text == 'hey x')\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "'red'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_206", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_px_defaults", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_px_defaults():\n    px.defaults.labels = dict(x='hey x')\n    px.defaults.category_orders = dict(color=['b', 'a'])\n    px.defaults.color_discrete_map = dict(b='red')\n    fig = px.scatter(x=[1, 2], y=[1, 2], color=['a', 'b'])\n    try:\n        assert (fig.data[0].name == 'b')\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.layout.xaxis.title.text == 'hey x')\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "masked_code": "def test_px_defaults():\n    px.defaults.labels = dict(x='hey x')\n    px.defaults.category_orders = dict(color=['b', 'a'])\n    px.defaults.color_discrete_map = dict(b='red')\n    fig = px.scatter(x=[1, 2], y=[1, 2], color=['a', 'b'])\n    try:\n        assert (fig.data[0].name == 'b')\n        assert (fig.data[0].marker.color == 'red')\n        assert (fig.layout.xaxis.title.text == '???')\n    finally:\n        px.defaults.reset()\n        pio.templates.default = 'plotly'", "ground_truth": "'hey x'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_207", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_category_order_with_category_as_x", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_category_order_with_category_as_x(backend):\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.bar(tips.to_native(), x='day', y='total_bill', color='smoker', barmode='group', facet_col='sex', category_orders={'day': ['Thur', 'Fri', 'Sat', 'Sun'], 'smoker': ['Yes', 'No'], 'sex': ['Male', 'Female']})\n    assert (fig['layout']['xaxis']['categoryarray'] == ('Thur', 'Fri', 'Sat', 'Sun'))\n    for trace in fig['data']:\n        assert (set(trace['x']) == {'Thur', 'Fri', 'Sat', 'Sun'})", "masked_code": "def test_category_order_with_category_as_x(backend):\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.bar(tips.to_native(), x='day', y='total_bill', color='smoker', barmode='group', facet_col='sex', category_orders={'day': ['Thur', 'Fri', 'Sat', 'Sun'], 'smoker': ['Yes', 'No'], 'sex': ['Male', 'Female']})\n    assert (fig['layout']['xaxis']['categoryarray'] == '???')\n    for trace in fig['data']:\n        assert (set(trace['x']) == {'Thur', 'Fri', 'Sat', 'Sun'})", "ground_truth": "('Thur', 'Fri', 'Sat', 'Sun')", "quality_analysis": {"complexity_score": 19, "left_complexity": 13, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_208", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_category_order_with_category_as_x", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_category_order_with_category_as_x(backend):\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.bar(tips.to_native(), x='day', y='total_bill', color='smoker', barmode='group', facet_col='sex', category_orders={'day': ['Thur', 'Fri', 'Sat', 'Sun'], 'smoker': ['Yes', 'No'], 'sex': ['Male', 'Female']})\n    assert (fig['layout']['xaxis']['categoryarray'] == ('Thur', 'Fri', 'Sat', 'Sun'))\n    for trace in fig['data']:\n        assert (set(trace['x']) == {'Thur', 'Fri', 'Sat', 'Sun'})", "masked_code": "def test_category_order_with_category_as_x(backend):\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.bar(tips.to_native(), x='day', y='total_bill', color='smoker', barmode='group', facet_col='sex', category_orders={'day': ['Thur', 'Fri', 'Sat', 'Sun'], 'smoker': ['Yes', 'No'], 'sex': ['Male', 'Female']})\n    assert (fig['layout']['xaxis']['categoryarray'] == ('Thur', 'Fri', 'Sat', 'Sun'))\n    for trace in fig['data']:\n        assert (set(trace['x']) == '???')", "ground_truth": "{'Thur', 'Fri', 'Sat', 'Sun'}", "quality_analysis": {"complexity_score": 8, "left_complexity": 8, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_209", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_render_mode", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "masked_code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == '???')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "ground_truth": "'scatter'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_210", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_render_mode", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "masked_code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == '???')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "ground_truth": "'scatter'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_211", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_render_mode", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "masked_code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == '???')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "ground_truth": "'scattergl'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_212", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_render_mode", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "masked_code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == '???')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "ground_truth": "'scattergl'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_213", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_render_mode", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "masked_code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == '???')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "ground_truth": "'scattergl'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_214", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_render_mode", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "masked_code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == '???')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "ground_truth": "'scattergl'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_215", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_render_mode", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "masked_code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == '???')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "ground_truth": "'scatter'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_216", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_render_mode", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "masked_code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == '???')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "ground_truth": "'scatter'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_217", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_render_mode", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "masked_code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == '???')\n    assert (fig.data[1].type == 'scatter')", "ground_truth": "'histogram2dcontour'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_218", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px.py", "testname": "test_px.py", "classname": null, "funcname": "test_render_mode", "imports": ["from itertools import permutations", "import warnings", "import plotly.express as px", "import plotly.io as pio", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest"], "code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == 'scatter')", "masked_code": "def test_render_mode(backend):\n    df = nw.from_native(px.data.gapminder(return_type=backend))\n    df2007 = df.filter((nw.col('year') == 2007))\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.scatter(df2007.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='webgl')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'scattergl')\n    assert (fig.data[1].type == 'scattergl')\n    fig = px.scatter(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols', render_mode='svg')\n    assert (fig.data[0].type == 'scatter')\n    assert (fig.data[1].type == 'scatter')\n    fig = px.density_contour(df.to_native(), x='gdpPercap', y='lifeExp', trendline='ols')\n    assert (fig.data[0].type == 'histogram2dcontour')\n    assert (fig.data[1].type == '???')", "ground_truth": "'scatter'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_219", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_pie_custom_category_order", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_pie_custom_category_order(constructor):\n    data = {'status': ['On Route', 'Pending', 'Waiting Result', 'Delivered'], 'count': [28, 10, 73, 8]}\n    df = constructor(data)\n    custom_order = ['Pending', 'Waiting Result', 'On Route', 'Delivered']\n    result = px.pie(data_frame=df, values='count', names='status', category_orders={'status': custom_order})\n    assert (list(result.to_dict()['data'][0]['labels']) == ['Pending', 'Waiting Result', 'On Route', 'Delivered'])\n    values_ = np.array([x[0] for x in sorted(zip(data['count'], data['status']), key=(lambda t: custom_order.index(t[1])))])\n    trace = go.Pie(values=values_, labels=custom_order)\n    _compare_figures(trace, result)", "masked_code": "def test_pie_custom_category_order(constructor):\n    data = {'status': ['On Route', 'Pending', 'Waiting Result', 'Delivered'], 'count': [28, 10, 73, 8]}\n    df = constructor(data)\n    custom_order = ['Pending', 'Waiting Result', 'On Route', 'Delivered']\n    result = px.pie(data_frame=df, values='count', names='status', category_orders={'status': custom_order})\n    assert (list(result.to_dict()['data'][0]['labels']) == '???')\n    values_ = np.array([x[0] for x in sorted(zip(data['count'], data['status']), key=(lambda t: custom_order.index(t[1])))])\n    trace = go.Pie(values=values_, labels=custom_order)\n    _compare_figures(trace, result)", "ground_truth": "['Pending', 'Waiting Result', 'On Route', 'Delivered']", "quality_analysis": {"complexity_score": 24, "left_complexity": 18, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_220", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_sunburst_treemap_colorscales", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_sunburst_treemap_colorscales():\n    labels = ['Eve', 'Cain', 'Seth', 'Enos', 'Noam', 'Abel', 'Awan', 'Enoch', 'Azura']\n    parents = ['', 'Eve', 'Eve', 'Seth', 'Seth', 'Eve', 'Eve', 'Awan', 'Eve']\n    values = [10, 14, 12, 10, 2, 6, 6, 4, 4]\n    for (func, colorway) in zip([px.sunburst, px.treemap], ['sunburstcolorway', 'treemapcolorway']):\n        fig = func(names=labels, parents=parents, values=values, color=values, color_continuous_scale='Viridis', range_color=(5, 15))\n        assert fig.layout.coloraxis.cmin, (fig.layout.coloraxis.cmax == (5, 15))\n        color_seq = px.colors.sequential.Reds\n        fig = func(names=labels, parents=parents, values=values, color=labels, color_discrete_sequence=color_seq)\n        assert np.all([(col in color_seq) for col in fig.data[0].marker.colors])\n        fig = func(names=labels, parents=parents, values=values, color=values)\n        assert [(el[0] == px.colors.sequential.Viridis) for (i, el) in enumerate(fig.layout.coloraxis.colorscale)]\n        fig = func(names=labels, parents=parents, values=values, color=values, color_discrete_sequence=color_seq)\n        assert [(el[0] == px.colors.sequential.Viridis) for (i, el) in enumerate(fig.layout.coloraxis.colorscale)]\n        color_seq = px.colors.sequential.Reds\n        fig = func(names=labels, parents=parents, values=values, color_discrete_sequence=color_seq)\n        assert (list(fig.layout[colorway]) == color_seq)", "masked_code": "def test_sunburst_treemap_colorscales():\n    labels = ['Eve', 'Cain', 'Seth', 'Enos', 'Noam', 'Abel', 'Awan', 'Enoch', 'Azura']\n    parents = ['', 'Eve', 'Eve', 'Seth', 'Seth', 'Eve', 'Eve', 'Awan', 'Eve']\n    values = [10, 14, 12, 10, 2, 6, 6, 4, 4]\n    for (func, colorway) in zip([px.sunburst, px.treemap], ['sunburstcolorway', 'treemapcolorway']):\n        fig = func(names=labels, parents=parents, values=values, color=values, color_continuous_scale='Viridis', range_color=(5, 15))\n        assert fig.layout.coloraxis.cmin, (fig.layout.coloraxis.cmax == (5, 15))\n        color_seq = px.colors.sequential.Reds\n        fig = func(names=labels, parents=parents, values=values, color=labels, color_discrete_sequence=color_seq)\n        assert np.all([(col in color_seq) for col in fig.data[0].marker.colors])\n        fig = func(names=labels, parents=parents, values=values, color=values)\n        assert [(el[0] == px.colors.sequential.Viridis) for (i, el) in enumerate(fig.layout.coloraxis.colorscale)]\n        fig = func(names=labels, parents=parents, values=values, color=values, color_discrete_sequence=color_seq)\n        assert [(el[0] == px.colors.sequential.Viridis) for (i, el) in enumerate(fig.layout.coloraxis.colorscale)]\n        color_seq = px.colors.sequential.Reds\n        fig = func(names=labels, parents=parents, values=values, color_discrete_sequence=color_seq)\n        assert (list(fig.layout[colorway]) == '???')", "ground_truth": "color_seq", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_221", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_sunburst_treemap_with_path", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_sunburst_treemap_with_path(constructor):\n    vendors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', 'Tech', 'Tech', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 2, 2, 1, 4]\n    total = (['total'] * 8)\n    df = constructor(dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df, path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    fig = px.sunburst(df, path=path, values='values')\n    assert (fig.data[0].branchvalues == 'total')\n    assert (fig.data[0].values[(- 1)] == np.sum(values))\n    df = nw.from_native(df)\n    native_namespace = nw.get_native_namespace(df)\n    df = df.with_columns(values=nw.new_series('values', ['1 000', '3 000', '2', '4', '2', '2', '1 000', '4 000'], dtype=nw.String(), native_namespace=native_namespace))\n    pd_msg = 'Column `values` of `df` could not be converted to a numerical data type.'\n    pl_msg = \"conversion from `str` to `f64` failed in column 'values'\"\n    with pytest.raises((ValueError, InvalidOperationError), match=f'({pd_msg}|{pl_msg})'):\n        fig = px.sunburst(df.to_native(), path=path, values='values')\n    path = [df.get_column('total').to_native(), 'regions', df.get_column('sectors').to_native(), 'vendors']\n    fig = px.sunburst(df.to_native(), path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    df = df.with_columns(values=nw.lit(1))\n    fig = px.sunburst(df.to_native(), path=path, values='values', color='values')\n    assert ('coloraxis' in fig.data[0].marker)\n    assert np.all((np.array(fig.data[0].marker.colors) == 1))\n    assert (fig.data[0].values[(- 1)] == 8)", "masked_code": "def test_sunburst_treemap_with_path(constructor):\n    vendors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', 'Tech', 'Tech', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 2, 2, 1, 4]\n    total = (['total'] * 8)\n    df = constructor(dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df, path=path)\n    assert (fig.data[0].branchvalues == '???')\n    fig = px.sunburst(df, path=path, values='values')\n    assert (fig.data[0].branchvalues == 'total')\n    assert (fig.data[0].values[(- 1)] == np.sum(values))\n    df = nw.from_native(df)\n    native_namespace = nw.get_native_namespace(df)\n    df = df.with_columns(values=nw.new_series('values', ['1 000', '3 000', '2', '4', '2', '2', '1 000', '4 000'], dtype=nw.String(), native_namespace=native_namespace))\n    pd_msg = 'Column `values` of `df` could not be converted to a numerical data type.'\n    pl_msg = \"conversion from `str` to `f64` failed in column 'values'\"\n    with pytest.raises((ValueError, InvalidOperationError), match=f'({pd_msg}|{pl_msg})'):\n        fig = px.sunburst(df.to_native(), path=path, values='values')\n    path = [df.get_column('total').to_native(), 'regions', df.get_column('sectors').to_native(), 'vendors']\n    fig = px.sunburst(df.to_native(), path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    df = df.with_columns(values=nw.lit(1))\n    fig = px.sunburst(df.to_native(), path=path, values='values', color='values')\n    assert ('coloraxis' in fig.data[0].marker)\n    assert np.all((np.array(fig.data[0].marker.colors) == 1))\n    assert (fig.data[0].values[(- 1)] == 8)", "ground_truth": "'total'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_222", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_sunburst_treemap_with_path", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_sunburst_treemap_with_path(constructor):\n    vendors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', 'Tech', 'Tech', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 2, 2, 1, 4]\n    total = (['total'] * 8)\n    df = constructor(dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df, path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    fig = px.sunburst(df, path=path, values='values')\n    assert (fig.data[0].branchvalues == 'total')\n    assert (fig.data[0].values[(- 1)] == np.sum(values))\n    df = nw.from_native(df)\n    native_namespace = nw.get_native_namespace(df)\n    df = df.with_columns(values=nw.new_series('values', ['1 000', '3 000', '2', '4', '2', '2', '1 000', '4 000'], dtype=nw.String(), native_namespace=native_namespace))\n    pd_msg = 'Column `values` of `df` could not be converted to a numerical data type.'\n    pl_msg = \"conversion from `str` to `f64` failed in column 'values'\"\n    with pytest.raises((ValueError, InvalidOperationError), match=f'({pd_msg}|{pl_msg})'):\n        fig = px.sunburst(df.to_native(), path=path, values='values')\n    path = [df.get_column('total').to_native(), 'regions', df.get_column('sectors').to_native(), 'vendors']\n    fig = px.sunburst(df.to_native(), path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    df = df.with_columns(values=nw.lit(1))\n    fig = px.sunburst(df.to_native(), path=path, values='values', color='values')\n    assert ('coloraxis' in fig.data[0].marker)\n    assert np.all((np.array(fig.data[0].marker.colors) == 1))\n    assert (fig.data[0].values[(- 1)] == 8)", "masked_code": "def test_sunburst_treemap_with_path(constructor):\n    vendors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', 'Tech', 'Tech', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 2, 2, 1, 4]\n    total = (['total'] * 8)\n    df = constructor(dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df, path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    fig = px.sunburst(df, path=path, values='values')\n    assert (fig.data[0].branchvalues == '???')\n    assert (fig.data[0].values[(- 1)] == np.sum(values))\n    df = nw.from_native(df)\n    native_namespace = nw.get_native_namespace(df)\n    df = df.with_columns(values=nw.new_series('values', ['1 000', '3 000', '2', '4', '2', '2', '1 000', '4 000'], dtype=nw.String(), native_namespace=native_namespace))\n    pd_msg = 'Column `values` of `df` could not be converted to a numerical data type.'\n    pl_msg = \"conversion from `str` to `f64` failed in column 'values'\"\n    with pytest.raises((ValueError, InvalidOperationError), match=f'({pd_msg}|{pl_msg})'):\n        fig = px.sunburst(df.to_native(), path=path, values='values')\n    path = [df.get_column('total').to_native(), 'regions', df.get_column('sectors').to_native(), 'vendors']\n    fig = px.sunburst(df.to_native(), path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    df = df.with_columns(values=nw.lit(1))\n    fig = px.sunburst(df.to_native(), path=path, values='values', color='values')\n    assert ('coloraxis' in fig.data[0].marker)\n    assert np.all((np.array(fig.data[0].marker.colors) == 1))\n    assert (fig.data[0].values[(- 1)] == 8)", "ground_truth": "'total'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_223", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_sunburst_treemap_with_path", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_sunburst_treemap_with_path(constructor):\n    vendors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', 'Tech', 'Tech', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 2, 2, 1, 4]\n    total = (['total'] * 8)\n    df = constructor(dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df, path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    fig = px.sunburst(df, path=path, values='values')\n    assert (fig.data[0].branchvalues == 'total')\n    assert (fig.data[0].values[(- 1)] == np.sum(values))\n    df = nw.from_native(df)\n    native_namespace = nw.get_native_namespace(df)\n    df = df.with_columns(values=nw.new_series('values', ['1 000', '3 000', '2', '4', '2', '2', '1 000', '4 000'], dtype=nw.String(), native_namespace=native_namespace))\n    pd_msg = 'Column `values` of `df` could not be converted to a numerical data type.'\n    pl_msg = \"conversion from `str` to `f64` failed in column 'values'\"\n    with pytest.raises((ValueError, InvalidOperationError), match=f'({pd_msg}|{pl_msg})'):\n        fig = px.sunburst(df.to_native(), path=path, values='values')\n    path = [df.get_column('total').to_native(), 'regions', df.get_column('sectors').to_native(), 'vendors']\n    fig = px.sunburst(df.to_native(), path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    df = df.with_columns(values=nw.lit(1))\n    fig = px.sunburst(df.to_native(), path=path, values='values', color='values')\n    assert ('coloraxis' in fig.data[0].marker)\n    assert np.all((np.array(fig.data[0].marker.colors) == 1))\n    assert (fig.data[0].values[(- 1)] == 8)", "masked_code": "def test_sunburst_treemap_with_path(constructor):\n    vendors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', 'Tech', 'Tech', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 2, 2, 1, 4]\n    total = (['total'] * 8)\n    df = constructor(dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df, path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    fig = px.sunburst(df, path=path, values='values')\n    assert (fig.data[0].branchvalues == 'total')\n    assert (fig.data[0].values[(- 1)] == '???')\n    df = nw.from_native(df)\n    native_namespace = nw.get_native_namespace(df)\n    df = df.with_columns(values=nw.new_series('values', ['1 000', '3 000', '2', '4', '2', '2', '1 000', '4 000'], dtype=nw.String(), native_namespace=native_namespace))\n    pd_msg = 'Column `values` of `df` could not be converted to a numerical data type.'\n    pl_msg = \"conversion from `str` to `f64` failed in column 'values'\"\n    with pytest.raises((ValueError, InvalidOperationError), match=f'({pd_msg}|{pl_msg})'):\n        fig = px.sunburst(df.to_native(), path=path, values='values')\n    path = [df.get_column('total').to_native(), 'regions', df.get_column('sectors').to_native(), 'vendors']\n    fig = px.sunburst(df.to_native(), path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    df = df.with_columns(values=nw.lit(1))\n    fig = px.sunburst(df.to_native(), path=path, values='values', color='values')\n    assert ('coloraxis' in fig.data[0].marker)\n    assert np.all((np.array(fig.data[0].marker.colors) == 1))\n    assert (fig.data[0].values[(- 1)] == 8)", "ground_truth": "np.sum(values)", "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_224", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_sunburst_treemap_with_path", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_sunburst_treemap_with_path(constructor):\n    vendors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', 'Tech', 'Tech', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 2, 2, 1, 4]\n    total = (['total'] * 8)\n    df = constructor(dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df, path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    fig = px.sunburst(df, path=path, values='values')\n    assert (fig.data[0].branchvalues == 'total')\n    assert (fig.data[0].values[(- 1)] == np.sum(values))\n    df = nw.from_native(df)\n    native_namespace = nw.get_native_namespace(df)\n    df = df.with_columns(values=nw.new_series('values', ['1 000', '3 000', '2', '4', '2', '2', '1 000', '4 000'], dtype=nw.String(), native_namespace=native_namespace))\n    pd_msg = 'Column `values` of `df` could not be converted to a numerical data type.'\n    pl_msg = \"conversion from `str` to `f64` failed in column 'values'\"\n    with pytest.raises((ValueError, InvalidOperationError), match=f'({pd_msg}|{pl_msg})'):\n        fig = px.sunburst(df.to_native(), path=path, values='values')\n    path = [df.get_column('total').to_native(), 'regions', df.get_column('sectors').to_native(), 'vendors']\n    fig = px.sunburst(df.to_native(), path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    df = df.with_columns(values=nw.lit(1))\n    fig = px.sunburst(df.to_native(), path=path, values='values', color='values')\n    assert ('coloraxis' in fig.data[0].marker)\n    assert np.all((np.array(fig.data[0].marker.colors) == 1))\n    assert (fig.data[0].values[(- 1)] == 8)", "masked_code": "def test_sunburst_treemap_with_path(constructor):\n    vendors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', 'Tech', 'Tech', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 2, 2, 1, 4]\n    total = (['total'] * 8)\n    df = constructor(dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df, path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    fig = px.sunburst(df, path=path, values='values')\n    assert (fig.data[0].branchvalues == 'total')\n    assert (fig.data[0].values[(- 1)] == np.sum(values))\n    df = nw.from_native(df)\n    native_namespace = nw.get_native_namespace(df)\n    df = df.with_columns(values=nw.new_series('values', ['1 000', '3 000', '2', '4', '2', '2', '1 000', '4 000'], dtype=nw.String(), native_namespace=native_namespace))\n    pd_msg = 'Column `values` of `df` could not be converted to a numerical data type.'\n    pl_msg = \"conversion from `str` to `f64` failed in column 'values'\"\n    with pytest.raises((ValueError, InvalidOperationError), match=f'({pd_msg}|{pl_msg})'):\n        fig = px.sunburst(df.to_native(), path=path, values='values')\n    path = [df.get_column('total').to_native(), 'regions', df.get_column('sectors').to_native(), 'vendors']\n    fig = px.sunburst(df.to_native(), path=path)\n    assert (fig.data[0].branchvalues == '???')\n    df = df.with_columns(values=nw.lit(1))\n    fig = px.sunburst(df.to_native(), path=path, values='values', color='values')\n    assert ('coloraxis' in fig.data[0].marker)\n    assert np.all((np.array(fig.data[0].marker.colors) == 1))\n    assert (fig.data[0].values[(- 1)] == 8)", "ground_truth": "'total'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_225", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_sunburst_treemap_with_path", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_sunburst_treemap_with_path(constructor):\n    vendors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', 'Tech', 'Tech', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 2, 2, 1, 4]\n    total = (['total'] * 8)\n    df = constructor(dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df, path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    fig = px.sunburst(df, path=path, values='values')\n    assert (fig.data[0].branchvalues == 'total')\n    assert (fig.data[0].values[(- 1)] == np.sum(values))\n    df = nw.from_native(df)\n    native_namespace = nw.get_native_namespace(df)\n    df = df.with_columns(values=nw.new_series('values', ['1 000', '3 000', '2', '4', '2', '2', '1 000', '4 000'], dtype=nw.String(), native_namespace=native_namespace))\n    pd_msg = 'Column `values` of `df` could not be converted to a numerical data type.'\n    pl_msg = \"conversion from `str` to `f64` failed in column 'values'\"\n    with pytest.raises((ValueError, InvalidOperationError), match=f'({pd_msg}|{pl_msg})'):\n        fig = px.sunburst(df.to_native(), path=path, values='values')\n    path = [df.get_column('total').to_native(), 'regions', df.get_column('sectors').to_native(), 'vendors']\n    fig = px.sunburst(df.to_native(), path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    df = df.with_columns(values=nw.lit(1))\n    fig = px.sunburst(df.to_native(), path=path, values='values', color='values')\n    assert ('coloraxis' in fig.data[0].marker)\n    assert np.all((np.array(fig.data[0].marker.colors) == 1))\n    assert (fig.data[0].values[(- 1)] == 8)", "masked_code": "def test_sunburst_treemap_with_path(constructor):\n    vendors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', 'Tech', 'Tech', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 2, 2, 1, 4]\n    total = (['total'] * 8)\n    df = constructor(dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df, path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    fig = px.sunburst(df, path=path, values='values')\n    assert (fig.data[0].branchvalues == 'total')\n    assert (fig.data[0].values[(- 1)] == np.sum(values))\n    df = nw.from_native(df)\n    native_namespace = nw.get_native_namespace(df)\n    df = df.with_columns(values=nw.new_series('values', ['1 000', '3 000', '2', '4', '2', '2', '1 000', '4 000'], dtype=nw.String(), native_namespace=native_namespace))\n    pd_msg = 'Column `values` of `df` could not be converted to a numerical data type.'\n    pl_msg = \"conversion from `str` to `f64` failed in column 'values'\"\n    with pytest.raises((ValueError, InvalidOperationError), match=f'({pd_msg}|{pl_msg})'):\n        fig = px.sunburst(df.to_native(), path=path, values='values')\n    path = [df.get_column('total').to_native(), 'regions', df.get_column('sectors').to_native(), 'vendors']\n    fig = px.sunburst(df.to_native(), path=path)\n    assert (fig.data[0].branchvalues == 'total')\n    df = df.with_columns(values=nw.lit(1))\n    fig = px.sunburst(df.to_native(), path=path, values='values', color='values')\n    assert ('coloraxis' in fig.data[0].marker)\n    assert np.all((np.array(fig.data[0].marker.colors) == 1))\n    assert (fig.data[0].values[(- 1)] == '???')", "ground_truth": "8", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_226", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_sunburst_treemap_with_path_and_hover", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_sunburst_treemap_with_path_and_hover(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.sunburst(df, path=['sex', 'day', 'time', 'smoker'], color='smoker', hover_data=['smoker'])\n    assert ('smoker' in fig.data[0].hovertemplate)\n    df = nw.from_native(px.data.gapminder(year=2007, return_type=backend))\n    fig = px.sunburst(df.to_native(), path=['continent', 'country'], color='lifeExp', hover_data=df.columns)\n    assert (fig.layout.coloraxis.colorbar.title.text == 'lifeExp')\n    df = px.data.tips(return_type=backend)\n    fig = px.sunburst(df, path=['sex', 'day', 'time', 'smoker'], hover_name='smoker')\n    assert ('smoker' not in fig.data[0].hovertemplate)\n    assert ('%{hovertext}' in fig.data[0].hovertemplate)\n    df = px.data.tips(return_type=backend)\n    fig = px.sunburst(df, path=['sex', 'day', 'time', 'smoker'], custom_data=['smoker'])\n    assert (fig.data[0].customdata[0][0] in ['Yes', 'No'])\n    assert ('smoker' not in fig.data[0].hovertemplate)\n    assert ('%{hovertext}' not in fig.data[0].hovertemplate)", "masked_code": "def test_sunburst_treemap_with_path_and_hover(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.sunburst(df, path=['sex', 'day', 'time', 'smoker'], color='smoker', hover_data=['smoker'])\n    assert ('smoker' in fig.data[0].hovertemplate)\n    df = nw.from_native(px.data.gapminder(year=2007, return_type=backend))\n    fig = px.sunburst(df.to_native(), path=['continent', 'country'], color='lifeExp', hover_data=df.columns)\n    assert (fig.layout.coloraxis.colorbar.title.text == '???')\n    df = px.data.tips(return_type=backend)\n    fig = px.sunburst(df, path=['sex', 'day', 'time', 'smoker'], hover_name='smoker')\n    assert ('smoker' not in fig.data[0].hovertemplate)\n    assert ('%{hovertext}' in fig.data[0].hovertemplate)\n    df = px.data.tips(return_type=backend)\n    fig = px.sunburst(df, path=['sex', 'day', 'time', 'smoker'], custom_data=['smoker'])\n    assert (fig.data[0].customdata[0][0] in ['Yes', 'No'])\n    assert ('smoker' not in fig.data[0].hovertemplate)\n    assert ('%{hovertext}' not in fig.data[0].hovertemplate)", "ground_truth": "'lifeExp'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_227", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_sunburst_treemap_with_path_color", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_sunburst_treemap_with_path_color(constructor):\n    vendors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', 'Tech', 'Tech', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 2, 2, 1, 4]\n    calls = [8, 2, 1, 3, 2, 2, 4, 1]\n    total = (['total'] * 8)\n    hover = [el.lower() for el in vendors]\n    data = dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total, calls=calls)\n    df = nw.from_native(constructor(data))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df.to_native(), path=path, values='values', color='calls')\n    colors = fig.data[0].marker.colors\n    assert np.all((np.array(np.sort(colors[:8])) == np.array(sorted(calls))))\n    fig = px.sunburst(df.to_native(), path=path, color='calls')\n    colors = fig.data[0].marker.colors\n    assert np.all((np.sort(colors[:8]) == np.array(sorted(calls))))\n    df = df.with_columns(hover=nw.new_series(name='hover', values=hover, dtype=nw.String(), native_namespace=nw.get_native_namespace(df)))\n    fig = px.sunburst(df.to_native(), path=path, color='calls', hover_data=['hover'])\n    custom = fig.data[0].customdata\n    assert np.all((np.sort(custom[(:8, 0)]) == sorted(hover)))\n    assert np.all((np.sort(custom[(8:, 0)]) == '(?)'))\n    assert np.all((np.sort(custom[(:8, 1)]) == sorted(calls)))\n    fig = px.sunburst(df.to_native(), path=path, color='vendors')\n    assert (len(np.unique(fig.data[0].marker.colors)) == 9)\n    cmap = {'Tech': 'yellow', 'Finance': 'magenta', '(?)': 'black'}\n    fig = px.sunburst(df.to_native(), path=path, color='sectors', color_discrete_map=cmap)\n    assert np.all(np.in1d(fig.data[0].marker.colors, list(cmap.values())))\n    df = nw.from_native(df).with_columns(regions=nw.when((nw.col('regions') == 'North')).then(1).otherwise(2).cast(nw.Int64())).to_native()\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df, path=path, values='values', color='calls')\n    colors = fig.data[0].marker.colors\n    assert np.all((np.sort(colors[:8]) == sorted(calls)))", "masked_code": "def test_sunburst_treemap_with_path_color(constructor):\n    vendors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', 'Tech', 'Tech', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 2, 2, 1, 4]\n    calls = [8, 2, 1, 3, 2, 2, 4, 1]\n    total = (['total'] * 8)\n    hover = [el.lower() for el in vendors]\n    data = dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total, calls=calls)\n    df = nw.from_native(constructor(data))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df.to_native(), path=path, values='values', color='calls')\n    colors = fig.data[0].marker.colors\n    assert np.all((np.array(np.sort(colors[:8])) == np.array(sorted(calls))))\n    fig = px.sunburst(df.to_native(), path=path, color='calls')\n    colors = fig.data[0].marker.colors\n    assert np.all((np.sort(colors[:8]) == np.array(sorted(calls))))\n    df = df.with_columns(hover=nw.new_series(name='hover', values=hover, dtype=nw.String(), native_namespace=nw.get_native_namespace(df)))\n    fig = px.sunburst(df.to_native(), path=path, color='calls', hover_data=['hover'])\n    custom = fig.data[0].customdata\n    assert np.all((np.sort(custom[(:8, 0)]) == sorted(hover)))\n    assert np.all((np.sort(custom[(8:, 0)]) == '(?)'))\n    assert np.all((np.sort(custom[(:8, 1)]) == sorted(calls)))\n    fig = px.sunburst(df.to_native(), path=path, color='vendors')\n    assert (len(np.unique(fig.data[0].marker.colors)) == '???')\n    cmap = {'Tech': 'yellow', 'Finance': 'magenta', '(?)': 'black'}\n    fig = px.sunburst(df.to_native(), path=path, color='sectors', color_discrete_map=cmap)\n    assert np.all(np.in1d(fig.data[0].marker.colors, list(cmap.values())))\n    df = nw.from_native(df).with_columns(regions=nw.when((nw.col('regions') == 'North')).then(1).otherwise(2).cast(nw.Int64())).to_native()\n    path = ['total', 'regions', 'sectors', 'vendors']\n    fig = px.sunburst(df, path=path, values='values', color='calls')\n    colors = fig.data[0].marker.colors\n    assert np.all((np.sort(colors[:8]) == sorted(calls)))", "ground_truth": "9", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_228", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_sunburst_treemap_with_path_non_rectangular", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_sunburst_treemap_with_path_non_rectangular(constructor):\n    vendors = ['A', 'B', 'C', 'D', None, 'E', 'F', 'G', 'H', None]\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', None, 'Tech', 'Tech', 'Finance', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'North', 'South', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 1, 2, 2, 1, 4, 1]\n    total = (['total'] * 10)\n    df = constructor(dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    msg = 'Non-leaves rows are not permitted in the dataframe'\n    with pytest.raises(ValueError, match=msg):\n        fig = px.sunburst(df, path=path, values='values')\n    df = nw.from_native(df).with_columns(sectors=nw.when((~ nw.col('vendors').is_null())).then(nw.col('sectors')).otherwise(nw.lit('Other'))).to_native()\n    fig = px.sunburst(df, path=path, values='values')\n    assert (fig.data[0].values[(- 1)] == np.sum(values))", "masked_code": "def test_sunburst_treemap_with_path_non_rectangular(constructor):\n    vendors = ['A', 'B', 'C', 'D', None, 'E', 'F', 'G', 'H', None]\n    sectors = ['Tech', 'Tech', 'Finance', 'Finance', None, 'Tech', 'Tech', 'Finance', 'Finance', 'Finance']\n    regions = ['North', 'North', 'North', 'North', 'North', 'South', 'South', 'South', 'South', 'South']\n    values = [1, 3, 2, 4, 1, 2, 2, 1, 4, 1]\n    total = (['total'] * 10)\n    df = constructor(dict(vendors=vendors, sectors=sectors, regions=regions, values=values, total=total))\n    path = ['total', 'regions', 'sectors', 'vendors']\n    msg = 'Non-leaves rows are not permitted in the dataframe'\n    with pytest.raises(ValueError, match=msg):\n        fig = px.sunburst(df, path=path, values='values')\n    df = nw.from_native(df).with_columns(sectors=nw.when((~ nw.col('vendors').is_null())).then(nw.col('sectors')).otherwise(nw.lit('Other'))).to_native()\n    fig = px.sunburst(df, path=path, values='values')\n    assert (fig.data[0].values[(- 1)] == '???')", "ground_truth": "np.sum(values)", "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_229", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_pie_funnelarea_colorscale", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_pie_funnelarea_colorscale():\n    labels = ['A', 'B', 'C', 'D']\n    values = [3, 2, 1, 4]\n    for (func, colorway) in zip([px.sunburst, px.treemap], ['sunburstcolorway', 'treemapcolorway']):\n        color_seq = px.colors.sequential.Reds\n        fig = func(names=labels, values=values, color_discrete_sequence=color_seq)\n        assert (list(fig.layout[colorway]) == color_seq)\n        color_seq = px.colors.sequential.Reds\n        fig = func(names=labels, values=values, color=labels, color_discrete_sequence=color_seq)\n        assert np.all([(col in color_seq) for col in fig.data[0].marker.colors])", "masked_code": "def test_pie_funnelarea_colorscale():\n    labels = ['A', 'B', 'C', 'D']\n    values = [3, 2, 1, 4]\n    for (func, colorway) in zip([px.sunburst, px.treemap], ['sunburstcolorway', 'treemapcolorway']):\n        color_seq = px.colors.sequential.Reds\n        fig = func(names=labels, values=values, color_discrete_sequence=color_seq)\n        assert (list(fig.layout[colorway]) == '???')\n        color_seq = px.colors.sequential.Reds\n        fig = func(names=labels, values=values, color=labels, color_discrete_sequence=color_seq)\n        assert np.all([(col in color_seq) for col in fig.data[0].marker.colors])", "ground_truth": "color_seq", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_230", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_parcats_dimensions_max", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_parcats_dimensions_max(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.parallel_categories(df)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time', 'size'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day'])\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day'])\n    fig = px.parallel_categories(df, dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day', 'size'], dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'size'])", "masked_code": "def test_parcats_dimensions_max(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.parallel_categories(df)\n    assert ([d.label for d in fig.data[0].dimensions] == '???')\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day'])\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day'])\n    fig = px.parallel_categories(df, dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day', 'size'], dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'size'])", "ground_truth": "['sex', 'smoker', 'day', 'time', 'size']", "quality_analysis": {"complexity_score": 7, "left_complexity": 0, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_231", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_parcats_dimensions_max", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_parcats_dimensions_max(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.parallel_categories(df)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time', 'size'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day'])\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day'])\n    fig = px.parallel_categories(df, dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day', 'size'], dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'size'])", "masked_code": "def test_parcats_dimensions_max(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.parallel_categories(df)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time', 'size'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day'])\n    assert ([d.label for d in fig.data[0].dimensions] == '???')\n    fig = px.parallel_categories(df, dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day', 'size'], dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'size'])", "ground_truth": "['sex', 'smoker', 'day']", "quality_analysis": {"complexity_score": 5, "left_complexity": 0, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_232", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_parcats_dimensions_max", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_parcats_dimensions_max(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.parallel_categories(df)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time', 'size'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day'])\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day'])\n    fig = px.parallel_categories(df, dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day', 'size'], dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'size'])", "masked_code": "def test_parcats_dimensions_max(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.parallel_categories(df)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time', 'size'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day'])\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day'])\n    fig = px.parallel_categories(df, dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == '???')\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day', 'size'], dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'size'])", "ground_truth": "['sex', 'smoker', 'day', 'time']", "quality_analysis": {"complexity_score": 6, "left_complexity": 0, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_233", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_parcats_dimensions_max", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_parcats_dimensions_max(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.parallel_categories(df)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time', 'size'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day'])\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day'])\n    fig = px.parallel_categories(df, dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day', 'size'], dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'size'])", "masked_code": "def test_parcats_dimensions_max(backend):\n    df = px.data.tips(return_type=backend)\n    fig = px.parallel_categories(df)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time', 'size'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day'])\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day'])\n    fig = px.parallel_categories(df, dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == ['sex', 'smoker', 'day', 'time'])\n    fig = px.parallel_categories(df, dimensions=['sex', 'smoker', 'day', 'size'], dimensions_max_cardinality=4)\n    assert ([d.label for d in fig.data[0].dimensions] == '???')", "ground_truth": "['sex', 'smoker', 'day', 'size']", "quality_analysis": {"complexity_score": 6, "left_complexity": 0, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_234", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_histfunc_hoverlabels_univariate", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "@pytest.mark.parametrize('histfunc,y', [(None, None), ('count', 'tip')])\ndef test_histfunc_hoverlabels_univariate(backend, histfunc, y):\n\n    def check_label(label, fig):\n        assert (fig.layout.yaxis.title.text == label)\n        assert ((label + '=') in fig.data[0].hovertemplate)\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', y=y, histfunc=histfunc)\n    check_label('count', fig)\n    for histnorm in ['probability', 'percent', 'density', 'probability density']:\n        fig = px.histogram(df, x='total_bill', y=y, histfunc=histfunc, histnorm=histnorm)\n        check_label(histnorm, fig)\n    for histnorm in ['probability', 'percent', 'density', 'probability density']:\n        for barnorm in ['percent', 'fraction']:\n            fig = px.histogram(df, x='total_bill', y=y, histfunc=histfunc, histnorm=histnorm, barnorm=barnorm)\n            check_label(('%s (normalized as %s)' % (histnorm, barnorm)), fig)", "masked_code": "@pytest.mark.parametrize('histfunc,y', [(None, None), ('count', 'tip')])\ndef test_histfunc_hoverlabels_univariate(backend, histfunc, y):\n\n    def check_label(label, fig):\n        assert (fig.layout.yaxis.title.text == '???')\n        assert ((label + '=') in fig.data[0].hovertemplate)\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', y=y, histfunc=histfunc)\n    check_label('count', fig)\n    for histnorm in ['probability', 'percent', 'density', 'probability density']:\n        fig = px.histogram(df, x='total_bill', y=y, histfunc=histfunc, histnorm=histnorm)\n        check_label(histnorm, fig)\n    for histnorm in ['probability', 'percent', 'density', 'probability density']:\n        for barnorm in ['percent', 'fraction']:\n            fig = px.histogram(df, x='total_bill', y=y, histfunc=histfunc, histnorm=histnorm, barnorm=barnorm)\n            check_label(('%s (normalized as %s)' % (histnorm, barnorm)), fig)", "ground_truth": "label", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_235", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_histfunc_hoverlabels_bivariate", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_histfunc_hoverlabels_bivariate(backend):\n\n    def check_label(label, fig):\n        assert (fig.layout.yaxis.title.text == label)\n        assert ((label + '=') in fig.data[0].hovertemplate)\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', y='tip')\n    check_label('sum of tip', fig)\n    fig = px.histogram(df, x='total_bill', y='tip', histnorm='probability')\n    check_label('fraction of sum of tip', fig)\n    fig = px.histogram(df, x='total_bill', y='tip', histnorm='percent')\n    check_label('percent of sum of tip', fig)\n    for histnorm in ['density', 'probability density']:\n        fig = px.histogram(df, x='total_bill', y='tip', histnorm=histnorm)\n        check_label(('%s weighted by tip' % histnorm), fig)\n    for histnorm in ['density', 'probability density']:\n        for barnorm in ['fraction', 'percent']:\n            fig = px.histogram(df, x='total_bill', y='tip', histnorm=histnorm, barnorm=barnorm)\n            check_label(('%s weighted by tip (normalized as %s)' % (histnorm, barnorm)), fig)\n    fig = px.histogram(df, x='total_bill', y='tip', histfunc='min', histnorm='probability', barnorm='percent')\n    check_label('fraction of sum of min of tip (normalized as percent)', fig)\n    fig = px.histogram(df, x='total_bill', y='tip', histfunc='avg', histnorm='percent', barnorm='fraction')\n    check_label('percent of sum of avg of tip (normalized as fraction)', fig)\n    fig = px.histogram(df, x='total_bill', y='tip', histfunc='max', histnorm='density')\n    check_label('density of max of tip', fig)", "masked_code": "def test_histfunc_hoverlabels_bivariate(backend):\n\n    def check_label(label, fig):\n        assert (fig.layout.yaxis.title.text == '???')\n        assert ((label + '=') in fig.data[0].hovertemplate)\n    df = px.data.tips(return_type=backend)\n    fig = px.histogram(df, x='total_bill', y='tip')\n    check_label('sum of tip', fig)\n    fig = px.histogram(df, x='total_bill', y='tip', histnorm='probability')\n    check_label('fraction of sum of tip', fig)\n    fig = px.histogram(df, x='total_bill', y='tip', histnorm='percent')\n    check_label('percent of sum of tip', fig)\n    for histnorm in ['density', 'probability density']:\n        fig = px.histogram(df, x='total_bill', y='tip', histnorm=histnorm)\n        check_label(('%s weighted by tip' % histnorm), fig)\n    for histnorm in ['density', 'probability density']:\n        for barnorm in ['fraction', 'percent']:\n            fig = px.histogram(df, x='total_bill', y='tip', histnorm=histnorm, barnorm=barnorm)\n            check_label(('%s weighted by tip (normalized as %s)' % (histnorm, barnorm)), fig)\n    fig = px.histogram(df, x='total_bill', y='tip', histfunc='min', histnorm='probability', barnorm='percent')\n    check_label('fraction of sum of min of tip (normalized as percent)', fig)\n    fig = px.histogram(df, x='total_bill', y='tip', histfunc='avg', histnorm='percent', barnorm='fraction')\n    check_label('percent of sum of avg of tip (normalized as fraction)', fig)\n    fig = px.histogram(df, x='total_bill', y='tip', histfunc='max', histnorm='density')\n    check_label('density of max of tip', fig)", "ground_truth": "label", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_236", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_timeline", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_timeline(constructor):\n    df = constructor({'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']})\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.layout.xaxis.type == 'date')\n    assert (fig.layout.xaxis.title.text is None)\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', facet_row='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.data[1].xaxis == 'x2')\n    assert (fig.layout.xaxis.type == 'date')\n    msg = 'Both x_start and x_end are required'\n    with pytest.raises(ValueError, match=msg):\n        px.timeline(df, x_start='Start', y='Task', color='Task')\n    msg = 'Both x_start and x_end must refer to data convertible to datetimes.'\n    with pytest.raises(TypeError, match=msg):\n        px.timeline(df, x_start='Start', x_end=['a', 'b', 'c'], y='Task', color='Task')", "masked_code": "def test_timeline(constructor):\n    df = constructor({'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']})\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == '???')\n    assert (fig.layout.xaxis.type == 'date')\n    assert (fig.layout.xaxis.title.text is None)\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', facet_row='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.data[1].xaxis == 'x2')\n    assert (fig.layout.xaxis.type == 'date')\n    msg = 'Both x_start and x_end are required'\n    with pytest.raises(ValueError, match=msg):\n        px.timeline(df, x_start='Start', y='Task', color='Task')\n    msg = 'Both x_start and x_end must refer to data convertible to datetimes.'\n    with pytest.raises(TypeError, match=msg):\n        px.timeline(df, x_start='Start', x_end=['a', 'b', 'c'], y='Task', color='Task')", "ground_truth": "3", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_237", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_timeline", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_timeline(constructor):\n    df = constructor({'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']})\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.layout.xaxis.type == 'date')\n    assert (fig.layout.xaxis.title.text is None)\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', facet_row='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.data[1].xaxis == 'x2')\n    assert (fig.layout.xaxis.type == 'date')\n    msg = 'Both x_start and x_end are required'\n    with pytest.raises(ValueError, match=msg):\n        px.timeline(df, x_start='Start', y='Task', color='Task')\n    msg = 'Both x_start and x_end must refer to data convertible to datetimes.'\n    with pytest.raises(TypeError, match=msg):\n        px.timeline(df, x_start='Start', x_end=['a', 'b', 'c'], y='Task', color='Task')", "masked_code": "def test_timeline(constructor):\n    df = constructor({'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']})\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.layout.xaxis.type == '???')\n    assert (fig.layout.xaxis.title.text is None)\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', facet_row='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.data[1].xaxis == 'x2')\n    assert (fig.layout.xaxis.type == 'date')\n    msg = 'Both x_start and x_end are required'\n    with pytest.raises(ValueError, match=msg):\n        px.timeline(df, x_start='Start', y='Task', color='Task')\n    msg = 'Both x_start and x_end must refer to data convertible to datetimes.'\n    with pytest.raises(TypeError, match=msg):\n        px.timeline(df, x_start='Start', x_end=['a', 'b', 'c'], y='Task', color='Task')", "ground_truth": "'date'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_238", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_timeline", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_timeline(constructor):\n    df = constructor({'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']})\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.layout.xaxis.type == 'date')\n    assert (fig.layout.xaxis.title.text is None)\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', facet_row='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.data[1].xaxis == 'x2')\n    assert (fig.layout.xaxis.type == 'date')\n    msg = 'Both x_start and x_end are required'\n    with pytest.raises(ValueError, match=msg):\n        px.timeline(df, x_start='Start', y='Task', color='Task')\n    msg = 'Both x_start and x_end must refer to data convertible to datetimes.'\n    with pytest.raises(TypeError, match=msg):\n        px.timeline(df, x_start='Start', x_end=['a', 'b', 'c'], y='Task', color='Task')", "masked_code": "def test_timeline(constructor):\n    df = constructor({'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']})\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.layout.xaxis.type == 'date')\n    assert (fig.layout.xaxis.title.text is None)\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', facet_row='Task')\n    assert (len(fig.data) == '???')\n    assert (fig.data[1].xaxis == 'x2')\n    assert (fig.layout.xaxis.type == 'date')\n    msg = 'Both x_start and x_end are required'\n    with pytest.raises(ValueError, match=msg):\n        px.timeline(df, x_start='Start', y='Task', color='Task')\n    msg = 'Both x_start and x_end must refer to data convertible to datetimes.'\n    with pytest.raises(TypeError, match=msg):\n        px.timeline(df, x_start='Start', x_end=['a', 'b', 'c'], y='Task', color='Task')", "ground_truth": "3", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_239", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_timeline", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_timeline(constructor):\n    df = constructor({'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']})\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.layout.xaxis.type == 'date')\n    assert (fig.layout.xaxis.title.text is None)\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', facet_row='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.data[1].xaxis == 'x2')\n    assert (fig.layout.xaxis.type == 'date')\n    msg = 'Both x_start and x_end are required'\n    with pytest.raises(ValueError, match=msg):\n        px.timeline(df, x_start='Start', y='Task', color='Task')\n    msg = 'Both x_start and x_end must refer to data convertible to datetimes.'\n    with pytest.raises(TypeError, match=msg):\n        px.timeline(df, x_start='Start', x_end=['a', 'b', 'c'], y='Task', color='Task')", "masked_code": "def test_timeline(constructor):\n    df = constructor({'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']})\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.layout.xaxis.type == 'date')\n    assert (fig.layout.xaxis.title.text is None)\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', facet_row='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.data[1].xaxis == '???')\n    assert (fig.layout.xaxis.type == 'date')\n    msg = 'Both x_start and x_end are required'\n    with pytest.raises(ValueError, match=msg):\n        px.timeline(df, x_start='Start', y='Task', color='Task')\n    msg = 'Both x_start and x_end must refer to data convertible to datetimes.'\n    with pytest.raises(TypeError, match=msg):\n        px.timeline(df, x_start='Start', x_end=['a', 'b', 'c'], y='Task', color='Task')", "ground_truth": "'x2'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_240", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_timeline", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "def test_timeline(constructor):\n    df = constructor({'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']})\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.layout.xaxis.type == 'date')\n    assert (fig.layout.xaxis.title.text is None)\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', facet_row='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.data[1].xaxis == 'x2')\n    assert (fig.layout.xaxis.type == 'date')\n    msg = 'Both x_start and x_end are required'\n    with pytest.raises(ValueError, match=msg):\n        px.timeline(df, x_start='Start', y='Task', color='Task')\n    msg = 'Both x_start and x_end must refer to data convertible to datetimes.'\n    with pytest.raises(TypeError, match=msg):\n        px.timeline(df, x_start='Start', x_end=['a', 'b', 'c'], y='Task', color='Task')", "masked_code": "def test_timeline(constructor):\n    df = constructor({'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']})\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.layout.xaxis.type == 'date')\n    assert (fig.layout.xaxis.title.text is None)\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', facet_row='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.data[1].xaxis == 'x2')\n    assert (fig.layout.xaxis.type == '???')\n    msg = 'Both x_start and x_end are required'\n    with pytest.raises(ValueError, match=msg):\n        px.timeline(df, x_start='Start', y='Task', color='Task')\n    msg = 'Both x_start and x_end must refer to data convertible to datetimes.'\n    with pytest.raises(TypeError, match=msg):\n        px.timeline(df, x_start='Start', x_end=['a', 'b', 'c'], y='Task', color='Task')", "ground_truth": "'date'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_241", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_timeline_cols_already_temporal", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "@pytest.mark.parametrize('datetime_columns', [['Start'], ['Start', 'Finish'], ['Finish']])\ndef test_timeline_cols_already_temporal(constructor, datetime_columns):\n    data = {'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']}\n    df = nw.from_native(constructor(data)).with_columns(nw.col(datetime_columns).str.to_datetime(format='%Y-%m-%d')).to_native()\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.layout.xaxis.type == 'date')\n    assert (fig.layout.xaxis.title.text is None)", "masked_code": "@pytest.mark.parametrize('datetime_columns', [['Start'], ['Start', 'Finish'], ['Finish']])\ndef test_timeline_cols_already_temporal(constructor, datetime_columns):\n    data = {'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']}\n    df = nw.from_native(constructor(data)).with_columns(nw.col(datetime_columns).str.to_datetime(format='%Y-%m-%d')).to_native()\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == '???')\n    assert (fig.layout.xaxis.type == 'date')\n    assert (fig.layout.xaxis.title.text is None)", "ground_truth": "3", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_242", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_functions.py", "testname": "test_px_functions.py", "classname": null, "funcname": "test_timeline_cols_already_temporal", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "from numpy.testing import assert_array_equal", "import narwhals.stable.v1 as nw", "import numpy as np", "from polars.exceptions import InvalidOperationError", "import pytest"], "code": "@pytest.mark.parametrize('datetime_columns', [['Start'], ['Start', 'Finish'], ['Finish']])\ndef test_timeline_cols_already_temporal(constructor, datetime_columns):\n    data = {'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']}\n    df = nw.from_native(constructor(data)).with_columns(nw.col(datetime_columns).str.to_datetime(format='%Y-%m-%d')).to_native()\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.layout.xaxis.type == 'date')\n    assert (fig.layout.xaxis.title.text is None)", "masked_code": "@pytest.mark.parametrize('datetime_columns', [['Start'], ['Start', 'Finish'], ['Finish']])\ndef test_timeline_cols_already_temporal(constructor, datetime_columns):\n    data = {'Task': ['Job A', 'Job B', 'Job C'], 'Start': ['2009-01-01', '2009-03-05', '2009-02-20'], 'Finish': ['2009-02-28', '2009-04-15', '2009-05-30']}\n    df = nw.from_native(constructor(data)).with_columns(nw.col(datetime_columns).str.to_datetime(format='%Y-%m-%d')).to_native()\n    fig = px.timeline(df, x_start='Start', x_end='Finish', y='Task', color='Task')\n    assert (len(fig.data) == 3)\n    assert (fig.layout.xaxis.type == '???')\n    assert (fig.layout.xaxis.title.text is None)", "ground_truth": "'date'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_243", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_hover.py", "testname": "test_px_hover.py", "classname": null, "funcname": "test_skip_hover", "imports": ["import plotly.express as px", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from collections import OrderedDict"], "code": "def test_skip_hover(backend):\n    df = px.data.iris(return_type=backend)\n    fig = px.scatter(df, x='petal_length', y='petal_width', size='species_id', hover_data={'petal_length': None, 'petal_width': None})\n    assert (fig.data[0].hovertemplate == 'species_id=%{marker.size}<extra></extra>')", "masked_code": "def test_skip_hover(backend):\n    df = px.data.iris(return_type=backend)\n    fig = px.scatter(df, x='petal_length', y='petal_width', size='species_id', hover_data={'petal_length': None, 'petal_width': None})\n    assert (fig.data[0].hovertemplate == '???')", "ground_truth": "'species_id=%{marker.size}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_244", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_hover.py", "testname": "test_px_hover.py", "classname": null, "funcname": "test_newdatain_hover_data", "imports": ["import plotly.express as px", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from collections import OrderedDict"], "code": "def test_newdatain_hover_data():\n    hover_dicts = [{'comment': ['a', 'b', 'c']}, {'comment': (1.234, 45.3455, 5666.234)}, {'comment': [1.234, 45.3455, 5666.234]}, {'comment': np.array([1.234, 45.3455, 5666.234])}, {'comment': pd.Series([1.234, 45.3455, 5666.234])}]\n    for hover_dict in hover_dicts:\n        fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data=hover_dict)\n        assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]}<extra></extra>')\n    fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data={'comment': (True, ['a', 'b', 'c'])})\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]}<extra></extra>')\n    hover_dicts = [{'comment': (':.1f', (1.234, 45.3455, 5666.234))}, {'comment': (':.1f', [1.234, 45.3455, 5666.234])}, {'comment': (':.1f', np.array([1.234, 45.3455, 5666.234]))}, {'comment': (':.1f', pd.Series([1.234, 45.3455, 5666.234]))}]\n    for hover_dict in hover_dicts:\n        fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data=hover_dict)\n        assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]:.1f}<extra></extra>')", "masked_code": "def test_newdatain_hover_data():\n    hover_dicts = [{'comment': ['a', 'b', 'c']}, {'comment': (1.234, 45.3455, 5666.234)}, {'comment': [1.234, 45.3455, 5666.234]}, {'comment': np.array([1.234, 45.3455, 5666.234])}, {'comment': pd.Series([1.234, 45.3455, 5666.234])}]\n    for hover_dict in hover_dicts:\n        fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data=hover_dict)\n        assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]}<extra></extra>')\n    fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data={'comment': (True, ['a', 'b', 'c'])})\n    assert (fig.data[0].hovertemplate == '???')\n    hover_dicts = [{'comment': (':.1f', (1.234, 45.3455, 5666.234))}, {'comment': (':.1f', [1.234, 45.3455, 5666.234])}, {'comment': (':.1f', np.array([1.234, 45.3455, 5666.234]))}, {'comment': (':.1f', pd.Series([1.234, 45.3455, 5666.234]))}]\n    for hover_dict in hover_dicts:\n        fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data=hover_dict)\n        assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]:.1f}<extra></extra>')", "ground_truth": "'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_245", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_hover.py", "testname": "test_px_hover.py", "classname": null, "funcname": "test_newdatain_hover_data", "imports": ["import plotly.express as px", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from collections import OrderedDict"], "code": "def test_newdatain_hover_data():\n    hover_dicts = [{'comment': ['a', 'b', 'c']}, {'comment': (1.234, 45.3455, 5666.234)}, {'comment': [1.234, 45.3455, 5666.234]}, {'comment': np.array([1.234, 45.3455, 5666.234])}, {'comment': pd.Series([1.234, 45.3455, 5666.234])}]\n    for hover_dict in hover_dicts:\n        fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data=hover_dict)\n        assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]}<extra></extra>')\n    fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data={'comment': (True, ['a', 'b', 'c'])})\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]}<extra></extra>')\n    hover_dicts = [{'comment': (':.1f', (1.234, 45.3455, 5666.234))}, {'comment': (':.1f', [1.234, 45.3455, 5666.234])}, {'comment': (':.1f', np.array([1.234, 45.3455, 5666.234]))}, {'comment': (':.1f', pd.Series([1.234, 45.3455, 5666.234]))}]\n    for hover_dict in hover_dicts:\n        fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data=hover_dict)\n        assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]:.1f}<extra></extra>')", "masked_code": "def test_newdatain_hover_data():\n    hover_dicts = [{'comment': ['a', 'b', 'c']}, {'comment': (1.234, 45.3455, 5666.234)}, {'comment': [1.234, 45.3455, 5666.234]}, {'comment': np.array([1.234, 45.3455, 5666.234])}, {'comment': pd.Series([1.234, 45.3455, 5666.234])}]\n    for hover_dict in hover_dicts:\n        fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data=hover_dict)\n        assert (fig.data[0].hovertemplate == '???')\n    fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data={'comment': (True, ['a', 'b', 'c'])})\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]}<extra></extra>')\n    hover_dicts = [{'comment': (':.1f', (1.234, 45.3455, 5666.234))}, {'comment': (':.1f', [1.234, 45.3455, 5666.234])}, {'comment': (':.1f', np.array([1.234, 45.3455, 5666.234]))}, {'comment': (':.1f', pd.Series([1.234, 45.3455, 5666.234]))}]\n    for hover_dict in hover_dicts:\n        fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data=hover_dict)\n        assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]:.1f}<extra></extra>')", "ground_truth": "'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_246", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_hover.py", "testname": "test_px_hover.py", "classname": null, "funcname": "test_newdatain_hover_data", "imports": ["import plotly.express as px", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from collections import OrderedDict"], "code": "def test_newdatain_hover_data():\n    hover_dicts = [{'comment': ['a', 'b', 'c']}, {'comment': (1.234, 45.3455, 5666.234)}, {'comment': [1.234, 45.3455, 5666.234]}, {'comment': np.array([1.234, 45.3455, 5666.234])}, {'comment': pd.Series([1.234, 45.3455, 5666.234])}]\n    for hover_dict in hover_dicts:\n        fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data=hover_dict)\n        assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]}<extra></extra>')\n    fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data={'comment': (True, ['a', 'b', 'c'])})\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]}<extra></extra>')\n    hover_dicts = [{'comment': (':.1f', (1.234, 45.3455, 5666.234))}, {'comment': (':.1f', [1.234, 45.3455, 5666.234])}, {'comment': (':.1f', np.array([1.234, 45.3455, 5666.234]))}, {'comment': (':.1f', pd.Series([1.234, 45.3455, 5666.234]))}]\n    for hover_dict in hover_dicts:\n        fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data=hover_dict)\n        assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]:.1f}<extra></extra>')", "masked_code": "def test_newdatain_hover_data():\n    hover_dicts = [{'comment': ['a', 'b', 'c']}, {'comment': (1.234, 45.3455, 5666.234)}, {'comment': [1.234, 45.3455, 5666.234]}, {'comment': np.array([1.234, 45.3455, 5666.234])}, {'comment': pd.Series([1.234, 45.3455, 5666.234])}]\n    for hover_dict in hover_dicts:\n        fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data=hover_dict)\n        assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]}<extra></extra>')\n    fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data={'comment': (True, ['a', 'b', 'c'])})\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]}<extra></extra>')\n    hover_dicts = [{'comment': (':.1f', (1.234, 45.3455, 5666.234))}, {'comment': (':.1f', [1.234, 45.3455, 5666.234])}, {'comment': (':.1f', np.array([1.234, 45.3455, 5666.234]))}, {'comment': (':.1f', pd.Series([1.234, 45.3455, 5666.234]))}]\n    for hover_dict in hover_dicts:\n        fig = px.scatter(x=[1, 2, 3], y=[3, 4, 5], hover_data=hover_dict)\n        assert (fig.data[0].hovertemplate == '???')", "ground_truth": "'x=%{x}<br>y=%{y}<br>comment=%{customdata[0]:.1f}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_247", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_hover.py", "testname": "test_px_hover.py", "classname": null, "funcname": "test_date_in_hover", "imports": ["import plotly.express as px", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from collections import OrderedDict"], "code": "def test_date_in_hover(constructor):\n    df = nw.from_native(constructor({'date': ['2015-04-04 19:31:30+0100'], 'value': [3]})).with_columns(date=nw.col('date').str.to_datetime(format='%Y-%m-%d %H:%M:%S%z'))\n    fig = px.scatter(df.to_native(), x='value', y='value', hover_data=['date'])\n    assert (nw.to_py_scalar(fig.data[0].customdata[0][0]) == nw.to_py_scalar(df.item(row=0, column='date')).replace(tzinfo=None))", "masked_code": "def test_date_in_hover(constructor):\n    df = nw.from_native(constructor({'date': ['2015-04-04 19:31:30+0100'], 'value': [3]})).with_columns(date=nw.col('date').str.to_datetime(format='%Y-%m-%d %H:%M:%S%z'))\n    fig = px.scatter(df.to_native(), x='value', y='value', hover_data=['date'])\n    assert (nw.to_py_scalar(fig.data[0].customdata[0][0]) == '???')", "ground_truth": "nw.to_py_scalar(df.item(row=0, column='date')).replace(tzinfo=None)", "quality_analysis": {"complexity_score": 16, "left_complexity": 13, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_248", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_numpy_labels", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_numpy_labels():\n    fig = px.scatter(x=[1, 2, 3], y=[2, 3, 4], labels={'x': 'time'})\n    assert (fig.data[0]['hovertemplate'] == 'time=%{x}<br>y=%{y}<extra></extra>')", "masked_code": "def test_numpy_labels():\n    fig = px.scatter(x=[1, 2, 3], y=[2, 3, 4], labels={'x': 'time'})\n    assert (fig.data[0]['hovertemplate'] == '???')", "ground_truth": "'time=%{x}<br>y=%{y}<extra></extra>'", "quality_analysis": {"complexity_score": 11, "left_complexity": 10, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_249", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_with_index", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_with_index():\n    tips = px.data.tips()\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill)\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill, labels={'index': 'number'})\n    assert (fig.data[0]['hovertemplate'] == 'number=%{x}<br>total_bill=%{y}<extra></extra>')\n    with pytest.raises(ValueError) as err_msg:\n        fig = px.scatter(tips, x='index', y='total_bill')\n    assert ('To use the index, pass it in directly as `df.index`.' in str(err_msg.value))\n    tips = px.data.tips()\n    tips.index.name = 'item'\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'item=%{x}<br>total_bill=%{y}<extra></extra>')", "masked_code": "def test_with_index():\n    tips = px.data.tips()\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == '???')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill)\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill, labels={'index': 'number'})\n    assert (fig.data[0]['hovertemplate'] == 'number=%{x}<br>total_bill=%{y}<extra></extra>')\n    with pytest.raises(ValueError) as err_msg:\n        fig = px.scatter(tips, x='index', y='total_bill')\n    assert ('To use the index, pass it in directly as `df.index`.' in str(err_msg.value))\n    tips = px.data.tips()\n    tips.index.name = 'item'\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'item=%{x}<br>total_bill=%{y}<extra></extra>')", "ground_truth": "'index=%{x}<br>total_bill=%{y}<extra></extra>'", "quality_analysis": {"complexity_score": 11, "left_complexity": 10, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_250", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_with_index", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_with_index():\n    tips = px.data.tips()\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill)\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill, labels={'index': 'number'})\n    assert (fig.data[0]['hovertemplate'] == 'number=%{x}<br>total_bill=%{y}<extra></extra>')\n    with pytest.raises(ValueError) as err_msg:\n        fig = px.scatter(tips, x='index', y='total_bill')\n    assert ('To use the index, pass it in directly as `df.index`.' in str(err_msg.value))\n    tips = px.data.tips()\n    tips.index.name = 'item'\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'item=%{x}<br>total_bill=%{y}<extra></extra>')", "masked_code": "def test_with_index():\n    tips = px.data.tips()\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill)\n    assert (fig.data[0]['hovertemplate'] == '???')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill, labels={'index': 'number'})\n    assert (fig.data[0]['hovertemplate'] == 'number=%{x}<br>total_bill=%{y}<extra></extra>')\n    with pytest.raises(ValueError) as err_msg:\n        fig = px.scatter(tips, x='index', y='total_bill')\n    assert ('To use the index, pass it in directly as `df.index`.' in str(err_msg.value))\n    tips = px.data.tips()\n    tips.index.name = 'item'\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'item=%{x}<br>total_bill=%{y}<extra></extra>')", "ground_truth": "'index=%{x}<br>total_bill=%{y}<extra></extra>'", "quality_analysis": {"complexity_score": 11, "left_complexity": 10, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_251", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_with_index", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_with_index():\n    tips = px.data.tips()\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill)\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill, labels={'index': 'number'})\n    assert (fig.data[0]['hovertemplate'] == 'number=%{x}<br>total_bill=%{y}<extra></extra>')\n    with pytest.raises(ValueError) as err_msg:\n        fig = px.scatter(tips, x='index', y='total_bill')\n    assert ('To use the index, pass it in directly as `df.index`.' in str(err_msg.value))\n    tips = px.data.tips()\n    tips.index.name = 'item'\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'item=%{x}<br>total_bill=%{y}<extra></extra>')", "masked_code": "def test_with_index():\n    tips = px.data.tips()\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill)\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill, labels={'index': 'number'})\n    assert (fig.data[0]['hovertemplate'] == '???')\n    with pytest.raises(ValueError) as err_msg:\n        fig = px.scatter(tips, x='index', y='total_bill')\n    assert ('To use the index, pass it in directly as `df.index`.' in str(err_msg.value))\n    tips = px.data.tips()\n    tips.index.name = 'item'\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'item=%{x}<br>total_bill=%{y}<extra></extra>')", "ground_truth": "'number=%{x}<br>total_bill=%{y}<extra></extra>'", "quality_analysis": {"complexity_score": 11, "left_complexity": 10, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_252", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_with_index", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_with_index():\n    tips = px.data.tips()\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill)\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill, labels={'index': 'number'})\n    assert (fig.data[0]['hovertemplate'] == 'number=%{x}<br>total_bill=%{y}<extra></extra>')\n    with pytest.raises(ValueError) as err_msg:\n        fig = px.scatter(tips, x='index', y='total_bill')\n    assert ('To use the index, pass it in directly as `df.index`.' in str(err_msg.value))\n    tips = px.data.tips()\n    tips.index.name = 'item'\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'item=%{x}<br>total_bill=%{y}<extra></extra>')", "masked_code": "def test_with_index():\n    tips = px.data.tips()\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill)\n    assert (fig.data[0]['hovertemplate'] == 'index=%{x}<br>total_bill=%{y}<extra></extra>')\n    fig = px.scatter(tips, x=tips.index, y=tips.total_bill, labels={'index': 'number'})\n    assert (fig.data[0]['hovertemplate'] == 'number=%{x}<br>total_bill=%{y}<extra></extra>')\n    with pytest.raises(ValueError) as err_msg:\n        fig = px.scatter(tips, x='index', y='total_bill')\n    assert ('To use the index, pass it in directly as `df.index`.' in str(err_msg.value))\n    tips = px.data.tips()\n    tips.index.name = 'item'\n    fig = px.scatter(tips, x=tips.index, y='total_bill')\n    assert (fig.data[0]['hovertemplate'] == '???')", "ground_truth": "'item=%{x}<br>total_bill=%{y}<extra></extra>'", "quality_analysis": {"complexity_score": 11, "left_complexity": 10, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_253", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_series", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_series(request, backend):\n    if (backend == 'pyarrow'):\n        request.applymarker(pytest.mark.xfail)\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    before_tip = (tips.get_column('total_bill') - tips.get_column('tip')).to_native()\n    day = tips.get_column('day').to_native()\n    tips = tips.to_native()\n    fig = px.bar(tips, x='day', y=before_tip)\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>y=%{y}<extra></extra>')\n    fig = px.bar(tips, x='day', y=before_tip, labels={'y': 'bill'})\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>bill=%{y}<extra></extra>')\n    fig = px.bar(tips, x='day', y='tip', facet_row=day, facet_col=day)\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>tip=%{y}<extra></extra>')", "masked_code": "def test_series(request, backend):\n    if (backend == 'pyarrow'):\n        request.applymarker(pytest.mark.xfail)\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    before_tip = (tips.get_column('total_bill') - tips.get_column('tip')).to_native()\n    day = tips.get_column('day').to_native()\n    tips = tips.to_native()\n    fig = px.bar(tips, x='day', y=before_tip)\n    assert (fig.data[0].hovertemplate == '???')\n    fig = px.bar(tips, x='day', y=before_tip, labels={'y': 'bill'})\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>bill=%{y}<extra></extra>')\n    fig = px.bar(tips, x='day', y='tip', facet_row=day, facet_col=day)\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>tip=%{y}<extra></extra>')", "ground_truth": "'day=%{x}<br>y=%{y}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_254", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_series", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_series(request, backend):\n    if (backend == 'pyarrow'):\n        request.applymarker(pytest.mark.xfail)\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    before_tip = (tips.get_column('total_bill') - tips.get_column('tip')).to_native()\n    day = tips.get_column('day').to_native()\n    tips = tips.to_native()\n    fig = px.bar(tips, x='day', y=before_tip)\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>y=%{y}<extra></extra>')\n    fig = px.bar(tips, x='day', y=before_tip, labels={'y': 'bill'})\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>bill=%{y}<extra></extra>')\n    fig = px.bar(tips, x='day', y='tip', facet_row=day, facet_col=day)\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>tip=%{y}<extra></extra>')", "masked_code": "def test_series(request, backend):\n    if (backend == 'pyarrow'):\n        request.applymarker(pytest.mark.xfail)\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    before_tip = (tips.get_column('total_bill') - tips.get_column('tip')).to_native()\n    day = tips.get_column('day').to_native()\n    tips = tips.to_native()\n    fig = px.bar(tips, x='day', y=before_tip)\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>y=%{y}<extra></extra>')\n    fig = px.bar(tips, x='day', y=before_tip, labels={'y': 'bill'})\n    assert (fig.data[0].hovertemplate == '???')\n    fig = px.bar(tips, x='day', y='tip', facet_row=day, facet_col=day)\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>tip=%{y}<extra></extra>')", "ground_truth": "'day=%{x}<br>bill=%{y}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_255", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_series", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_series(request, backend):\n    if (backend == 'pyarrow'):\n        request.applymarker(pytest.mark.xfail)\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    before_tip = (tips.get_column('total_bill') - tips.get_column('tip')).to_native()\n    day = tips.get_column('day').to_native()\n    tips = tips.to_native()\n    fig = px.bar(tips, x='day', y=before_tip)\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>y=%{y}<extra></extra>')\n    fig = px.bar(tips, x='day', y=before_tip, labels={'y': 'bill'})\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>bill=%{y}<extra></extra>')\n    fig = px.bar(tips, x='day', y='tip', facet_row=day, facet_col=day)\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>tip=%{y}<extra></extra>')", "masked_code": "def test_series(request, backend):\n    if (backend == 'pyarrow'):\n        request.applymarker(pytest.mark.xfail)\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    before_tip = (tips.get_column('total_bill') - tips.get_column('tip')).to_native()\n    day = tips.get_column('day').to_native()\n    tips = tips.to_native()\n    fig = px.bar(tips, x='day', y=before_tip)\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>y=%{y}<extra></extra>')\n    fig = px.bar(tips, x='day', y=before_tip, labels={'y': 'bill'})\n    assert (fig.data[0].hovertemplate == 'day=%{x}<br>bill=%{y}<extra></extra>')\n    fig = px.bar(tips, x='day', y='tip', facet_row=day, facet_col=day)\n    assert (fig.data[0].hovertemplate == '???')", "ground_truth": "'day=%{x}<br>tip=%{y}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_256", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_several_dataframes", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_several_dataframes(request, constructor):\n    if ('pyarrow_table' in str(constructor)):\n        request.applymarker(pytest.mark.xfail)\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[1, 10], z=[0.1, 0.8])))\n    df2 = nw.from_native(constructor(dict(time=[23, 26], money=[100, 200])))\n    fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='x')\n    assert (fig.data[0].hovertemplate == 'z=%{x}<br>y=%{y}<br>x=%{marker.size}<extra></extra>')\n    fig = px.scatter(df2.to_native(), x=df.get_column('z').to_native(), y=df2.get_column('money').to_native(), size=df.get_column('z').to_native())\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>money=%{y}<br>size=%{marker.size}<extra></extra>')\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='y')\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size=df.get_column('y').to_native())\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), size=df3.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>size=%{marker.size}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), hover_data=[df3.get_column('y').to_native()])\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>')", "masked_code": "def test_several_dataframes(request, constructor):\n    if ('pyarrow_table' in str(constructor)):\n        request.applymarker(pytest.mark.xfail)\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[1, 10], z=[0.1, 0.8])))\n    df2 = nw.from_native(constructor(dict(time=[23, 26], money=[100, 200])))\n    fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='x')\n    assert (fig.data[0].hovertemplate == '???')\n    fig = px.scatter(df2.to_native(), x=df.get_column('z').to_native(), y=df2.get_column('money').to_native(), size=df.get_column('z').to_native())\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>money=%{y}<br>size=%{marker.size}<extra></extra>')\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='y')\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size=df.get_column('y').to_native())\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), size=df3.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>size=%{marker.size}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), hover_data=[df3.get_column('y').to_native()])\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>')", "ground_truth": "'z=%{x}<br>y=%{y}<br>x=%{marker.size}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_257", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_several_dataframes", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_several_dataframes(request, constructor):\n    if ('pyarrow_table' in str(constructor)):\n        request.applymarker(pytest.mark.xfail)\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[1, 10], z=[0.1, 0.8])))\n    df2 = nw.from_native(constructor(dict(time=[23, 26], money=[100, 200])))\n    fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='x')\n    assert (fig.data[0].hovertemplate == 'z=%{x}<br>y=%{y}<br>x=%{marker.size}<extra></extra>')\n    fig = px.scatter(df2.to_native(), x=df.get_column('z').to_native(), y=df2.get_column('money').to_native(), size=df.get_column('z').to_native())\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>money=%{y}<br>size=%{marker.size}<extra></extra>')\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='y')\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size=df.get_column('y').to_native())\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), size=df3.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>size=%{marker.size}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), hover_data=[df3.get_column('y').to_native()])\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>')", "masked_code": "def test_several_dataframes(request, constructor):\n    if ('pyarrow_table' in str(constructor)):\n        request.applymarker(pytest.mark.xfail)\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[1, 10], z=[0.1, 0.8])))\n    df2 = nw.from_native(constructor(dict(time=[23, 26], money=[100, 200])))\n    fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='x')\n    assert (fig.data[0].hovertemplate == 'z=%{x}<br>y=%{y}<br>x=%{marker.size}<extra></extra>')\n    fig = px.scatter(df2.to_native(), x=df.get_column('z').to_native(), y=df2.get_column('money').to_native(), size=df.get_column('z').to_native())\n    assert (fig.data[0].hovertemplate == '???')\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='y')\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size=df.get_column('y').to_native())\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), size=df3.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>size=%{marker.size}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), hover_data=[df3.get_column('y').to_native()])\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>')", "ground_truth": "'x=%{x}<br>money=%{y}<br>size=%{marker.size}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_258", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_several_dataframes", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_several_dataframes(request, constructor):\n    if ('pyarrow_table' in str(constructor)):\n        request.applymarker(pytest.mark.xfail)\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[1, 10], z=[0.1, 0.8])))\n    df2 = nw.from_native(constructor(dict(time=[23, 26], money=[100, 200])))\n    fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='x')\n    assert (fig.data[0].hovertemplate == 'z=%{x}<br>y=%{y}<br>x=%{marker.size}<extra></extra>')\n    fig = px.scatter(df2.to_native(), x=df.get_column('z').to_native(), y=df2.get_column('money').to_native(), size=df.get_column('z').to_native())\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>money=%{y}<br>size=%{marker.size}<extra></extra>')\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='y')\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size=df.get_column('y').to_native())\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), size=df3.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>size=%{marker.size}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), hover_data=[df3.get_column('y').to_native()])\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>')", "masked_code": "def test_several_dataframes(request, constructor):\n    if ('pyarrow_table' in str(constructor)):\n        request.applymarker(pytest.mark.xfail)\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[1, 10], z=[0.1, 0.8])))\n    df2 = nw.from_native(constructor(dict(time=[23, 26], money=[100, 200])))\n    fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='x')\n    assert (fig.data[0].hovertemplate == 'z=%{x}<br>y=%{y}<br>x=%{marker.size}<extra></extra>')\n    fig = px.scatter(df2.to_native(), x=df.get_column('z').to_native(), y=df2.get_column('money').to_native(), size=df.get_column('z').to_native())\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>money=%{y}<br>size=%{marker.size}<extra></extra>')\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='y')\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size=df.get_column('y').to_native())\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == '???')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), size=df3.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>size=%{marker.size}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), hover_data=[df3.get_column('y').to_native()])\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>')", "ground_truth": "'x=%{x}<br>y=%{y}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_259", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_several_dataframes", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_several_dataframes(request, constructor):\n    if ('pyarrow_table' in str(constructor)):\n        request.applymarker(pytest.mark.xfail)\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[1, 10], z=[0.1, 0.8])))\n    df2 = nw.from_native(constructor(dict(time=[23, 26], money=[100, 200])))\n    fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='x')\n    assert (fig.data[0].hovertemplate == 'z=%{x}<br>y=%{y}<br>x=%{marker.size}<extra></extra>')\n    fig = px.scatter(df2.to_native(), x=df.get_column('z').to_native(), y=df2.get_column('money').to_native(), size=df.get_column('z').to_native())\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>money=%{y}<br>size=%{marker.size}<extra></extra>')\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='y')\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size=df.get_column('y').to_native())\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), size=df3.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>size=%{marker.size}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), hover_data=[df3.get_column('y').to_native()])\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>')", "masked_code": "def test_several_dataframes(request, constructor):\n    if ('pyarrow_table' in str(constructor)):\n        request.applymarker(pytest.mark.xfail)\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[1, 10], z=[0.1, 0.8])))\n    df2 = nw.from_native(constructor(dict(time=[23, 26], money=[100, 200])))\n    fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='x')\n    assert (fig.data[0].hovertemplate == 'z=%{x}<br>y=%{y}<br>x=%{marker.size}<extra></extra>')\n    fig = px.scatter(df2.to_native(), x=df.get_column('z').to_native(), y=df2.get_column('money').to_native(), size=df.get_column('z').to_native())\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>money=%{y}<br>size=%{marker.size}<extra></extra>')\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='y')\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size=df.get_column('y').to_native())\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), size=df3.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == '???')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), hover_data=[df3.get_column('y').to_native()])\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>')", "ground_truth": "'x=%{x}<br>y=%{y}<br>size=%{marker.size}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_260", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_several_dataframes", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_several_dataframes(request, constructor):\n    if ('pyarrow_table' in str(constructor)):\n        request.applymarker(pytest.mark.xfail)\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[1, 10], z=[0.1, 0.8])))\n    df2 = nw.from_native(constructor(dict(time=[23, 26], money=[100, 200])))\n    fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='x')\n    assert (fig.data[0].hovertemplate == 'z=%{x}<br>y=%{y}<br>x=%{marker.size}<extra></extra>')\n    fig = px.scatter(df2.to_native(), x=df.get_column('z').to_native(), y=df2.get_column('money').to_native(), size=df.get_column('z').to_native())\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>money=%{y}<br>size=%{marker.size}<extra></extra>')\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='y')\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size=df.get_column('y').to_native())\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), size=df3.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>size=%{marker.size}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), hover_data=[df3.get_column('y').to_native()])\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>')", "masked_code": "def test_several_dataframes(request, constructor):\n    if ('pyarrow_table' in str(constructor)):\n        request.applymarker(pytest.mark.xfail)\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[1, 10], z=[0.1, 0.8])))\n    df2 = nw.from_native(constructor(dict(time=[23, 26], money=[100, 200])))\n    fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='x')\n    assert (fig.data[0].hovertemplate == 'z=%{x}<br>y=%{y}<br>x=%{marker.size}<extra></extra>')\n    fig = px.scatter(df2.to_native(), x=df.get_column('z').to_native(), y=df2.get_column('money').to_native(), size=df.get_column('z').to_native())\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>money=%{y}<br>size=%{marker.size}<extra></extra>')\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size='y')\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    with pytest.raises(NameError) as err_msg:\n        fig = px.scatter(df.to_native(), x='z', y=df2.get_column('money').to_native(), size=df.get_column('y').to_native())\n    assert (\"A name conflict was encountered for argument 'y'\" in str(err_msg.value))\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), size=df3.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == 'x=%{x}<br>y=%{y}<br>size=%{marker.size}<extra></extra>')\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4])))\n    df2 = nw.from_native(constructor(dict(x=[3, 5], y=[23, 24])))\n    df3 = nw.from_native(constructor(dict(y=[0.1, 0.2])))\n    fig = px.scatter(x=df.get_column('y').to_native(), y=df2.get_column('y').to_native(), hover_data=[df3.get_column('y').to_native()])\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([23, 24])))\n    assert (fig.data[0].hovertemplate == '???')", "ground_truth": "'x=%{x}<br>y=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_261", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_name_heuristics", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_name_heuristics(request, constructor):\n    if ('pyarrow_table' in str(constructor)):\n        request.applymarker(pytest.mark.xfail)\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4], z=[0.1, 0.2])))\n    fig = px.scatter(df.to_native(), x=df.get_column('y').to_native(), y=df.get_column('x').to_native(), size=df.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([0, 1])))\n    assert (fig.data[0].hovertemplate == 'y=%{marker.size}<br>x=%{y}<extra></extra>')", "masked_code": "def test_name_heuristics(request, constructor):\n    if ('pyarrow_table' in str(constructor)):\n        request.applymarker(pytest.mark.xfail)\n    df = nw.from_native(constructor(dict(x=[0, 1], y=[3, 4], z=[0.1, 0.2])))\n    fig = px.scatter(df.to_native(), x=df.get_column('y').to_native(), y=df.get_column('x').to_native(), size=df.get_column('y').to_native())\n    assert np.all((fig.data[0].x == np.array([3, 4])))\n    assert np.all((fig.data[0].y == np.array([0, 1])))\n    assert (fig.data[0].hovertemplate == '???')", "ground_truth": "'y=%{marker.size}<br>x=%{y}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_262", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_repeated_name", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_repeated_name(backend):\n    iris = px.data.iris(return_type=backend)\n    fig = px.scatter(iris, x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width', 'species_id'], custom_data=['species_id', 'species'])\n    assert (fig.data[0].customdata.shape[1] == 4)", "masked_code": "def test_repeated_name(backend):\n    iris = px.data.iris(return_type=backend)\n    fig = px.scatter(iris, x='sepal_width', y='sepal_length', hover_data=['petal_length', 'petal_width', 'species_id'], custom_data=['species_id', 'species'])\n    assert (fig.data[0].customdata.shape[1] == '???')", "ground_truth": "4", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_263", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_arrayattrable_numpy", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_arrayattrable_numpy(backend):\n    tips = px.data.tips(return_type=backend)\n    fig = px.scatter(tips, x='total_bill', y='tip', hover_data=[np.random.random(tips.shape[0])])\n    assert (fig.data[0]['hovertemplate'] == 'total_bill=%{x}<br>tip=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>')\n    fig = px.scatter(tips, x='total_bill', y='tip', hover_data=[np.random.random(tips.shape[0])], labels={'hover_data_0': 'suppl'})\n    assert (fig.data[0]['hovertemplate'] == 'total_bill=%{x}<br>tip=%{y}<br>suppl=%{customdata[0]}<extra></extra>')", "masked_code": "def test_arrayattrable_numpy(backend):\n    tips = px.data.tips(return_type=backend)\n    fig = px.scatter(tips, x='total_bill', y='tip', hover_data=[np.random.random(tips.shape[0])])\n    assert (fig.data[0]['hovertemplate'] == '???')\n    fig = px.scatter(tips, x='total_bill', y='tip', hover_data=[np.random.random(tips.shape[0])], labels={'hover_data_0': 'suppl'})\n    assert (fig.data[0]['hovertemplate'] == 'total_bill=%{x}<br>tip=%{y}<br>suppl=%{customdata[0]}<extra></extra>')", "ground_truth": "'total_bill=%{x}<br>tip=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>'", "quality_analysis": {"complexity_score": 11, "left_complexity": 10, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_264", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_arrayattrable_numpy", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_arrayattrable_numpy(backend):\n    tips = px.data.tips(return_type=backend)\n    fig = px.scatter(tips, x='total_bill', y='tip', hover_data=[np.random.random(tips.shape[0])])\n    assert (fig.data[0]['hovertemplate'] == 'total_bill=%{x}<br>tip=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>')\n    fig = px.scatter(tips, x='total_bill', y='tip', hover_data=[np.random.random(tips.shape[0])], labels={'hover_data_0': 'suppl'})\n    assert (fig.data[0]['hovertemplate'] == 'total_bill=%{x}<br>tip=%{y}<br>suppl=%{customdata[0]}<extra></extra>')", "masked_code": "def test_arrayattrable_numpy(backend):\n    tips = px.data.tips(return_type=backend)\n    fig = px.scatter(tips, x='total_bill', y='tip', hover_data=[np.random.random(tips.shape[0])])\n    assert (fig.data[0]['hovertemplate'] == 'total_bill=%{x}<br>tip=%{y}<br>hover_data_0=%{customdata[0]}<extra></extra>')\n    fig = px.scatter(tips, x='total_bill', y='tip', hover_data=[np.random.random(tips.shape[0])], labels={'hover_data_0': 'suppl'})\n    assert (fig.data[0]['hovertemplate'] == '???')", "ground_truth": "'total_bill=%{x}<br>tip=%{y}<br>suppl=%{customdata[0]}<extra></extra>'", "quality_analysis": {"complexity_score": 11, "left_complexity": 10, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_265", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_timezones", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_timezones(constructor):\n    df = nw.from_native(constructor({'date': ['2015-04-04 19:31:30+0100'], 'value': [3]})).with_columns(nw.col('date').str.to_datetime(format='%Y-%m-%d %H:%M:%S%z'))\n    args = dict(data_frame=df.to_native(), x='date', y='value')\n    out = build_dataframe(args, go.Scatter)\n    assert (str(out['data_frame'].item(row=0, column='date')) == str(nw.from_native(df).item(row=0, column='date')))", "masked_code": "def test_timezones(constructor):\n    df = nw.from_native(constructor({'date': ['2015-04-04 19:31:30+0100'], 'value': [3]})).with_columns(nw.col('date').str.to_datetime(format='%Y-%m-%d %H:%M:%S%z'))\n    args = dict(data_frame=df.to_native(), x='date', y='value')\n    out = build_dataframe(args, go.Scatter)\n    assert (str(out['data_frame'].item(row=0, column='date')) == '???')", "ground_truth": "str(nw.from_native(df).item(row=0, column='date'))", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_266", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_splom_case", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_splom_case(backend):\n    iris = px.data.iris(return_type=backend)\n    fig = px.scatter_matrix(iris)\n    assert (len(fig.data[0].dimensions) == len(iris.columns))\n    dic = {'a': [1, 2, 3], 'b': [4, 5, 6], 'c': [7, 8, 9]}\n    fig = px.scatter_matrix(dic)\n    assert np.all((fig.data[0].dimensions[0].values == np.array(dic['a'])))\n    ar = np.arange(9).reshape((3, 3))\n    fig = px.scatter_matrix(ar)\n    assert np.all((fig.data[0].dimensions[0].values == ar[(:, 0)]))", "masked_code": "def test_splom_case(backend):\n    iris = px.data.iris(return_type=backend)\n    fig = px.scatter_matrix(iris)\n    assert (len(fig.data[0].dimensions) == '???')\n    dic = {'a': [1, 2, 3], 'b': [4, 5, 6], 'c': [7, 8, 9]}\n    fig = px.scatter_matrix(dic)\n    assert np.all((fig.data[0].dimensions[0].values == np.array(dic['a'])))\n    ar = np.arange(9).reshape((3, 3))\n    fig = px.scatter_matrix(ar)\n    assert np.all((fig.data[0].dimensions[0].values == ar[(:, 0)]))", "ground_truth": "len(iris.columns)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_267", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_data_frame_from_dict", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_data_frame_from_dict():\n    fig = px.scatter({'time': [0, 1], 'money': [1, 2]}, x='time', y='money')\n    assert (fig.data[0].hovertemplate == 'time=%{x}<br>money=%{y}<extra></extra>')\n    assert np.all((fig.data[0].x == [0, 1]))", "masked_code": "def test_data_frame_from_dict():\n    fig = px.scatter({'time': [0, 1], 'money': [1, 2]}, x='time', y='money')\n    assert (fig.data[0].hovertemplate == '???')\n    assert np.all((fig.data[0].x == [0, 1]))", "ground_truth": "'time=%{x}<br>money=%{y}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_268", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_pass_df_columns", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_pass_df_columns(backend):\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.histogram(tips.to_native(), x='total_bill', y='tip', color='sex', marginal='rug', hover_data=tips.columns)\n    assert (fig.data[1].hovertemplate.count('customdata') == (len(tips.columns) - 2))\n    tips_copy = nw.from_native(px.data.tips(return_type=backend))\n    assert (tips_copy.columns == tips.columns)", "masked_code": "def test_pass_df_columns(backend):\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.histogram(tips.to_native(), x='total_bill', y='tip', color='sex', marginal='rug', hover_data=tips.columns)\n    assert (fig.data[1].hovertemplate.count('customdata') == '???')\n    tips_copy = nw.from_native(px.data.tips(return_type=backend))\n    assert (tips_copy.columns == tips.columns)", "ground_truth": "(len(tips.columns) - 2)", "quality_analysis": {"complexity_score": 12, "left_complexity": 4, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_269", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_pass_df_columns", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_pass_df_columns(backend):\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.histogram(tips.to_native(), x='total_bill', y='tip', color='sex', marginal='rug', hover_data=tips.columns)\n    assert (fig.data[1].hovertemplate.count('customdata') == (len(tips.columns) - 2))\n    tips_copy = nw.from_native(px.data.tips(return_type=backend))\n    assert (tips_copy.columns == tips.columns)", "masked_code": "def test_pass_df_columns(backend):\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.histogram(tips.to_native(), x='total_bill', y='tip', color='sex', marginal='rug', hover_data=tips.columns)\n    assert (fig.data[1].hovertemplate.count('customdata') == (len(tips.columns) - 2))\n    tips_copy = nw.from_native(px.data.tips(return_type=backend))\n    assert (tips_copy.columns == '???')", "ground_truth": "tips.columns", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_270", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_size_column", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_size_column(request, backend):\n    if (backend == 'pyarrow'):\n        request.applymarker(pytest.mark.xfail)\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.scatter(tips.to_native(), x=tips.get_column('size').to_native(), y=tips.get_column('tip').to_native())\n    assert (fig.data[0].hovertemplate == 'size=%{x}<br>tip=%{y}<extra></extra>')", "masked_code": "def test_size_column(request, backend):\n    if (backend == 'pyarrow'):\n        request.applymarker(pytest.mark.xfail)\n    tips = nw.from_native(px.data.tips(return_type=backend))\n    fig = px.scatter(tips.to_native(), x=tips.get_column('size').to_native(), y=tips.get_column('tip').to_native())\n    assert (fig.data[0].hovertemplate == '???')", "ground_truth": "'size=%{x}<br>tip=%{y}<extra></extra>'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_271", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_identity_map", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_identity_map():\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map='identity')\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "masked_code": "def test_identity_map():\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == '???')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map='identity')\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "ground_truth": "'red'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_272", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_identity_map", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_identity_map():\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map='identity')\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "masked_code": "def test_identity_map():\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == '???')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map='identity')\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "ground_truth": "'blue'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_273", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_identity_map", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_identity_map():\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map='identity')\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "masked_code": "def test_identity_map():\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == '???')\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map='identity')\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "ground_truth": "'symbol'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_274", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_identity_map", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_identity_map():\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map='identity')\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "masked_code": "def test_identity_map():\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map='identity')\n    assert (fig.data[0].marker.color == '???')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "ground_truth": "'red'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_275", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_identity_map", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_identity_map():\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map='identity')\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "masked_code": "def test_identity_map():\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map='identity')\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == '???')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "ground_truth": "'blue'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_276", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_identity_map", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_identity_map():\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map='identity')\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "masked_code": "def test_identity_map():\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=['red', 'blue'], color_discrete_map='identity')\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[1].marker.color == 'blue')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == '???')", "ground_truth": "'symbol'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_277", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_constants", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_constants():\n    fig = px.scatter(x=px.Constant(1), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=px.Constant(1, label='time'), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' not in fig.data[0].hovertemplate)\n    assert ('time=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=px.Constant('red', label='the_identity_label'), hover_data=[px.Constant('data', label='the_data')], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[0].customdata[0][0] == 'data')\n    assert (fig.data[1].marker.color == 'red')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('the_identity_label=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert ('the_data=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "masked_code": "def test_constants():\n    fig = px.scatter(x=px.Constant(1), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=px.Constant(1, label='time'), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' not in fig.data[0].hovertemplate)\n    assert ('time=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=px.Constant('red', label='the_identity_label'), hover_data=[px.Constant('data', label='the_data')], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == '???')\n    assert (fig.data[0].customdata[0][0] == 'data')\n    assert (fig.data[1].marker.color == 'red')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('the_identity_label=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert ('the_data=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "ground_truth": "'red'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_278", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_constants", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_constants():\n    fig = px.scatter(x=px.Constant(1), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=px.Constant(1, label='time'), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' not in fig.data[0].hovertemplate)\n    assert ('time=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=px.Constant('red', label='the_identity_label'), hover_data=[px.Constant('data', label='the_data')], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[0].customdata[0][0] == 'data')\n    assert (fig.data[1].marker.color == 'red')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('the_identity_label=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert ('the_data=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "masked_code": "def test_constants():\n    fig = px.scatter(x=px.Constant(1), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=px.Constant(1, label='time'), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' not in fig.data[0].hovertemplate)\n    assert ('time=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=px.Constant('red', label='the_identity_label'), hover_data=[px.Constant('data', label='the_data')], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[0].customdata[0][0] == '???')\n    assert (fig.data[1].marker.color == 'red')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('the_identity_label=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert ('the_data=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "ground_truth": "'data'", "quality_analysis": {"complexity_score": 11, "left_complexity": 10, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_279", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_constants", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_constants():\n    fig = px.scatter(x=px.Constant(1), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=px.Constant(1, label='time'), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' not in fig.data[0].hovertemplate)\n    assert ('time=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=px.Constant('red', label='the_identity_label'), hover_data=[px.Constant('data', label='the_data')], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[0].customdata[0][0] == 'data')\n    assert (fig.data[1].marker.color == 'red')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('the_identity_label=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert ('the_data=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "masked_code": "def test_constants():\n    fig = px.scatter(x=px.Constant(1), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=px.Constant(1, label='time'), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' not in fig.data[0].hovertemplate)\n    assert ('time=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=px.Constant('red', label='the_identity_label'), hover_data=[px.Constant('data', label='the_data')], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[0].customdata[0][0] == 'data')\n    assert (fig.data[1].marker.color == '???')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('the_identity_label=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert ('the_data=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "ground_truth": "'red'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_280", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_constants", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_constants():\n    fig = px.scatter(x=px.Constant(1), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=px.Constant(1, label='time'), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' not in fig.data[0].hovertemplate)\n    assert ('time=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=px.Constant('red', label='the_identity_label'), hover_data=[px.Constant('data', label='the_data')], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[0].customdata[0][0] == 'data')\n    assert (fig.data[1].marker.color == 'red')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('the_identity_label=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert ('the_data=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == 'symbol')", "masked_code": "def test_constants():\n    fig = px.scatter(x=px.Constant(1), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=px.Constant(1, label='time'), y=[1, 2])\n    assert (fig.data[0].x[0] == 1)\n    assert (fig.data[0].x[1] == 1)\n    assert ('x=' not in fig.data[0].hovertemplate)\n    assert ('time=' in fig.data[0].hovertemplate)\n    fig = px.scatter(x=[1, 2], y=[1, 2], symbol=['a', 'b'], color=px.Constant('red', label='the_identity_label'), hover_data=[px.Constant('data', label='the_data')], color_discrete_map=px.IdentityMap())\n    assert (fig.data[0].marker.color == 'red')\n    assert (fig.data[0].customdata[0][0] == 'data')\n    assert (fig.data[1].marker.color == 'red')\n    assert ('color=' not in fig.data[0].hovertemplate)\n    assert ('the_identity_label=' not in fig.data[0].hovertemplate)\n    assert ('symbol=' in fig.data[0].hovertemplate)\n    assert ('the_data=' in fig.data[0].hovertemplate)\n    assert (fig.layout.legend.title.text == '???')", "ground_truth": "'symbol'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_281", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_auto_orient_x_and_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', ([px.scatter, px.line, px.area, px.violin, px.box, px.strip] + [px.bar, px.funnel, px.histogram]))\n@pytest.mark.parametrize('x,y,result', [('numerical', 'categorical', 'h'), ('categorical', 'numerical', 'v'), ('categorical', 'categorical', 'v'), ('numerical', 'numerical', 'v'), ('numerical', 'none', 'h'), ('categorical', 'none', 'h'), ('none', 'categorical', 'v'), ('none', 'numerical', 'v')])\ndef test_auto_orient_x_and_y(fn, x, y, result):\n    series = dict(categorical=['a', 'a', 'b', 'b'], numerical=[1, 2, 3, 4], none=None)\n    if ('none' not in [x, y]):\n        assert (fn(x=series[x], y=series[y]).data[0].orientation == result)\n    elif ((fn == px.histogram) or ((fn == px.bar) and ('categorical' in [x, y]))):\n        assert (fn(x=series[x], y=series[y]).data[0].orientation != result)\n    else:\n        assert (fn(x=series[x], y=series[y]).data[0].orientation == result)", "masked_code": "@pytest.mark.parametrize('fn', ([px.scatter, px.line, px.area, px.violin, px.box, px.strip] + [px.bar, px.funnel, px.histogram]))\n@pytest.mark.parametrize('x,y,result', [('numerical', 'categorical', 'h'), ('categorical', 'numerical', 'v'), ('categorical', 'categorical', 'v'), ('numerical', 'numerical', 'v'), ('numerical', 'none', 'h'), ('categorical', 'none', 'h'), ('none', 'categorical', 'v'), ('none', 'numerical', 'v')])\ndef test_auto_orient_x_and_y(fn, x, y, result):\n    series = dict(categorical=['a', 'a', 'b', 'b'], numerical=[1, 2, 3, 4], none=None)\n    if ('none' not in [x, y]):\n        assert (fn(x=series[x], y=series[y]).data[0].orientation == '???')\n    elif ((fn == px.histogram) or ((fn == px.bar) and ('categorical' in [x, y]))):\n        assert (fn(x=series[x], y=series[y]).data[0].orientation != result)\n    else:\n        assert (fn(x=series[x], y=series[y]).data[0].orientation == result)", "ground_truth": "result", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_282", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_auto_orient_x_and_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', ([px.scatter, px.line, px.area, px.violin, px.box, px.strip] + [px.bar, px.funnel, px.histogram]))\n@pytest.mark.parametrize('x,y,result', [('numerical', 'categorical', 'h'), ('categorical', 'numerical', 'v'), ('categorical', 'categorical', 'v'), ('numerical', 'numerical', 'v'), ('numerical', 'none', 'h'), ('categorical', 'none', 'h'), ('none', 'categorical', 'v'), ('none', 'numerical', 'v')])\ndef test_auto_orient_x_and_y(fn, x, y, result):\n    series = dict(categorical=['a', 'a', 'b', 'b'], numerical=[1, 2, 3, 4], none=None)\n    if ('none' not in [x, y]):\n        assert (fn(x=series[x], y=series[y]).data[0].orientation == result)\n    elif ((fn == px.histogram) or ((fn == px.bar) and ('categorical' in [x, y]))):\n        assert (fn(x=series[x], y=series[y]).data[0].orientation != result)\n    else:\n        assert (fn(x=series[x], y=series[y]).data[0].orientation == result)", "masked_code": "@pytest.mark.parametrize('fn', ([px.scatter, px.line, px.area, px.violin, px.box, px.strip] + [px.bar, px.funnel, px.histogram]))\n@pytest.mark.parametrize('x,y,result', [('numerical', 'categorical', 'h'), ('categorical', 'numerical', 'v'), ('categorical', 'categorical', 'v'), ('numerical', 'numerical', 'v'), ('numerical', 'none', 'h'), ('categorical', 'none', 'h'), ('none', 'categorical', 'v'), ('none', 'numerical', 'v')])\ndef test_auto_orient_x_and_y(fn, x, y, result):\n    series = dict(categorical=['a', 'a', 'b', 'b'], numerical=[1, 2, 3, 4], none=None)\n    if ('none' not in [x, y]):\n        assert (fn(x=series[x], y=series[y]).data[0].orientation == result)\n    elif ((fn == px.histogram) or ((fn == px.bar) and ('categorical' in [x, y]))):\n        assert (fn(x=series[x], y=series[y]).data[0].orientation != result)\n    else:\n        assert (fn(x=series[x], y=series[y]).data[0].orientation == '???')", "ground_truth": "result", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_283", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_histogram_auto_orient", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_histogram_auto_orient():\n    numerical = [1, 2, 3, 4]\n    assert (px.histogram(x=numerical, nbins=5).data[0].nbinsx == 5)\n    assert (px.histogram(y=numerical, nbins=5).data[0].nbinsy == 5)\n    assert (px.histogram(x=numerical, y=numerical, nbins=5).data[0].nbinsx == 5)", "masked_code": "def test_histogram_auto_orient():\n    numerical = [1, 2, 3, 4]\n    assert (px.histogram(x=numerical, nbins=5).data[0].nbinsx == '???')\n    assert (px.histogram(y=numerical, nbins=5).data[0].nbinsy == 5)\n    assert (px.histogram(x=numerical, y=numerical, nbins=5).data[0].nbinsx == 5)", "ground_truth": "5", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_284", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_histogram_auto_orient", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_histogram_auto_orient():\n    numerical = [1, 2, 3, 4]\n    assert (px.histogram(x=numerical, nbins=5).data[0].nbinsx == 5)\n    assert (px.histogram(y=numerical, nbins=5).data[0].nbinsy == 5)\n    assert (px.histogram(x=numerical, y=numerical, nbins=5).data[0].nbinsx == 5)", "masked_code": "def test_histogram_auto_orient():\n    numerical = [1, 2, 3, 4]\n    assert (px.histogram(x=numerical, nbins=5).data[0].nbinsx == 5)\n    assert (px.histogram(y=numerical, nbins=5).data[0].nbinsy == '???')\n    assert (px.histogram(x=numerical, y=numerical, nbins=5).data[0].nbinsx == 5)", "ground_truth": "5", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_285", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_histogram_auto_orient", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_histogram_auto_orient():\n    numerical = [1, 2, 3, 4]\n    assert (px.histogram(x=numerical, nbins=5).data[0].nbinsx == 5)\n    assert (px.histogram(y=numerical, nbins=5).data[0].nbinsy == 5)\n    assert (px.histogram(x=numerical, y=numerical, nbins=5).data[0].nbinsx == 5)", "masked_code": "def test_histogram_auto_orient():\n    numerical = [1, 2, 3, 4]\n    assert (px.histogram(x=numerical, nbins=5).data[0].nbinsx == 5)\n    assert (px.histogram(y=numerical, nbins=5).data[0].nbinsy == 5)\n    assert (px.histogram(x=numerical, y=numerical, nbins=5).data[0].nbinsx == '???')", "ground_truth": "5", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_286", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_auto_histfunc", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_auto_histfunc():\n    a = [1, 2]\n    assert (px.histogram(x=a).data[0].histfunc is None)\n    assert (px.histogram(y=a).data[0].histfunc is None)\n    assert (px.histogram(x=a, y=a).data[0].histfunc == 'sum')\n    assert (px.histogram(x=a, y=a, histfunc='avg').data[0].histfunc == 'avg')\n    assert (px.density_heatmap(x=a, y=a).data[0].histfunc is None)\n    assert (px.density_heatmap(x=a, y=a, z=a).data[0].histfunc == 'sum')\n    assert (px.density_heatmap(x=a, y=a, z=a, histfunc='avg').data[0].histfunc == 'avg')", "masked_code": "def test_auto_histfunc():\n    a = [1, 2]\n    assert (px.histogram(x=a).data[0].histfunc is None)\n    assert (px.histogram(y=a).data[0].histfunc is None)\n    assert (px.histogram(x=a, y=a).data[0].histfunc == '???')\n    assert (px.histogram(x=a, y=a, histfunc='avg').data[0].histfunc == 'avg')\n    assert (px.density_heatmap(x=a, y=a).data[0].histfunc is None)\n    assert (px.density_heatmap(x=a, y=a, z=a).data[0].histfunc == 'sum')\n    assert (px.density_heatmap(x=a, y=a, z=a, histfunc='avg').data[0].histfunc == 'avg')", "ground_truth": "'sum'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_287", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_auto_histfunc", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_auto_histfunc():\n    a = [1, 2]\n    assert (px.histogram(x=a).data[0].histfunc is None)\n    assert (px.histogram(y=a).data[0].histfunc is None)\n    assert (px.histogram(x=a, y=a).data[0].histfunc == 'sum')\n    assert (px.histogram(x=a, y=a, histfunc='avg').data[0].histfunc == 'avg')\n    assert (px.density_heatmap(x=a, y=a).data[0].histfunc is None)\n    assert (px.density_heatmap(x=a, y=a, z=a).data[0].histfunc == 'sum')\n    assert (px.density_heatmap(x=a, y=a, z=a, histfunc='avg').data[0].histfunc == 'avg')", "masked_code": "def test_auto_histfunc():\n    a = [1, 2]\n    assert (px.histogram(x=a).data[0].histfunc is None)\n    assert (px.histogram(y=a).data[0].histfunc is None)\n    assert (px.histogram(x=a, y=a).data[0].histfunc == 'sum')\n    assert (px.histogram(x=a, y=a, histfunc='avg').data[0].histfunc == '???')\n    assert (px.density_heatmap(x=a, y=a).data[0].histfunc is None)\n    assert (px.density_heatmap(x=a, y=a, z=a).data[0].histfunc == 'sum')\n    assert (px.density_heatmap(x=a, y=a, z=a, histfunc='avg').data[0].histfunc == 'avg')", "ground_truth": "'avg'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_288", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_auto_histfunc", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_auto_histfunc():\n    a = [1, 2]\n    assert (px.histogram(x=a).data[0].histfunc is None)\n    assert (px.histogram(y=a).data[0].histfunc is None)\n    assert (px.histogram(x=a, y=a).data[0].histfunc == 'sum')\n    assert (px.histogram(x=a, y=a, histfunc='avg').data[0].histfunc == 'avg')\n    assert (px.density_heatmap(x=a, y=a).data[0].histfunc is None)\n    assert (px.density_heatmap(x=a, y=a, z=a).data[0].histfunc == 'sum')\n    assert (px.density_heatmap(x=a, y=a, z=a, histfunc='avg').data[0].histfunc == 'avg')", "masked_code": "def test_auto_histfunc():\n    a = [1, 2]\n    assert (px.histogram(x=a).data[0].histfunc is None)\n    assert (px.histogram(y=a).data[0].histfunc is None)\n    assert (px.histogram(x=a, y=a).data[0].histfunc == 'sum')\n    assert (px.histogram(x=a, y=a, histfunc='avg').data[0].histfunc == 'avg')\n    assert (px.density_heatmap(x=a, y=a).data[0].histfunc is None)\n    assert (px.density_heatmap(x=a, y=a, z=a).data[0].histfunc == '???')\n    assert (px.density_heatmap(x=a, y=a, z=a, histfunc='avg').data[0].histfunc == 'avg')", "ground_truth": "'sum'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_289", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_auto_histfunc", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "def test_auto_histfunc():\n    a = [1, 2]\n    assert (px.histogram(x=a).data[0].histfunc is None)\n    assert (px.histogram(y=a).data[0].histfunc is None)\n    assert (px.histogram(x=a, y=a).data[0].histfunc == 'sum')\n    assert (px.histogram(x=a, y=a, histfunc='avg').data[0].histfunc == 'avg')\n    assert (px.density_heatmap(x=a, y=a).data[0].histfunc is None)\n    assert (px.density_heatmap(x=a, y=a, z=a).data[0].histfunc == 'sum')\n    assert (px.density_heatmap(x=a, y=a, z=a, histfunc='avg').data[0].histfunc == 'avg')", "masked_code": "def test_auto_histfunc():\n    a = [1, 2]\n    assert (px.histogram(x=a).data[0].histfunc is None)\n    assert (px.histogram(y=a).data[0].histfunc is None)\n    assert (px.histogram(x=a, y=a).data[0].histfunc == 'sum')\n    assert (px.histogram(x=a, y=a, histfunc='avg').data[0].histfunc == 'avg')\n    assert (px.density_heatmap(x=a, y=a).data[0].histfunc is None)\n    assert (px.density_heatmap(x=a, y=a, z=a).data[0].histfunc == 'sum')\n    assert (px.density_heatmap(x=a, y=a, z=a, histfunc='avg').data[0].histfunc == '???')", "ground_truth": "'avg'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_290", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_auto_boxlike_overlay", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn,mode', [(px.violin, 'violinmode'), (px.box, 'boxmode'), (px.strip, 'boxmode')])\n@pytest.mark.parametrize('x,y,color,result', [('categorical1', 'numerical', None, 'group'), ('categorical1', 'numerical', 'categorical2', 'group'), ('categorical1', 'numerical', 'categorical1', 'overlay'), ('numerical', 'categorical1', None, 'group'), ('numerical', 'categorical1', 'categorical2', 'group'), ('numerical', 'categorical1', 'categorical1', 'overlay')])\ndef test_auto_boxlike_overlay(constructor, fn, mode, x, y, color, result):\n    df = constructor(dict(categorical1=['a', 'a', 'b', 'b'], categorical2=['a', 'a', 'b', 'b'], numerical=[1, 2, 3, 4]))\n    assert (fn(df, x=x, y=y, color=color).layout[mode] == result)", "masked_code": "@pytest.mark.parametrize('fn,mode', [(px.violin, 'violinmode'), (px.box, 'boxmode'), (px.strip, 'boxmode')])\n@pytest.mark.parametrize('x,y,color,result', [('categorical1', 'numerical', None, 'group'), ('categorical1', 'numerical', 'categorical2', 'group'), ('categorical1', 'numerical', 'categorical1', 'overlay'), ('numerical', 'categorical1', None, 'group'), ('numerical', 'categorical1', 'categorical2', 'group'), ('numerical', 'categorical1', 'categorical1', 'overlay')])\ndef test_auto_boxlike_overlay(constructor, fn, mode, x, y, color, result):\n    df = constructor(dict(categorical1=['a', 'a', 'b', 'b'], categorical2=['a', 'a', 'b', 'b'], numerical=[1, 2, 3, 4]))\n    assert (fn(df, x=x, y=y, color=color).layout[mode] == '???')", "ground_truth": "result", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_291", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == '???')\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "numerical", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_292", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == '???')\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "range_4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_293", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == '???')\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "range_4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_294", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == '???')\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "numerical", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_295", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == '???')\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "numerical", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_296", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == '???')\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "index", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_297", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == '???')\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "index", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_298", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == '???')\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "numerical", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_299", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == '???')\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "categorical", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_300", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == '???')\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "range_4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_301", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == '???')\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "range_4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_302", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == '???')\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "categorical", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_303", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == '???')\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "categorical", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_304", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == '???')\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "index", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_305", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == '???')\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "index", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_306", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == '???')\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "categorical", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_307", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == '???')\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "categorical", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_308", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == '???')\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "constant", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_309", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == '???')\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "constant", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_310", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == '???')\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "categorical", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_311", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == '???')\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "categorical", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_312", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == '???')\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "constant", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_313", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == '???')\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "constant", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_314", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_input.py", "testname": "test_px_input.py", "classname": null, "funcname": "test_x_or_y", "imports": ["import plotly.express as px", "import pyarrow as pa", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "import pytest", "from packaging import version", "import unittest.mock as mock", "from plotly.express._core import build_dataframe", "from plotly import optional_imports", "from pandas.testing import assert_frame_equal", "import sys", "import warnings"], "code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')", "masked_code": "@pytest.mark.parametrize('fn', [px.scatter, px.line, px.area, px.bar])\ndef test_x_or_y(fn):\n    categorical = ['a', 'a', 'b', 'b']\n    numerical = [1, 2, 3, 4]\n    constant = [1, 1, 1, 1]\n    range_4 = [0, 1, 2, 3]\n    index = [11, 12, 13, 14]\n    numerical_df = pd.DataFrame(dict(col=numerical), index=index)\n    categorical_df = pd.DataFrame(dict(col=categorical), index=index)\n    fig = fn(x=numerical)\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == range_4)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(y=numerical)\n    assert (list(fig.data[0].x) == range_4)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    fig = fn(numerical_df, x='col')\n    assert (list(fig.data[0].x) == numerical)\n    assert (list(fig.data[0].y) == index)\n    assert (fig.data[0].orientation == 'h')\n    fig = fn(numerical_df, y='col')\n    assert (list(fig.data[0].x) == index)\n    assert (list(fig.data[0].y) == numerical)\n    assert (fig.data[0].orientation == 'v')\n    if (fn != px.bar):\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == range_4)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == range_4)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == index)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == index)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'v')\n    else:\n        fig = fn(x=categorical)\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(y=categorical)\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == categorical)\n        assert (fig.data[0].orientation == 'h')\n        fig = fn(categorical_df, x='col')\n        assert (list(fig.data[0].x) == categorical)\n        assert (list(fig.data[0].y) == constant)\n        assert (fig.data[0].orientation == 'v')\n        fig = fn(categorical_df, y='col')\n        assert (list(fig.data[0].x) == constant)\n        assert (list(fig.data[0].y) == '???')\n        assert (fig.data[0].orientation == 'h')", "ground_truth": "categorical", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_315", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == '???')\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "3", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_316", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == '???')\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "[11, 12, 13]", "quality_analysis": {"complexity_score": 18, "left_complexity": 13, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_317", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == '???')\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "[1, 2, 3]", "quality_analysis": {"complexity_score": 18, "left_complexity": 13, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_318", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == '???')\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "[11, 12, 13]", "quality_analysis": {"complexity_score": 18, "left_complexity": 13, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_319", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == '???')\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "[4, 5, 6]", "quality_analysis": {"complexity_score": 18, "left_complexity": 13, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_320", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == '???')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "'index'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_321", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == '???')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "'value'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_322", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == '???')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "'variable'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_323", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == '???')\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "[11, 12, 13, 11, 12, 13, 11, 12, 13]", "quality_analysis": {"complexity_score": 24, "left_complexity": 13, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_324", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == '???')\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "[1, 2, 3, 4, 5, 6, 7, 8, 9]", "quality_analysis": {"complexity_score": 24, "left_complexity": 13, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_325", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == '???')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "'index'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_326", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == '???')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "'value'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_327", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == '???')\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "(((['a'] * 3) + (['b'] * 3)) + (['c'] * 3))", "quality_analysis": {"complexity_score": 35, "left_complexity": 13, "right_complexity": 22, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_328", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == '???')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "list(range(1, 10))", "quality_analysis": {"complexity_score": 21, "left_complexity": 13, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_329", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == '???')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "'value'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_330", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == '???')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "'variable'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_331", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == '???')\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "3", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_332", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == '???')\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "[4, 5, 6]", "quality_analysis": {"complexity_score": 18, "left_complexity": 13, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_333", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == '???')\n        assert (fig.layout[xaxis].title.text == 'value')", "ground_truth": "'variable'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_334", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == 'value')", "masked_code": "@pytest.mark.parametrize('px_fn', ([px.scatter, px.line, px.area, px.bar, px.violin, px.box, px.strip] + [px.histogram, px.funnel, px.density_contour, px.density_heatmap]))\n@pytest.mark.parametrize('orientation', [None, 'v', 'h'])\n@pytest.mark.parametrize('style', ['implicit', 'explicit'])\ndef test_wide_mode_external(px_fn, orientation, style):\n    if (px_fn != px.funnel):\n        (x, y) = (('y', 'x') if (orientation == 'h') else ('x', 'y'))\n    else:\n        (x, y) = (('y', 'x') if (orientation != 'v') else ('x', 'y'))\n    (xaxis, yaxis) = ((x + 'axis'), (y + 'axis'))\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    if (style == 'implicit'):\n        fig = px_fn(df, orientation=orientation)\n    if (px_fn in [px.scatter, px.line, px.area, px.bar, px.funnel, px.density_contour]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[0][x]) == [11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3])\n        assert (list(fig.data[1][x]) == [11, 12, 13])\n        assert (list(fig.data[1][y]) == [4, 5, 6])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout.legend.title.text == 'variable')\n    if (px_fn in [px.density_heatmap]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns), x: df.index})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == [11, 12, 13, 11, 12, 13, 11, 12, 13])\n        assert (list(fig.data[0][y]) == [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        assert (fig.layout[xaxis].title.text == 'index')\n        assert (fig.layout[yaxis].title.text == 'value')\n    if (px_fn in [px.violin, px.box, px.strip]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, y: list(df.columns)})\n        assert (len(fig.data) == 1)\n        assert (list(fig.data[0][x]) == (((['a'] * 3) + (['b'] * 3)) + (['c'] * 3)))\n        assert (list(fig.data[0][y]) == list(range(1, 10)))\n        assert (fig.layout[yaxis].title.text == 'value')\n        assert (fig.layout[xaxis].title.text == 'variable')\n    if (px_fn in [px.histogram]):\n        if (style == 'explicit'):\n            fig = px_fn(**{'data_frame': df, x: list(df.columns)})\n        assert (len(fig.data) == 3)\n        assert (list(fig.data[1][x]) == [4, 5, 6])\n        assert (fig.layout.legend.title.text == 'variable')\n        assert (fig.layout[xaxis].title.text == '???')", "ground_truth": "'value'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_335", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_labels_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "masked_code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == '???')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "ground_truth": "'index'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_336", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_labels_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "masked_code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == '???')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "ground_truth": "'value'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_337", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_labels_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "masked_code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == '???')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "ground_truth": "'variable'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_338", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_labels_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "masked_code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == '???')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "ground_truth": "'my index'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_339", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_labels_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "masked_code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == '???')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "ground_truth": "'my value'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_340", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_labels_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "masked_code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == '???')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "ground_truth": "'my column'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_341", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_labels_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "masked_code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == '???')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "ground_truth": "'my index'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_342", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_labels_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "masked_code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == '???')\n    assert (fig.layout.legend.title.text == 'my column')", "ground_truth": "'value'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_343", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_wide_mode_labels_external", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'my column')", "masked_code": "def test_wide_mode_labels_external():\n    df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6], c=[7, 8, 9]), index=[11, 12, 13])\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == 'variable')\n    labels = dict(index='my index', value='my value', variable='my column')\n    fig = px.bar(df, labels=labels)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'my value')\n    assert (fig.layout.legend.title.text == 'my column')\n    df.index.name = 'my index'\n    df.columns.name = 'my column'\n    fig = px.bar(df)\n    assert (fig.layout.xaxis.title.text == 'my index')\n    assert (fig.layout.yaxis.title.text == 'value')\n    assert (fig.layout.legend.title.text == '???')", "ground_truth": "'my column'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_344", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_px_wide.py", "testname": "test_px_wide.py", "classname": null, "funcname": "test_line_group", "imports": ["import plotly.express as px", "import plotly.graph_objects as go", "import narwhals.stable.v1 as nw", "import numpy as np", "import pandas as pd", "from plotly.express._core import build_dataframe, _is_col_list", "from pandas.testing import assert_frame_equal", "import pytest", "import warnings"], "code": "def test_line_group(constructor):\n    df = constructor({'who': ['a', 'a', 'b', 'b'], 'x': [0, 1, 0, 1], 'score': [1.0, 2, 3, 4], 'miss': [3.2, 2.5, 1.3, 1.5]})\n    fig = px.line(df, x='x', y=['miss', 'score'])\n    assert (len(fig.data) == 2)\n    fig = px.line(df, x='x', y=['miss', 'score'], color='who')\n    assert (len(fig.data) == 4)\n    fig = px.scatter(df, x='x', y=['miss', 'score'], color='who')\n    assert (len(fig.data) == 2)", "masked_code": "def test_line_group(constructor):\n    df = constructor({'who': ['a', 'a', 'b', 'b'], 'x': [0, 1, 0, 1], 'score': [1.0, 2, 3, 4], 'miss': [3.2, 2.5, 1.3, 1.5]})\n    fig = px.line(df, x='x', y=['miss', 'score'])\n    assert (len(fig.data) == 2)\n    fig = px.line(df, x='x', y=['miss', 'score'], color='who')\n    assert (len(fig.data) == '???')\n    fig = px.scatter(df, x='x', y=['miss', 'score'], color='who')\n    assert (len(fig.data) == 2)", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_345", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_trendline.py", "testname": "test_trendline.py", "classname": null, "funcname": "test_trendline_results_passthrough", "imports": ["import plotly.express as px", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest", "from datetime import datetime", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('mode,options', [('ols', None), ('lowess', None), ('lowess', dict(frac=0.3)), ('rolling', dict(window=2)), ('expanding', None), ('ewm', dict(alpha=0.5))])\ndef test_trendline_results_passthrough(backend, mode, options):\n    df = nw.from_native(px.data.gapminder(return_type=backend)).filter((nw.col('continent') == 'Oceania'))\n    fig = px.scatter(df.to_native(), x='year', y='pop', color='country', trendline=mode, trendline_options=options)\n    assert (len(fig.data) == 4)\n    for trace in fig['data'][0::2]:\n        assert ('trendline' not in trace.hovertemplate)\n    for trendline in fig['data'][1::2]:\n        assert ('trendline' in trendline.hovertemplate)\n        if (mode == 'ols'):\n            assert ('R<sup>2</sup>' in trendline.hovertemplate)\n    results = px.get_trendline_results(fig)\n    if (mode == 'ols'):\n        assert (len(results) == 2)\n        assert (set(results['country'].to_list()) == {'Australia', 'New Zealand'})\n        result = results['px_fit_results'].values[0]\n        assert (len(result.params) == 2)\n    else:\n        assert (len(results) == 0)", "masked_code": "@pytest.mark.parametrize('mode,options', [('ols', None), ('lowess', None), ('lowess', dict(frac=0.3)), ('rolling', dict(window=2)), ('expanding', None), ('ewm', dict(alpha=0.5))])\ndef test_trendline_results_passthrough(backend, mode, options):\n    df = nw.from_native(px.data.gapminder(return_type=backend)).filter((nw.col('continent') == 'Oceania'))\n    fig = px.scatter(df.to_native(), x='year', y='pop', color='country', trendline=mode, trendline_options=options)\n    assert (len(fig.data) == '???')\n    for trace in fig['data'][0::2]:\n        assert ('trendline' not in trace.hovertemplate)\n    for trendline in fig['data'][1::2]:\n        assert ('trendline' in trendline.hovertemplate)\n        if (mode == 'ols'):\n            assert ('R<sup>2</sup>' in trendline.hovertemplate)\n    results = px.get_trendline_results(fig)\n    if (mode == 'ols'):\n        assert (len(results) == 2)\n        assert (set(results['country'].to_list()) == {'Australia', 'New Zealand'})\n        result = results['px_fit_results'].values[0]\n        assert (len(result.params) == 2)\n    else:\n        assert (len(results) == 0)", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_346", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_trendline.py", "testname": "test_trendline.py", "classname": null, "funcname": "test_trendline_results_passthrough", "imports": ["import plotly.express as px", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest", "from datetime import datetime", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('mode,options', [('ols', None), ('lowess', None), ('lowess', dict(frac=0.3)), ('rolling', dict(window=2)), ('expanding', None), ('ewm', dict(alpha=0.5))])\ndef test_trendline_results_passthrough(backend, mode, options):\n    df = nw.from_native(px.data.gapminder(return_type=backend)).filter((nw.col('continent') == 'Oceania'))\n    fig = px.scatter(df.to_native(), x='year', y='pop', color='country', trendline=mode, trendline_options=options)\n    assert (len(fig.data) == 4)\n    for trace in fig['data'][0::2]:\n        assert ('trendline' not in trace.hovertemplate)\n    for trendline in fig['data'][1::2]:\n        assert ('trendline' in trendline.hovertemplate)\n        if (mode == 'ols'):\n            assert ('R<sup>2</sup>' in trendline.hovertemplate)\n    results = px.get_trendline_results(fig)\n    if (mode == 'ols'):\n        assert (len(results) == 2)\n        assert (set(results['country'].to_list()) == {'Australia', 'New Zealand'})\n        result = results['px_fit_results'].values[0]\n        assert (len(result.params) == 2)\n    else:\n        assert (len(results) == 0)", "masked_code": "@pytest.mark.parametrize('mode,options', [('ols', None), ('lowess', None), ('lowess', dict(frac=0.3)), ('rolling', dict(window=2)), ('expanding', None), ('ewm', dict(alpha=0.5))])\ndef test_trendline_results_passthrough(backend, mode, options):\n    df = nw.from_native(px.data.gapminder(return_type=backend)).filter((nw.col('continent') == 'Oceania'))\n    fig = px.scatter(df.to_native(), x='year', y='pop', color='country', trendline=mode, trendline_options=options)\n    assert (len(fig.data) == 4)\n    for trace in fig['data'][0::2]:\n        assert ('trendline' not in trace.hovertemplate)\n    for trendline in fig['data'][1::2]:\n        assert ('trendline' in trendline.hovertemplate)\n        if (mode == 'ols'):\n            assert ('R<sup>2</sup>' in trendline.hovertemplate)\n    results = px.get_trendline_results(fig)\n    if (mode == 'ols'):\n        assert (len(results) == 2)\n        assert (set(results['country'].to_list()) == '???')\n        result = results['px_fit_results'].values[0]\n        assert (len(result.params) == 2)\n    else:\n        assert (len(results) == 0)", "ground_truth": "{'Australia', 'New Zealand'}", "quality_analysis": {"complexity_score": 6, "left_complexity": 6, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_347", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_trendline.py", "testname": "test_trendline.py", "classname": null, "funcname": "test_trendline_nan_values", "imports": ["import plotly.express as px", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest", "from datetime import datetime", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('mode,options', [('ols', None), ('ols', dict(add_constant=False, log_x=True, log_y=True)), ('lowess', None), ('lowess', dict(frac=0.3)), ('rolling', dict(window=2)), ('expanding', None), ('ewm', dict(alpha=0.5))])\ndef test_trendline_nan_values(backend, mode, options):\n    start_date = 1970\n    df = nw.from_native(px.data.gapminder(return_type=backend)).filter((nw.col('continent') == 'Oceania')).with_columns(pop=nw.when((nw.col('year') >= start_date)).then(nw.col('pop')).otherwise(None))\n    fig = px.scatter(df.to_native(), x='year', y='pop', color='country', trendline=mode, trendline_options=options)\n    for trendline in fig['data'][1::2]:\n        assert (trendline.x[0] >= start_date)\n        assert (len(trendline.x) == len(trendline.y))", "masked_code": "@pytest.mark.parametrize('mode,options', [('ols', None), ('ols', dict(add_constant=False, log_x=True, log_y=True)), ('lowess', None), ('lowess', dict(frac=0.3)), ('rolling', dict(window=2)), ('expanding', None), ('ewm', dict(alpha=0.5))])\ndef test_trendline_nan_values(backend, mode, options):\n    start_date = 1970\n    df = nw.from_native(px.data.gapminder(return_type=backend)).filter((nw.col('continent') == 'Oceania')).with_columns(pop=nw.when((nw.col('year') >= start_date)).then(nw.col('pop')).otherwise(None))\n    fig = px.scatter(df.to_native(), x='year', y='pop', color='country', trendline=mode, trendline_options=options)\n    for trendline in fig['data'][1::2]:\n        assert (trendline.x[0] >= start_date)\n        assert (len(trendline.x) == '???')", "ground_truth": "len(trendline.y)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_348", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_trendline.py", "testname": "test_trendline.py", "classname": null, "funcname": "test_trendline_on_timeseries", "imports": ["import plotly.express as px", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest", "from datetime import datetime", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('mode,options', [('ols', None), ('lowess', None), ('lowess', dict(frac=0.3)), ('rolling', dict(window=2)), ('rolling', dict(window='10d')), ('expanding', None), ('ewm', dict(alpha=0.5))])\ndef test_trendline_on_timeseries(backend, mode, options):\n    df = nw.from_native(px.data.stocks(return_type=backend))\n    pd_err_msg = \"Could not convert value of 'x' \\\\('date'\\\\) into a numeric type.\"\n    pl_err_msg = \"conversion from `str` to `f64` failed in column 'date'\"\n    with pytest.raises(Exception, match=f'({pd_err_msg}|{pl_err_msg})'):\n        px.scatter(df.to_native(), x='date', y='GOOG', trendline=mode, trendline_options=options)\n    df = df.with_columns(date=nw.col('date').str.to_datetime(format='%Y-%m-%d').dt.replace_time_zone('CET'))\n    fig = px.scatter(df.to_native(), x='date', y='GOOG', trendline=mode, trendline_options=options)\n    assert (len(fig.data) == 2)\n    assert (len(fig.data[0].x) == len(fig.data[1].x))\n    assert isinstance(fig.data[0].x[0], (datetime, np.datetime64))\n    assert isinstance(fig.data[1].x[0], (datetime, np.datetime64))\n    assert np.all((fig.data[0].x == fig.data[1].x))\n    assert (str(fig.data[0].x[0]) == str(fig.data[1].x[0]))", "masked_code": "@pytest.mark.parametrize('mode,options', [('ols', None), ('lowess', None), ('lowess', dict(frac=0.3)), ('rolling', dict(window=2)), ('rolling', dict(window='10d')), ('expanding', None), ('ewm', dict(alpha=0.5))])\ndef test_trendline_on_timeseries(backend, mode, options):\n    df = nw.from_native(px.data.stocks(return_type=backend))\n    pd_err_msg = \"Could not convert value of 'x' \\\\('date'\\\\) into a numeric type.\"\n    pl_err_msg = \"conversion from `str` to `f64` failed in column 'date'\"\n    with pytest.raises(Exception, match=f'({pd_err_msg}|{pl_err_msg})'):\n        px.scatter(df.to_native(), x='date', y='GOOG', trendline=mode, trendline_options=options)\n    df = df.with_columns(date=nw.col('date').str.to_datetime(format='%Y-%m-%d').dt.replace_time_zone('CET'))\n    fig = px.scatter(df.to_native(), x='date', y='GOOG', trendline=mode, trendline_options=options)\n    assert (len(fig.data) == 2)\n    assert (len(fig.data[0].x) == '???')\n    assert isinstance(fig.data[0].x[0], (datetime, np.datetime64))\n    assert isinstance(fig.data[1].x[0], (datetime, np.datetime64))\n    assert np.all((fig.data[0].x == fig.data[1].x))\n    assert (str(fig.data[0].x[0]) == str(fig.data[1].x[0]))", "ground_truth": "len(fig.data[1].x)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_349", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_trendline.py", "testname": "test_trendline.py", "classname": null, "funcname": "test_trendline_on_timeseries", "imports": ["import plotly.express as px", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest", "from datetime import datetime", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('mode,options', [('ols', None), ('lowess', None), ('lowess', dict(frac=0.3)), ('rolling', dict(window=2)), ('rolling', dict(window='10d')), ('expanding', None), ('ewm', dict(alpha=0.5))])\ndef test_trendline_on_timeseries(backend, mode, options):\n    df = nw.from_native(px.data.stocks(return_type=backend))\n    pd_err_msg = \"Could not convert value of 'x' \\\\('date'\\\\) into a numeric type.\"\n    pl_err_msg = \"conversion from `str` to `f64` failed in column 'date'\"\n    with pytest.raises(Exception, match=f'({pd_err_msg}|{pl_err_msg})'):\n        px.scatter(df.to_native(), x='date', y='GOOG', trendline=mode, trendline_options=options)\n    df = df.with_columns(date=nw.col('date').str.to_datetime(format='%Y-%m-%d').dt.replace_time_zone('CET'))\n    fig = px.scatter(df.to_native(), x='date', y='GOOG', trendline=mode, trendline_options=options)\n    assert (len(fig.data) == 2)\n    assert (len(fig.data[0].x) == len(fig.data[1].x))\n    assert isinstance(fig.data[0].x[0], (datetime, np.datetime64))\n    assert isinstance(fig.data[1].x[0], (datetime, np.datetime64))\n    assert np.all((fig.data[0].x == fig.data[1].x))\n    assert (str(fig.data[0].x[0]) == str(fig.data[1].x[0]))", "masked_code": "@pytest.mark.parametrize('mode,options', [('ols', None), ('lowess', None), ('lowess', dict(frac=0.3)), ('rolling', dict(window=2)), ('rolling', dict(window='10d')), ('expanding', None), ('ewm', dict(alpha=0.5))])\ndef test_trendline_on_timeseries(backend, mode, options):\n    df = nw.from_native(px.data.stocks(return_type=backend))\n    pd_err_msg = \"Could not convert value of 'x' \\\\('date'\\\\) into a numeric type.\"\n    pl_err_msg = \"conversion from `str` to `f64` failed in column 'date'\"\n    with pytest.raises(Exception, match=f'({pd_err_msg}|{pl_err_msg})'):\n        px.scatter(df.to_native(), x='date', y='GOOG', trendline=mode, trendline_options=options)\n    df = df.with_columns(date=nw.col('date').str.to_datetime(format='%Y-%m-%d').dt.replace_time_zone('CET'))\n    fig = px.scatter(df.to_native(), x='date', y='GOOG', trendline=mode, trendline_options=options)\n    assert (len(fig.data) == 2)\n    assert (len(fig.data[0].x) == len(fig.data[1].x))\n    assert isinstance(fig.data[0].x[0], (datetime, np.datetime64))\n    assert isinstance(fig.data[1].x[0], (datetime, np.datetime64))\n    assert np.all((fig.data[0].x == fig.data[1].x))\n    assert (str(fig.data[0].x[0]) == '???')", "ground_truth": "str(fig.data[1].x[0])", "quality_analysis": {"complexity_score": 18, "left_complexity": 9, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_350", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_trendline.py", "testname": "test_trendline.py", "classname": null, "funcname": "test_overall_trendline", "imports": ["import plotly.express as px", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest", "from datetime import datetime", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_overall_trendline(backend):\n    df = px.data.tips(return_type=backend)\n    fig1 = px.scatter(df, x='total_bill', y='tip', trendline='ols')\n    assert (len(fig1.data) == 2)\n    assert ('trendline' in fig1.data[1].hovertemplate)\n    results1 = px.get_trendline_results(fig1)\n    params1 = results1['px_fit_results'].iloc[0].params\n    fig2 = px.scatter(df, x='total_bill', y='tip', color='sex', trendline='ols', trendline_scope='overall')\n    assert (len(fig2.data) == 3)\n    assert ('trendline' in fig2.data[2].hovertemplate)\n    results2 = px.get_trendline_results(fig2)\n    params2 = results2['px_fit_results'].iloc[0].params\n    assert np.all(np.array_equal(params1, params2))\n    fig3 = px.scatter(df, x='total_bill', y='tip', facet_row='sex', trendline='ols', trendline_scope='overall')\n    assert (len(fig3.data) == 4)\n    assert ('trendline' in fig3.data[3].hovertemplate)\n    results3 = px.get_trendline_results(fig3)\n    params3 = results3['px_fit_results'].iloc[0].params\n    assert np.all(np.array_equal(params1, params3))", "masked_code": "def test_overall_trendline(backend):\n    df = px.data.tips(return_type=backend)\n    fig1 = px.scatter(df, x='total_bill', y='tip', trendline='ols')\n    assert (len(fig1.data) == 2)\n    assert ('trendline' in fig1.data[1].hovertemplate)\n    results1 = px.get_trendline_results(fig1)\n    params1 = results1['px_fit_results'].iloc[0].params\n    fig2 = px.scatter(df, x='total_bill', y='tip', color='sex', trendline='ols', trendline_scope='overall')\n    assert (len(fig2.data) == '???')\n    assert ('trendline' in fig2.data[2].hovertemplate)\n    results2 = px.get_trendline_results(fig2)\n    params2 = results2['px_fit_results'].iloc[0].params\n    assert np.all(np.array_equal(params1, params2))\n    fig3 = px.scatter(df, x='total_bill', y='tip', facet_row='sex', trendline='ols', trendline_scope='overall')\n    assert (len(fig3.data) == 4)\n    assert ('trendline' in fig3.data[3].hovertemplate)\n    results3 = px.get_trendline_results(fig3)\n    params3 = results3['px_fit_results'].iloc[0].params\n    assert np.all(np.array_equal(params1, params3))", "ground_truth": "3", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_351", "reponame": "plotly", "testpath": "tests/test_optional/test_px/test_trendline.py", "testname": "test_trendline.py", "classname": null, "funcname": "test_overall_trendline", "imports": ["import plotly.express as px", "import narwhals.stable.v1 as nw", "import numpy as np", "import pytest", "from datetime import datetime", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "def test_overall_trendline(backend):\n    df = px.data.tips(return_type=backend)\n    fig1 = px.scatter(df, x='total_bill', y='tip', trendline='ols')\n    assert (len(fig1.data) == 2)\n    assert ('trendline' in fig1.data[1].hovertemplate)\n    results1 = px.get_trendline_results(fig1)\n    params1 = results1['px_fit_results'].iloc[0].params\n    fig2 = px.scatter(df, x='total_bill', y='tip', color='sex', trendline='ols', trendline_scope='overall')\n    assert (len(fig2.data) == 3)\n    assert ('trendline' in fig2.data[2].hovertemplate)\n    results2 = px.get_trendline_results(fig2)\n    params2 = results2['px_fit_results'].iloc[0].params\n    assert np.all(np.array_equal(params1, params2))\n    fig3 = px.scatter(df, x='total_bill', y='tip', facet_row='sex', trendline='ols', trendline_scope='overall')\n    assert (len(fig3.data) == 4)\n    assert ('trendline' in fig3.data[3].hovertemplate)\n    results3 = px.get_trendline_results(fig3)\n    params3 = results3['px_fit_results'].iloc[0].params\n    assert np.all(np.array_equal(params1, params3))", "masked_code": "def test_overall_trendline(backend):\n    df = px.data.tips(return_type=backend)\n    fig1 = px.scatter(df, x='total_bill', y='tip', trendline='ols')\n    assert (len(fig1.data) == 2)\n    assert ('trendline' in fig1.data[1].hovertemplate)\n    results1 = px.get_trendline_results(fig1)\n    params1 = results1['px_fit_results'].iloc[0].params\n    fig2 = px.scatter(df, x='total_bill', y='tip', color='sex', trendline='ols', trendline_scope='overall')\n    assert (len(fig2.data) == 3)\n    assert ('trendline' in fig2.data[2].hovertemplate)\n    results2 = px.get_trendline_results(fig2)\n    params2 = results2['px_fit_results'].iloc[0].params\n    assert np.all(np.array_equal(params1, params2))\n    fig3 = px.scatter(df, x='total_bill', y='tip', facet_row='sex', trendline='ols', trendline_scope='overall')\n    assert (len(fig3.data) == '???')\n    assert ('trendline' in fig3.data[3].hovertemplate)\n    results3 = px.get_trendline_results(fig3)\n    params3 = results3['px_fit_results'].iloc[0].params\n    assert np.all(np.array_equal(params1, params3))", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_352", "reponame": "plotly", "testpath": "tests/test_optional/test_utils/test_utils.py", "testname": "test_utils.py", "classname": "TestJSONEncoder", "funcname": "test_figure_json_encoding", "imports": ["import datetime", "import math", "import decimal", "from datetime import datetime as dt", "from unittest import TestCase", "import pytest", "from packaging.version import Version", "import numpy as np", "import pandas as pd", "import pytz", "from pandas.testing import assert_series_equal", "import json as _json", "import os", "import base64", "from plotly import optional_imports, utils", "import plotly.graph_objects as go", "from plotly.graph_objs import Scatter, Scatter3d, Figure, Data", "from plotly.utils import get_by_path", "from PIL import Image"], "code": "def test_figure_json_encoding(self):\n    df = pd.DataFrame(columns=['col 1'], data=[1, 2, 3])\n    s1 = Scatter3d(x=numeric_list, y=np_list, z=mixed_list)\n    s2 = Scatter(x=df['col 1'])\n    data = Data([s1, s2])\n    figure = Figure(data=data)\n    js1 = _json.dumps(s1, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    js2 = _json.dumps(s2, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    assert (js1 == '{\"type\": \"scatter3d\", \"x\": [1, 2, 3], \"y\": [1, 2, 3, null, null, \"2014-01-05T00:00:00\"], \"z\": [1, \"A\", \"2014-01-05T00:00:00\", \"2014-01-05T01:01:01\", \"2014-01-05T01:01:01.000001\"]}')\n    assert (js2 == '{\"type\": \"scatter\", \"x\": [1, 2, 3]}')\n    _json.dumps(data, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    _json.dumps(figure, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    np_array = np.array([1, 2, 3, np_nan(), np_inf(), dt(2014, 1, 5)])\n    for k in range(len(np_array)):\n        if (k == 3):\n            assert (np.isnan(np_list[k]) and np.isnan(np_array[k]))\n        else:\n            assert (np_list[k] == np_array[k])\n    assert (set(data[0]['z']) == set([1, 'A', dt(2014, 1, 5), dt(2014, 1, 5, 1, 1, 1), dt(2014, 1, 5, 1, 1, 1, 1)]))", "masked_code": "def test_figure_json_encoding(self):\n    df = pd.DataFrame(columns=['col 1'], data=[1, 2, 3])\n    s1 = Scatter3d(x=numeric_list, y=np_list, z=mixed_list)\n    s2 = Scatter(x=df['col 1'])\n    data = Data([s1, s2])\n    figure = Figure(data=data)\n    js1 = _json.dumps(s1, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    js2 = _json.dumps(s2, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    assert (js1 == '{\"type\": \"scatter3d\", \"x\": [1, 2, 3], \"y\": [1, 2, 3, null, null, \"2014-01-05T00:00:00\"], \"z\": [1, \"A\", \"2014-01-05T00:00:00\", \"2014-01-05T01:01:01\", \"2014-01-05T01:01:01.000001\"]}')\n    assert (js2 == '{\"type\": \"scatter\", \"x\": [1, 2, 3]}')\n    _json.dumps(data, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    _json.dumps(figure, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    np_array = np.array([1, 2, 3, np_nan(), np_inf(), dt(2014, 1, 5)])\n    for k in range(len(np_array)):\n        if (k == 3):\n            assert (np.isnan(np_list[k]) and np.isnan(np_array[k]))\n        else:\n            assert (np_list[k] == np_array[k])\n    assert (set(data[0]['z']) == '???')", "ground_truth": "set([1, 'A', dt(2014, 1, 5), dt(2014, 1, 5, 1, 1, 1), dt(2014, 1, 5, 1, 1, 1, 1)])", "quality_analysis": {"complexity_score": 44, "left_complexity": 12, "right_complexity": 32, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_353", "reponame": "plotly", "testpath": "tests/test_optional/test_utils/test_utils.py", "testname": "test_utils.py", "classname": "TestJSONEncoder", "funcname": "test_figure_json_encoding", "imports": ["import datetime", "import math", "import decimal", "from datetime import datetime as dt", "from unittest import TestCase", "import pytest", "from packaging.version import Version", "import numpy as np", "import pandas as pd", "import pytz", "from pandas.testing import assert_series_equal", "import json as _json", "import os", "import base64", "from plotly import optional_imports, utils", "import plotly.graph_objects as go", "from plotly.graph_objs import Scatter, Scatter3d, Figure, Data", "from plotly.utils import get_by_path", "from PIL import Image"], "code": "def test_figure_json_encoding(self):\n    df = pd.DataFrame(columns=['col 1'], data=[1, 2, 3])\n    s1 = Scatter3d(x=numeric_list, y=np_list, z=mixed_list)\n    s2 = Scatter(x=df['col 1'])\n    data = Data([s1, s2])\n    figure = Figure(data=data)\n    js1 = _json.dumps(s1, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    js2 = _json.dumps(s2, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    assert (js1 == '{\"type\": \"scatter3d\", \"x\": [1, 2, 3], \"y\": [1, 2, 3, null, null, \"2014-01-05T00:00:00\"], \"z\": [1, \"A\", \"2014-01-05T00:00:00\", \"2014-01-05T01:01:01\", \"2014-01-05T01:01:01.000001\"]}')\n    assert (js2 == '{\"type\": \"scatter\", \"x\": [1, 2, 3]}')\n    _json.dumps(data, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    _json.dumps(figure, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    np_array = np.array([1, 2, 3, np_nan(), np_inf(), dt(2014, 1, 5)])\n    for k in range(len(np_array)):\n        if (k == 3):\n            assert (np.isnan(np_list[k]) and np.isnan(np_array[k]))\n        else:\n            assert (np_list[k] == np_array[k])\n    assert (set(data[0]['z']) == set([1, 'A', dt(2014, 1, 5), dt(2014, 1, 5, 1, 1, 1), dt(2014, 1, 5, 1, 1, 1, 1)]))", "masked_code": "def test_figure_json_encoding(self):\n    df = pd.DataFrame(columns=['col 1'], data=[1, 2, 3])\n    s1 = Scatter3d(x=numeric_list, y=np_list, z=mixed_list)\n    s2 = Scatter(x=df['col 1'])\n    data = Data([s1, s2])\n    figure = Figure(data=data)\n    js1 = _json.dumps(s1, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    js2 = _json.dumps(s2, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    assert (js1 == '{\"type\": \"scatter3d\", \"x\": [1, 2, 3], \"y\": [1, 2, 3, null, null, \"2014-01-05T00:00:00\"], \"z\": [1, \"A\", \"2014-01-05T00:00:00\", \"2014-01-05T01:01:01\", \"2014-01-05T01:01:01.000001\"]}')\n    assert (js2 == '{\"type\": \"scatter\", \"x\": [1, 2, 3]}')\n    _json.dumps(data, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    _json.dumps(figure, cls=utils.PlotlyJSONEncoder, sort_keys=True)\n    np_array = np.array([1, 2, 3, np_nan(), np_inf(), dt(2014, 1, 5)])\n    for k in range(len(np_array)):\n        if (k == 3):\n            assert (np.isnan(np_list[k]) and np.isnan(np_array[k]))\n        else:\n            assert (np_list[k] == '???')\n    assert (set(data[0]['z']) == set([1, 'A', dt(2014, 1, 5), dt(2014, 1, 5, 1, 1, 1), dt(2014, 1, 5, 1, 1, 1, 1)]))", "ground_truth": "np_array[k]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_354", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_angle_validator.py", "testname": "test_angle_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import AngleValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val', ([0] + list(np.linspace((- 180), 179.99))))\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ([0] + list(np.linspace((- 180), 179.99))))\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_355", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_angle_validator.py", "testname": "test_angle_validator.py", "classname": null, "funcname": "test_coercion", "imports": ["import pytest", "from _plotly_utils.basevalidators import AngleValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val,expected', [(180, (- 180)), (181, (- 179)), ((- 180.25), 179.75), (540, (- 180)), ((- 541), 179)])\ndef test_coercion(val, expected, validator):\n    assert (validator.validate_coerce(val) == expected)", "masked_code": "@pytest.mark.parametrize('val,expected', [(180, (- 180)), (181, (- 179)), ((- 180.25), 179.75), (540, (- 180)), ((- 541), 179)])\ndef test_coercion(val, expected, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_356", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_angle_validator.py", "testname": "test_angle_validator.py", "classname": null, "funcname": "test_aok_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import AngleValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val', [[0, 179, (- 179)]])\ndef test_aok_acceptance(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == val)\n    assert (validator_aok.validate_coerce(tuple(val)) == val)\n    assert np.array_equal(validator_aok.validate_coerce(np.array(val)), np.array(val))", "masked_code": "@pytest.mark.parametrize('val', [[0, 179, (- 179)]])\ndef test_aok_acceptance(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == '???')\n    assert (validator_aok.validate_coerce(tuple(val)) == val)\n    assert np.array_equal(validator_aok.validate_coerce(np.array(val)), np.array(val))", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_357", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_angle_validator.py", "testname": "test_angle_validator.py", "classname": null, "funcname": "test_aok_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import AngleValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val', [[0, 179, (- 179)]])\ndef test_aok_acceptance(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == val)\n    assert (validator_aok.validate_coerce(tuple(val)) == val)\n    assert np.array_equal(validator_aok.validate_coerce(np.array(val)), np.array(val))", "masked_code": "@pytest.mark.parametrize('val', [[0, 179, (- 179)]])\ndef test_aok_acceptance(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == val)\n    assert (validator_aok.validate_coerce(tuple(val)) == '???')\n    assert np.array_equal(validator_aok.validate_coerce(np.array(val)), np.array(val))", "ground_truth": "val", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_358", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_angle_validator.py", "testname": "test_angle_validator.py", "classname": null, "funcname": "test_aok_coercion", "imports": ["import pytest", "from _plotly_utils.basevalidators import AngleValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val,expected', [(180, (- 180)), (181, (- 179)), ((- 180.25), 179.75), (540, (- 180)), ((- 541), 179)])\ndef test_aok_coercion(val, expected, validator_aok):\n    assert (validator_aok.validate_coerce([val]) == [expected])\n    assert np.array_equal(validator_aok.validate_coerce(np.array([val])), np.array([expected]))", "masked_code": "@pytest.mark.parametrize('val,expected', [(180, (- 180)), (181, (- 179)), ((- 180.25), 179.75), (540, (- 180)), ((- 541), 179)])\ndef test_aok_coercion(val, expected, validator_aok):\n    assert (validator_aok.validate_coerce([val]) == '???')\n    assert np.array_equal(validator_aok.validate_coerce(np.array([val])), np.array([expected]))", "ground_truth": "[expected]", "quality_analysis": {"complexity_score": 9, "left_complexity": 6, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_359", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_any_validator.py", "testname": "test_any_validator.py", "classname": null, "funcname": "test_acceptance_array", "imports": ["import pytest", "from _plotly_utils.basevalidators import AnyValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [23, 'Hello!', [], (), np.array([]), ('Hello', 'World'), ['Hello', 'World'], [np.pi, np.e, {}]])\ndef test_acceptance_array(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert (coerce_val.dtype == 'object')\n        assert np.array_equal(coerce_val, val)\n    elif isinstance(val, (list, tuple)):\n        assert (coerce_val == list(val))\n        assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)\n        assert (validator_aok.present(coerce_val) == val)", "masked_code": "@pytest.mark.parametrize('val', [23, 'Hello!', [], (), np.array([]), ('Hello', 'World'), ['Hello', 'World'], [np.pi, np.e, {}]])\ndef test_acceptance_array(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert (coerce_val.dtype == '???')\n        assert np.array_equal(coerce_val, val)\n    elif isinstance(val, (list, tuple)):\n        assert (coerce_val == list(val))\n        assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)\n        assert (validator_aok.present(coerce_val) == val)", "ground_truth": "'object'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_360", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_any_validator.py", "testname": "test_any_validator.py", "classname": null, "funcname": "test_acceptance_array", "imports": ["import pytest", "from _plotly_utils.basevalidators import AnyValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [23, 'Hello!', [], (), np.array([]), ('Hello', 'World'), ['Hello', 'World'], [np.pi, np.e, {}]])\ndef test_acceptance_array(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert (coerce_val.dtype == 'object')\n        assert np.array_equal(coerce_val, val)\n    elif isinstance(val, (list, tuple)):\n        assert (coerce_val == list(val))\n        assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)\n        assert (validator_aok.present(coerce_val) == val)", "masked_code": "@pytest.mark.parametrize('val', [23, 'Hello!', [], (), np.array([]), ('Hello', 'World'), ['Hello', 'World'], [np.pi, np.e, {}]])\ndef test_acceptance_array(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert (coerce_val.dtype == 'object')\n        assert np.array_equal(coerce_val, val)\n    elif isinstance(val, (list, tuple)):\n        assert (coerce_val == list(val))\n        assert (validator_aok.present(coerce_val) == '???')\n    else:\n        assert (coerce_val == val)\n        assert (validator_aok.present(coerce_val) == val)", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_361", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_any_validator.py", "testname": "test_any_validator.py", "classname": null, "funcname": "test_acceptance_array", "imports": ["import pytest", "from _plotly_utils.basevalidators import AnyValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [23, 'Hello!', [], (), np.array([]), ('Hello', 'World'), ['Hello', 'World'], [np.pi, np.e, {}]])\ndef test_acceptance_array(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert (coerce_val.dtype == 'object')\n        assert np.array_equal(coerce_val, val)\n    elif isinstance(val, (list, tuple)):\n        assert (coerce_val == list(val))\n        assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)\n        assert (validator_aok.present(coerce_val) == val)", "masked_code": "@pytest.mark.parametrize('val', [23, 'Hello!', [], (), np.array([]), ('Hello', 'World'), ['Hello', 'World'], [np.pi, np.e, {}]])\ndef test_acceptance_array(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert (coerce_val.dtype == 'object')\n        assert np.array_equal(coerce_val, val)\n    elif isinstance(val, (list, tuple)):\n        assert (coerce_val == list(val))\n        assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)\n        assert (validator_aok.present(coerce_val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_362", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_basetraces_validator.py", "testname": "test_basetraces_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import BaseDataValidator", "from plotly.graph_objs import Scatter, Box"], "code": "def test_acceptance(validator):\n    val = [Scatter(mode='lines'), Box(fillcolor='yellow')]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "masked_code": "def test_acceptance(validator):\n    val = [Scatter(mode='lines'), Box(fillcolor='yellow')]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == '???')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "ground_truth": "'scatter'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_363", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_basetraces_validator.py", "testname": "test_basetraces_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import BaseDataValidator", "from plotly.graph_objs import Scatter, Box"], "code": "def test_acceptance(validator):\n    val = [Scatter(mode='lines'), Box(fillcolor='yellow')]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "masked_code": "def test_acceptance(validator):\n    val = [Scatter(mode='lines'), Box(fillcolor='yellow')]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == '???')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "ground_truth": "'lines'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_364", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_basetraces_validator.py", "testname": "test_basetraces_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import BaseDataValidator", "from plotly.graph_objs import Scatter, Box"], "code": "def test_acceptance(validator):\n    val = [Scatter(mode='lines'), Box(fillcolor='yellow')]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "masked_code": "def test_acceptance(validator):\n    val = [Scatter(mode='lines'), Box(fillcolor='yellow')]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == '???')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "ground_truth": "'box'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_365", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_basetraces_validator.py", "testname": "test_basetraces_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import BaseDataValidator", "from plotly.graph_objs import Scatter, Box"], "code": "def test_acceptance(validator):\n    val = [Scatter(mode='lines'), Box(fillcolor='yellow')]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "masked_code": "def test_acceptance(validator):\n    val = [Scatter(mode='lines'), Box(fillcolor='yellow')]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == '???')\n    assert (res_present[0].uid != res_present[1].uid)", "ground_truth": "'yellow'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_366", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_basetraces_validator.py", "testname": "test_basetraces_validator.py", "classname": null, "funcname": "test_acceptance_dict", "imports": ["import pytest", "from _plotly_utils.basevalidators import BaseDataValidator", "from plotly.graph_objs import Scatter, Box"], "code": "def test_acceptance_dict(validator):\n    val = (dict(type='scatter', mode='lines'), dict(type='box', fillcolor='yellow'))\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "masked_code": "def test_acceptance_dict(validator):\n    val = (dict(type='scatter', mode='lines'), dict(type='box', fillcolor='yellow'))\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == '???')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "ground_truth": "'scatter'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_367", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_basetraces_validator.py", "testname": "test_basetraces_validator.py", "classname": null, "funcname": "test_acceptance_dict", "imports": ["import pytest", "from _plotly_utils.basevalidators import BaseDataValidator", "from plotly.graph_objs import Scatter, Box"], "code": "def test_acceptance_dict(validator):\n    val = (dict(type='scatter', mode='lines'), dict(type='box', fillcolor='yellow'))\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "masked_code": "def test_acceptance_dict(validator):\n    val = (dict(type='scatter', mode='lines'), dict(type='box', fillcolor='yellow'))\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == '???')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "ground_truth": "'lines'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_368", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_basetraces_validator.py", "testname": "test_basetraces_validator.py", "classname": null, "funcname": "test_acceptance_dict", "imports": ["import pytest", "from _plotly_utils.basevalidators import BaseDataValidator", "from plotly.graph_objs import Scatter, Box"], "code": "def test_acceptance_dict(validator):\n    val = (dict(type='scatter', mode='lines'), dict(type='box', fillcolor='yellow'))\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "masked_code": "def test_acceptance_dict(validator):\n    val = (dict(type='scatter', mode='lines'), dict(type='box', fillcolor='yellow'))\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == '???')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "ground_truth": "'box'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_369", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_basetraces_validator.py", "testname": "test_basetraces_validator.py", "classname": null, "funcname": "test_acceptance_dict", "imports": ["import pytest", "from _plotly_utils.basevalidators import BaseDataValidator", "from plotly.graph_objs import Scatter, Box"], "code": "def test_acceptance_dict(validator):\n    val = (dict(type='scatter', mode='lines'), dict(type='box', fillcolor='yellow'))\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == 'yellow')\n    assert (res_present[0].uid != res_present[1].uid)", "masked_code": "def test_acceptance_dict(validator):\n    val = (dict(type='scatter', mode='lines'), dict(type='box', fillcolor='yellow'))\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')\n    assert isinstance(res_present[1], Box)\n    assert (res_present[1].type == 'box')\n    assert (res_present[1].fillcolor == '???')\n    assert (res_present[0].uid != res_present[1].uid)", "ground_truth": "'yellow'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_370", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_basetraces_validator.py", "testname": "test_basetraces_validator.py", "classname": null, "funcname": "test_default_is_scatter", "imports": ["import pytest", "from _plotly_utils.basevalidators import BaseDataValidator", "from plotly.graph_objs import Scatter, Box"], "code": "def test_default_is_scatter(validator):\n    val = [dict(mode='lines')]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')", "masked_code": "def test_default_is_scatter(validator):\n    val = [dict(mode='lines')]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == '???')\n    assert (res_present[0].mode == 'lines')", "ground_truth": "'scatter'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_371", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_basetraces_validator.py", "testname": "test_basetraces_validator.py", "classname": null, "funcname": "test_default_is_scatter", "imports": ["import pytest", "from _plotly_utils.basevalidators import BaseDataValidator", "from plotly.graph_objs import Scatter, Box"], "code": "def test_default_is_scatter(validator):\n    val = [dict(mode='lines')]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == 'lines')", "masked_code": "def test_default_is_scatter(validator):\n    val = [dict(mode='lines')]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Scatter)\n    assert (res_present[0].type == 'scatter')\n    assert (res_present[0].mode == '???')", "ground_truth": "'lines'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_372", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_basetraces_validator.py", "testname": "test_basetraces_validator.py", "classname": null, "funcname": "test_skip_invalid", "imports": ["import pytest", "from _plotly_utils.basevalidators import BaseDataValidator", "from plotly.graph_objs import Scatter, Box"], "code": "def test_skip_invalid(validator_nouid):\n    val = (dict(type='scatter', mode='lines', marker={'color': 'green', 'bogus': 23}, line='bad_value'), dict(type='box', fillcolor='yellow', bogus=111), dict(type='bogus', mode='lines+markers', x=[2, 1, 3]))\n    expected = [dict(type='scatter', mode='lines', marker={'color': 'green'}), dict(type='box', fillcolor='yellow'), dict(type='scatter', mode='lines+markers', x=[2, 1, 3])]\n    res = validator_nouid.validate_coerce(val, skip_invalid=True)\n    assert ([el.to_plotly_json() for el in res] == expected)", "masked_code": "def test_skip_invalid(validator_nouid):\n    val = (dict(type='scatter', mode='lines', marker={'color': 'green', 'bogus': 23}, line='bad_value'), dict(type='box', fillcolor='yellow', bogus=111), dict(type='bogus', mode='lines+markers', x=[2, 1, 3]))\n    expected = [dict(type='scatter', mode='lines', marker={'color': 'green'}), dict(type='box', fillcolor='yellow'), dict(type='scatter', mode='lines+markers', x=[2, 1, 3])]\n    res = validator_nouid.validate_coerce(val, skip_invalid=True)\n    assert ([el.to_plotly_json() for el in res] == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 1, "left_complexity": 0, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_373", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorlist_validator.py", "testname": "test_colorlist_validator.py", "classname": null, "funcname": "test_acceptance_aok", "imports": ["import pytest", "import numpy as np", "from _plotly_utils.basevalidators import ColorlistValidator"], "code": "@pytest.mark.parametrize('val', [['blue'], ['red', 'rgb(255, 0, 0)'], np.array(['red', 'rgb(255, 0, 0)']), ['hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)', 'hsv(0, 100%, 100%)'], np.array(['hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)', 'hsv(0, 100%, 100%)']), ['hsva(0, 100%, 100%, 50%)']])\ndef test_acceptance_aok(val, validator):\n    coerce_val = validator.validate_coerce(val)\n    assert isinstance(coerce_val, list)\n    assert (validator.present(coerce_val) == tuple(val))", "masked_code": "@pytest.mark.parametrize('val', [['blue'], ['red', 'rgb(255, 0, 0)'], np.array(['red', 'rgb(255, 0, 0)']), ['hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)', 'hsv(0, 100%, 100%)'], np.array(['hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)', 'hsv(0, 100%, 100%)']), ['hsva(0, 100%, 100%, 50%)']])\ndef test_acceptance_aok(val, validator):\n    coerce_val = validator.validate_coerce(val)\n    assert isinstance(coerce_val, list)\n    assert (validator.present(coerce_val) == '???')", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_374", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "classname": null, "funcname": "test_acceptance_named", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "def test_acceptance_named(named_colorscale, validator):\n    d = (len(named_colorscales[named_colorscale]) - 1)\n    expected = [[((1.0 * i) / (1.0 * d)), x] for (i, x) in enumerate(named_colorscales[named_colorscale])]\n    assert (validator.validate_coerce(named_colorscale) == expected)\n    assert (validator.validate_coerce(named_colorscale.upper()) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "masked_code": "def test_acceptance_named(named_colorscale, validator):\n    d = (len(named_colorscales[named_colorscale]) - 1)\n    expected = [[((1.0 * i) / (1.0 * d)), x] for (i, x) in enumerate(named_colorscales[named_colorscale])]\n    assert (validator.validate_coerce(named_colorscale) == '???')\n    assert (validator.validate_coerce(named_colorscale.upper()) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_375", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "classname": null, "funcname": "test_acceptance_named", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "def test_acceptance_named(named_colorscale, validator):\n    d = (len(named_colorscales[named_colorscale]) - 1)\n    expected = [[((1.0 * i) / (1.0 * d)), x] for (i, x) in enumerate(named_colorscales[named_colorscale])]\n    assert (validator.validate_coerce(named_colorscale) == expected)\n    assert (validator.validate_coerce(named_colorscale.upper()) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "masked_code": "def test_acceptance_named(named_colorscale, validator):\n    d = (len(named_colorscales[named_colorscale]) - 1)\n    expected = [[((1.0 * i) / (1.0 * d)), x] for (i, x) in enumerate(named_colorscales[named_colorscale])]\n    assert (validator.validate_coerce(named_colorscale) == expected)\n    assert (validator.validate_coerce(named_colorscale.upper()) == '???')\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "ground_truth": "expected", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_376", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "classname": null, "funcname": "test_acceptance_named", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "def test_acceptance_named(named_colorscale, validator):\n    d = (len(named_colorscales[named_colorscale]) - 1)\n    expected = [[((1.0 * i) / (1.0 * d)), x] for (i, x) in enumerate(named_colorscales[named_colorscale])]\n    assert (validator.validate_coerce(named_colorscale) == expected)\n    assert (validator.validate_coerce(named_colorscale.upper()) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "masked_code": "def test_acceptance_named(named_colorscale, validator):\n    d = (len(named_colorscales[named_colorscale]) - 1)\n    expected = [[((1.0 * i) / (1.0 * d)), x] for (i, x) in enumerate(named_colorscales[named_colorscale])]\n    assert (validator.validate_coerce(named_colorscale) == expected)\n    assert (validator.validate_coerce(named_colorscale.upper()) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == '???')", "ground_truth": "expected_tuples", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_377", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "classname": null, "funcname": "test_acceptance_sequence", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "def test_acceptance_sequence(seqence_colorscale, validator):\n    d = (len(seqence_colorscale) - 1)\n    expected = [[((1.0 * i) / (1.0 * d)), x] for (i, x) in enumerate(seqence_colorscale)]\n    assert (validator.validate_coerce(seqence_colorscale) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "masked_code": "def test_acceptance_sequence(seqence_colorscale, validator):\n    d = (len(seqence_colorscale) - 1)\n    expected = [[((1.0 * i) / (1.0 * d)), x] for (i, x) in enumerate(seqence_colorscale)]\n    assert (validator.validate_coerce(seqence_colorscale) == '???')\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_378", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "classname": null, "funcname": "test_acceptance_sequence", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "def test_acceptance_sequence(seqence_colorscale, validator):\n    d = (len(seqence_colorscale) - 1)\n    expected = [[((1.0 * i) / (1.0 * d)), x] for (i, x) in enumerate(seqence_colorscale)]\n    assert (validator.validate_coerce(seqence_colorscale) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == expected_tuples)", "masked_code": "def test_acceptance_sequence(seqence_colorscale, validator):\n    d = (len(seqence_colorscale) - 1)\n    expected = [[((1.0 * i) / (1.0 * d)), x] for (i, x) in enumerate(seqence_colorscale)]\n    assert (validator.validate_coerce(seqence_colorscale) == expected)\n    expected_tuples = tuple(((c[0], c[1]) for c in expected))\n    assert (validator.present(expected) == '???')", "ground_truth": "expected_tuples", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_379", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "classname": null, "funcname": "test_acceptance_array_1", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "@pytest.mark.parametrize('val', [[[0, 'red']], [[0.1, 'rgb(255,0,0)'], [0.3, 'green']], [[0, 'purple'], [0.2, 'yellow'], [1.0, 'rgba(255,0,0,100)']]])\ndef test_acceptance_array_1(val, validator):\n    assert (validator.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', [[[0, 'red']], [[0.1, 'rgb(255,0,0)'], [0.3, 'green']], [[0, 'purple'], [0.2, 'yellow'], [1.0, 'rgba(255,0,0,100)']]])\ndef test_acceptance_array_1(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_380", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_colorscale_validator.py", "testname": "test_colorscale_validator.py", "classname": null, "funcname": "test_acceptance_array_2", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorscaleValidator", "from _plotly_utils import colors", "import numpy as np", "import inspect", "import itertools"], "code": "@pytest.mark.parametrize('val', [([0, 'red'],), [(0.1, 'rgb(255, 0, 0)'), (0.3, 'GREEN')], (np.array([0, 'Purple'], dtype='object'), (0.2, 'yellow'), (1.0, 'RGBA(255,0,0,100)'))])\ndef test_acceptance_array_2(val, validator):\n    expected = [[e[0], e[1]] for e in val]\n    coerce_val = validator.validate_coerce(val)\n    assert (coerce_val == expected)\n    expected_present = tuple([tuple(e) for e in expected])\n    assert (validator.present(coerce_val) == expected_present)", "masked_code": "@pytest.mark.parametrize('val', [([0, 'red'],), [(0.1, 'rgb(255, 0, 0)'), (0.3, 'GREEN')], (np.array([0, 'Purple'], dtype='object'), (0.2, 'yellow'), (1.0, 'RGBA(255,0,0,100)'))])\ndef test_acceptance_array_2(val, validator):\n    expected = [[e[0], e[1]] for e in val]\n    coerce_val = validator.validate_coerce(val)\n    assert (coerce_val == expected)\n    expected_present = tuple([tuple(e) for e in expected])\n    assert (validator.present(coerce_val) == '???')", "ground_truth": "expected_present", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_381", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_color_validator.py", "testname": "test_color_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val', ['red', 'BLUE', 'rgb(255, 0, 0)', 'var(--accent)', 'hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)', 'hsv(0, 100%, 100%)', 'hsva(0, 100%, 100%, 50%)'])\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['red', 'BLUE', 'rgb(255, 0, 0)', 'var(--accent)', 'hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)', 'hsv(0, 100%, 100%)', 'hsva(0, 100%, 100%, 50%)'])\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_382", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_color_validator.py", "testname": "test_color_validator.py", "classname": null, "funcname": "test_acceptance_colorscale", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val', ['red', 'BLUE', 23, 15, 'rgb(255, 0, 0)', 'var(--accent)', 'hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)', 'hsv(0, 100%, 100%)', 'hsva(0, 100%, 100%, 50%)'])\ndef test_acceptance_colorscale(val, validator_colorscale):\n    assert (validator_colorscale.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['red', 'BLUE', 23, 15, 'rgb(255, 0, 0)', 'var(--accent)', 'hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)', 'hsv(0, 100%, 100%)', 'hsva(0, 100%, 100%, 50%)'])\ndef test_acceptance_colorscale(val, validator_colorscale):\n    assert (validator_colorscale.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_383", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_color_validator.py", "testname": "test_color_validator.py", "classname": null, "funcname": "test_acceptance_aok", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val', ['blue', ['red', 'rgb(255, 0, 0)'], np.array(['red', 'rgb(255, 0, 0)']), ['hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)', 'hsv(0, 100%, 100%)'], np.array(['hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)', 'hsv(0, 100%, 100%)']), ['hsva(0, 100%, 100%, 50%)']])\ndef test_acceptance_aok(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert np.array_equal(coerce_val, val)\n    elif isinstance(val, list):\n        assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)", "masked_code": "@pytest.mark.parametrize('val', ['blue', ['red', 'rgb(255, 0, 0)'], np.array(['red', 'rgb(255, 0, 0)']), ['hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)', 'hsv(0, 100%, 100%)'], np.array(['hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)', 'hsv(0, 100%, 100%)']), ['hsva(0, 100%, 100%, 50%)']])\ndef test_acceptance_aok(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert np.array_equal(coerce_val, val)\n    elif isinstance(val, list):\n        assert (validator_aok.present(coerce_val) == '???')\n    else:\n        assert (coerce_val == val)", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_384", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_color_validator.py", "testname": "test_color_validator.py", "classname": null, "funcname": "test_acceptance_aok_2D", "imports": ["import pytest", "from _plotly_utils.basevalidators import ColorValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('val', ['green', [['blue']], [['red', 'rgb(255, 0, 0)'], ['hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)']], np.array([['red', 'rgb(255, 0, 0)'], ['hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)']])])\ndef test_acceptance_aok_2D(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert np.array_equal(coerce_val, val)\n    elif isinstance(val, list):\n        assert (validator_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)", "masked_code": "@pytest.mark.parametrize('val', ['green', [['blue']], [['red', 'rgb(255, 0, 0)'], ['hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)']], np.array([['red', 'rgb(255, 0, 0)'], ['hsl(0, 100%, 50%)', 'hsla(0, 100%, 50%, 100%)']])])\ndef test_acceptance_aok_2D(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert np.array_equal(coerce_val, val)\n    elif isinstance(val, list):\n        assert (validator_aok.present(coerce_val) == '???')\n    else:\n        assert (coerce_val == val)", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_385", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_acceptance(validator):\n    val = [Image(opacity=0.5, sizex=120), Image(x=99)]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0.5)\n    assert (res_present[0].sizex == 120)\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].opacity is None)\n    assert (res_present[1].sizex is None)\n    assert (res_present[1].x == 99)", "masked_code": "def test_acceptance(validator):\n    val = [Image(opacity=0.5, sizex=120), Image(x=99)]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == '???')\n    assert (res_present[0].sizex == 120)\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].opacity is None)\n    assert (res_present[1].sizex is None)\n    assert (res_present[1].x == 99)", "ground_truth": "0.5", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_386", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_acceptance(validator):\n    val = [Image(opacity=0.5, sizex=120), Image(x=99)]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0.5)\n    assert (res_present[0].sizex == 120)\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].opacity is None)\n    assert (res_present[1].sizex is None)\n    assert (res_present[1].x == 99)", "masked_code": "def test_acceptance(validator):\n    val = [Image(opacity=0.5, sizex=120), Image(x=99)]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0.5)\n    assert (res_present[0].sizex == '???')\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].opacity is None)\n    assert (res_present[1].sizex is None)\n    assert (res_present[1].x == 99)", "ground_truth": "120", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_387", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_acceptance(validator):\n    val = [Image(opacity=0.5, sizex=120), Image(x=99)]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0.5)\n    assert (res_present[0].sizex == 120)\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].opacity is None)\n    assert (res_present[1].sizex is None)\n    assert (res_present[1].x == 99)", "masked_code": "def test_acceptance(validator):\n    val = [Image(opacity=0.5, sizex=120), Image(x=99)]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0.5)\n    assert (res_present[0].sizex == 120)\n    assert (res_present[0].x is None)\n    assert isinstance(res_present[1], Image)\n    assert (res_present[1].opacity is None)\n    assert (res_present[1].sizex is None)\n    assert (res_present[1].x == '???')", "ground_truth": "99", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_388", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "classname": null, "funcname": "test_acceptance_dict", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_acceptance_dict(validator):\n    val = [dict(opacity=0.5, sizex=120), dict(x=99)]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0.5)\n    assert (res_present[0].sizex == 120)\n    assert (res_present[0].x is None)\n    assert isinstance(res[1], Image)\n    assert (res_present[1].opacity is None)\n    assert (res_present[1].sizex is None)\n    assert (res_present[1].x == 99)", "masked_code": "def test_acceptance_dict(validator):\n    val = [dict(opacity=0.5, sizex=120), dict(x=99)]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == '???')\n    assert (res_present[0].sizex == 120)\n    assert (res_present[0].x is None)\n    assert isinstance(res[1], Image)\n    assert (res_present[1].opacity is None)\n    assert (res_present[1].sizex is None)\n    assert (res_present[1].x == 99)", "ground_truth": "0.5", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_389", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "classname": null, "funcname": "test_acceptance_dict", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_acceptance_dict(validator):\n    val = [dict(opacity=0.5, sizex=120), dict(x=99)]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0.5)\n    assert (res_present[0].sizex == 120)\n    assert (res_present[0].x is None)\n    assert isinstance(res[1], Image)\n    assert (res_present[1].opacity is None)\n    assert (res_present[1].sizex is None)\n    assert (res_present[1].x == 99)", "masked_code": "def test_acceptance_dict(validator):\n    val = [dict(opacity=0.5, sizex=120), dict(x=99)]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0.5)\n    assert (res_present[0].sizex == '???')\n    assert (res_present[0].x is None)\n    assert isinstance(res[1], Image)\n    assert (res_present[1].opacity is None)\n    assert (res_present[1].sizex is None)\n    assert (res_present[1].x == 99)", "ground_truth": "120", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_390", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "classname": null, "funcname": "test_acceptance_dict", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_acceptance_dict(validator):\n    val = [dict(opacity=0.5, sizex=120), dict(x=99)]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0.5)\n    assert (res_present[0].sizex == 120)\n    assert (res_present[0].x is None)\n    assert isinstance(res[1], Image)\n    assert (res_present[1].opacity is None)\n    assert (res_present[1].sizex is None)\n    assert (res_present[1].x == 99)", "masked_code": "def test_acceptance_dict(validator):\n    val = [dict(opacity=0.5, sizex=120), dict(x=99)]\n    res = validator.validate_coerce(val)\n    res_present = validator.present(res)\n    assert isinstance(res, list)\n    assert isinstance(res_present, tuple)\n    assert isinstance(res_present[0], Image)\n    assert (res_present[0].opacity == 0.5)\n    assert (res_present[0].sizex == 120)\n    assert (res_present[0].x is None)\n    assert isinstance(res[1], Image)\n    assert (res_present[1].opacity is None)\n    assert (res_present[1].sizex is None)\n    assert (res_present[1].x == '???')", "ground_truth": "99", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_391", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compoundarray_validator.py", "testname": "test_compoundarray_validator.py", "classname": null, "funcname": "test_skip_invalid", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundArrayValidator", "from plotly.graph_objs.layout import Image"], "code": "def test_skip_invalid(validator):\n    val = [dict(opacity='bad_opacity', x=23, sizex=120), dict(x=99, bogus={'a': 23}, sizey=300)]\n    expected = [dict(x=23, sizex=120), dict(x=99, sizey=300)]\n    res = validator.validate_coerce(val, skip_invalid=True)\n    assert ([el.to_plotly_json() for el in res] == expected)", "masked_code": "def test_skip_invalid(validator):\n    val = [dict(opacity='bad_opacity', x=23, sizex=120), dict(x=99, bogus={'a': 23}, sizey=300)]\n    expected = [dict(x=23, sizex=120), dict(x=99, sizey=300)]\n    res = validator.validate_coerce(val, skip_invalid=True)\n    assert ([el.to_plotly_json() for el in res] == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 1, "left_complexity": 0, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_392", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compound_validator.py", "testname": "test_compound_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundValidator", "from plotly.graph_objs.scatter import Marker"], "code": "def test_acceptance(validator):\n    val = Marker(color='green', size=10)\n    res = validator.validate_coerce(val)\n    assert isinstance(res, Marker)\n    assert (res.color == 'green')\n    assert (res.size == 10)", "masked_code": "def test_acceptance(validator):\n    val = Marker(color='green', size=10)\n    res = validator.validate_coerce(val)\n    assert isinstance(res, Marker)\n    assert (res.color == '???')\n    assert (res.size == 10)", "ground_truth": "'green'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_393", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compound_validator.py", "testname": "test_compound_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundValidator", "from plotly.graph_objs.scatter import Marker"], "code": "def test_acceptance(validator):\n    val = Marker(color='green', size=10)\n    res = validator.validate_coerce(val)\n    assert isinstance(res, Marker)\n    assert (res.color == 'green')\n    assert (res.size == 10)", "masked_code": "def test_acceptance(validator):\n    val = Marker(color='green', size=10)\n    res = validator.validate_coerce(val)\n    assert isinstance(res, Marker)\n    assert (res.color == 'green')\n    assert (res.size == '???')", "ground_truth": "10", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_394", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compound_validator.py", "testname": "test_compound_validator.py", "classname": null, "funcname": "test_acceptance_dict", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundValidator", "from plotly.graph_objs.scatter import Marker"], "code": "def test_acceptance_dict(validator):\n    val = dict(color='green', size=10)\n    res = validator.validate_coerce(val)\n    assert isinstance(res, Marker)\n    assert (res.color == 'green')\n    assert (res.size == 10)", "masked_code": "def test_acceptance_dict(validator):\n    val = dict(color='green', size=10)\n    res = validator.validate_coerce(val)\n    assert isinstance(res, Marker)\n    assert (res.color == '???')\n    assert (res.size == 10)", "ground_truth": "'green'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_395", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compound_validator.py", "testname": "test_compound_validator.py", "classname": null, "funcname": "test_acceptance_dict", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundValidator", "from plotly.graph_objs.scatter import Marker"], "code": "def test_acceptance_dict(validator):\n    val = dict(color='green', size=10)\n    res = validator.validate_coerce(val)\n    assert isinstance(res, Marker)\n    assert (res.color == 'green')\n    assert (res.size == 10)", "masked_code": "def test_acceptance_dict(validator):\n    val = dict(color='green', size=10)\n    res = validator.validate_coerce(val)\n    assert isinstance(res, Marker)\n    assert (res.color == 'green')\n    assert (res.size == '???')", "ground_truth": "10", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_396", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compound_validator.py", "testname": "test_compound_validator.py", "classname": null, "funcname": "test_skip_invalid", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundValidator", "from plotly.graph_objs.scatter import Marker"], "code": "def test_skip_invalid(validator):\n    val = dict(color='green', size=10, bogus=99, colorbar={'bgcolor': 'blue', 'bogus_inner': 23}, opacity='bogus value')\n    expected = dict(color='green', size=10, colorbar={'bgcolor': 'blue'})\n    res = validator.validate_coerce(val, skip_invalid=True)\n    assert (res.to_plotly_json() == expected)", "masked_code": "def test_skip_invalid(validator):\n    val = dict(color='green', size=10, bogus=99, colorbar={'bgcolor': 'blue', 'bogus_inner': 23}, opacity='bogus value')\n    expected = dict(color='green', size=10, colorbar={'bgcolor': 'blue'})\n    res = validator.validate_coerce(val, skip_invalid=True)\n    assert (res.to_plotly_json() == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_397", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_compound_validator.py", "testname": "test_compound_validator.py", "classname": null, "funcname": "test_skip_invalid_empty_object", "imports": ["import pytest", "from _plotly_utils.basevalidators import CompoundValidator", "from plotly.graph_objs.scatter import Marker"], "code": "def test_skip_invalid_empty_object(validator):\n    val = dict(color='green', size=10, colorbar={'bgcolor': 'bad_color', 'bogus_inner': 23}, opacity=0.5)\n    expected = dict(color='green', size=10, opacity=0.5)\n    res = validator.validate_coerce(val, skip_invalid=True)\n    assert (res.to_plotly_json() == expected)", "masked_code": "def test_skip_invalid_empty_object(validator):\n    val = dict(color='green', size=10, colorbar={'bgcolor': 'bad_color', 'bogus_inner': 23}, opacity=0.5)\n    expected = dict(color='green', size=10, opacity=0.5)\n    res = validator.validate_coerce(val, skip_invalid=True)\n    assert (res.to_plotly_json() == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_398", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_dash_validator.py", "testname": "test_dash_validator.py", "classname": null, "funcname": "test_acceptance_dash_types", "imports": ["import pytest", "from _plotly_utils.basevalidators import DashValidator"], "code": "@pytest.mark.parametrize('val', dash_types)\ndef test_acceptance_dash_types(val, validator):\n    assert (validator.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', dash_types)\ndef test_acceptance_dash_types(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_399", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_dash_validator.py", "testname": "test_dash_validator.py", "classname": null, "funcname": "test_acceptance_dash_lists", "imports": ["import pytest", "from _plotly_utils.basevalidators import DashValidator"], "code": "@pytest.mark.parametrize('val', ['2', '2.2', '2.002', '1 2 002', '1,2,3', '1, 2, 3', '1px 2px 3px', '1.5px, 2px, 3.9px', '23% 18% 13px', '200%   3px'])\ndef test_acceptance_dash_lists(val, validator):\n    assert (validator.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['2', '2.2', '2.002', '1 2 002', '1,2,3', '1, 2, 3', '1px 2px 3px', '1.5px, 2px, 3.9px', '23% 18% 13px', '200%   3px'])\ndef test_acceptance_dash_lists(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_400", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_dataarray_validator.py", "testname": "test_dataarray_validator.py", "classname": null, "funcname": "test_validator_acceptance_simple", "imports": ["import pytest", "from _plotly_utils.basevalidators import DataArrayValidator", "import numpy as np", "import pandas as pd"], "code": "@pytest.mark.parametrize('val', [[], [1], [''], (), ('Hello, ', 'world!'), ['A', 1, 'B', 0, 'C'], [np.array(1), np.array(2)]])\ndef test_validator_acceptance_simple(val, validator):\n    coerce_val = validator.validate_coerce(val)\n    assert isinstance(coerce_val, list)\n    assert (validator.present(coerce_val) == tuple(val))", "masked_code": "@pytest.mark.parametrize('val', [[], [1], [''], (), ('Hello, ', 'world!'), ['A', 1, 'B', 0, 'C'], [np.array(1), np.array(2)]])\ndef test_validator_acceptance_simple(val, validator):\n    coerce_val = validator.validate_coerce(val)\n    assert isinstance(coerce_val, list)\n    assert (validator.present(coerce_val) == '???')", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_401", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_enumerated_validator.py", "testname": "test_enumerated_validator.py", "classname": null, "funcname": "test_acceptance_no_array", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import EnumeratedValidator", "from ...test_optional.test_utils.test_utils import np_inf"], "code": "@pytest.mark.parametrize('val', ['first', 'second', 'third', 4])\ndef test_acceptance_no_array(val, validator):\n    assert (validator.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['first', 'second', 'third', 4])\ndef test_acceptance_no_array(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_402", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_enumerated_validator.py", "testname": "test_enumerated_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import EnumeratedValidator", "from ...test_optional.test_utils.test_utils import np_inf"], "code": "@pytest.mark.parametrize('val', ['foo', 'bar0', 'bar1', 'bar234'])\ndef test_acceptance(val, validator_re):\n    assert (validator_re.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['foo', 'bar0', 'bar1', 'bar234'])\ndef test_acceptance(val, validator_re):\n    assert (validator_re.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_403", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_enumerated_validator.py", "testname": "test_enumerated_validator.py", "classname": null, "funcname": "test_acceptance_array_ok_re", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import EnumeratedValidator", "from ...test_optional.test_utils.test_utils import np_inf"], "code": "@pytest.mark.parametrize('val', ['foo', 'bar12', 'bar21', [], ['bar12'], ('foo', 'bar012', 'baz'), np.array([], dtype='object'), np.array(['bar12']), np.array(['foo', 'bar012', 'baz'])])\ndef test_acceptance_array_ok_re(val, validator_aok_re):\n    coerce_val = validator_aok_re.validate_coerce(val)\n    if isinstance(val, (np.ndarray, pd.Series)):\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif isinstance(val, (list, tuple)):\n        assert (validator_aok_re.present(coerce_val) == tuple(val))\n    else:\n        assert (validator_aok_re.present(coerce_val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['foo', 'bar12', 'bar21', [], ['bar12'], ('foo', 'bar012', 'baz'), np.array([], dtype='object'), np.array(['bar12']), np.array(['foo', 'bar012', 'baz'])])\ndef test_acceptance_array_ok_re(val, validator_aok_re):\n    coerce_val = validator_aok_re.validate_coerce(val)\n    if isinstance(val, (np.ndarray, pd.Series)):\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif isinstance(val, (list, tuple)):\n        assert (validator_aok_re.present(coerce_val) == '???')\n    else:\n        assert (validator_aok_re.present(coerce_val) == val)", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_404", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_enumerated_validator.py", "testname": "test_enumerated_validator.py", "classname": null, "funcname": "test_acceptance_array_ok_re", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import EnumeratedValidator", "from ...test_optional.test_utils.test_utils import np_inf"], "code": "@pytest.mark.parametrize('val', ['foo', 'bar12', 'bar21', [], ['bar12'], ('foo', 'bar012', 'baz'), np.array([], dtype='object'), np.array(['bar12']), np.array(['foo', 'bar012', 'baz'])])\ndef test_acceptance_array_ok_re(val, validator_aok_re):\n    coerce_val = validator_aok_re.validate_coerce(val)\n    if isinstance(val, (np.ndarray, pd.Series)):\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif isinstance(val, (list, tuple)):\n        assert (validator_aok_re.present(coerce_val) == tuple(val))\n    else:\n        assert (validator_aok_re.present(coerce_val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['foo', 'bar12', 'bar21', [], ['bar12'], ('foo', 'bar012', 'baz'), np.array([], dtype='object'), np.array(['bar12']), np.array(['foo', 'bar012', 'baz'])])\ndef test_acceptance_array_ok_re(val, validator_aok_re):\n    coerce_val = validator_aok_re.validate_coerce(val)\n    if isinstance(val, (np.ndarray, pd.Series)):\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif isinstance(val, (list, tuple)):\n        assert (validator_aok_re.present(coerce_val) == tuple(val))\n    else:\n        assert (validator_aok_re.present(coerce_val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_405", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_fig_deepcopy.py", "testname": "test_fig_deepcopy.py", "classname": null, "funcname": "test_deepcopy_dataframe", "imports": ["import copy", "import pytest", "import plotly.express as px"], "code": "@pytest.mark.parametrize('return_type', ['pandas', 'polars', 'pyarrow'])\n@pytest.mark.filterwarnings('ignore:\\\\*scattermapbox\\\\* is deprecated! Use \\\\*scattermap\\\\* instead')\ndef test_deepcopy_dataframe(return_type):\n    gapminder = px.data.gapminder(return_type=return_type)\n    fig = px.line(gapminder, x='year', y='gdpPercap', color='country')\n    fig_copied = copy.deepcopy(fig)\n    assert (fig_copied.to_dict() == fig.to_dict())", "masked_code": "@pytest.mark.parametrize('return_type', ['pandas', 'polars', 'pyarrow'])\n@pytest.mark.filterwarnings('ignore:\\\\*scattermapbox\\\\* is deprecated! Use \\\\*scattermap\\\\* instead')\ndef test_deepcopy_dataframe(return_type):\n    gapminder = px.data.gapminder(return_type=return_type)\n    fig = px.line(gapminder, x='year', y='gdpPercap', color='country')\n    fig_copied = copy.deepcopy(fig)\n    assert (fig_copied.to_dict() == '???')", "ground_truth": "fig.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_406", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_fig_deepcopy.py", "testname": "test_fig_deepcopy.py", "classname": null, "funcname": "test_deepcopy_array", "imports": ["import copy", "import pytest", "import plotly.express as px"], "code": "@pytest.mark.filterwarnings('ignore:\\\\*scattermapbox\\\\* is deprecated! Use \\\\*scattermap\\\\* instead')\ndef test_deepcopy_array():\n    gapminder = px.data.gapminder()\n    x = gapminder['year'].to_numpy()\n    y = gapminder['gdpPercap'].to_numpy()\n    color = gapminder['country'].to_numpy()\n    fig = px.line(x=x, y=y, color=color)\n    fig_copied = copy.deepcopy(fig)\n    assert (fig_copied.to_dict() == fig.to_dict())", "masked_code": "@pytest.mark.filterwarnings('ignore:\\\\*scattermapbox\\\\* is deprecated! Use \\\\*scattermap\\\\* instead')\ndef test_deepcopy_array():\n    gapminder = px.data.gapminder()\n    x = gapminder['year'].to_numpy()\n    y = gapminder['gdpPercap'].to_numpy()\n    color = gapminder['country'].to_numpy()\n    fig = px.line(x=x, y=y, color=color)\n    fig_copied = copy.deepcopy(fig)\n    assert (fig_copied.to_dict() == '???')", "ground_truth": "fig.to_dict()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_407", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_flaglist_validator.py", "testname": "test_flaglist_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import itertools", "import pytest", "from _plotly_utils.basevalidators import FlaglistValidator", "import numpy as np"], "code": "def test_acceptance(flaglist, validator):\n    assert (validator.validate_coerce(flaglist) == flaglist)", "masked_code": "def test_acceptance(flaglist, validator):\n    assert (validator.validate_coerce(flaglist) == '???')", "ground_truth": "flaglist", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_408", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_flaglist_validator.py", "testname": "test_flaglist_validator.py", "classname": null, "funcname": "test_coercion_1", "imports": ["import itertools", "import pytest", "from _plotly_utils.basevalidators import FlaglistValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('in_val,coerce_val', [('  lines ', 'lines'), (' lines + markers ', 'lines+markers'), ('lines ,markers', 'lines+markers')])\ndef test_coercion_1(in_val, coerce_val, validator):\n    assert (validator.validate_coerce(in_val) == coerce_val)", "masked_code": "@pytest.mark.parametrize('in_val,coerce_val', [('  lines ', 'lines'), (' lines + markers ', 'lines+markers'), ('lines ,markers', 'lines+markers')])\ndef test_coercion_1(in_val, coerce_val, validator):\n    assert (validator.validate_coerce(in_val) == '???')", "ground_truth": "coerce_val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_409", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_flaglist_validator.py", "testname": "test_flaglist_validator.py", "classname": null, "funcname": "test_acceptance_extra", "imports": ["import itertools", "import pytest", "from _plotly_utils.basevalidators import FlaglistValidator", "import numpy as np"], "code": "def test_acceptance_extra(extra, validator_extra):\n    assert (validator_extra.validate_coerce(extra) == extra)", "masked_code": "def test_acceptance_extra(extra, validator_extra):\n    assert (validator_extra.validate_coerce(extra) == '???')", "ground_truth": "extra", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_410", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_flaglist_validator.py", "testname": "test_flaglist_validator.py", "classname": null, "funcname": "test_coercion_2", "imports": ["import itertools", "import pytest", "from _plotly_utils.basevalidators import FlaglistValidator", "import numpy as np"], "code": "@pytest.mark.parametrize('in_val,coerce_val', [('  none ', 'none'), ('all  ', 'all')])\ndef test_coercion_2(in_val, coerce_val, validator_extra):\n    assert (validator_extra.validate_coerce(in_val) == coerce_val)", "masked_code": "@pytest.mark.parametrize('in_val,coerce_val', [('  none ', 'none'), ('all  ', 'all')])\ndef test_coercion_2(in_val, coerce_val, validator_extra):\n    assert (validator_extra.validate_coerce(in_val) == '???')", "ground_truth": "coerce_val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_411", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_flaglist_validator.py", "testname": "test_flaglist_validator.py", "classname": null, "funcname": "test_acceptance_aok_scalar_flaglist", "imports": ["import itertools", "import pytest", "from _plotly_utils.basevalidators import FlaglistValidator", "import numpy as np"], "code": "def test_acceptance_aok_scalar_flaglist(flaglist, validator_extra_aok):\n    assert (validator_extra_aok.validate_coerce(flaglist) == flaglist)", "masked_code": "def test_acceptance_aok_scalar_flaglist(flaglist, validator_extra_aok):\n    assert (validator_extra_aok.validate_coerce(flaglist) == '???')", "ground_truth": "flaglist", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_412", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_flaglist_validator.py", "testname": "test_flaglist_validator.py", "classname": null, "funcname": "test_acceptance_aok_scalar_extra", "imports": ["import itertools", "import pytest", "from _plotly_utils.basevalidators import FlaglistValidator", "import numpy as np"], "code": "def test_acceptance_aok_scalar_extra(extra, validator_extra_aok):\n    assert (validator_extra_aok.validate_coerce(extra) == extra)", "masked_code": "def test_acceptance_aok_scalar_extra(extra, validator_extra_aok):\n    assert (validator_extra_aok.validate_coerce(extra) == '???')", "ground_truth": "extra", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_413", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_imageuri_validator.py", "testname": "test_imageuri_validator.py", "classname": null, "funcname": "test_validator_acceptance", "imports": ["import base64", "import os", "import pytest", "from _plotly_utils.basevalidators import ImageUriValidator", "from PIL import Image"], "code": "@pytest.mark.parametrize('val', ['http://somewhere.com/images/image12.png', 'data:image/png;base64,iVBORw0KGgoAAAANSU'])\ndef test_validator_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['http://somewhere.com/images/image12.png', 'data:image/png;base64,iVBORw0KGgoAAAANSU'])\ndef test_validator_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_414", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_infoarray_validator.py", "testname": "test_infoarray_validator.py", "classname": null, "funcname": "test_validator_acceptance_any2", "imports": ["import pytest", "from _plotly_utils.basevalidators import InfoArrayValidator, type_str", "import numpy as np"], "code": "@pytest.mark.parametrize('val', [[1, 'A'], ('hello', 'world!'), [1, set()], [(- 1), 1]])\ndef test_validator_acceptance_any2(val, validator_any2):\n    coerce_val = validator_any2.validate_coerce(val)\n    assert (coerce_val == list(val))\n    assert (validator_any2.present(coerce_val) == tuple(val))", "masked_code": "@pytest.mark.parametrize('val', [[1, 'A'], ('hello', 'world!'), [1, set()], [(- 1), 1]])\ndef test_validator_acceptance_any2(val, validator_any2):\n    coerce_val = validator_any2.validate_coerce(val)\n    assert (coerce_val == list(val))\n    assert (validator_any2.present(coerce_val) == '???')", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_415", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_infoarray_validator.py", "testname": "test_infoarray_validator.py", "classname": null, "funcname": "test_validator_acceptance_number3", "imports": ["import pytest", "from _plotly_utils.basevalidators import InfoArrayValidator, type_str", "import numpy as np"], "code": "@pytest.mark.parametrize('val', [[1, 0, 0.5], (0.1, 0.4, 0.99), [1, 1, 0]])\ndef test_validator_acceptance_number3(val, validator_number3):\n    coerce_val = validator_number3.validate_coerce(val)\n    assert (coerce_val == list(val))\n    assert (validator_number3.present(coerce_val) == tuple(val))", "masked_code": "@pytest.mark.parametrize('val', [[1, 0, 0.5], (0.1, 0.4, 0.99), [1, 1, 0]])\ndef test_validator_acceptance_number3(val, validator_number3):\n    coerce_val = validator_number3.validate_coerce(val)\n    assert (coerce_val == list(val))\n    assert (validator_number3.present(coerce_val) == '???')", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_416", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_infoarray_validator.py", "testname": "test_infoarray_validator.py", "classname": null, "funcname": "test_validator_acceptance_number3_free", "imports": ["import pytest", "from _plotly_utils.basevalidators import InfoArrayValidator, type_str", "import numpy as np"], "code": "@pytest.mark.parametrize('val', [[1, 0, 0.5], (0.1, 0.99), np.array([0.1, 0.99]), [0], []])\ndef test_validator_acceptance_number3_free(val, validator_number3_free):\n    coerce_val = validator_number3_free.validate_coerce(val)\n    assert (coerce_val == list(val))\n    assert (validator_number3_free.present(coerce_val) == tuple(val))", "masked_code": "@pytest.mark.parametrize('val', [[1, 0, 0.5], (0.1, 0.99), np.array([0.1, 0.99]), [0], []])\ndef test_validator_acceptance_number3_free(val, validator_number3_free):\n    coerce_val = validator_number3_free.validate_coerce(val)\n    assert (coerce_val == list(val))\n    assert (validator_number3_free.present(coerce_val) == '???')", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_417", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_infoarray_validator.py", "testname": "test_infoarray_validator.py", "classname": null, "funcname": "test_validator_acceptance_any3_free", "imports": ["import pytest", "from _plotly_utils.basevalidators import InfoArrayValidator, type_str", "import numpy as np"], "code": "@pytest.mark.parametrize('val', [[1, 0, 'Hello'], (False, 0.99), np.array([0.1, 0.99]), [0], [], [['a', 'list']], [['a', 'list'], 0], [0, ['a', 'list'], 1]])\ndef test_validator_acceptance_any3_free(val, validator_any3_free):\n    coerce_val = validator_any3_free.validate_coerce(val)\n    assert (coerce_val == list(val))\n    expected = tuple(((tuple(el) if isinstance(el, list) else el) for el in val))\n    assert (validator_any3_free.present(coerce_val) == expected)", "masked_code": "@pytest.mark.parametrize('val', [[1, 0, 'Hello'], (False, 0.99), np.array([0.1, 0.99]), [0], [], [['a', 'list']], [['a', 'list'], 0], [0, ['a', 'list'], 1]])\ndef test_validator_acceptance_any3_free(val, validator_any3_free):\n    coerce_val = validator_any3_free.validate_coerce(val)\n    assert (coerce_val == list(val))\n    expected = tuple(((tuple(el) if isinstance(el, list) else el) for el in val))\n    assert (validator_any3_free.present(coerce_val) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_418", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_infoarray_validator.py", "testname": "test_infoarray_validator.py", "classname": null, "funcname": "test_validator_acceptance_number2_2d", "imports": ["import pytest", "from _plotly_utils.basevalidators import InfoArrayValidator, type_str", "import numpy as np"], "code": "@pytest.mark.parametrize('val', [[], [[1, 0]], [(0.1, 0.99)], np.array([[0.1, 0.99]]), [np.array([0.1, 0.4]), [0.2, 0], (0.9, 0.5)]])\ndef test_validator_acceptance_number2_2d(val, validator_number2_2d):\n    coerce_val = validator_number2_2d.validate_coerce(val)\n    assert (coerce_val == list((list(row) for row in val)))\n    expected = tuple([tuple(e) for e in val])\n    assert (validator_number2_2d.present(coerce_val) == expected)", "masked_code": "@pytest.mark.parametrize('val', [[], [[1, 0]], [(0.1, 0.99)], np.array([[0.1, 0.99]]), [np.array([0.1, 0.4]), [0.2, 0], (0.9, 0.5)]])\ndef test_validator_acceptance_number2_2d(val, validator_number2_2d):\n    coerce_val = validator_number2_2d.validate_coerce(val)\n    assert (coerce_val == list((list(row) for row in val)))\n    expected = tuple([tuple(e) for e in val])\n    assert (validator_number2_2d.present(coerce_val) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_419", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_infoarray_validator.py", "testname": "test_infoarray_validator.py", "classname": null, "funcname": "test_validator_acceptance_number2_12d_1d", "imports": ["import pytest", "from _plotly_utils.basevalidators import InfoArrayValidator, type_str", "import numpy as np"], "code": "@pytest.mark.parametrize('val', [[], [1, 0], (0.1, 0.99), np.array([0.1, 0.99])])\ndef test_validator_acceptance_number2_12d_1d(val, validator_number2_12d):\n    coerce_val = validator_number2_12d.validate_coerce(val)\n    assert (coerce_val == list(val))\n    expected = tuple(val)\n    assert (validator_number2_12d.present(coerce_val) == expected)", "masked_code": "@pytest.mark.parametrize('val', [[], [1, 0], (0.1, 0.99), np.array([0.1, 0.99])])\ndef test_validator_acceptance_number2_12d_1d(val, validator_number2_12d):\n    coerce_val = validator_number2_12d.validate_coerce(val)\n    assert (coerce_val == list(val))\n    expected = tuple(val)\n    assert (validator_number2_12d.present(coerce_val) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_420", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_infoarray_validator.py", "testname": "test_infoarray_validator.py", "classname": null, "funcname": "test_validator_acceptance_number2_12d_2d", "imports": ["import pytest", "from _plotly_utils.basevalidators import InfoArrayValidator, type_str", "import numpy as np"], "code": "@pytest.mark.parametrize('val', [[], [[1, 0]], [(0.1, 0.99)], np.array([[0.1, 0.99]]), [np.array([0.1, 0.4]), [0.2, 0], (0.9, 0.5)]])\ndef test_validator_acceptance_number2_12d_2d(val, validator_number2_12d):\n    coerce_val = validator_number2_12d.validate_coerce(val)\n    assert (coerce_val == list((list(row) for row in val)))\n    expected = tuple([tuple(e) for e in val])\n    assert (validator_number2_12d.present(coerce_val) == expected)", "masked_code": "@pytest.mark.parametrize('val', [[], [[1, 0]], [(0.1, 0.99)], np.array([[0.1, 0.99]]), [np.array([0.1, 0.4]), [0.2, 0], (0.9, 0.5)]])\ndef test_validator_acceptance_number2_12d_2d(val, validator_number2_12d):\n    coerce_val = validator_number2_12d.validate_coerce(val)\n    assert (coerce_val == list((list(row) for row in val)))\n    expected = tuple([tuple(e) for e in val])\n    assert (validator_number2_12d.present(coerce_val) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_421", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_infoarray_validator.py", "testname": "test_infoarray_validator.py", "classname": null, "funcname": "test_validator_acceptance_number_free_1d", "imports": ["import pytest", "from _plotly_utils.basevalidators import InfoArrayValidator, type_str", "import numpy as np"], "code": "@pytest.mark.parametrize('val', [[], [1, 0], (0.1, 0.99, 0.4), np.array([0.1, 0.4, 0.5, 0.1, 0.6, 0.99])])\ndef test_validator_acceptance_number_free_1d(val, validator_number_free_1d):\n    coerce_val = validator_number_free_1d.validate_coerce(val)\n    assert (coerce_val == list(val))\n    expected = tuple(val)\n    assert (validator_number_free_1d.present(coerce_val) == expected)", "masked_code": "@pytest.mark.parametrize('val', [[], [1, 0], (0.1, 0.99, 0.4), np.array([0.1, 0.4, 0.5, 0.1, 0.6, 0.99])])\ndef test_validator_acceptance_number_free_1d(val, validator_number_free_1d):\n    coerce_val = validator_number_free_1d.validate_coerce(val)\n    assert (coerce_val == list(val))\n    expected = tuple(val)\n    assert (validator_number_free_1d.present(coerce_val) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_422", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_infoarray_validator.py", "testname": "test_infoarray_validator.py", "classname": null, "funcname": "test_validator_acceptance_number_free_2d", "imports": ["import pytest", "from _plotly_utils.basevalidators import InfoArrayValidator, type_str", "import numpy as np"], "code": "@pytest.mark.parametrize('val', [[], [[1, 0]], [(0.1, 0.99)], np.array([[0.1, 0.99]]), [np.array([0.1, 0.4]), [0.2, 0], (0.9, 0.5)]])\ndef test_validator_acceptance_number_free_2d(val, validator_number_free_2d):\n    coerce_val = validator_number_free_2d.validate_coerce(val)\n    assert (coerce_val == list((list(row) for row in val)))\n    expected = tuple([tuple(e) for e in val])\n    assert (validator_number_free_2d.present(coerce_val) == expected)", "masked_code": "@pytest.mark.parametrize('val', [[], [[1, 0]], [(0.1, 0.99)], np.array([[0.1, 0.99]]), [np.array([0.1, 0.4]), [0.2, 0], (0.9, 0.5)]])\ndef test_validator_acceptance_number_free_2d(val, validator_number_free_2d):\n    coerce_val = validator_number_free_2d.validate_coerce(val)\n    assert (coerce_val == list((list(row) for row in val)))\n    expected = tuple([tuple(e) for e in val])\n    assert (validator_number_free_2d.present(coerce_val) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_423", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_integer_validator.py", "testname": "test_integer_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import IntegerValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [1, (- 19), 0, (- 1234)])\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', [1, (- 19), 0, (- 1234)])\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_424", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_integer_validator.py", "testname": "test_integer_validator.py", "classname": null, "funcname": "test_acceptance_min_max", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import IntegerValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [0, 1, (- 1), 2])\ndef test_acceptance_min_max(val, validator_min_max):\n    assert (validator_min_max.validate_coerce(val) == approx(val))", "masked_code": "@pytest.mark.parametrize('val', [0, 1, (- 1), 2])\ndef test_acceptance_min_max(val, validator_min_max):\n    assert (validator_min_max.validate_coerce(val) == '???')", "ground_truth": "approx(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_425", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_integer_validator.py", "testname": "test_integer_validator.py", "classname": null, "funcname": "test_acceptance_extras", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import IntegerValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', ['normal', 'bold', 10, (- 2)])\ndef test_acceptance_extras(val, validator_extras):\n    assert (validator_extras.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['normal', 'bold', 10, (- 2)])\ndef test_acceptance_extras(val, validator_extras):\n    assert (validator_extras.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_426", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_integer_validator.py", "testname": "test_integer_validator.py", "classname": null, "funcname": "test_acceptance_extras_array", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import IntegerValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [[10, 'normal', 'bold'], ['normal'], [10, (- 2)], [5]])\ndef test_acceptance_extras_array(val, validator_extras_aok):\n    assert (validator_extras_aok.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', [[10, 'normal', 'bold'], ['normal'], [10, (- 2)], [5]])\ndef test_acceptance_extras_array(val, validator_extras_aok):\n    assert (validator_extras_aok.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_427", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_integer_validator.py", "testname": "test_integer_validator.py", "classname": null, "funcname": "test_acceptance_min", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import IntegerValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [(- 1), 0, 1, 23, 99999])\ndef test_acceptance_min(val, validator_min):\n    assert (validator_min.validate_coerce(val) == approx(val))", "masked_code": "@pytest.mark.parametrize('val', [(- 1), 0, 1, 23, 99999])\ndef test_acceptance_min(val, validator_min):\n    assert (validator_min.validate_coerce(val) == '???')", "ground_truth": "approx(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_428", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_integer_validator.py", "testname": "test_integer_validator.py", "classname": null, "funcname": "test_acceptance_max", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import IntegerValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [1, 2, (- 10), (- 999999), np.iinfo(np.int32).min])\ndef test_acceptance_max(val, validator_max):\n    assert (validator_max.validate_coerce(val) == approx(val))", "masked_code": "@pytest.mark.parametrize('val', [1, 2, (- 10), (- 999999), np.iinfo(np.int32).min])\ndef test_acceptance_max(val, validator_max):\n    assert (validator_max.validate_coerce(val) == '???')", "ground_truth": "approx(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_429", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_integer_validator.py", "testname": "test_integer_validator.py", "classname": null, "funcname": "test_acceptance_aok_scalars", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import IntegerValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [(- 2), 1, 0, 1, 10])\ndef test_acceptance_aok_scalars(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', [(- 2), 1, 0, 1, 10])\ndef test_acceptance_aok_scalars(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_430", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_integer_validator.py", "testname": "test_integer_validator.py", "classname": null, "funcname": "test_coercion_aok_list", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import IntegerValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val,expected', [([1, 0], (1, 0)), ((1, (- 1)), (1, (- 1))), (np.array([(- 1), 0, 5.0], dtype='int16'), [(- 1), 0, 5]), (np.array([1, 0], dtype=np.int64), [1, 0]), (pd.Series([1, 0], dtype=np.int64), [1, 0]), (pd.Index([1, 0], dtype=np.int64), [1, 0])])\ndef test_coercion_aok_list(val, expected, validator_aok):\n    v = validator_aok.validate_coerce(val)\n    if isinstance(val, (np.ndarray, pd.Series, pd.Index)):\n        assert (v.dtype == val.dtype)\n        assert np.array_equal(validator_aok.present(v), np.array(expected, dtype=np.int32))\n    else:\n        assert isinstance(v, list)\n        assert (validator_aok.present(v) == expected)", "masked_code": "@pytest.mark.parametrize('val,expected', [([1, 0], (1, 0)), ((1, (- 1)), (1, (- 1))), (np.array([(- 1), 0, 5.0], dtype='int16'), [(- 1), 0, 5]), (np.array([1, 0], dtype=np.int64), [1, 0]), (pd.Series([1, 0], dtype=np.int64), [1, 0]), (pd.Index([1, 0], dtype=np.int64), [1, 0])])\ndef test_coercion_aok_list(val, expected, validator_aok):\n    v = validator_aok.validate_coerce(val)\n    if isinstance(val, (np.ndarray, pd.Series, pd.Index)):\n        assert (v.dtype == '???')\n        assert np.array_equal(validator_aok.present(v), np.array(expected, dtype=np.int32))\n    else:\n        assert isinstance(v, list)\n        assert (validator_aok.present(v) == expected)", "ground_truth": "val.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_431", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_integer_validator.py", "testname": "test_integer_validator.py", "classname": null, "funcname": "test_coercion_aok_list", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import IntegerValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val,expected', [([1, 0], (1, 0)), ((1, (- 1)), (1, (- 1))), (np.array([(- 1), 0, 5.0], dtype='int16'), [(- 1), 0, 5]), (np.array([1, 0], dtype=np.int64), [1, 0]), (pd.Series([1, 0], dtype=np.int64), [1, 0]), (pd.Index([1, 0], dtype=np.int64), [1, 0])])\ndef test_coercion_aok_list(val, expected, validator_aok):\n    v = validator_aok.validate_coerce(val)\n    if isinstance(val, (np.ndarray, pd.Series, pd.Index)):\n        assert (v.dtype == val.dtype)\n        assert np.array_equal(validator_aok.present(v), np.array(expected, dtype=np.int32))\n    else:\n        assert isinstance(v, list)\n        assert (validator_aok.present(v) == expected)", "masked_code": "@pytest.mark.parametrize('val,expected', [([1, 0], (1, 0)), ((1, (- 1)), (1, (- 1))), (np.array([(- 1), 0, 5.0], dtype='int16'), [(- 1), 0, 5]), (np.array([1, 0], dtype=np.int64), [1, 0]), (pd.Series([1, 0], dtype=np.int64), [1, 0]), (pd.Index([1, 0], dtype=np.int64), [1, 0])])\ndef test_coercion_aok_list(val, expected, validator_aok):\n    v = validator_aok.validate_coerce(val)\n    if isinstance(val, (np.ndarray, pd.Series, pd.Index)):\n        assert (v.dtype == val.dtype)\n        assert np.array_equal(validator_aok.present(v), np.array(expected, dtype=np.int32))\n    else:\n        assert isinstance(v, list)\n        assert (validator_aok.present(v) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_432", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_number_validator.py", "testname": "test_number_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import NumberValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [1.0, 0.0, 1, (- 1234.5678), 54321, np.pi, np_nan(), np_inf(), (- np_inf())])\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == approx(val, nan_ok=True))", "masked_code": "@pytest.mark.parametrize('val', [1.0, 0.0, 1, (- 1234.5678), 54321, np.pi, np_nan(), np_inf(), (- np_inf())])\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "approx(val, nan_ok=True)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_433", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_number_validator.py", "testname": "test_number_validator.py", "classname": null, "funcname": "test_acceptance_min_max", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import NumberValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [0, 0.0, (- 0.5), 1, 1.0, 2, 2.0, (np.pi / 2.0)])\ndef test_acceptance_min_max(val, validator_min_max):\n    assert (validator_min_max.validate_coerce(val) == approx(val))", "masked_code": "@pytest.mark.parametrize('val', [0, 0.0, (- 0.5), 1, 1.0, 2, 2.0, (np.pi / 2.0)])\ndef test_acceptance_min_max(val, validator_min_max):\n    assert (validator_min_max.validate_coerce(val) == '???')", "ground_truth": "approx(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_434", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_number_validator.py", "testname": "test_number_validator.py", "classname": null, "funcname": "test_acceptance_min", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import NumberValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [0, 0.0, (- 0.5), 99999, np_inf()])\ndef test_acceptance_min(val, validator_min):\n    assert (validator_min.validate_coerce(val) == approx(val))", "masked_code": "@pytest.mark.parametrize('val', [0, 0.0, (- 0.5), 99999, np_inf()])\ndef test_acceptance_min(val, validator_min):\n    assert (validator_min.validate_coerce(val) == '???')", "ground_truth": "approx(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_435", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_number_validator.py", "testname": "test_number_validator.py", "classname": null, "funcname": "test_acceptance_max", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import NumberValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [0, 0.0, (- np_inf()), (- 123456), (np.pi / 2)])\ndef test_acceptance_max(val, validator_max):\n    assert (validator_max.validate_coerce(val) == approx(val))", "masked_code": "@pytest.mark.parametrize('val', [0, 0.0, (- np_inf()), (- 123456), (np.pi / 2)])\ndef test_acceptance_max(val, validator_max):\n    assert (validator_max.validate_coerce(val) == '???')", "ground_truth": "approx(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_436", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_number_validator.py", "testname": "test_number_validator.py", "classname": null, "funcname": "test_acceptance_aok_scalars", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import NumberValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', [1.0, 0.0, 1, 0.4])\ndef test_acceptance_aok_scalars(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', [1.0, 0.0, 1, 0.4])\ndef test_acceptance_aok_scalars(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_437", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_number_validator.py", "testname": "test_number_validator.py", "classname": null, "funcname": "test_coercion_aok_list", "imports": ["import pytest", "from pytest import approx", "from _plotly_utils.basevalidators import NumberValidator", "import numpy as np", "import pandas as pd", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val,expected', [([1.0, 0], (1.0, 0)), (np.array([1, (- 1)]), np.array([1, (- 1)])), (pd.Series([1, (- 1)]), np.array([1, (- 1)])), (pd.Index([1, (- 1)]), np.array([1, (- 1)])), (((- 0.1234), 0, (- 1)), ((- 0.1234), 0.0, (- 1.0)))])\ndef test_coercion_aok_list(val, expected, validator_aok):\n    v = validator_aok.validate_coerce(val)\n    if isinstance(val, (np.ndarray, pd.Series, pd.Index)):\n        assert np.array_equal(v, expected)\n    else:\n        assert isinstance(v, list)\n        assert (validator_aok.present(v) == tuple(val))", "masked_code": "@pytest.mark.parametrize('val,expected', [([1.0, 0], (1.0, 0)), (np.array([1, (- 1)]), np.array([1, (- 1)])), (pd.Series([1, (- 1)]), np.array([1, (- 1)])), (pd.Index([1, (- 1)]), np.array([1, (- 1)])), (((- 0.1234), 0, (- 1)), ((- 0.1234), 0.0, (- 1.0)))])\ndef test_coercion_aok_list(val, expected, validator_aok):\n    v = validator_aok.validate_coerce(val)\n    if isinstance(val, (np.ndarray, pd.Series, pd.Index)):\n        assert np.array_equal(v, expected)\n    else:\n        assert isinstance(v, list)\n        assert (validator_aok.present(v) == '???')", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_438", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "classname": null, "funcname": "test_numeric_validator_numeric_pandas", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_numeric_validator_numeric_pandas(number_validator, numeric_pandas):\n    res = number_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == numeric_pandas.dtype)\n    np.testing.assert_array_equal(res, numeric_pandas)", "masked_code": "def test_numeric_validator_numeric_pandas(number_validator, numeric_pandas):\n    res = number_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_pandas)", "ground_truth": "numeric_pandas.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_439", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "classname": null, "funcname": "test_integer_validator_numeric_pandas", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_integer_validator_numeric_pandas(integer_validator, numeric_pandas):\n    res = integer_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    if (numeric_pandas.dtype.kind in ('u', 'i')):\n        assert (res.dtype == numeric_pandas.dtype)\n    else:\n        assert (res.dtype == 'int32')\n    np.testing.assert_array_equal(res, numeric_pandas)", "masked_code": "def test_integer_validator_numeric_pandas(integer_validator, numeric_pandas):\n    res = integer_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    if (numeric_pandas.dtype.kind in ('u', 'i')):\n        assert (res.dtype == '???')\n    else:\n        assert (res.dtype == 'int32')\n    np.testing.assert_array_equal(res, numeric_pandas)", "ground_truth": "numeric_pandas.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_440", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "classname": null, "funcname": "test_integer_validator_numeric_pandas", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_integer_validator_numeric_pandas(integer_validator, numeric_pandas):\n    res = integer_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    if (numeric_pandas.dtype.kind in ('u', 'i')):\n        assert (res.dtype == numeric_pandas.dtype)\n    else:\n        assert (res.dtype == 'int32')\n    np.testing.assert_array_equal(res, numeric_pandas)", "masked_code": "def test_integer_validator_numeric_pandas(integer_validator, numeric_pandas):\n    res = integer_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    if (numeric_pandas.dtype.kind in ('u', 'i')):\n        assert (res.dtype == numeric_pandas.dtype)\n    else:\n        assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_pandas)", "ground_truth": "'int32'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_441", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "classname": null, "funcname": "test_data_array_validator", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_data_array_validator(data_array_validator, numeric_pandas):\n    res = data_array_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == numeric_pandas.dtype)\n    np.testing.assert_array_equal(res, numeric_pandas)", "masked_code": "def test_data_array_validator(data_array_validator, numeric_pandas):\n    res = data_array_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_pandas)", "ground_truth": "numeric_pandas.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_442", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "classname": null, "funcname": "test_color_validator_numeric", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_color_validator_numeric(color_validator, numeric_pandas):\n    res = color_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == numeric_pandas.dtype)\n    np.testing.assert_array_equal(res, numeric_pandas)", "masked_code": "def test_color_validator_numeric(color_validator, numeric_pandas):\n    res = color_validator.validate_coerce(numeric_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_pandas)", "ground_truth": "numeric_pandas.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_443", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "classname": null, "funcname": "test_color_validator_object", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_color_validator_object(color_validator, color_object_pandas):\n    res = color_validator.validate_coerce(color_object_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == 'object')\n    np.testing.assert_array_equal(res, color_object_pandas)", "masked_code": "def test_color_validator_object(color_validator, color_object_pandas):\n    res = color_validator.validate_coerce(color_object_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, color_object_pandas)", "ground_truth": "'object'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_444", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "classname": null, "funcname": "test_color_validator_categorical", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_color_validator_categorical(color_validator, color_categorical_pandas):\n    res = color_validator.validate_coerce(color_categorical_pandas)\n    assert (color_categorical_pandas.dtype == 'category')\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == 'object')\n    np.testing.assert_array_equal(res, np.array(color_categorical_pandas))", "masked_code": "def test_color_validator_categorical(color_validator, color_categorical_pandas):\n    res = color_validator.validate_coerce(color_categorical_pandas)\n    assert (color_categorical_pandas.dtype == '???')\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == 'object')\n    np.testing.assert_array_equal(res, np.array(color_categorical_pandas))", "ground_truth": "'category'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_445", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "classname": null, "funcname": "test_color_validator_categorical", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_color_validator_categorical(color_validator, color_categorical_pandas):\n    res = color_validator.validate_coerce(color_categorical_pandas)\n    assert (color_categorical_pandas.dtype == 'category')\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == 'object')\n    np.testing.assert_array_equal(res, np.array(color_categorical_pandas))", "masked_code": "def test_color_validator_categorical(color_validator, color_categorical_pandas):\n    res = color_validator.validate_coerce(color_categorical_pandas)\n    assert (color_categorical_pandas.dtype == 'category')\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, np.array(color_categorical_pandas))", "ground_truth": "'object'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_446", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "classname": null, "funcname": "test_data_array_validator_dates_series", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_data_array_validator_dates_series(data_array_validator, datetime_pandas, dates_array):\n    res = data_array_validator.validate_coerce(datetime_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '<M8[ns]')\n    np.testing.assert_array_equal(res, dates_array)", "masked_code": "def test_data_array_validator_dates_series(data_array_validator, datetime_pandas, dates_array):\n    res = data_array_validator.validate_coerce(datetime_pandas)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, dates_array)", "ground_truth": "'<M8[ns]'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_447", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_pandas_series_input.py", "testname": "test_pandas_series_input.py", "classname": null, "funcname": "test_data_array_validator_dates_dataframe", "imports": ["import pytest", "import numpy as np", "import pandas as pd", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_data_array_validator_dates_dataframe(data_array_validator, datetime_pandas, dates_array):\n    df = pd.DataFrame({'d': datetime_pandas})\n    res = data_array_validator.validate_coerce(df)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '<M8[ns]')\n    np.testing.assert_array_equal(res, dates_array.reshape(len(dates_array), 1))", "masked_code": "def test_data_array_validator_dates_dataframe(data_array_validator, datetime_pandas, dates_array):\n    df = pd.DataFrame({'d': datetime_pandas})\n    res = data_array_validator.validate_coerce(df)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, dates_array.reshape(len(dates_array), 1))", "ground_truth": "'<M8[ns]'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_448", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', ['bar', 234, np_nan(), 'HELLO!!!', 'world!@#$%^&*()', '', 'μ'])\ndef test_acceptance(val, validator):\n    expected = (str(val) if (not isinstance(val, str)) else val)\n    assert (validator.validate_coerce(val) == expected)", "masked_code": "@pytest.mark.parametrize('val', ['bar', 234, np_nan(), 'HELLO!!!', 'world!@#$%^&*()', '', 'μ'])\ndef test_acceptance(val, validator):\n    expected = (str(val) if (not isinstance(val, str)) else val)\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_449", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "classname": null, "funcname": "test_acceptance_values", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', ['foo', 'BAR', ''])\ndef test_acceptance_values(val, validator_values):\n    assert (validator_values.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['foo', 'BAR', ''])\ndef test_acceptance_values(val, validator_values):\n    assert (validator_values.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_450", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "classname": null, "funcname": "test_acceptance_no_blanks", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', ['bar', 'HELLO!!!', 'world!@#$%^&*()', 'μ'])\ndef test_acceptance_no_blanks(val, validator_no_blanks):\n    assert (validator_no_blanks.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['bar', 'HELLO!!!', 'world!@#$%^&*()', 'μ'])\ndef test_acceptance_no_blanks(val, validator_no_blanks):\n    assert (validator_no_blanks.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_451", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "classname": null, "funcname": "test_acceptance_strict", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', ['bar', 'HELLO!!!', 'world!@#$%^&*()', '', 'μ'])\ndef test_acceptance_strict(val, validator_strict):\n    assert (validator_strict.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['bar', 'HELLO!!!', 'world!@#$%^&*()', '', 'μ'])\ndef test_acceptance_strict(val, validator_strict):\n    assert (validator_strict.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_452", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "classname": null, "funcname": "test_acceptance_aok_scalars", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', ['foo', 'BAR', '', 'baz', 'μ'])\ndef test_acceptance_aok_scalars(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', ['foo', 'BAR', '', 'baz', 'μ'])\ndef test_acceptance_aok_scalars(val, validator_aok):\n    assert (validator_aok.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_453", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "classname": null, "funcname": "test_acceptance_aok_list", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', ['foo', ['foo'], np.array(['BAR', '', 'μ'], dtype='object'), ['baz', 'baz', 'baz'], ['foo', None, 'bar', 'μ']])\ndef test_acceptance_aok_list(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif isinstance(val, list):\n        assert (validator_aok.present(val) == tuple(val))\n    else:\n        assert (coerce_val == val)", "masked_code": "@pytest.mark.parametrize('val', ['foo', ['foo'], np.array(['BAR', '', 'μ'], dtype='object'), ['baz', 'baz', 'baz'], ['foo', None, 'bar', 'μ']])\ndef test_acceptance_aok_list(val, validator_aok):\n    coerce_val = validator_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert isinstance(coerce_val, np.ndarray)\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif isinstance(val, list):\n        assert (validator_aok.present(val) == '???')\n    else:\n        assert (coerce_val == val)", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_454", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_string_validator.py", "testname": "test_string_validator.py", "classname": null, "funcname": "test_acceptance_no_blanks_aok", "imports": ["import pytest", "from _plotly_utils.basevalidators import StringValidator", "import numpy as np", "from ...test_optional.test_utils.test_utils import np_nan"], "code": "@pytest.mark.parametrize('val', ['123', ['bar', 'HELLO!!!'], np.array(['bar', 'HELLO!!!'], dtype='object'), ['world!@#$%^&*()', 'μ']])\ndef test_acceptance_no_blanks_aok(val, validator_no_blanks_aok):\n    coerce_val = validator_no_blanks_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif isinstance(val, list):\n        assert (validator_no_blanks_aok.present(coerce_val) == tuple(val))\n    else:\n        assert (coerce_val == val)", "masked_code": "@pytest.mark.parametrize('val', ['123', ['bar', 'HELLO!!!'], np.array(['bar', 'HELLO!!!'], dtype='object'), ['world!@#$%^&*()', 'μ']])\ndef test_acceptance_no_blanks_aok(val, validator_no_blanks_aok):\n    coerce_val = validator_no_blanks_aok.validate_coerce(val)\n    if isinstance(val, np.ndarray):\n        assert np.array_equal(coerce_val, np.array(val, dtype=coerce_val.dtype))\n    elif isinstance(val, list):\n        assert (validator_no_blanks_aok.present(coerce_val) == '???')\n    else:\n        assert (coerce_val == val)", "ground_truth": "tuple(val)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_455", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_subplotid_validator.py", "testname": "test_subplotid_validator.py", "classname": null, "funcname": "test_acceptance", "imports": ["import pytest", "from _plotly_utils.basevalidators import SubplotidValidator", "from ...test_optional.test_utils.test_utils import np_nan, np_inf"], "code": "@pytest.mark.parametrize('val', (['geo'] + [('geo%d' % i) for i in range(2, 10)]))\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == val)", "masked_code": "@pytest.mark.parametrize('val', (['geo'] + [('geo%d' % i) for i in range(2, 10)]))\ndef test_acceptance(val, validator):\n    assert (validator.validate_coerce(val) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_456", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_xarray_input.py", "testname": "test_xarray_input.py", "classname": null, "funcname": "test_numeric_validator_numeric_xarray", "imports": ["import pytest", "import numpy as np", "import xarray", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_numeric_validator_numeric_xarray(number_validator, numeric_xarray):\n    res = number_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == numeric_xarray.dtype)\n    np.testing.assert_array_equal(res, numeric_xarray)", "masked_code": "def test_numeric_validator_numeric_xarray(number_validator, numeric_xarray):\n    res = number_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_xarray)", "ground_truth": "numeric_xarray.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_457", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_xarray_input.py", "testname": "test_xarray_input.py", "classname": null, "funcname": "test_integer_validator_numeric_xarray", "imports": ["import pytest", "import numpy as np", "import xarray", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_integer_validator_numeric_xarray(integer_validator, numeric_xarray):\n    res = integer_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    if (numeric_xarray.dtype.kind in ('u', 'i')):\n        assert (res.dtype == numeric_xarray.dtype)\n    else:\n        assert (res.dtype == 'int32')\n    np.testing.assert_array_equal(res, numeric_xarray)", "masked_code": "def test_integer_validator_numeric_xarray(integer_validator, numeric_xarray):\n    res = integer_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    if (numeric_xarray.dtype.kind in ('u', 'i')):\n        assert (res.dtype == '???')\n    else:\n        assert (res.dtype == 'int32')\n    np.testing.assert_array_equal(res, numeric_xarray)", "ground_truth": "numeric_xarray.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_458", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_xarray_input.py", "testname": "test_xarray_input.py", "classname": null, "funcname": "test_integer_validator_numeric_xarray", "imports": ["import pytest", "import numpy as np", "import xarray", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_integer_validator_numeric_xarray(integer_validator, numeric_xarray):\n    res = integer_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    if (numeric_xarray.dtype.kind in ('u', 'i')):\n        assert (res.dtype == numeric_xarray.dtype)\n    else:\n        assert (res.dtype == 'int32')\n    np.testing.assert_array_equal(res, numeric_xarray)", "masked_code": "def test_integer_validator_numeric_xarray(integer_validator, numeric_xarray):\n    res = integer_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    if (numeric_xarray.dtype.kind in ('u', 'i')):\n        assert (res.dtype == numeric_xarray.dtype)\n    else:\n        assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_xarray)", "ground_truth": "'int32'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_459", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_xarray_input.py", "testname": "test_xarray_input.py", "classname": null, "funcname": "test_data_array_validator", "imports": ["import pytest", "import numpy as np", "import xarray", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_data_array_validator(data_array_validator, numeric_xarray):\n    res = data_array_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == numeric_xarray.dtype)\n    np.testing.assert_array_equal(res, numeric_xarray)", "masked_code": "def test_data_array_validator(data_array_validator, numeric_xarray):\n    res = data_array_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_xarray)", "ground_truth": "numeric_xarray.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_460", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_xarray_input.py", "testname": "test_xarray_input.py", "classname": null, "funcname": "test_color_validator_numeric", "imports": ["import pytest", "import numpy as np", "import xarray", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_color_validator_numeric(color_validator, numeric_xarray):\n    res = color_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == numeric_xarray.dtype)\n    np.testing.assert_array_equal(res, numeric_xarray)", "masked_code": "def test_color_validator_numeric(color_validator, numeric_xarray):\n    res = color_validator.validate_coerce(numeric_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, numeric_xarray)", "ground_truth": "numeric_xarray.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "plotly_461", "reponame": "plotly", "testpath": "tests/test_plotly_utils/validators/test_xarray_input.py", "testname": "test_xarray_input.py", "classname": null, "funcname": "test_color_validator_object", "imports": ["import pytest", "import numpy as np", "import xarray", "from _plotly_utils.basevalidators import NumberValidator, IntegerValidator, DataArrayValidator, ColorValidator"], "code": "def test_color_validator_object(color_validator, color_object_xarray):\n    res = color_validator.validate_coerce(color_object_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == 'object')\n    np.testing.assert_array_equal(res, color_object_xarray)", "masked_code": "def test_color_validator_object(color_validator, color_object_xarray):\n    res = color_validator.validate_coerce(color_object_xarray)\n    assert isinstance(res, np.ndarray)\n    assert (res.dtype == '???')\n    np.testing.assert_array_equal(res, color_object_xarray)", "ground_truth": "'object'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
