{"task_id": "openmdao_0", "reponame": "openmdao", "testpath": "openmdao/core/tests/test_expl_comp.py", "testname": "test_expl_comp.py", "classname": "ExplCompTestCase", "funcname": "test_add_input_output_retval", "imports": ["from io import StringIO", "import unittest", "import itertools", "import numpy as np", "import openmdao.api as om", "from openmdao.test_suite.components.double_sellar import SubSellar", "from openmdao.test_suite.components.expl_comp_simple import TestExplCompSimple, TestExplCompSimpleDense", "from openmdao.test_suite.components.sellar import SellarDis1withDerivatives, SellarDis2withDerivatives", "from openmdao.test_suite.components.rectangle import RectangleGroup, RectangleComp, RectangleCompWithTags, RectangleJacVec", "from openmdao.utils.assert_utils import assert_near_equal", "from openmdao.utils.general_utils import printoptions, remove_whitespace", "from openmdao.utils.mpi import MPI", "from openmdao.utils.testing_utils import parameterized_name"], "code": "def test_add_input_output_retval(self):\n    expected = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class Comp(om.ExplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', Comp())\n    prob.setup()", "masked_code": "def test_add_input_output_retval(self):\n    expected = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class Comp(om.ExplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == '???'), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', Comp())\n    prob.setup()", "ground_truth": "val", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "openmdao_1", "reponame": "openmdao", "testpath": "openmdao/core/tests/test_expl_comp.py", "testname": "test_expl_comp.py", "classname": "ExplCompTestCase", "funcname": "test_add_input_output_retval", "imports": ["from io import StringIO", "import unittest", "import itertools", "import numpy as np", "import openmdao.api as om", "from openmdao.test_suite.components.double_sellar import SubSellar", "from openmdao.test_suite.components.expl_comp_simple import TestExplCompSimple, TestExplCompSimpleDense", "from openmdao.test_suite.components.sellar import SellarDis1withDerivatives, SellarDis2withDerivatives", "from openmdao.test_suite.components.rectangle import RectangleGroup, RectangleComp, RectangleCompWithTags, RectangleJacVec", "from openmdao.utils.assert_utils import assert_near_equal", "from openmdao.utils.general_utils import printoptions, remove_whitespace", "from openmdao.utils.mpi import MPI", "from openmdao.utils.testing_utils import parameterized_name"], "code": "def test_add_input_output_retval(self):\n    expected = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class Comp(om.ExplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', Comp())\n    prob.setup()", "masked_code": "def test_add_input_output_retval(self):\n    expected = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class Comp(om.ExplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == '???'), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', Comp())\n    prob.setup()", "ground_truth": "val", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "openmdao_2", "reponame": "openmdao", "testpath": "openmdao/core/tests/test_expl_comp.py", "testname": "test_expl_comp.py", "classname": "ExplCompTestCase", "funcname": "test_add_input_output_retval", "imports": ["from io import StringIO", "import unittest", "import itertools", "import numpy as np", "import openmdao.api as om", "from openmdao.test_suite.components.double_sellar import SubSellar", "from openmdao.test_suite.components.expl_comp_simple import TestExplCompSimple, TestExplCompSimpleDense", "from openmdao.test_suite.components.sellar import SellarDis1withDerivatives, SellarDis2withDerivatives", "from openmdao.test_suite.components.rectangle import RectangleGroup, RectangleComp, RectangleCompWithTags, RectangleJacVec", "from openmdao.utils.assert_utils import assert_near_equal", "from openmdao.utils.general_utils import printoptions, remove_whitespace", "from openmdao.utils.mpi import MPI", "from openmdao.utils.testing_utils import parameterized_name"], "code": "def test_add_input_output_retval(self):\n    expected = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class Comp(om.ExplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', Comp())\n    prob.setup()", "masked_code": "def test_add_input_output_retval(self):\n    expected = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class Comp(om.ExplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == '???'), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', Comp())\n    prob.setup()", "ground_truth": "val", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "openmdao_3", "reponame": "openmdao", "testpath": "openmdao/core/tests/test_expl_comp.py", "testname": "test_expl_comp.py", "classname": "ExplCompTestCase", "funcname": "test_add_input_output_retval", "imports": ["from io import StringIO", "import unittest", "import itertools", "import numpy as np", "import openmdao.api as om", "from openmdao.test_suite.components.double_sellar import SubSellar", "from openmdao.test_suite.components.expl_comp_simple import TestExplCompSimple, TestExplCompSimpleDense", "from openmdao.test_suite.components.sellar import SellarDis1withDerivatives, SellarDis2withDerivatives", "from openmdao.test_suite.components.rectangle import RectangleGroup, RectangleComp, RectangleCompWithTags, RectangleJacVec", "from openmdao.utils.assert_utils import assert_near_equal", "from openmdao.utils.general_utils import printoptions, remove_whitespace", "from openmdao.utils.mpi import MPI", "from openmdao.utils.testing_utils import parameterized_name"], "code": "def test_add_input_output_retval(self):\n    expected = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class Comp(om.ExplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', Comp())\n    prob.setup()", "masked_code": "def test_add_input_output_retval(self):\n    expected = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class Comp(om.ExplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == '???'), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', Comp())\n    prob.setup()", "ground_truth": "val", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "openmdao_4", "reponame": "openmdao", "testpath": "openmdao/core/tests/test_impl_comp.py", "testname": "test_impl_comp.py", "classname": "ImplCompTestCase", "funcname": "test_add_input_output_retval", "imports": ["import unittest", "from io import StringIO", "import numpy as np", "import openmdao.api as om", "from openmdao.utils.assert_utils import assert_near_equal, assert_check_totals", "from openmdao.utils.general_utils import remove_whitespace", "from openmdao.test_suite.components.sellar import SellarImplicitDis1, SellarImplicitDis2"], "code": "def test_add_input_output_retval(self):\n    expected_ivp_input = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_ivp_output = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': {'openmdao:allow_desvar'}}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class ImplComp(om.ImplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected_ivp_input.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected_ivp_output.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', ImplComp())\n    prob.setup()", "masked_code": "def test_add_input_output_retval(self):\n    expected_ivp_input = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_ivp_output = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': {'openmdao:allow_desvar'}}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class ImplComp(om.ImplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected_ivp_input.items():\n                assert (meta[key] == '???'), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected_ivp_output.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', ImplComp())\n    prob.setup()", "ground_truth": "val", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "openmdao_5", "reponame": "openmdao", "testpath": "openmdao/core/tests/test_impl_comp.py", "testname": "test_impl_comp.py", "classname": "ImplCompTestCase", "funcname": "test_add_input_output_retval", "imports": ["import unittest", "from io import StringIO", "import numpy as np", "import openmdao.api as om", "from openmdao.utils.assert_utils import assert_near_equal, assert_check_totals", "from openmdao.utils.general_utils import remove_whitespace", "from openmdao.test_suite.components.sellar import SellarImplicitDis1, SellarImplicitDis2"], "code": "def test_add_input_output_retval(self):\n    expected_ivp_input = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_ivp_output = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': {'openmdao:allow_desvar'}}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class ImplComp(om.ImplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected_ivp_input.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected_ivp_output.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', ImplComp())\n    prob.setup()", "masked_code": "def test_add_input_output_retval(self):\n    expected_ivp_input = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_ivp_output = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': {'openmdao:allow_desvar'}}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class ImplComp(om.ImplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected_ivp_input.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == '???'), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected_ivp_output.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', ImplComp())\n    prob.setup()", "ground_truth": "val", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "openmdao_6", "reponame": "openmdao", "testpath": "openmdao/core/tests/test_impl_comp.py", "testname": "test_impl_comp.py", "classname": "ImplCompTestCase", "funcname": "test_add_input_output_retval", "imports": ["import unittest", "from io import StringIO", "import numpy as np", "import openmdao.api as om", "from openmdao.utils.assert_utils import assert_near_equal, assert_check_totals", "from openmdao.utils.general_utils import remove_whitespace", "from openmdao.test_suite.components.sellar import SellarImplicitDis1, SellarImplicitDis2"], "code": "def test_add_input_output_retval(self):\n    expected_ivp_input = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_ivp_output = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': {'openmdao:allow_desvar'}}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class ImplComp(om.ImplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected_ivp_input.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected_ivp_output.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', ImplComp())\n    prob.setup()", "masked_code": "def test_add_input_output_retval(self):\n    expected_ivp_input = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_ivp_output = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': {'openmdao:allow_desvar'}}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class ImplComp(om.ImplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected_ivp_input.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected_ivp_output.items():\n                assert (meta[key] == '???'), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', ImplComp())\n    prob.setup()", "ground_truth": "val", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "openmdao_7", "reponame": "openmdao", "testpath": "openmdao/core/tests/test_impl_comp.py", "testname": "test_impl_comp.py", "classname": "ImplCompTestCase", "funcname": "test_add_input_output_retval", "imports": ["import unittest", "from io import StringIO", "import numpy as np", "import openmdao.api as om", "from openmdao.utils.assert_utils import assert_near_equal, assert_check_totals", "from openmdao.utils.general_utils import remove_whitespace", "from openmdao.test_suite.components.sellar import SellarImplicitDis1, SellarImplicitDis2"], "code": "def test_add_input_output_retval(self):\n    expected_ivp_input = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_ivp_output = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': {'openmdao:allow_desvar'}}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class ImplComp(om.ImplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected_ivp_input.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected_ivp_output.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', ImplComp())\n    prob.setup()", "masked_code": "def test_add_input_output_retval(self):\n    expected_ivp_input = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': set()}\n    expected_ivp_output = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': {'openmdao:allow_desvar'}}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': set()}\n\n    class ImplComp(om.ImplicitComponent):\n\n        def setup(self):\n            meta = self.add_input('x', val=3.0, units='ft')\n            for (key, val) in expected_ivp_input.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_input('x_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected_ivp_output.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('y_disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == '???'), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('comp', ImplComp())\n    prob.setup()", "ground_truth": "val", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "openmdao_8", "reponame": "openmdao", "testpath": "openmdao/core/tests/test_indep_var_comp.py", "testname": "test_indep_var_comp.py", "classname": "TestIndepVarComp", "funcname": "test_add_output_retval", "imports": ["import unittest", "import numpy as np", "import openmdao.api as om", "from openmdao.utils.assert_utils import assert_near_equal"], "code": "def test_add_output_retval(self):\n    expected = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': {'openmdao:indep_var', 'openmdao:allow_desvar'}}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': {'openmdao:indep_var'}}\n\n    class IDVComp(om.IndepVarComp):\n\n        def setup(self):\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('idv', IDVComp())\n    prob.setup()", "masked_code": "def test_add_output_retval(self):\n    expected = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': {'openmdao:indep_var', 'openmdao:allow_desvar'}}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': {'openmdao:indep_var'}}\n\n    class IDVComp(om.IndepVarComp):\n\n        def setup(self):\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == '???'), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('idv', IDVComp())\n    prob.setup()", "ground_truth": "val", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "openmdao_9", "reponame": "openmdao", "testpath": "openmdao/core/tests/test_indep_var_comp.py", "testname": "test_indep_var_comp.py", "classname": "TestIndepVarComp", "funcname": "test_add_output_retval", "imports": ["import unittest", "import numpy as np", "import openmdao.api as om", "from openmdao.utils.assert_utils import assert_near_equal"], "code": "def test_add_output_retval(self):\n    expected = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': {'openmdao:indep_var', 'openmdao:allow_desvar'}}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': {'openmdao:indep_var'}}\n\n    class IDVComp(om.IndepVarComp):\n\n        def setup(self):\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('idv', IDVComp())\n    prob.setup()", "masked_code": "def test_add_output_retval(self):\n    expected = {'val': 3, 'shape': (1,), 'size': 1, 'units': 'ft', 'desc': '', 'tags': {'openmdao:indep_var', 'openmdao:allow_desvar'}}\n    expected_discrete = {'val': 3, 'type': int, 'desc': '', 'tags': {'openmdao:indep_var'}}\n\n    class IDVComp(om.IndepVarComp):\n\n        def setup(self):\n            meta = self.add_output('y', val=3.0, units='ft')\n            for (key, val) in expected.items():\n                assert (meta[key] == val), f'Expected {key}: {val} but got {key}: {meta[key]}'\n            meta = self.add_discrete_output('disc', val=3)\n            for (key, val) in expected_discrete.items():\n                assert (meta[key] == '???'), f'Expected {key}: {val} but got {key}: {meta[key]}'\n    prob = om.Problem()\n    prob.model.add_subsystem('idv', IDVComp())\n    prob.setup()", "ground_truth": "val", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "openmdao_10", "reponame": "openmdao", "testpath": "openmdao/jacobians/tests/test_jacobian.py", "testname": "test_jacobian.py", "classname": "TestJacobian", "funcname": "test_compute_totals_relevancy", "imports": ["import itertools", "import unittest", "import numpy as np", "from scipy.sparse import coo_matrix, csr_matrix", "from openmdao.api import IndepVarComp, Group, Problem, ExplicitComponent, ImplicitComponent, ExecComp, NewtonSolver, ScipyKrylov, LinearBlockGS, DirectSolver", "from openmdao.utils.assert_utils import assert_near_equal, assert_check_partials", "from openmdao.utils.array_utils import rand_sparsity", "from openmdao.test_suite.components.paraboloid import Paraboloid", "from openmdao.api import ScipyOptimizeDriver"], "code": "def test_compute_totals_relevancy(self):\n\n    class DParaboloid(ExplicitComponent):\n\n        def setup(self):\n            ndvs = 3\n            self.add_input('w', val=1.0)\n            self.add_input('x', shape=ndvs)\n            self.add_output('y', shape=1)\n            self.add_output('z', shape=ndvs)\n            self.declare_partials('y', 'x')\n            self.declare_partials('y', 'w')\n            self.declare_partials('z', 'x')\n\n        def compute(self, inputs, outputs):\n            x = inputs['x']\n            y_g = np.sum(((x - 5) ** 2))\n            outputs['y'] = (np.sum(y_g) + ((inputs['w'] - 10) ** 2))\n            outputs['z'] = (x ** 2)\n\n        def compute_partials(self, inputs, J):\n            x = inputs['x']\n            J[('y', 'x')] = (2 * (x - 5))\n            J[('y', 'w')] = (2 * (inputs['w'] - 10))\n            J[('z', 'x')] = np.diag((2 * x))\n    p = Problem()\n    d_ivc = p.model.add_subsystem('distrib_ivc', IndepVarComp(), promotes=['*'])\n    ndvs = 3\n    d_ivc.add_output('x', (2 * np.ones(ndvs)))\n    ivc = p.model.add_subsystem('ivc', IndepVarComp(), promotes=['*'])\n    ivc.add_output('w', 2.0)\n    p.model.add_subsystem('dp', DParaboloid(), promotes=['*'])\n    p.model.add_design_var('x', lower=(- 100), upper=100)\n    p.model.add_objective('y')\n    p.setup(mode='rev')\n    p.run_model()\n    J = p.compute_totals(of=['y', 'z'], wrt=['w', 'x'])\n    assert (J[('y', 'w')][(0, 0)] == (- 16))", "masked_code": "def test_compute_totals_relevancy(self):\n\n    class DParaboloid(ExplicitComponent):\n\n        def setup(self):\n            ndvs = 3\n            self.add_input('w', val=1.0)\n            self.add_input('x', shape=ndvs)\n            self.add_output('y', shape=1)\n            self.add_output('z', shape=ndvs)\n            self.declare_partials('y', 'x')\n            self.declare_partials('y', 'w')\n            self.declare_partials('z', 'x')\n\n        def compute(self, inputs, outputs):\n            x = inputs['x']\n            y_g = np.sum(((x - 5) ** 2))\n            outputs['y'] = (np.sum(y_g) + ((inputs['w'] - 10) ** 2))\n            outputs['z'] = (x ** 2)\n\n        def compute_partials(self, inputs, J):\n            x = inputs['x']\n            J[('y', 'x')] = (2 * (x - 5))\n            J[('y', 'w')] = (2 * (inputs['w'] - 10))\n            J[('z', 'x')] = np.diag((2 * x))\n    p = Problem()\n    d_ivc = p.model.add_subsystem('distrib_ivc', IndepVarComp(), promotes=['*'])\n    ndvs = 3\n    d_ivc.add_output('x', (2 * np.ones(ndvs)))\n    ivc = p.model.add_subsystem('ivc', IndepVarComp(), promotes=['*'])\n    ivc.add_output('w', 2.0)\n    p.model.add_subsystem('dp', DParaboloid(), promotes=['*'])\n    p.model.add_design_var('x', lower=(- 100), upper=100)\n    p.model.add_objective('y')\n    p.setup(mode='rev')\n    p.run_model()\n    J = p.compute_totals(of=['y', 'z'], wrt=['w', 'x'])\n    assert (J[('y', 'w')][(0, 0)] == '???')", "ground_truth": "(- 16)", "quality_analysis": {"complexity_score": 18, "left_complexity": 15, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "openmdao_11", "reponame": "openmdao", "testpath": "openmdao/solvers/linear/tests/test_petsc_ksp.py", "testname": "test_petsc_ksp.py", "classname": "TestPETScKrylov", "funcname": "test_options", "imports": ["import unittest", "import numpy as np", "import openmdao.api as om", "from openmdao.test_suite.components.misc_components import Comp4LinearCacheTest", "from openmdao.test_suite.components.sellar import SellarDis1withDerivatives, SellarDis2withDerivatives", "from openmdao.test_suite.groups.implicit_group import TestImplicitGroup", "from openmdao.utils.assert_utils import assert_near_equal"], "code": "def test_options(self):\n    'Verify that the PETScKrylov specific options are declared.'\n    group = om.Group()\n    group.linear_solver = om.PETScKrylov()\n    assert (group.linear_solver.options['ksp_type'] == 'fgmres')", "masked_code": "def test_options(self):\n    'Verify that the PETScKrylov specific options are declared.'\n    group = om.Group()\n    group.linear_solver = om.PETScKrylov()\n    assert (group.linear_solver.options['ksp_type'] == '???')", "ground_truth": "'fgmres'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
