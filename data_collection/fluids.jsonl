{"task_id": "fluids_0", "reponame": "fluids", "testpath": "tests/test_design_climate.py", "testname": "test_design_climate.py", "classname": null, "funcname": "test_month_average_temperature", "imports": ["import os", "import pytest", "from fluids.design_climate import IntegratedSurfaceDatabaseStation, StationDataGSOD, get_latlongs, cooling_degree_days, geocode, get_closest_station, get_station_year_text, heating_degree_days, get_stations", "from fluids.numerics import assert_close, assert_close1d"], "code": "@pytest.mark.slow\ndef test_month_average_temperature():\n    station = get_closest_station(38.8572, (- 77.0369))\n    station_data = StationDataGSOD(station, data_dir_override=data_dir_override)\n    Ts_calc = station_data.month_average_temperature(1990, 2000, include_yearly=False, minimum_days=23)\n    Ts_expect = [276.1599380905833, 277.5375516246206, 281.1881231671554, 286.7367003367004, 291.8689638318671, 296.79545454545456, 299.51868686868687, 298.2097914630174, 294.4116161616162, 288.25883023786247, 282.3188552188553, 277.8282339524275]\n    assert_close1d(Ts_calc, Ts_expect, rtol=0.001)\n    assert (station_data.warmest_month(1990, 2000) == 6)\n    assert (station_data.coldest_month(1990, 2000) == 0)", "masked_code": "@pytest.mark.slow\ndef test_month_average_temperature():\n    station = get_closest_station(38.8572, (- 77.0369))\n    station_data = StationDataGSOD(station, data_dir_override=data_dir_override)\n    Ts_calc = station_data.month_average_temperature(1990, 2000, include_yearly=False, minimum_days=23)\n    Ts_expect = [276.1599380905833, 277.5375516246206, 281.1881231671554, 286.7367003367004, 291.8689638318671, 296.79545454545456, 299.51868686868687, 298.2097914630174, 294.4116161616162, 288.25883023786247, 282.3188552188553, 277.8282339524275]\n    assert_close1d(Ts_calc, Ts_expect, rtol=0.001)\n    assert (station_data.warmest_month(1990, 2000) == '???')\n    assert (station_data.coldest_month(1990, 2000) == 0)", "ground_truth": "6", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_1", "reponame": "fluids", "testpath": "tests/test_design_climate.py", "testname": "test_design_climate.py", "classname": null, "funcname": "test_correct_WBAN", "imports": ["import os", "import pytest", "from fluids.design_climate import IntegratedSurfaceDatabaseStation, StationDataGSOD, get_latlongs, cooling_degree_days, geocode, get_closest_station, get_station_year_text, heating_degree_days, get_stations", "from fluids.numerics import assert_close, assert_close1d"], "code": "@pytest.mark.slow\ndef test_correct_WBAN():\n    station = get_closest_station(31.9973, (- 102.0779))\n    station_data = StationDataGSOD(station, data_dir_override=data_dir_override)\n    assert (station.WBAN == '03071')\n    assert station_data.month_average_temperature(2010, 2011, include_yearly=False)", "masked_code": "@pytest.mark.slow\ndef test_correct_WBAN():\n    station = get_closest_station(31.9973, (- 102.0779))\n    station_data = StationDataGSOD(station, data_dir_override=data_dir_override)\n    assert (station.WBAN == '???')\n    assert station_data.month_average_temperature(2010, 2011, include_yearly=False)", "ground_truth": "'03071'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_2", "reponame": "fluids", "testpath": "tests/test_design_climate.py", "testname": "test_design_climate.py", "classname": null, "funcname": "test_get_closest_station", "imports": ["import os", "import pytest", "from fluids.design_climate import IntegratedSurfaceDatabaseStation, StationDataGSOD, get_latlongs, cooling_degree_days, geocode, get_closest_station, get_station_year_text, heating_degree_days, get_stations", "from fluids.numerics import assert_close, assert_close1d"], "code": "def test_get_closest_station():\n    s = get_closest_station(51.02532675, (- 114.049868485806), 20150000)\n    assert (s.NAME == 'CALGARY INTL CS')\n    with pytest.raises(Exception):\n        get_closest_station(51.02532675, (- 114.049868485806), 90150000)", "masked_code": "def test_get_closest_station():\n    s = get_closest_station(51.02532675, (- 114.049868485806), 20150000)\n    assert (s.NAME == '???')\n    with pytest.raises(Exception):\n        get_closest_station(51.02532675, (- 114.049868485806), 90150000)", "ground_truth": "'CALGARY INTL CS'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_3", "reponame": "fluids", "testpath": "tests/test_drag.py", "testname": "test_drag.py", "classname": null, "funcname": "test_drag_sphere", "imports": ["import pytest", "from fluids.drag import Almedeij, Barati, Barati_high, Ceylan, Cheng, Clift, Clift_Gauvin, Engelund_Hansen, Flemmer_Banks, Graf, Haider_Levenspiel, Khan_Richardson, Mikhailov_Freire, Morrison, Morsi_Alexander, Rouse, Song_Xu, Stokes, Swamee_Ojha, Terfous, Yen, drag_sphere, drag_sphere_correlations, drag_sphere_methods, integrate_drag_sphere, time_v_terminal_Stokes, v_terminal", "from fluids.numerics import assert_close, assert_close1d"], "code": "def test_drag_sphere():\n    Cd = drag_sphere(200)\n    assert_close(Cd, 0.7682237950389874)\n    Cd = drag_sphere(1000000.0)\n    assert_close(Cd, 0.21254574397767056)\n    Cd = drag_sphere(1000000.0, Method='Barati_high')\n    assert_close(Cd, 0.21254574397767056)\n    Cd = drag_sphere(0.001)\n    assert_close(Cd, 24000.0)\n    Cd = drag_sphere(0.05)\n    assert_close(Cd, 481.23769162684573)\n    with pytest.raises(Exception):\n        drag_sphere(200, Method='BADMETHOD')\n    assert_close(drag_sphere(10000000.0), drag_sphere(1000000.0))\n    methods = drag_sphere_methods(300000.0, True)\n    method_known = ['Barati_high', 'Ceylan', 'Morrison', 'Clift', 'Almedeij']\n    assert (sorted(method_known) == sorted(methods))\n    assert (20 == len(drag_sphere_methods(200)))\n    assert (21 == len(drag_sphere_methods(200000, check_ranges=False)))\n    assert (5 == len(drag_sphere_methods(200000, check_ranges=True)))", "masked_code": "def test_drag_sphere():\n    Cd = drag_sphere(200)\n    assert_close(Cd, 0.7682237950389874)\n    Cd = drag_sphere(1000000.0)\n    assert_close(Cd, 0.21254574397767056)\n    Cd = drag_sphere(1000000.0, Method='Barati_high')\n    assert_close(Cd, 0.21254574397767056)\n    Cd = drag_sphere(0.001)\n    assert_close(Cd, 24000.0)\n    Cd = drag_sphere(0.05)\n    assert_close(Cd, 481.23769162684573)\n    with pytest.raises(Exception):\n        drag_sphere(200, Method='BADMETHOD')\n    assert_close(drag_sphere(10000000.0), drag_sphere(1000000.0))\n    methods = drag_sphere_methods(300000.0, True)\n    method_known = ['Barati_high', 'Ceylan', 'Morrison', 'Clift', 'Almedeij']\n    assert (sorted(method_known) == '???')\n    assert (20 == len(drag_sphere_methods(200)))\n    assert (21 == len(drag_sphere_methods(200000, check_ranges=False)))\n    assert (5 == len(drag_sphere_methods(200000, check_ranges=True)))", "ground_truth": "sorted(methods)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_4", "reponame": "fluids", "testpath": "tests/test_fittings.py", "testname": "test_fittings.py", "classname": null, "funcname": "test_bend_rounded", "imports": ["from math import isinf, isnan, log10, pi", "from fluids.fittings import Cv_to_K, Cv_to_Kv, Darby, Darby3K, Hooper, Hooper2K, K_angle_stop_check_valve_Crane, K_angle_valve_Crane, K_ball_valve_Crane, K_branch_converging_Crane, K_branch_diverging_Crane, K_butterfly_valve_Crane, K_diaphragm_valve_Crane, K_foot_valve_Crane, K_gate_valve_Crane, K_globe_stop_check_valve_Crane, K_globe_valve_Crane, K_lift_check_valve_Crane, K_plug_valve_Crane, K_run_converging_Crane, K_run_diverging_Crane, K_swing_check_valve_Crane, K_tilting_disk_check_valve_Crane, K_to_Cv, K_to_Kv, Kv_to_Cv, Kv_to_K, bend_miter, bend_miter_Miller, bend_rounded, bend_rounded_Crane, bend_rounded_Miller, change_K_basis, contraction_beveled, contraction_conical, contraction_conical_Crane, contraction_round, contraction_round_Miller, contraction_sharp, diffuser_conical, diffuser_conical_staged, diffuser_curved, diffuser_pipe_reducer, diffuser_sharp, entrance_angled, entrance_beveled, entrance_beveled_orifice, entrance_distance, entrance_rounded, entrance_sharp, exit_normal, helix, spiral, v_lift_valve_Crane", "import pytest", "from fluids.constants import inch, liter, minute", "from fluids.core import Reynolds", "from fluids.friction import ft_Crane", "from fluids.numerics import assert_close, assert_close1d, secant"], "code": "def test_bend_rounded():\n    K_5_rc = [bend_rounded(Di=4.02, rc=(4.0 * 5), angle=i, fd=0.0163) for i in [15.0, 30.0, 45, 60, 75, 90]]\n    K_5_rc_values = [0.07038212630028828, 0.10680196344492195, 0.13858204974134541, 0.16977191374717754, 0.20114941557508642, 0.23248382866658507]\n    assert_close1d(K_5_rc, K_5_rc_values)\n    K_10_rc = [bend_rounded(Di=34.5, rc=(36 * 10), angle=i, fd=0.0106) for i in [15, 30, 45, 60, 75, 90]]\n    K_10_rc_values = [0.061075866683922314, 0.10162621862720357, 0.14158887563243763, 0.18225270014527103, 0.22309967045081655, 0.26343782210280947]\n    assert_close1d(K_10_rc, K_10_rc_values)\n    K = bend_rounded(Di=4.02, bend_diameters=5.0, angle=30.0, fd=0.0163)\n    assert_close(K, 0.106920213333191)\n    K = bend_rounded(Di=4.02, bend_diameters=5.0, angle=30, Re=100000.0)\n    assert_close(K, 0.11532121658742862)\n    K = bend_rounded(Di=4.02, bend_diameters=5.0, angle=30, Re=100000.0, method='Miller')\n    assert_close(K, 0.10276501180879682)\n    K = bend_rounded(Di=0.5, bend_diameters=5.0, angle=30, Re=100000.0, method='Crane')\n    assert_close(K, 0.08959057097762159)\n    K = bend_rounded(Di=0.5, bend_diameters=5.0, angle=30, Re=100000.0, method='Ito')\n    assert_close(K, 0.10457946464978755)\n    K = bend_rounded(Di=0.5, bend_diameters=5.0, angle=30, Re=100000.0, method='Swamee')\n    assert_close(K, 0.055429466248839564)\n    assert (type(bend_rounded(Di=4.02, rc=(4.0 * 5), angle=30, Re=100000.0, method='Miller')) == float)\n    Di = 4\n    v0 = (bend_rounded(Di=4, angle=45, method='Crane standard') / ft_Crane(Di))\n    assert_close(v0, 16.0)\n    v0 = (bend_rounded(Di=4, angle=90, method='Crane standard') / ft_Crane(Di))\n    assert_close(v0, 30.0)\n    v0 = (bend_rounded(Di=4, angle=180, method='Crane standard') / ft_Crane(Di))\n    assert_close(v0, 50.0)\n    v0 = (bend_rounded(Di=4, angle=360, method='Crane standard') / ft_Crane(Di))\n    assert_close(v0, 90.0)\n    v0 = (bend_rounded(Di=4, angle=0, method='Crane standard') / ft_Crane(Di))\n    assert_close(v0, 2.0)", "masked_code": "def test_bend_rounded():\n    K_5_rc = [bend_rounded(Di=4.02, rc=(4.0 * 5), angle=i, fd=0.0163) for i in [15.0, 30.0, 45, 60, 75, 90]]\n    K_5_rc_values = [0.07038212630028828, 0.10680196344492195, 0.13858204974134541, 0.16977191374717754, 0.20114941557508642, 0.23248382866658507]\n    assert_close1d(K_5_rc, K_5_rc_values)\n    K_10_rc = [bend_rounded(Di=34.5, rc=(36 * 10), angle=i, fd=0.0106) for i in [15, 30, 45, 60, 75, 90]]\n    K_10_rc_values = [0.061075866683922314, 0.10162621862720357, 0.14158887563243763, 0.18225270014527103, 0.22309967045081655, 0.26343782210280947]\n    assert_close1d(K_10_rc, K_10_rc_values)\n    K = bend_rounded(Di=4.02, bend_diameters=5.0, angle=30.0, fd=0.0163)\n    assert_close(K, 0.106920213333191)\n    K = bend_rounded(Di=4.02, bend_diameters=5.0, angle=30, Re=100000.0)\n    assert_close(K, 0.11532121658742862)\n    K = bend_rounded(Di=4.02, bend_diameters=5.0, angle=30, Re=100000.0, method='Miller')\n    assert_close(K, 0.10276501180879682)\n    K = bend_rounded(Di=0.5, bend_diameters=5.0, angle=30, Re=100000.0, method='Crane')\n    assert_close(K, 0.08959057097762159)\n    K = bend_rounded(Di=0.5, bend_diameters=5.0, angle=30, Re=100000.0, method='Ito')\n    assert_close(K, 0.10457946464978755)\n    K = bend_rounded(Di=0.5, bend_diameters=5.0, angle=30, Re=100000.0, method='Swamee')\n    assert_close(K, 0.055429466248839564)\n    assert (type(bend_rounded(Di=4.02, rc=(4.0 * 5), angle=30, Re=100000.0, method='Miller')) == '???')\n    Di = 4\n    v0 = (bend_rounded(Di=4, angle=45, method='Crane standard') / ft_Crane(Di))\n    assert_close(v0, 16.0)\n    v0 = (bend_rounded(Di=4, angle=90, method='Crane standard') / ft_Crane(Di))\n    assert_close(v0, 30.0)\n    v0 = (bend_rounded(Di=4, angle=180, method='Crane standard') / ft_Crane(Di))\n    assert_close(v0, 50.0)\n    v0 = (bend_rounded(Di=4, angle=360, method='Crane standard') / ft_Crane(Di))\n    assert_close(v0, 90.0)\n    v0 = (bend_rounded(Di=4, angle=0, method='Crane standard') / ft_Crane(Di))\n    assert_close(v0, 2.0)", "ground_truth": "float", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_5", "reponame": "fluids", "testpath": "tests/test_flow_meter.py", "testname": "test_flow_meter.py", "classname": null, "funcname": "test_C_quarter_circle_orifice_ISO_15377_1998", "imports": ["from math import log, log10", "import pytest", "from fluids.constants import inch", "from fluids.flow_meter import AS_CAST_VENTURI_TUBE, CONCENTRIC_ORIFICE, CONE_METER, HOLLINGSHEAD_CONE, HOLLINGSHEAD_ORIFICE, HOLLINGSHEAD_VENTURI_SHARP, HOLLINGSHEAD_VENTURI_SMOOTH, HOLLINGSHEAD_WEDGE, ISA_1932_NOZZLE, ISO_5167_ORIFICE, ISO_15377_CONICAL_ORIFICE, ISO_15377_ECCENTRIC_ORIFICE, ISO_15377_QUARTER_CIRCLE_ORIFICE, LONG_RADIUS_NOZZLE, MACHINED_CONVERGENT_VENTURI_TUBE, MILLER_CONICAL_ORIFICE, MILLER_ECCENTRIC_ORIFICE, MILLER_ORIFICE, MILLER_QUARTER_CIRCLE_ORIFICE, MILLER_SEGMENTAL_ORIFICE, ORIFICE_CORNER_TAPS, ORIFICE_D_AND_D_2_TAPS, ORIFICE_FLANGE_TAPS, ORIFICE_PIPE_TAPS, ORIFICE_VENA_CONTRACTA_TAPS, ROUGH_WELDED_CONVERGENT_VENTURI_TUBE, TAPS_OPPOSITE, TAPS_SIDE, VENTURI_NOZZLE, WEDGE_METER, C_eccentric_orifice_ISO_15377_1998, C_ISA_1932_nozzle, C_long_radius_nozzle, C_Miller_1996, C_quarter_circle_orifice_ISO_15377_1998, C_Reader_Harris_Gallagher, C_Reader_Harris_Gallagher_wet_venturi_tube, C_venturi_nozzle, C_wedge_meter_ISO_5167_6_2017, C_wedge_meter_Miller, K_to_discharge_coefficient, cone_meter_expansibility_Stewart, diameter_ratio_cone_meter, diameter_ratio_wedge_meter, differential_pressure_meter_beta, differential_pressure_meter_C_epsilon, differential_pressure_meter_dP, differential_pressure_meter_solver, discharge_coefficient_to_K, dP_cone_meter, dP_orifice, dP_Reader_Harris_Gallagher_wet_venturi_tube, dP_venturi_tube, dP_wedge_meter, flow_coefficient, flow_meter_discharge, nozzle_expansibility, orifice_expansibility, orifice_expansibility_1989, velocity_of_approach_factor", "from fluids.numerics import assert_close, assert_close1d, assert_close2d, isclose, logspace, secant"], "code": "def test_C_quarter_circle_orifice_ISO_15377_1998():\n    C = C_quarter_circle_orifice_ISO_15377_1998(0.2, 0.075)\n    assert_close(C, 0.7785148437500001, rtol=1e-12)\n    betas = [0.245, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3, 0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4, 0.41, 0.42, 0.43, 0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.5, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.6]\n    Cs_expect = [0.772, 0.772, 0.772, 0.773, 0.773, 0.773, 0.774, 0.774, 0.775, 0.775, 0.776, 0.776, 0.777, 0.778, 0.779, 0.78, 0.781, 0.783, 0.784, 0.786, 0.787, 0.789, 0.791, 0.794, 0.796, 0.799, 0.802, 0.805, 0.808, 0.812, 0.816, 0.82, 0.824, 0.829, 0.834, 0.839, 0.844]\n    for (Do, C_expect) in zip(betas, Cs_expect):\n        C = C_quarter_circle_orifice_ISO_15377_1998(D=1, Do=Do)\n        assert (round(C, 3) == C_expect)", "masked_code": "def test_C_quarter_circle_orifice_ISO_15377_1998():\n    C = C_quarter_circle_orifice_ISO_15377_1998(0.2, 0.075)\n    assert_close(C, 0.7785148437500001, rtol=1e-12)\n    betas = [0.245, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3, 0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4, 0.41, 0.42, 0.43, 0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.5, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.6]\n    Cs_expect = [0.772, 0.772, 0.772, 0.773, 0.773, 0.773, 0.774, 0.774, 0.775, 0.775, 0.776, 0.776, 0.777, 0.778, 0.779, 0.78, 0.781, 0.783, 0.784, 0.786, 0.787, 0.789, 0.791, 0.794, 0.796, 0.799, 0.802, 0.805, 0.808, 0.812, 0.816, 0.82, 0.824, 0.829, 0.834, 0.839, 0.844]\n    for (Do, C_expect) in zip(betas, Cs_expect):\n        C = C_quarter_circle_orifice_ISO_15377_1998(D=1, Do=Do)\n        assert (round(C, 3) == '???')", "ground_truth": "C_expect", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_6", "reponame": "fluids", "testpath": "tests/test_friction.py", "testname": "test_friction.py", "classname": null, "funcname": "test_friction", "imports": ["from math import isnan, log10, pi", "import pytest", "from fluids.friction import Alshul_1952, Avci_Karagoz_2009, Barr_1981, Blasius, Brkic_2011_1, Brkic_2011_2, Buzzelli_2008, Chen_1979, Churchill_1973, Churchill_1977, Clamond, Colebrook, Eck_1973, Fang_2011, Haaland, Jain_1976, Manadilli_1997, Moody, Papaevangelo_2010, Prandtl_von_Karman_Nikuradse, Rao_Kumar_2007, Romeo_2002, Round_1980, Serghides_1, Serghides_2, Shacham_1980, Sonnad_Goudar_2006, Swamee_Jain_1976, Tsal_1989, Wood_1966, Zigrang_Sylvester_1, Zigrang_Sylvester_2, _Farshad_roughness, _roughness, friction_factor, friction_factor_curved, friction_factor_curved_methods, friction_factor_methods, friction_laminar, friction_plate_Kumar, friction_plate_Martin_1999, friction_plate_Martin_VDI, friction_plate_Muley_Manglik, ft_Crane, helical_laminar_fd_Mori_Nakayama, helical_laminar_fd_Schmidt, helical_laminar_fd_White, helical_Re_crit, helical_transition_Re_Ito, helical_transition_Re_Kubair_Kuloor, helical_transition_Re_Kutateladze_Borishanskii, helical_transition_Re_Schmidt, helical_transition_Re_Seth_Stahel, helical_transition_Re_Srinivasan, helical_turbulent_fd_Czop, helical_turbulent_fd_Guo, helical_turbulent_fd_Ju, helical_turbulent_fd_Mandal_Nigam, helical_turbulent_fd_Mori_Nakayama, helical_turbulent_fd_Prasad, helical_turbulent_fd_Schmidt, helical_turbulent_fd_Srinivasan, material_roughness, nearest_material_roughness, one_phase_dP, one_phase_dP_dz_acceleration, one_phase_dP_gravitational, roughness_Farshad, transmission_factor, von_Karman", "from fluids.numerics import assert_close, assert_close1d, assert_close3d, linspace, logspace, secant"], "code": "def test_friction():\n    assert_close(sum(_roughness.values()), 0.01504508)\n    assert_close(friction_factor(Re=100000.0, eD=0.0001), 0.01851386607747165)\n    methods_1 = friction_factor_methods(Re=100000.0, eD=0.0001)\n    methods_1.sort()\n    methods_2 = ['Clamond', 'Colebrook', 'Manadilli_1997', 'Haaland', 'Alshul_1952', 'Avci_Karagoz_2009', 'Rao_Kumar_2007', 'Zigrang_Sylvester_2', 'Eck_1973', 'Buzzelli_2008', 'Tsal_1989', 'Papaevangelo_2010', 'Barr_1981', 'Jain_1976', 'Moody', 'Brkic_2011_2', 'Brkic_2011_1', 'Swamee_Jain_1976', 'Wood_1966', 'Shacham_1980', 'Romeo_2002', 'Chen_1979', 'Fang_2011', 'Round_1980', 'Sonnad_Goudar_2006', 'Churchill_1973', 'Churchill_1977', 'Serghides_2', 'Serghides_1', 'Zigrang_Sylvester_1']\n    methods_2.sort()\n    assert (methods_1 == methods_2)\n    assert_close(friction_factor(Re=100000.0, eD=0.0001, Darcy=False), (0.01851386607747165 / 4))\n    assert_close(friction_factor(Re=128), 0.5)\n    assert_close(friction_factor(Re=100000.0, eD=0, Method=None), 0.01798977308427384)\n    assert_close(friction_factor(20000, eD=0.0, Method='laminar'), 0.0032)\n    with pytest.raises(ValueError):\n        friction_factor(Re=100000.0, eD=0, Method='BADMETHOD')\n    assert (['laminar'] == friction_factor_methods(200, 0, True))\n    assert (31 == len(friction_factor_methods(200, 0, False)))\n    for m in friction_factor_methods(200, 0, False):\n        friction_factor(Re=100000.0, eD=1e-06, Method=m)\n    fd = ft_Crane(0.1)\n    Di = 0.1\n    fd_act = Clamond((7500000.0 * Di), eD=(roughness_Farshad(ID='Carbon steel, bare', D=Di) / Di))\n    assert_close(fd, fd_act, rtol=5e-06)", "masked_code": "def test_friction():\n    assert_close(sum(_roughness.values()), 0.01504508)\n    assert_close(friction_factor(Re=100000.0, eD=0.0001), 0.01851386607747165)\n    methods_1 = friction_factor_methods(Re=100000.0, eD=0.0001)\n    methods_1.sort()\n    methods_2 = ['Clamond', 'Colebrook', 'Manadilli_1997', 'Haaland', 'Alshul_1952', 'Avci_Karagoz_2009', 'Rao_Kumar_2007', 'Zigrang_Sylvester_2', 'Eck_1973', 'Buzzelli_2008', 'Tsal_1989', 'Papaevangelo_2010', 'Barr_1981', 'Jain_1976', 'Moody', 'Brkic_2011_2', 'Brkic_2011_1', 'Swamee_Jain_1976', 'Wood_1966', 'Shacham_1980', 'Romeo_2002', 'Chen_1979', 'Fang_2011', 'Round_1980', 'Sonnad_Goudar_2006', 'Churchill_1973', 'Churchill_1977', 'Serghides_2', 'Serghides_1', 'Zigrang_Sylvester_1']\n    methods_2.sort()\n    assert (methods_1 == methods_2)\n    assert_close(friction_factor(Re=100000.0, eD=0.0001, Darcy=False), (0.01851386607747165 / 4))\n    assert_close(friction_factor(Re=128), 0.5)\n    assert_close(friction_factor(Re=100000.0, eD=0, Method=None), 0.01798977308427384)\n    assert_close(friction_factor(20000, eD=0.0, Method='laminar'), 0.0032)\n    with pytest.raises(ValueError):\n        friction_factor(Re=100000.0, eD=0, Method='BADMETHOD')\n    assert (['laminar'] == '???')\n    assert (31 == len(friction_factor_methods(200, 0, False)))\n    for m in friction_factor_methods(200, 0, False):\n        friction_factor(Re=100000.0, eD=1e-06, Method=m)\n    fd = ft_Crane(0.1)\n    Di = 0.1\n    fd_act = Clamond((7500000.0 * Di), eD=(roughness_Farshad(ID='Carbon steel, bare', D=Di) / Di))\n    assert_close(fd, fd_act, rtol=5e-06)", "ground_truth": "friction_factor_methods(200, 0, True)", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_7", "reponame": "fluids", "testpath": "tests/test_friction.py", "testname": "test_friction.py", "classname": null, "funcname": "test_friction_Colebrook", "imports": ["from math import isnan, log10, pi", "import pytest", "from fluids.friction import Alshul_1952, Avci_Karagoz_2009, Barr_1981, Blasius, Brkic_2011_1, Brkic_2011_2, Buzzelli_2008, Chen_1979, Churchill_1973, Churchill_1977, Clamond, Colebrook, Eck_1973, Fang_2011, Haaland, Jain_1976, Manadilli_1997, Moody, Papaevangelo_2010, Prandtl_von_Karman_Nikuradse, Rao_Kumar_2007, Romeo_2002, Round_1980, Serghides_1, Serghides_2, Shacham_1980, Sonnad_Goudar_2006, Swamee_Jain_1976, Tsal_1989, Wood_1966, Zigrang_Sylvester_1, Zigrang_Sylvester_2, _Farshad_roughness, _roughness, friction_factor, friction_factor_curved, friction_factor_curved_methods, friction_factor_methods, friction_laminar, friction_plate_Kumar, friction_plate_Martin_1999, friction_plate_Martin_VDI, friction_plate_Muley_Manglik, ft_Crane, helical_laminar_fd_Mori_Nakayama, helical_laminar_fd_Schmidt, helical_laminar_fd_White, helical_Re_crit, helical_transition_Re_Ito, helical_transition_Re_Kubair_Kuloor, helical_transition_Re_Kutateladze_Borishanskii, helical_transition_Re_Schmidt, helical_transition_Re_Seth_Stahel, helical_transition_Re_Srinivasan, helical_turbulent_fd_Czop, helical_turbulent_fd_Guo, helical_turbulent_fd_Ju, helical_turbulent_fd_Mandal_Nigam, helical_turbulent_fd_Mori_Nakayama, helical_turbulent_fd_Prasad, helical_turbulent_fd_Schmidt, helical_turbulent_fd_Srinivasan, material_roughness, nearest_material_roughness, one_phase_dP, one_phase_dP_dz_acceleration, one_phase_dP_gravitational, roughness_Farshad, transmission_factor, von_Karman", "from fluids.numerics import assert_close, assert_close1d, assert_close3d, linspace, logspace, secant"], "code": "def test_friction_Colebrook():\n    assert_close(Colebrook(100000.0, 0.0001), 0.018513866077471648)\n    assert (Colebrook(100000.0, 0.0001, (- 1)) == Clamond(100000.0, 0.0001))\n    assert (Colebrook(1, 0.0001, (- 1)) == Colebrook(1, 0.0001))", "masked_code": "def test_friction_Colebrook():\n    assert_close(Colebrook(100000.0, 0.0001), 0.018513866077471648)\n    assert (Colebrook(100000.0, 0.0001, (- 1)) == '???')\n    assert (Colebrook(1, 0.0001, (- 1)) == Colebrook(1, 0.0001))", "ground_truth": "Clamond(100000.0, 0.0001)", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_8", "reponame": "fluids", "testpath": "tests/test_friction.py", "testname": "test_friction.py", "classname": null, "funcname": "test_friction_Colebrook", "imports": ["from math import isnan, log10, pi", "import pytest", "from fluids.friction import Alshul_1952, Avci_Karagoz_2009, Barr_1981, Blasius, Brkic_2011_1, Brkic_2011_2, Buzzelli_2008, Chen_1979, Churchill_1973, Churchill_1977, Clamond, Colebrook, Eck_1973, Fang_2011, Haaland, Jain_1976, Manadilli_1997, Moody, Papaevangelo_2010, Prandtl_von_Karman_Nikuradse, Rao_Kumar_2007, Romeo_2002, Round_1980, Serghides_1, Serghides_2, Shacham_1980, Sonnad_Goudar_2006, Swamee_Jain_1976, Tsal_1989, Wood_1966, Zigrang_Sylvester_1, Zigrang_Sylvester_2, _Farshad_roughness, _roughness, friction_factor, friction_factor_curved, friction_factor_curved_methods, friction_factor_methods, friction_laminar, friction_plate_Kumar, friction_plate_Martin_1999, friction_plate_Martin_VDI, friction_plate_Muley_Manglik, ft_Crane, helical_laminar_fd_Mori_Nakayama, helical_laminar_fd_Schmidt, helical_laminar_fd_White, helical_Re_crit, helical_transition_Re_Ito, helical_transition_Re_Kubair_Kuloor, helical_transition_Re_Kutateladze_Borishanskii, helical_transition_Re_Schmidt, helical_transition_Re_Seth_Stahel, helical_transition_Re_Srinivasan, helical_turbulent_fd_Czop, helical_turbulent_fd_Guo, helical_turbulent_fd_Ju, helical_turbulent_fd_Mandal_Nigam, helical_turbulent_fd_Mori_Nakayama, helical_turbulent_fd_Prasad, helical_turbulent_fd_Schmidt, helical_turbulent_fd_Srinivasan, material_roughness, nearest_material_roughness, one_phase_dP, one_phase_dP_dz_acceleration, one_phase_dP_gravitational, roughness_Farshad, transmission_factor, von_Karman", "from fluids.numerics import assert_close, assert_close1d, assert_close3d, linspace, logspace, secant"], "code": "def test_friction_Colebrook():\n    assert_close(Colebrook(100000.0, 0.0001), 0.018513866077471648)\n    assert (Colebrook(100000.0, 0.0001, (- 1)) == Clamond(100000.0, 0.0001))\n    assert (Colebrook(1, 0.0001, (- 1)) == Colebrook(1, 0.0001))", "masked_code": "def test_friction_Colebrook():\n    assert_close(Colebrook(100000.0, 0.0001), 0.018513866077471648)\n    assert (Colebrook(100000.0, 0.0001, (- 1)) == Clamond(100000.0, 0.0001))\n    assert (Colebrook(1, 0.0001, (- 1)) == '???')", "ground_truth": "Colebrook(1, 0.0001)", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_9", "reponame": "fluids", "testpath": "tests/test_friction.py", "testname": "test_friction.py", "classname": null, "funcname": "test_friction_factor_curved", "imports": ["from math import isnan, log10, pi", "import pytest", "from fluids.friction import Alshul_1952, Avci_Karagoz_2009, Barr_1981, Blasius, Brkic_2011_1, Brkic_2011_2, Buzzelli_2008, Chen_1979, Churchill_1973, Churchill_1977, Clamond, Colebrook, Eck_1973, Fang_2011, Haaland, Jain_1976, Manadilli_1997, Moody, Papaevangelo_2010, Prandtl_von_Karman_Nikuradse, Rao_Kumar_2007, Romeo_2002, Round_1980, Serghides_1, Serghides_2, Shacham_1980, Sonnad_Goudar_2006, Swamee_Jain_1976, Tsal_1989, Wood_1966, Zigrang_Sylvester_1, Zigrang_Sylvester_2, _Farshad_roughness, _roughness, friction_factor, friction_factor_curved, friction_factor_curved_methods, friction_factor_methods, friction_laminar, friction_plate_Kumar, friction_plate_Martin_1999, friction_plate_Martin_VDI, friction_plate_Muley_Manglik, ft_Crane, helical_laminar_fd_Mori_Nakayama, helical_laminar_fd_Schmidt, helical_laminar_fd_White, helical_Re_crit, helical_transition_Re_Ito, helical_transition_Re_Kubair_Kuloor, helical_transition_Re_Kutateladze_Borishanskii, helical_transition_Re_Schmidt, helical_transition_Re_Seth_Stahel, helical_transition_Re_Srinivasan, helical_turbulent_fd_Czop, helical_turbulent_fd_Guo, helical_turbulent_fd_Ju, helical_turbulent_fd_Mandal_Nigam, helical_turbulent_fd_Mori_Nakayama, helical_turbulent_fd_Prasad, helical_turbulent_fd_Schmidt, helical_turbulent_fd_Srinivasan, material_roughness, nearest_material_roughness, one_phase_dP, one_phase_dP_dz_acceleration, one_phase_dP_gravitational, roughness_Farshad, transmission_factor, von_Karman", "from fluids.numerics import assert_close, assert_close1d, assert_close3d, linspace, logspace, secant"], "code": "def test_friction_factor_curved():\n    fd = friction_factor_curved(20000.0, 0.01, 0.02)\n    assert_close(fd, 0.050134646621603024)\n    fd = friction_factor_curved(250, 0.02, 0.1)\n    assert_close(fd, 0.47460725672835236)\n    fd_transition = [friction_factor_curved(i, 0.01, 0.02) for i in [16779, 16780]]\n    assert_close1d(fd_transition, [0.03323676794260526, 0.057221855744623344])\n    with pytest.raises(Exception):\n        friction_factor_curved(16779, 0.01, 0.02, Method='BADMETHOD')\n    with pytest.raises(Exception):\n        friction_factor_curved(16779, 0.01, 0.02, Rec_method='BADMETHOD')\n    fd_rough_false = friction_factor_curved(20000, 0.01, 0.02, roughness=0.0001, turbulent_method='Guo')\n    assert_close(fd_rough_false, 0.1014240343662085)\n    methods = friction_factor_curved_methods(20000, 0.01, 0.02, check_ranges=True)\n    assert (sorted(methods) == sorted(['Guo', 'Ju', 'Schmidt turbulent', 'Prasad', 'Mandel Nigam', 'Mori Nakayama turbulent', 'Czop', 'Srinivasan turbulent']))\n    methods = friction_factor_curved_methods(2000, 0.01, 0.02, check_ranges=True)\n    assert (sorted(methods) == sorted(['White', 'Schmidt laminar', 'Mori Nakayama laminar']))\n    assert ('Schmidt turbulent' in friction_factor_curved_methods(Re=100000.0, Di=0.02, Dc=0.5))\n    assert (11 == len(friction_factor_curved_methods(Re=100000.0, Di=0.02, Dc=0.5, check_ranges=False)))\n    for m in friction_factor_curved_methods(Re=100000.0, Di=0.02, Dc=0.5, check_ranges=False):\n        friction_factor_curved(2000, 0.01, 0.02, Method=m)\n    fd = friction_factor_curved(20000.0, 0.01, 0.02, Darcy=False)\n    assert_close(fd, 0.012533661655400756)\n    for m in ['Seth Stahel', 'Ito', 'Kubair Kuloor', 'Kutateladze Borishanskii', 'Schmidt', 'Srinivasan']:\n        helical_Re_crit(Di=0.02, Dc=0.5, Method=m)", "masked_code": "def test_friction_factor_curved():\n    fd = friction_factor_curved(20000.0, 0.01, 0.02)\n    assert_close(fd, 0.050134646621603024)\n    fd = friction_factor_curved(250, 0.02, 0.1)\n    assert_close(fd, 0.47460725672835236)\n    fd_transition = [friction_factor_curved(i, 0.01, 0.02) for i in [16779, 16780]]\n    assert_close1d(fd_transition, [0.03323676794260526, 0.057221855744623344])\n    with pytest.raises(Exception):\n        friction_factor_curved(16779, 0.01, 0.02, Method='BADMETHOD')\n    with pytest.raises(Exception):\n        friction_factor_curved(16779, 0.01, 0.02, Rec_method='BADMETHOD')\n    fd_rough_false = friction_factor_curved(20000, 0.01, 0.02, roughness=0.0001, turbulent_method='Guo')\n    assert_close(fd_rough_false, 0.1014240343662085)\n    methods = friction_factor_curved_methods(20000, 0.01, 0.02, check_ranges=True)\n    assert (sorted(methods) == '???')\n    methods = friction_factor_curved_methods(2000, 0.01, 0.02, check_ranges=True)\n    assert (sorted(methods) == sorted(['White', 'Schmidt laminar', 'Mori Nakayama laminar']))\n    assert ('Schmidt turbulent' in friction_factor_curved_methods(Re=100000.0, Di=0.02, Dc=0.5))\n    assert (11 == len(friction_factor_curved_methods(Re=100000.0, Di=0.02, Dc=0.5, check_ranges=False)))\n    for m in friction_factor_curved_methods(Re=100000.0, Di=0.02, Dc=0.5, check_ranges=False):\n        friction_factor_curved(2000, 0.01, 0.02, Method=m)\n    fd = friction_factor_curved(20000.0, 0.01, 0.02, Darcy=False)\n    assert_close(fd, 0.012533661655400756)\n    for m in ['Seth Stahel', 'Ito', 'Kubair Kuloor', 'Kutateladze Borishanskii', 'Schmidt', 'Srinivasan']:\n        helical_Re_crit(Di=0.02, Dc=0.5, Method=m)", "ground_truth": "sorted(['Guo', 'Ju', 'Schmidt turbulent', 'Prasad', 'Mandel Nigam', 'Mori Nakayama turbulent', 'Czop', 'Srinivasan turbulent'])", "quality_analysis": {"complexity_score": 17, "left_complexity": 4, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_10", "reponame": "fluids", "testpath": "tests/test_friction.py", "testname": "test_friction.py", "classname": null, "funcname": "test_friction_factor_curved", "imports": ["from math import isnan, log10, pi", "import pytest", "from fluids.friction import Alshul_1952, Avci_Karagoz_2009, Barr_1981, Blasius, Brkic_2011_1, Brkic_2011_2, Buzzelli_2008, Chen_1979, Churchill_1973, Churchill_1977, Clamond, Colebrook, Eck_1973, Fang_2011, Haaland, Jain_1976, Manadilli_1997, Moody, Papaevangelo_2010, Prandtl_von_Karman_Nikuradse, Rao_Kumar_2007, Romeo_2002, Round_1980, Serghides_1, Serghides_2, Shacham_1980, Sonnad_Goudar_2006, Swamee_Jain_1976, Tsal_1989, Wood_1966, Zigrang_Sylvester_1, Zigrang_Sylvester_2, _Farshad_roughness, _roughness, friction_factor, friction_factor_curved, friction_factor_curved_methods, friction_factor_methods, friction_laminar, friction_plate_Kumar, friction_plate_Martin_1999, friction_plate_Martin_VDI, friction_plate_Muley_Manglik, ft_Crane, helical_laminar_fd_Mori_Nakayama, helical_laminar_fd_Schmidt, helical_laminar_fd_White, helical_Re_crit, helical_transition_Re_Ito, helical_transition_Re_Kubair_Kuloor, helical_transition_Re_Kutateladze_Borishanskii, helical_transition_Re_Schmidt, helical_transition_Re_Seth_Stahel, helical_transition_Re_Srinivasan, helical_turbulent_fd_Czop, helical_turbulent_fd_Guo, helical_turbulent_fd_Ju, helical_turbulent_fd_Mandal_Nigam, helical_turbulent_fd_Mori_Nakayama, helical_turbulent_fd_Prasad, helical_turbulent_fd_Schmidt, helical_turbulent_fd_Srinivasan, material_roughness, nearest_material_roughness, one_phase_dP, one_phase_dP_dz_acceleration, one_phase_dP_gravitational, roughness_Farshad, transmission_factor, von_Karman", "from fluids.numerics import assert_close, assert_close1d, assert_close3d, linspace, logspace, secant"], "code": "def test_friction_factor_curved():\n    fd = friction_factor_curved(20000.0, 0.01, 0.02)\n    assert_close(fd, 0.050134646621603024)\n    fd = friction_factor_curved(250, 0.02, 0.1)\n    assert_close(fd, 0.47460725672835236)\n    fd_transition = [friction_factor_curved(i, 0.01, 0.02) for i in [16779, 16780]]\n    assert_close1d(fd_transition, [0.03323676794260526, 0.057221855744623344])\n    with pytest.raises(Exception):\n        friction_factor_curved(16779, 0.01, 0.02, Method='BADMETHOD')\n    with pytest.raises(Exception):\n        friction_factor_curved(16779, 0.01, 0.02, Rec_method='BADMETHOD')\n    fd_rough_false = friction_factor_curved(20000, 0.01, 0.02, roughness=0.0001, turbulent_method='Guo')\n    assert_close(fd_rough_false, 0.1014240343662085)\n    methods = friction_factor_curved_methods(20000, 0.01, 0.02, check_ranges=True)\n    assert (sorted(methods) == sorted(['Guo', 'Ju', 'Schmidt turbulent', 'Prasad', 'Mandel Nigam', 'Mori Nakayama turbulent', 'Czop', 'Srinivasan turbulent']))\n    methods = friction_factor_curved_methods(2000, 0.01, 0.02, check_ranges=True)\n    assert (sorted(methods) == sorted(['White', 'Schmidt laminar', 'Mori Nakayama laminar']))\n    assert ('Schmidt turbulent' in friction_factor_curved_methods(Re=100000.0, Di=0.02, Dc=0.5))\n    assert (11 == len(friction_factor_curved_methods(Re=100000.0, Di=0.02, Dc=0.5, check_ranges=False)))\n    for m in friction_factor_curved_methods(Re=100000.0, Di=0.02, Dc=0.5, check_ranges=False):\n        friction_factor_curved(2000, 0.01, 0.02, Method=m)\n    fd = friction_factor_curved(20000.0, 0.01, 0.02, Darcy=False)\n    assert_close(fd, 0.012533661655400756)\n    for m in ['Seth Stahel', 'Ito', 'Kubair Kuloor', 'Kutateladze Borishanskii', 'Schmidt', 'Srinivasan']:\n        helical_Re_crit(Di=0.02, Dc=0.5, Method=m)", "masked_code": "def test_friction_factor_curved():\n    fd = friction_factor_curved(20000.0, 0.01, 0.02)\n    assert_close(fd, 0.050134646621603024)\n    fd = friction_factor_curved(250, 0.02, 0.1)\n    assert_close(fd, 0.47460725672835236)\n    fd_transition = [friction_factor_curved(i, 0.01, 0.02) for i in [16779, 16780]]\n    assert_close1d(fd_transition, [0.03323676794260526, 0.057221855744623344])\n    with pytest.raises(Exception):\n        friction_factor_curved(16779, 0.01, 0.02, Method='BADMETHOD')\n    with pytest.raises(Exception):\n        friction_factor_curved(16779, 0.01, 0.02, Rec_method='BADMETHOD')\n    fd_rough_false = friction_factor_curved(20000, 0.01, 0.02, roughness=0.0001, turbulent_method='Guo')\n    assert_close(fd_rough_false, 0.1014240343662085)\n    methods = friction_factor_curved_methods(20000, 0.01, 0.02, check_ranges=True)\n    assert (sorted(methods) == sorted(['Guo', 'Ju', 'Schmidt turbulent', 'Prasad', 'Mandel Nigam', 'Mori Nakayama turbulent', 'Czop', 'Srinivasan turbulent']))\n    methods = friction_factor_curved_methods(2000, 0.01, 0.02, check_ranges=True)\n    assert (sorted(methods) == '???')\n    assert ('Schmidt turbulent' in friction_factor_curved_methods(Re=100000.0, Di=0.02, Dc=0.5))\n    assert (11 == len(friction_factor_curved_methods(Re=100000.0, Di=0.02, Dc=0.5, check_ranges=False)))\n    for m in friction_factor_curved_methods(Re=100000.0, Di=0.02, Dc=0.5, check_ranges=False):\n        friction_factor_curved(2000, 0.01, 0.02, Method=m)\n    fd = friction_factor_curved(20000.0, 0.01, 0.02, Darcy=False)\n    assert_close(fd, 0.012533661655400756)\n    for m in ['Seth Stahel', 'Ito', 'Kubair Kuloor', 'Kutateladze Borishanskii', 'Schmidt', 'Srinivasan']:\n        helical_Re_crit(Di=0.02, Dc=0.5, Method=m)", "ground_truth": "sorted(['White', 'Schmidt laminar', 'Mori Nakayama laminar'])", "quality_analysis": {"complexity_score": 12, "left_complexity": 4, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_11", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_SA_partial", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_SA_partial():\n    SA = (SA_partial_cylindrical_body(L=(120 * inch), D=(72 * inch), h=(24 * inch)) + (2 * A_partial_circle(D=(72 * inch), h=(24 * inch))))\n    assert_close((SA / (foot ** 2)), ((8.250207631 * 2) + 73.85756504))\n    assert_close(A_partial_circle(D=72, h=24), 1188.02989891)\n    assert_close(A_partial_circle(D=72, h=72), ((0.25 * pi) * (72 ** 2)))\n    assert_close(A_partial_circle(D=72, h=0), 0)\n    assert (A_partial_circle(D=72, h=(72 * (1 + 1e-15))) == A_partial_circle(D=72, h=72))\n    assert (0 == A_partial_circle(D=72, h=1e-09))\n    assert (0 == A_partial_circle(D=72, h=(- 1e-20)))\n    assert_close(SA_partial_cylindrical_body(L=200.0, D=96.0, h=22.0), 19168.852890279868, rtol=1e-12)\n    assert_close(SA_partial_cylindrical_body(L=200.0, D=96.0, h=96), ((pi * 96) * 200.0), rtol=1e-15)\n    assert (0 == SA_partial_cylindrical_body(L=200.0, D=96.0, h=0))\n    assert (0 == SA_partial_cylindrical_body(L=200.0, D=96.0, h=(- 1e-14)))\n    SA_higher = SA_partial_cylindrical_body(L=200.0, D=1.0, h=(1 + 1e-15))\n    assert_close(SA_higher, (pi * 200.0), rtol=1e-15)", "masked_code": "def test_SA_partial():\n    SA = (SA_partial_cylindrical_body(L=(120 * inch), D=(72 * inch), h=(24 * inch)) + (2 * A_partial_circle(D=(72 * inch), h=(24 * inch))))\n    assert_close((SA / (foot ** 2)), ((8.250207631 * 2) + 73.85756504))\n    assert_close(A_partial_circle(D=72, h=24), 1188.02989891)\n    assert_close(A_partial_circle(D=72, h=72), ((0.25 * pi) * (72 ** 2)))\n    assert_close(A_partial_circle(D=72, h=0), 0)\n    assert (A_partial_circle(D=72, h=(72 * (1 + 1e-15))) == '???')\n    assert (0 == A_partial_circle(D=72, h=1e-09))\n    assert (0 == A_partial_circle(D=72, h=(- 1e-20)))\n    assert_close(SA_partial_cylindrical_body(L=200.0, D=96.0, h=22.0), 19168.852890279868, rtol=1e-12)\n    assert_close(SA_partial_cylindrical_body(L=200.0, D=96.0, h=96), ((pi * 96) * 200.0), rtol=1e-15)\n    assert (0 == SA_partial_cylindrical_body(L=200.0, D=96.0, h=0))\n    assert (0 == SA_partial_cylindrical_body(L=200.0, D=96.0, h=(- 1e-14)))\n    SA_higher = SA_partial_cylindrical_body(L=200.0, D=1.0, h=(1 + 1e-15))\n    assert_close(SA_higher, (pi * 200.0), rtol=1e-15)", "ground_truth": "A_partial_circle(D=72, h=72)", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_12", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_SA_partial_horiz_conical_head", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_SA_partial_horiz_conical_head():\n    As_expect = [101.35826, 141.37167, 181.38508]\n    hs = [(24 * inch), (36 * inch), (48 * inch)]\n    for (h, A_expect) in zip(hs, As_expect):\n        SA = ((2 * SA_partial_horiz_conical_head(D=(72 * inch), a=(48 * inch), h=h)) + SA_partial_cylindrical_body(D=(72 * inch), L=(120 * inch), h=h))\n        A_calc = (SA / (foot ** 2))\n        assert_close(A_calc, A_expect, rtol=4e-08)\n    assert (0 == SA_partial_horiz_conical_head(D=72.0, a=48.0, h=0))\n    assert (0 == SA_partial_horiz_conical_head(D=72.0, a=48.0, h=(- 1e-16)))\n    assert (SA_partial_horiz_conical_head(D=72.0, a=48.0, h=72) == SA_partial_horiz_conical_head(D=72.0, a=48.0, h=(72 + 1e-05)))\n    assert_close(SA_partial_horiz_conical_head(D=72.0, a=0, h=35), A_partial_circle(D=72, h=35), rtol=1e-12)\n    T1 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='conical', sideA_a=(48 * inch), sideB='same')\n    assert_close((T1.SA_from_h((24 * inch)) / (foot ** 2)), 101.35826, rtol=1e-07)\n    assert_close((T1.SA_from_h((36 * inch)) / (foot ** 2)), 141.37167, rtol=1e-07)\n    assert_close((T1.SA_from_h((48 * inch)) / (foot ** 2)), 181.38508, rtol=1e-07)\n    assert (T1.SA_from_h(0) == 0.0)\n    assert_close(T1.SA_from_h(T1.h_max), T1.A, rtol=1e-14)", "masked_code": "def test_SA_partial_horiz_conical_head():\n    As_expect = [101.35826, 141.37167, 181.38508]\n    hs = [(24 * inch), (36 * inch), (48 * inch)]\n    for (h, A_expect) in zip(hs, As_expect):\n        SA = ((2 * SA_partial_horiz_conical_head(D=(72 * inch), a=(48 * inch), h=h)) + SA_partial_cylindrical_body(D=(72 * inch), L=(120 * inch), h=h))\n        A_calc = (SA / (foot ** 2))\n        assert_close(A_calc, A_expect, rtol=4e-08)\n    assert (0 == SA_partial_horiz_conical_head(D=72.0, a=48.0, h=0))\n    assert (0 == SA_partial_horiz_conical_head(D=72.0, a=48.0, h=(- 1e-16)))\n    assert (SA_partial_horiz_conical_head(D=72.0, a=48.0, h=72) == '???')\n    assert_close(SA_partial_horiz_conical_head(D=72.0, a=0, h=35), A_partial_circle(D=72, h=35), rtol=1e-12)\n    T1 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='conical', sideA_a=(48 * inch), sideB='same')\n    assert_close((T1.SA_from_h((24 * inch)) / (foot ** 2)), 101.35826, rtol=1e-07)\n    assert_close((T1.SA_from_h((36 * inch)) / (foot ** 2)), 141.37167, rtol=1e-07)\n    assert_close((T1.SA_from_h((48 * inch)) / (foot ** 2)), 181.38508, rtol=1e-07)\n    assert (T1.SA_from_h(0) == 0.0)\n    assert_close(T1.SA_from_h(T1.h_max), T1.A, rtol=1e-14)", "ground_truth": "SA_partial_horiz_conical_head(D=72.0, a=48.0, h=(72 + 1e-05))", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_13", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_SA_partial_horiz_spherical_head", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_SA_partial_horiz_spherical_head():\n    L = (120 * inch)\n    D = (72 * inch)\n    a_values = (([(24 * inch)] * 3) + ([(36 * inch)] * 3))\n    h_values = ([(24 * inch), (36 * inch), (48 * inch)] * 2)\n    SA_expect = [99.49977, 135.08848, 170.6772, 111.55668, 150.79645, 190.03622]\n    SA_expect = [(i * (foot ** 2)) for i in SA_expect]\n    for i in range(6):\n        SA = ((2 * SA_partial_horiz_spherical_head(D=D, a=a_values[i], h=h_values[i])) + SA_partial_cylindrical_body(D=D, L=L, h=h_values[i]))\n        assert_close(SA, SA_expect[i], rtol=4e-08)\n    SA_calc = SA_partial_horiz_spherical_head(D=72.0, a=48.0, h=24.0)\n    assert_close(SA_calc, 2027.2672091672684, rtol=1e-07)\n    assert (0 == SA_partial_horiz_spherical_head(D=72.0, a=48.0, h=1e-20))\n    assert (0 == SA_partial_horiz_spherical_head(D=72.0, a=48.0, h=(- 1e-12)))\n    assert (SA_partial_horiz_spherical_head(D=72.0, a=48.0, h=7200) == SA_partial_horiz_spherical_head(D=72.0, a=48.0, h=72))\n    assert_close(SA_partial_horiz_spherical_head(D=72.0, a=(36 + 1e-11), h=22), SA_partial_horiz_spherical_head(D=72.0, a=36, h=22), rtol=1e-08)\n    T1 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='spherical', sideA_a=(24 * inch), sideB='same')\n    assert_close((T1.SA_from_h((24 * inch)) / (foot ** 2)), 99.49977, rtol=1e-07)\n    assert_close((T1.SA_from_h((36 * inch)) / (foot ** 2)), 135.08848, rtol=1e-07)\n    assert_close((T1.SA_from_h((48 * inch)) / (foot ** 2)), 170.6772, rtol=1e-07)\n    assert (0.0 == T1.SA_from_h(0))\n    assert_close(T1.SA_from_h(T1.h_max), T1.A, rtol=1e-07)\n    T2 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='spherical', sideA_a=(36 * inch), sideB='same')\n    assert_close((T2.SA_from_h((24 * inch)) / (foot ** 2)), 111.55668, rtol=1e-07)\n    assert_close((T2.SA_from_h((36 * inch)) / (foot ** 2)), 150.79645, rtol=1e-07)\n    assert_close((T2.SA_from_h((48 * inch)) / (foot ** 2)), 190.03622, rtol=1e-07)\n    assert (0.0 == T2.SA_from_h(0))\n    assert_close(T2.SA_from_h(T2.h_max), T2.A, rtol=2e-12)", "masked_code": "def test_SA_partial_horiz_spherical_head():\n    L = (120 * inch)\n    D = (72 * inch)\n    a_values = (([(24 * inch)] * 3) + ([(36 * inch)] * 3))\n    h_values = ([(24 * inch), (36 * inch), (48 * inch)] * 2)\n    SA_expect = [99.49977, 135.08848, 170.6772, 111.55668, 150.79645, 190.03622]\n    SA_expect = [(i * (foot ** 2)) for i in SA_expect]\n    for i in range(6):\n        SA = ((2 * SA_partial_horiz_spherical_head(D=D, a=a_values[i], h=h_values[i])) + SA_partial_cylindrical_body(D=D, L=L, h=h_values[i]))\n        assert_close(SA, SA_expect[i], rtol=4e-08)\n    SA_calc = SA_partial_horiz_spherical_head(D=72.0, a=48.0, h=24.0)\n    assert_close(SA_calc, 2027.2672091672684, rtol=1e-07)\n    assert (0 == SA_partial_horiz_spherical_head(D=72.0, a=48.0, h=1e-20))\n    assert (0 == SA_partial_horiz_spherical_head(D=72.0, a=48.0, h=(- 1e-12)))\n    assert (SA_partial_horiz_spherical_head(D=72.0, a=48.0, h=7200) == '???')\n    assert_close(SA_partial_horiz_spherical_head(D=72.0, a=(36 + 1e-11), h=22), SA_partial_horiz_spherical_head(D=72.0, a=36, h=22), rtol=1e-08)\n    T1 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='spherical', sideA_a=(24 * inch), sideB='same')\n    assert_close((T1.SA_from_h((24 * inch)) / (foot ** 2)), 99.49977, rtol=1e-07)\n    assert_close((T1.SA_from_h((36 * inch)) / (foot ** 2)), 135.08848, rtol=1e-07)\n    assert_close((T1.SA_from_h((48 * inch)) / (foot ** 2)), 170.6772, rtol=1e-07)\n    assert (0.0 == T1.SA_from_h(0))\n    assert_close(T1.SA_from_h(T1.h_max), T1.A, rtol=1e-07)\n    T2 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='spherical', sideA_a=(36 * inch), sideB='same')\n    assert_close((T2.SA_from_h((24 * inch)) / (foot ** 2)), 111.55668, rtol=1e-07)\n    assert_close((T2.SA_from_h((36 * inch)) / (foot ** 2)), 150.79645, rtol=1e-07)\n    assert_close((T2.SA_from_h((48 * inch)) / (foot ** 2)), 190.03622, rtol=1e-07)\n    assert (0.0 == T2.SA_from_h(0))\n    assert_close(T2.SA_from_h(T2.h_max), T2.A, rtol=2e-12)", "ground_truth": "SA_partial_horiz_spherical_head(D=72.0, a=48.0, h=72)", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_14", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_SA_partial_horiz_guppy_head", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_SA_partial_horiz_guppy_head():\n    L = (120 * inch)\n    D = (72 * inch)\n    h_values = [(24 * inch), (36 * inch), (48 * inch)]\n    SA_expect = [94.245, 129.9833, 167.06207]\n    SA_expect = [(i * (foot ** 2)) for i in SA_expect]\n    for i in range(3):\n        SA = ((2 * SA_partial_horiz_guppy_head(D=D, a=(48 * inch), h=h_values[i])) + SA_partial_cylindrical_body(D=D, L=L, h=h_values[i]))\n        assert_close(SA, SA_expect[i], rtol=5e-08)\n        assert (type(SA) is float)\n    assert (0 == SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=1e-20))\n    assert (0 == SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=(- 1e-12)))\n    assert (SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=7200) == SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=72))\n    assert_close(SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=24.0), 1467.8949780037, rtol=1e-08)\n    assert ((((((pi * 72) * inch) / 2) * 72) * inch) == SA_partial_horiz_guppy_head(D=(72 * inch), a=(36 * inch), h=(72 * inch)))\n    T1 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='guppy', sideA_a=(48 * inch), sideB='same')\n    assert_close((T1.SA_from_h((24 * inch)) / (foot ** 2)), 94.245, rtol=1e-07)\n    assert_close((T1.SA_from_h((36 * inch)) / (foot ** 2)), 129.9833, rtol=1e-07)\n    assert_close((T1.SA_from_h((48 * inch)) / (foot ** 2)), 167.06207, rtol=1e-07)\n    assert (0.0 == T1.SA_from_h(0))", "masked_code": "def test_SA_partial_horiz_guppy_head():\n    L = (120 * inch)\n    D = (72 * inch)\n    h_values = [(24 * inch), (36 * inch), (48 * inch)]\n    SA_expect = [94.245, 129.9833, 167.06207]\n    SA_expect = [(i * (foot ** 2)) for i in SA_expect]\n    for i in range(3):\n        SA = ((2 * SA_partial_horiz_guppy_head(D=D, a=(48 * inch), h=h_values[i])) + SA_partial_cylindrical_body(D=D, L=L, h=h_values[i]))\n        assert_close(SA, SA_expect[i], rtol=5e-08)\n        assert (type(SA) is float)\n    assert (0 == SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=1e-20))\n    assert (0 == SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=(- 1e-12)))\n    assert (SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=7200) == '???')\n    assert_close(SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=24.0), 1467.8949780037, rtol=1e-08)\n    assert ((((((pi * 72) * inch) / 2) * 72) * inch) == SA_partial_horiz_guppy_head(D=(72 * inch), a=(36 * inch), h=(72 * inch)))\n    T1 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='guppy', sideA_a=(48 * inch), sideB='same')\n    assert_close((T1.SA_from_h((24 * inch)) / (foot ** 2)), 94.245, rtol=1e-07)\n    assert_close((T1.SA_from_h((36 * inch)) / (foot ** 2)), 129.9833, rtol=1e-07)\n    assert_close((T1.SA_from_h((48 * inch)) / (foot ** 2)), 167.06207, rtol=1e-07)\n    assert (0.0 == T1.SA_from_h(0))", "ground_truth": "SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=72)", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_15", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_SA_partial_horiz_guppy_head", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_SA_partial_horiz_guppy_head():\n    L = (120 * inch)\n    D = (72 * inch)\n    h_values = [(24 * inch), (36 * inch), (48 * inch)]\n    SA_expect = [94.245, 129.9833, 167.06207]\n    SA_expect = [(i * (foot ** 2)) for i in SA_expect]\n    for i in range(3):\n        SA = ((2 * SA_partial_horiz_guppy_head(D=D, a=(48 * inch), h=h_values[i])) + SA_partial_cylindrical_body(D=D, L=L, h=h_values[i]))\n        assert_close(SA, SA_expect[i], rtol=5e-08)\n        assert (type(SA) is float)\n    assert (0 == SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=1e-20))\n    assert (0 == SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=(- 1e-12)))\n    assert (SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=7200) == SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=72))\n    assert_close(SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=24.0), 1467.8949780037, rtol=1e-08)\n    assert ((((((pi * 72) * inch) / 2) * 72) * inch) == SA_partial_horiz_guppy_head(D=(72 * inch), a=(36 * inch), h=(72 * inch)))\n    T1 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='guppy', sideA_a=(48 * inch), sideB='same')\n    assert_close((T1.SA_from_h((24 * inch)) / (foot ** 2)), 94.245, rtol=1e-07)\n    assert_close((T1.SA_from_h((36 * inch)) / (foot ** 2)), 129.9833, rtol=1e-07)\n    assert_close((T1.SA_from_h((48 * inch)) / (foot ** 2)), 167.06207, rtol=1e-07)\n    assert (0.0 == T1.SA_from_h(0))", "masked_code": "def test_SA_partial_horiz_guppy_head():\n    L = (120 * inch)\n    D = (72 * inch)\n    h_values = [(24 * inch), (36 * inch), (48 * inch)]\n    SA_expect = [94.245, 129.9833, 167.06207]\n    SA_expect = [(i * (foot ** 2)) for i in SA_expect]\n    for i in range(3):\n        SA = ((2 * SA_partial_horiz_guppy_head(D=D, a=(48 * inch), h=h_values[i])) + SA_partial_cylindrical_body(D=D, L=L, h=h_values[i]))\n        assert_close(SA, SA_expect[i], rtol=5e-08)\n        assert (type(SA) is float)\n    assert (0 == SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=1e-20))\n    assert (0 == SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=(- 1e-12)))\n    assert (SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=7200) == SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=72))\n    assert_close(SA_partial_horiz_guppy_head(D=72.0, a=48.0, h=24.0), 1467.8949780037, rtol=1e-08)\n    assert ((((((pi * 72) * inch) / 2) * 72) * inch) == '???')\n    T1 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='guppy', sideA_a=(48 * inch), sideB='same')\n    assert_close((T1.SA_from_h((24 * inch)) / (foot ** 2)), 94.245, rtol=1e-07)\n    assert_close((T1.SA_from_h((36 * inch)) / (foot ** 2)), 129.9833, rtol=1e-07)\n    assert_close((T1.SA_from_h((48 * inch)) / (foot ** 2)), 167.06207, rtol=1e-07)\n    assert (0.0 == T1.SA_from_h(0))", "ground_truth": "SA_partial_horiz_guppy_head(D=(72 * inch), a=(36 * inch), h=(72 * inch))", "quality_analysis": {"complexity_score": 19, "left_complexity": 16, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_16", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_SA_partial_horiz_ellipsoidal_head", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_SA_partial_horiz_ellipsoidal_head():\n    L = (120 * inch)\n    D = (72 * inch)\n    h_values = ([(24 * inch), (36 * inch), (48 * inch)] * 3)\n    SA_expect = [102.59905, 138.74815, 174.89725, 111.55668, 150.79645, 190.03622, 121.09692, 163.71486, 206.33279]\n    SA_expect = [(i * (foot ** 2)) for i in SA_expect]\n    a_values = ((([(24 * inch)] * 3) + ([(36 * inch)] * 3)) + ([(48 * inch)] * 3))\n    for i in range(9):\n        SA = ((2 * SA_partial_horiz_ellipsoidal_head(D=D, a=a_values[i], h=h_values[i])) + SA_partial_cylindrical_body(D=D, L=L, h=h_values[i]))\n        assert_close(SA, SA_expect[i], rtol=5e-08)\n    assert (0 == SA_partial_horiz_ellipsoidal_head(D=72.0, a=48.0, h=1e-20))\n    assert (0 == SA_partial_horiz_ellipsoidal_head(D=72.0, a=48.0, h=(- 1e-12)))\n    assert (SA_partial_horiz_ellipsoidal_head(D=72.0, a=48.0, h=7200) == SA_partial_horiz_ellipsoidal_head(D=72.0, a=48.0, h=72))\n    assert_close(SA_partial_horiz_ellipsoidal_head(D=72.0, a=48.0, h=24.0), 3401.2336225352738, rtol=1e-11)\n    T1 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='ellipsoidal', sideA_a=(24 * inch), sideB='same')\n    assert_close((T1.SA_from_h((24 * inch)) / (foot ** 2)), 102.59905, rtol=1e-07)\n    assert_close((T1.SA_from_h((36 * inch)) / (foot ** 2)), 138.74815, rtol=1e-07)\n    assert_close((T1.SA_from_h((48 * inch)) / (foot ** 2)), 174.89725, rtol=1e-07)\n    assert_close(T1.SA_from_h(T1.h_max), T1.A, rtol=1e-12)\n    assert (0.0 == T1.SA_from_h(0))\n    T2 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='ellipsoidal', sideA_a=(36 * inch), sideB='same')\n    assert_close((T2.SA_from_h((24 * inch)) / (foot ** 2)), 111.55668, rtol=1e-07)\n    assert_close((T2.SA_from_h((36 * inch)) / (foot ** 2)), 150.79645, rtol=1e-07)\n    assert_close((T2.SA_from_h((48 * inch)) / (foot ** 2)), 190.03622, rtol=1e-07)\n    assert (0.0 == T2.SA_from_h(0))\n    assert_close(T2.SA_from_h(T2.h_max), T2.A, rtol=1e-12)\n    T3 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='ellipsoidal', sideA_a=(48 * inch), sideB='same')\n    assert_close((T3.SA_from_h((24 * inch)) / (foot ** 2)), 121.09692, rtol=1e-07)\n    assert_close((T3.SA_from_h((36 * inch)) / (foot ** 2)), 163.71486, rtol=1e-07)\n    assert_close((T3.SA_from_h((48 * inch)) / (foot ** 2)), 206.33279, rtol=1e-07)\n    assert (0.0 == T3.SA_from_h(0))\n    assert_close(T3.SA_from_h(T3.h_max), T3.A, rtol=1e-12)", "masked_code": "def test_SA_partial_horiz_ellipsoidal_head():\n    L = (120 * inch)\n    D = (72 * inch)\n    h_values = ([(24 * inch), (36 * inch), (48 * inch)] * 3)\n    SA_expect = [102.59905, 138.74815, 174.89725, 111.55668, 150.79645, 190.03622, 121.09692, 163.71486, 206.33279]\n    SA_expect = [(i * (foot ** 2)) for i in SA_expect]\n    a_values = ((([(24 * inch)] * 3) + ([(36 * inch)] * 3)) + ([(48 * inch)] * 3))\n    for i in range(9):\n        SA = ((2 * SA_partial_horiz_ellipsoidal_head(D=D, a=a_values[i], h=h_values[i])) + SA_partial_cylindrical_body(D=D, L=L, h=h_values[i]))\n        assert_close(SA, SA_expect[i], rtol=5e-08)\n    assert (0 == SA_partial_horiz_ellipsoidal_head(D=72.0, a=48.0, h=1e-20))\n    assert (0 == SA_partial_horiz_ellipsoidal_head(D=72.0, a=48.0, h=(- 1e-12)))\n    assert (SA_partial_horiz_ellipsoidal_head(D=72.0, a=48.0, h=7200) == '???')\n    assert_close(SA_partial_horiz_ellipsoidal_head(D=72.0, a=48.0, h=24.0), 3401.2336225352738, rtol=1e-11)\n    T1 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='ellipsoidal', sideA_a=(24 * inch), sideB='same')\n    assert_close((T1.SA_from_h((24 * inch)) / (foot ** 2)), 102.59905, rtol=1e-07)\n    assert_close((T1.SA_from_h((36 * inch)) / (foot ** 2)), 138.74815, rtol=1e-07)\n    assert_close((T1.SA_from_h((48 * inch)) / (foot ** 2)), 174.89725, rtol=1e-07)\n    assert_close(T1.SA_from_h(T1.h_max), T1.A, rtol=1e-12)\n    assert (0.0 == T1.SA_from_h(0))\n    T2 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='ellipsoidal', sideA_a=(36 * inch), sideB='same')\n    assert_close((T2.SA_from_h((24 * inch)) / (foot ** 2)), 111.55668, rtol=1e-07)\n    assert_close((T2.SA_from_h((36 * inch)) / (foot ** 2)), 150.79645, rtol=1e-07)\n    assert_close((T2.SA_from_h((48 * inch)) / (foot ** 2)), 190.03622, rtol=1e-07)\n    assert (0.0 == T2.SA_from_h(0))\n    assert_close(T2.SA_from_h(T2.h_max), T2.A, rtol=1e-12)\n    T3 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='ellipsoidal', sideA_a=(48 * inch), sideB='same')\n    assert_close((T3.SA_from_h((24 * inch)) / (foot ** 2)), 121.09692, rtol=1e-07)\n    assert_close((T3.SA_from_h((36 * inch)) / (foot ** 2)), 163.71486, rtol=1e-07)\n    assert_close((T3.SA_from_h((48 * inch)) / (foot ** 2)), 206.33279, rtol=1e-07)\n    assert (0.0 == T3.SA_from_h(0))\n    assert_close(T3.SA_from_h(T3.h_max), T3.A, rtol=1e-12)", "ground_truth": "SA_partial_horiz_ellipsoidal_head(D=72.0, a=48.0, h=72)", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_17", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_SA_partial_horiz_torispherical_head", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_SA_partial_horiz_torispherical_head():\n    assert_close(SA_partial_horiz_torispherical_head(D=1.8288, f=1.0, k=0.06, h=0.6095999999999999), 0.9491605631461236)\n    assert_close(SA_partial_horiz_torispherical_head(D=1.8288, f=0.9, k=0.1, h=0.6095999999999999), 1.037030313486593, rtol=1e-06)\n    L = (120 * inch)\n    D = (72 * inch)\n    h_values = [(2.28 * inch), (24 * inch), (36 * inch), (48 * inch), (69.72 * inch)]\n    h_values += [(3 * inch), (24 * inch), (36 * inch), (48 * inch), (69 * inch)]\n    SA_expect = [22.74924, 94.29092, 127.74876, 161.2066, 232.74828, 26.82339, 96.18257, 130.22802, 164.27347, 233.63265]\n    SA_expect = [(i * (foot ** 2)) for i in SA_expect]\n    k_values = (([0.06] * 5) + ([0.1] * 5))\n    f_values = (([1.0] * 5) + ([0.9] * 5))\n    for i in range(9):\n        SA = ((2 * SA_partial_horiz_torispherical_head(D=D, f=f_values[i], k=k_values[i], h=h_values[i])) + SA_partial_cylindrical_body(D=D, L=L, h=h_values[i]))\n        assert_close(SA, SA_expect[i], rtol=2e-07)\n    SA = SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=2)\n    assert_close(SA, 80.54614956735351, rtol=1e-07)\n    SA = SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=20)\n    assert_close(SA, 1171.9138610357936, rtol=1e-07)\n    SA = SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=71)\n    assert_close(SA, 4784.441787378645, rtol=1e-07)\n    SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=1e-20)\n    assert (0 == SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=0))\n    assert (0 == SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=(- 1e-12)))\n    assert (SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=7200) == SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=72))\n    assert_close(SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=1e-13), 3.859157404406146e-12, rtol=0.1)\n    T1 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='torispherical', sideA_f=1, sideA_k=0.06, sideB='same')\n    assert_close((T1.SA_from_h((2.28 * inch)) / (foot ** 2)), 22.74924, rtol=1e-07)\n    assert_close((T1.SA_from_h((24 * inch)) / (foot ** 2)), 94.29092, rtol=1e-07)\n    assert_close((T1.SA_from_h((36 * inch)) / (foot ** 2)), 127.74876, rtol=1e-07)\n    assert_close((T1.SA_from_h((48 * inch)) / (foot ** 2)), 161.2066, rtol=1e-07)\n    assert_close((T1.SA_from_h((69.72 * inch)) / (foot ** 2)), 232.74828, rtol=1e-07)\n    assert (0.0 == T1.SA_from_h(0))\n    assert_close(T1.SA_from_h(T1.h_max), T1.A, rtol=1e-12)\n    T2 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='torispherical', sideA_f=0.9, sideA_k=0.1, sideB='same')\n    assert_close((T2.SA_from_h((3 * inch)) / (foot ** 2)), 26.82339, rtol=2e-07)\n    assert_close((T2.SA_from_h((24 * inch)) / (foot ** 2)), 96.18257, rtol=1e-07)\n    assert_close((T2.SA_from_h((36 * inch)) / (foot ** 2)), 130.22802, rtol=1e-07)\n    assert_close((T2.SA_from_h((48 * inch)) / (foot ** 2)), 164.27347, rtol=1e-07)\n    assert_close((T2.SA_from_h((69 * inch)) / (foot ** 2)), 233.63265, rtol=1e-07)\n    assert (0.0 == T2.SA_from_h(0))\n    assert_close(T2.SA_from_h(T2.h_max), T2.A, rtol=1e-12)", "masked_code": "def test_SA_partial_horiz_torispherical_head():\n    assert_close(SA_partial_horiz_torispherical_head(D=1.8288, f=1.0, k=0.06, h=0.6095999999999999), 0.9491605631461236)\n    assert_close(SA_partial_horiz_torispherical_head(D=1.8288, f=0.9, k=0.1, h=0.6095999999999999), 1.037030313486593, rtol=1e-06)\n    L = (120 * inch)\n    D = (72 * inch)\n    h_values = [(2.28 * inch), (24 * inch), (36 * inch), (48 * inch), (69.72 * inch)]\n    h_values += [(3 * inch), (24 * inch), (36 * inch), (48 * inch), (69 * inch)]\n    SA_expect = [22.74924, 94.29092, 127.74876, 161.2066, 232.74828, 26.82339, 96.18257, 130.22802, 164.27347, 233.63265]\n    SA_expect = [(i * (foot ** 2)) for i in SA_expect]\n    k_values = (([0.06] * 5) + ([0.1] * 5))\n    f_values = (([1.0] * 5) + ([0.9] * 5))\n    for i in range(9):\n        SA = ((2 * SA_partial_horiz_torispherical_head(D=D, f=f_values[i], k=k_values[i], h=h_values[i])) + SA_partial_cylindrical_body(D=D, L=L, h=h_values[i]))\n        assert_close(SA, SA_expect[i], rtol=2e-07)\n    SA = SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=2)\n    assert_close(SA, 80.54614956735351, rtol=1e-07)\n    SA = SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=20)\n    assert_close(SA, 1171.9138610357936, rtol=1e-07)\n    SA = SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=71)\n    assert_close(SA, 4784.441787378645, rtol=1e-07)\n    SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=1e-20)\n    assert (0 == SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=0))\n    assert (0 == SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=(- 1e-12)))\n    assert (SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=7200) == '???')\n    assert_close(SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=1e-13), 3.859157404406146e-12, rtol=0.1)\n    T1 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='torispherical', sideA_f=1, sideA_k=0.06, sideB='same')\n    assert_close((T1.SA_from_h((2.28 * inch)) / (foot ** 2)), 22.74924, rtol=1e-07)\n    assert_close((T1.SA_from_h((24 * inch)) / (foot ** 2)), 94.29092, rtol=1e-07)\n    assert_close((T1.SA_from_h((36 * inch)) / (foot ** 2)), 127.74876, rtol=1e-07)\n    assert_close((T1.SA_from_h((48 * inch)) / (foot ** 2)), 161.2066, rtol=1e-07)\n    assert_close((T1.SA_from_h((69.72 * inch)) / (foot ** 2)), 232.74828, rtol=1e-07)\n    assert (0.0 == T1.SA_from_h(0))\n    assert_close(T1.SA_from_h(T1.h_max), T1.A, rtol=1e-12)\n    T2 = TANK(L=(120 * inch), D=(72 * inch), horizontal=True, sideA='torispherical', sideA_f=0.9, sideA_k=0.1, sideB='same')\n    assert_close((T2.SA_from_h((3 * inch)) / (foot ** 2)), 26.82339, rtol=2e-07)\n    assert_close((T2.SA_from_h((24 * inch)) / (foot ** 2)), 96.18257, rtol=1e-07)\n    assert_close((T2.SA_from_h((36 * inch)) / (foot ** 2)), 130.22802, rtol=1e-07)\n    assert_close((T2.SA_from_h((48 * inch)) / (foot ** 2)), 164.27347, rtol=1e-07)\n    assert_close((T2.SA_from_h((69 * inch)) / (foot ** 2)), 233.63265, rtol=1e-07)\n    assert (0.0 == T2.SA_from_h(0))\n    assert_close(T2.SA_from_h(T2.h_max), T2.A, rtol=1e-12)", "ground_truth": "SA_partial_horiz_torispherical_head(D=72.0, f=1, k=0.06, h=72)", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_18", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_AirCooledExchangerFull", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_AirCooledExchangerFull():\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3)\n    assert_close(AC.bare_length, 0.0022097999999999996)\n    assert (AC.tubes_per_bundle == 224)\n    assert (AC.tubes_per_bay == (224 * 2))\n    assert (AC.tubes == ((224 * 2) * 3))\n    assert_close(AC.pitch_diagonal, 0.057238126497990836)\n    assert_close(AC.A_bare_tube_per_tube, 0.875590523880476)\n    assert_close(AC.A_bare_tube_per_row, (AC.A_bare_tube_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_bare_tube_per_bundle, (AC.A_bare_tube_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_bare_tube_per_bay, (AC.A_bare_tube_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_bare_tube, (AC.A_bare_tube_per_tube * AC.tubes))\n    assert_close(AC.A_tube_showing_per_tube, 0.7617637557760141)\n    assert_close(AC.A_tube_showing_per_row, (AC.A_tube_showing_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_tube_showing_per_bundle, (AC.A_tube_showing_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_tube_showing_per_bay, (AC.A_tube_showing_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_tube_showing, (AC.A_tube_showing_per_tube * AC.tubes))\n    assert_close(AC.A_per_fin, 0.0041762830427215765)\n    assert_close(AC.A_fin_per_tube, 18.041542744557212)\n    assert_close(AC.A_fin_per_row, (AC.A_fin_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_fin_per_bundle, (AC.A_fin_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_fin_per_bay, (AC.A_fin_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_fin, (AC.A_fin_per_tube * AC.tubes))\n    assert_close(AC.A_per_tube, 18.803306500333225)\n    assert_close(AC.A_per_row, (AC.A_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_per_bundle, (AC.A_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_per_bay, (AC.A_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A, (AC.A_per_tube * AC.tubes))\n    assert_close(AC.A_increase, 21.47500000000001)\n    assert_close(AC.A_diagonal_per_bundle, 34.05507419296123)\n    assert_close(AC.A_normal_per_bundle, 1.365674687999997)\n    assert_close(AC.A_normal_per_bundle, AC.A_normal_per_bundle)\n    assert_close(AC.A_min_per_bay, (AC.A_min_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_min, (AC.A_min_per_bay * AC.parallel_bays))\n    assert_close(AC.A_face_per_bundle, 19.858025)\n    assert_close(AC.A_face_per_bay, (AC.A_face_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_face, (AC.A_face_per_bay * AC.parallel_bays))\n    assert_close(AC.flow_area_contraction_ratio, 0.06877192982456128)\n    assert_close(AC.Di, 0.018639999999999997)\n    assert_close(AC.A_tube_flow, 0.00027288627771317794)\n    assert_close(AC.A_tube_flow_per_row, 0.015281631551937964)\n    assert_close(AC.A_tube_flow_per_bundle, 0.06112652620775186)\n    assert_close(AC.A_tube_flow_per_bay, 0.12225305241550372)\n    assert_close(AC.A_tube_flow_total, 0.36675915724651115)\n    assert_close(AC.tube_volume_per_tube, 0.0029943265480911587)\n    assert_close(AC.tube_volume_per_row, (AC.tube_volume_per_tube * AC.tubes_per_row))\n    assert_close(AC.tube_volume_per_bundle, (AC.tube_volume_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.tube_volume, (AC.tube_volume_per_tube * AC.tubes))\n    assert (AC.channels == 56)\n    assert (AC.pitch_str == 'triangular')\n    assert (AC.pitch_class == 'staggered')\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3, corbels=True)\n    assert_close(AC.A_face_per_bundle, 19.683831599999998)", "masked_code": "def test_AirCooledExchangerFull():\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3)\n    assert_close(AC.bare_length, 0.0022097999999999996)\n    assert (AC.tubes_per_bundle == '???')\n    assert (AC.tubes_per_bay == (224 * 2))\n    assert (AC.tubes == ((224 * 2) * 3))\n    assert_close(AC.pitch_diagonal, 0.057238126497990836)\n    assert_close(AC.A_bare_tube_per_tube, 0.875590523880476)\n    assert_close(AC.A_bare_tube_per_row, (AC.A_bare_tube_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_bare_tube_per_bundle, (AC.A_bare_tube_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_bare_tube_per_bay, (AC.A_bare_tube_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_bare_tube, (AC.A_bare_tube_per_tube * AC.tubes))\n    assert_close(AC.A_tube_showing_per_tube, 0.7617637557760141)\n    assert_close(AC.A_tube_showing_per_row, (AC.A_tube_showing_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_tube_showing_per_bundle, (AC.A_tube_showing_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_tube_showing_per_bay, (AC.A_tube_showing_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_tube_showing, (AC.A_tube_showing_per_tube * AC.tubes))\n    assert_close(AC.A_per_fin, 0.0041762830427215765)\n    assert_close(AC.A_fin_per_tube, 18.041542744557212)\n    assert_close(AC.A_fin_per_row, (AC.A_fin_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_fin_per_bundle, (AC.A_fin_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_fin_per_bay, (AC.A_fin_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_fin, (AC.A_fin_per_tube * AC.tubes))\n    assert_close(AC.A_per_tube, 18.803306500333225)\n    assert_close(AC.A_per_row, (AC.A_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_per_bundle, (AC.A_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_per_bay, (AC.A_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A, (AC.A_per_tube * AC.tubes))\n    assert_close(AC.A_increase, 21.47500000000001)\n    assert_close(AC.A_diagonal_per_bundle, 34.05507419296123)\n    assert_close(AC.A_normal_per_bundle, 1.365674687999997)\n    assert_close(AC.A_normal_per_bundle, AC.A_normal_per_bundle)\n    assert_close(AC.A_min_per_bay, (AC.A_min_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_min, (AC.A_min_per_bay * AC.parallel_bays))\n    assert_close(AC.A_face_per_bundle, 19.858025)\n    assert_close(AC.A_face_per_bay, (AC.A_face_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_face, (AC.A_face_per_bay * AC.parallel_bays))\n    assert_close(AC.flow_area_contraction_ratio, 0.06877192982456128)\n    assert_close(AC.Di, 0.018639999999999997)\n    assert_close(AC.A_tube_flow, 0.00027288627771317794)\n    assert_close(AC.A_tube_flow_per_row, 0.015281631551937964)\n    assert_close(AC.A_tube_flow_per_bundle, 0.06112652620775186)\n    assert_close(AC.A_tube_flow_per_bay, 0.12225305241550372)\n    assert_close(AC.A_tube_flow_total, 0.36675915724651115)\n    assert_close(AC.tube_volume_per_tube, 0.0029943265480911587)\n    assert_close(AC.tube_volume_per_row, (AC.tube_volume_per_tube * AC.tubes_per_row))\n    assert_close(AC.tube_volume_per_bundle, (AC.tube_volume_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.tube_volume, (AC.tube_volume_per_tube * AC.tubes))\n    assert (AC.channels == 56)\n    assert (AC.pitch_str == 'triangular')\n    assert (AC.pitch_class == 'staggered')\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3, corbels=True)\n    assert_close(AC.A_face_per_bundle, 19.683831599999998)", "ground_truth": "224", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_19", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_AirCooledExchangerFull", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_AirCooledExchangerFull():\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3)\n    assert_close(AC.bare_length, 0.0022097999999999996)\n    assert (AC.tubes_per_bundle == 224)\n    assert (AC.tubes_per_bay == (224 * 2))\n    assert (AC.tubes == ((224 * 2) * 3))\n    assert_close(AC.pitch_diagonal, 0.057238126497990836)\n    assert_close(AC.A_bare_tube_per_tube, 0.875590523880476)\n    assert_close(AC.A_bare_tube_per_row, (AC.A_bare_tube_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_bare_tube_per_bundle, (AC.A_bare_tube_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_bare_tube_per_bay, (AC.A_bare_tube_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_bare_tube, (AC.A_bare_tube_per_tube * AC.tubes))\n    assert_close(AC.A_tube_showing_per_tube, 0.7617637557760141)\n    assert_close(AC.A_tube_showing_per_row, (AC.A_tube_showing_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_tube_showing_per_bundle, (AC.A_tube_showing_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_tube_showing_per_bay, (AC.A_tube_showing_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_tube_showing, (AC.A_tube_showing_per_tube * AC.tubes))\n    assert_close(AC.A_per_fin, 0.0041762830427215765)\n    assert_close(AC.A_fin_per_tube, 18.041542744557212)\n    assert_close(AC.A_fin_per_row, (AC.A_fin_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_fin_per_bundle, (AC.A_fin_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_fin_per_bay, (AC.A_fin_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_fin, (AC.A_fin_per_tube * AC.tubes))\n    assert_close(AC.A_per_tube, 18.803306500333225)\n    assert_close(AC.A_per_row, (AC.A_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_per_bundle, (AC.A_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_per_bay, (AC.A_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A, (AC.A_per_tube * AC.tubes))\n    assert_close(AC.A_increase, 21.47500000000001)\n    assert_close(AC.A_diagonal_per_bundle, 34.05507419296123)\n    assert_close(AC.A_normal_per_bundle, 1.365674687999997)\n    assert_close(AC.A_normal_per_bundle, AC.A_normal_per_bundle)\n    assert_close(AC.A_min_per_bay, (AC.A_min_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_min, (AC.A_min_per_bay * AC.parallel_bays))\n    assert_close(AC.A_face_per_bundle, 19.858025)\n    assert_close(AC.A_face_per_bay, (AC.A_face_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_face, (AC.A_face_per_bay * AC.parallel_bays))\n    assert_close(AC.flow_area_contraction_ratio, 0.06877192982456128)\n    assert_close(AC.Di, 0.018639999999999997)\n    assert_close(AC.A_tube_flow, 0.00027288627771317794)\n    assert_close(AC.A_tube_flow_per_row, 0.015281631551937964)\n    assert_close(AC.A_tube_flow_per_bundle, 0.06112652620775186)\n    assert_close(AC.A_tube_flow_per_bay, 0.12225305241550372)\n    assert_close(AC.A_tube_flow_total, 0.36675915724651115)\n    assert_close(AC.tube_volume_per_tube, 0.0029943265480911587)\n    assert_close(AC.tube_volume_per_row, (AC.tube_volume_per_tube * AC.tubes_per_row))\n    assert_close(AC.tube_volume_per_bundle, (AC.tube_volume_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.tube_volume, (AC.tube_volume_per_tube * AC.tubes))\n    assert (AC.channels == 56)\n    assert (AC.pitch_str == 'triangular')\n    assert (AC.pitch_class == 'staggered')\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3, corbels=True)\n    assert_close(AC.A_face_per_bundle, 19.683831599999998)", "masked_code": "def test_AirCooledExchangerFull():\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3)\n    assert_close(AC.bare_length, 0.0022097999999999996)\n    assert (AC.tubes_per_bundle == 224)\n    assert (AC.tubes_per_bay == '???')\n    assert (AC.tubes == ((224 * 2) * 3))\n    assert_close(AC.pitch_diagonal, 0.057238126497990836)\n    assert_close(AC.A_bare_tube_per_tube, 0.875590523880476)\n    assert_close(AC.A_bare_tube_per_row, (AC.A_bare_tube_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_bare_tube_per_bundle, (AC.A_bare_tube_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_bare_tube_per_bay, (AC.A_bare_tube_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_bare_tube, (AC.A_bare_tube_per_tube * AC.tubes))\n    assert_close(AC.A_tube_showing_per_tube, 0.7617637557760141)\n    assert_close(AC.A_tube_showing_per_row, (AC.A_tube_showing_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_tube_showing_per_bundle, (AC.A_tube_showing_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_tube_showing_per_bay, (AC.A_tube_showing_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_tube_showing, (AC.A_tube_showing_per_tube * AC.tubes))\n    assert_close(AC.A_per_fin, 0.0041762830427215765)\n    assert_close(AC.A_fin_per_tube, 18.041542744557212)\n    assert_close(AC.A_fin_per_row, (AC.A_fin_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_fin_per_bundle, (AC.A_fin_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_fin_per_bay, (AC.A_fin_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_fin, (AC.A_fin_per_tube * AC.tubes))\n    assert_close(AC.A_per_tube, 18.803306500333225)\n    assert_close(AC.A_per_row, (AC.A_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_per_bundle, (AC.A_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_per_bay, (AC.A_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A, (AC.A_per_tube * AC.tubes))\n    assert_close(AC.A_increase, 21.47500000000001)\n    assert_close(AC.A_diagonal_per_bundle, 34.05507419296123)\n    assert_close(AC.A_normal_per_bundle, 1.365674687999997)\n    assert_close(AC.A_normal_per_bundle, AC.A_normal_per_bundle)\n    assert_close(AC.A_min_per_bay, (AC.A_min_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_min, (AC.A_min_per_bay * AC.parallel_bays))\n    assert_close(AC.A_face_per_bundle, 19.858025)\n    assert_close(AC.A_face_per_bay, (AC.A_face_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_face, (AC.A_face_per_bay * AC.parallel_bays))\n    assert_close(AC.flow_area_contraction_ratio, 0.06877192982456128)\n    assert_close(AC.Di, 0.018639999999999997)\n    assert_close(AC.A_tube_flow, 0.00027288627771317794)\n    assert_close(AC.A_tube_flow_per_row, 0.015281631551937964)\n    assert_close(AC.A_tube_flow_per_bundle, 0.06112652620775186)\n    assert_close(AC.A_tube_flow_per_bay, 0.12225305241550372)\n    assert_close(AC.A_tube_flow_total, 0.36675915724651115)\n    assert_close(AC.tube_volume_per_tube, 0.0029943265480911587)\n    assert_close(AC.tube_volume_per_row, (AC.tube_volume_per_tube * AC.tubes_per_row))\n    assert_close(AC.tube_volume_per_bundle, (AC.tube_volume_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.tube_volume, (AC.tube_volume_per_tube * AC.tubes))\n    assert (AC.channels == 56)\n    assert (AC.pitch_str == 'triangular')\n    assert (AC.pitch_class == 'staggered')\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3, corbels=True)\n    assert_close(AC.A_face_per_bundle, 19.683831599999998)", "ground_truth": "(224 * 2)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_20", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_AirCooledExchangerFull", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_AirCooledExchangerFull():\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3)\n    assert_close(AC.bare_length, 0.0022097999999999996)\n    assert (AC.tubes_per_bundle == 224)\n    assert (AC.tubes_per_bay == (224 * 2))\n    assert (AC.tubes == ((224 * 2) * 3))\n    assert_close(AC.pitch_diagonal, 0.057238126497990836)\n    assert_close(AC.A_bare_tube_per_tube, 0.875590523880476)\n    assert_close(AC.A_bare_tube_per_row, (AC.A_bare_tube_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_bare_tube_per_bundle, (AC.A_bare_tube_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_bare_tube_per_bay, (AC.A_bare_tube_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_bare_tube, (AC.A_bare_tube_per_tube * AC.tubes))\n    assert_close(AC.A_tube_showing_per_tube, 0.7617637557760141)\n    assert_close(AC.A_tube_showing_per_row, (AC.A_tube_showing_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_tube_showing_per_bundle, (AC.A_tube_showing_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_tube_showing_per_bay, (AC.A_tube_showing_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_tube_showing, (AC.A_tube_showing_per_tube * AC.tubes))\n    assert_close(AC.A_per_fin, 0.0041762830427215765)\n    assert_close(AC.A_fin_per_tube, 18.041542744557212)\n    assert_close(AC.A_fin_per_row, (AC.A_fin_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_fin_per_bundle, (AC.A_fin_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_fin_per_bay, (AC.A_fin_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_fin, (AC.A_fin_per_tube * AC.tubes))\n    assert_close(AC.A_per_tube, 18.803306500333225)\n    assert_close(AC.A_per_row, (AC.A_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_per_bundle, (AC.A_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_per_bay, (AC.A_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A, (AC.A_per_tube * AC.tubes))\n    assert_close(AC.A_increase, 21.47500000000001)\n    assert_close(AC.A_diagonal_per_bundle, 34.05507419296123)\n    assert_close(AC.A_normal_per_bundle, 1.365674687999997)\n    assert_close(AC.A_normal_per_bundle, AC.A_normal_per_bundle)\n    assert_close(AC.A_min_per_bay, (AC.A_min_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_min, (AC.A_min_per_bay * AC.parallel_bays))\n    assert_close(AC.A_face_per_bundle, 19.858025)\n    assert_close(AC.A_face_per_bay, (AC.A_face_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_face, (AC.A_face_per_bay * AC.parallel_bays))\n    assert_close(AC.flow_area_contraction_ratio, 0.06877192982456128)\n    assert_close(AC.Di, 0.018639999999999997)\n    assert_close(AC.A_tube_flow, 0.00027288627771317794)\n    assert_close(AC.A_tube_flow_per_row, 0.015281631551937964)\n    assert_close(AC.A_tube_flow_per_bundle, 0.06112652620775186)\n    assert_close(AC.A_tube_flow_per_bay, 0.12225305241550372)\n    assert_close(AC.A_tube_flow_total, 0.36675915724651115)\n    assert_close(AC.tube_volume_per_tube, 0.0029943265480911587)\n    assert_close(AC.tube_volume_per_row, (AC.tube_volume_per_tube * AC.tubes_per_row))\n    assert_close(AC.tube_volume_per_bundle, (AC.tube_volume_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.tube_volume, (AC.tube_volume_per_tube * AC.tubes))\n    assert (AC.channels == 56)\n    assert (AC.pitch_str == 'triangular')\n    assert (AC.pitch_class == 'staggered')\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3, corbels=True)\n    assert_close(AC.A_face_per_bundle, 19.683831599999998)", "masked_code": "def test_AirCooledExchangerFull():\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3)\n    assert_close(AC.bare_length, 0.0022097999999999996)\n    assert (AC.tubes_per_bundle == 224)\n    assert (AC.tubes_per_bay == (224 * 2))\n    assert (AC.tubes == '???')\n    assert_close(AC.pitch_diagonal, 0.057238126497990836)\n    assert_close(AC.A_bare_tube_per_tube, 0.875590523880476)\n    assert_close(AC.A_bare_tube_per_row, (AC.A_bare_tube_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_bare_tube_per_bundle, (AC.A_bare_tube_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_bare_tube_per_bay, (AC.A_bare_tube_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_bare_tube, (AC.A_bare_tube_per_tube * AC.tubes))\n    assert_close(AC.A_tube_showing_per_tube, 0.7617637557760141)\n    assert_close(AC.A_tube_showing_per_row, (AC.A_tube_showing_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_tube_showing_per_bundle, (AC.A_tube_showing_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_tube_showing_per_bay, (AC.A_tube_showing_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_tube_showing, (AC.A_tube_showing_per_tube * AC.tubes))\n    assert_close(AC.A_per_fin, 0.0041762830427215765)\n    assert_close(AC.A_fin_per_tube, 18.041542744557212)\n    assert_close(AC.A_fin_per_row, (AC.A_fin_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_fin_per_bundle, (AC.A_fin_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_fin_per_bay, (AC.A_fin_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_fin, (AC.A_fin_per_tube * AC.tubes))\n    assert_close(AC.A_per_tube, 18.803306500333225)\n    assert_close(AC.A_per_row, (AC.A_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_per_bundle, (AC.A_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_per_bay, (AC.A_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A, (AC.A_per_tube * AC.tubes))\n    assert_close(AC.A_increase, 21.47500000000001)\n    assert_close(AC.A_diagonal_per_bundle, 34.05507419296123)\n    assert_close(AC.A_normal_per_bundle, 1.365674687999997)\n    assert_close(AC.A_normal_per_bundle, AC.A_normal_per_bundle)\n    assert_close(AC.A_min_per_bay, (AC.A_min_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_min, (AC.A_min_per_bay * AC.parallel_bays))\n    assert_close(AC.A_face_per_bundle, 19.858025)\n    assert_close(AC.A_face_per_bay, (AC.A_face_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_face, (AC.A_face_per_bay * AC.parallel_bays))\n    assert_close(AC.flow_area_contraction_ratio, 0.06877192982456128)\n    assert_close(AC.Di, 0.018639999999999997)\n    assert_close(AC.A_tube_flow, 0.00027288627771317794)\n    assert_close(AC.A_tube_flow_per_row, 0.015281631551937964)\n    assert_close(AC.A_tube_flow_per_bundle, 0.06112652620775186)\n    assert_close(AC.A_tube_flow_per_bay, 0.12225305241550372)\n    assert_close(AC.A_tube_flow_total, 0.36675915724651115)\n    assert_close(AC.tube_volume_per_tube, 0.0029943265480911587)\n    assert_close(AC.tube_volume_per_row, (AC.tube_volume_per_tube * AC.tubes_per_row))\n    assert_close(AC.tube_volume_per_bundle, (AC.tube_volume_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.tube_volume, (AC.tube_volume_per_tube * AC.tubes))\n    assert (AC.channels == 56)\n    assert (AC.pitch_str == 'triangular')\n    assert (AC.pitch_class == 'staggered')\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3, corbels=True)\n    assert_close(AC.A_face_per_bundle, 19.683831599999998)", "ground_truth": "((224 * 2) * 3)", "quality_analysis": {"complexity_score": 9, "left_complexity": 2, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_21", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_AirCooledExchangerFull", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_AirCooledExchangerFull():\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3)\n    assert_close(AC.bare_length, 0.0022097999999999996)\n    assert (AC.tubes_per_bundle == 224)\n    assert (AC.tubes_per_bay == (224 * 2))\n    assert (AC.tubes == ((224 * 2) * 3))\n    assert_close(AC.pitch_diagonal, 0.057238126497990836)\n    assert_close(AC.A_bare_tube_per_tube, 0.875590523880476)\n    assert_close(AC.A_bare_tube_per_row, (AC.A_bare_tube_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_bare_tube_per_bundle, (AC.A_bare_tube_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_bare_tube_per_bay, (AC.A_bare_tube_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_bare_tube, (AC.A_bare_tube_per_tube * AC.tubes))\n    assert_close(AC.A_tube_showing_per_tube, 0.7617637557760141)\n    assert_close(AC.A_tube_showing_per_row, (AC.A_tube_showing_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_tube_showing_per_bundle, (AC.A_tube_showing_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_tube_showing_per_bay, (AC.A_tube_showing_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_tube_showing, (AC.A_tube_showing_per_tube * AC.tubes))\n    assert_close(AC.A_per_fin, 0.0041762830427215765)\n    assert_close(AC.A_fin_per_tube, 18.041542744557212)\n    assert_close(AC.A_fin_per_row, (AC.A_fin_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_fin_per_bundle, (AC.A_fin_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_fin_per_bay, (AC.A_fin_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_fin, (AC.A_fin_per_tube * AC.tubes))\n    assert_close(AC.A_per_tube, 18.803306500333225)\n    assert_close(AC.A_per_row, (AC.A_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_per_bundle, (AC.A_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_per_bay, (AC.A_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A, (AC.A_per_tube * AC.tubes))\n    assert_close(AC.A_increase, 21.47500000000001)\n    assert_close(AC.A_diagonal_per_bundle, 34.05507419296123)\n    assert_close(AC.A_normal_per_bundle, 1.365674687999997)\n    assert_close(AC.A_normal_per_bundle, AC.A_normal_per_bundle)\n    assert_close(AC.A_min_per_bay, (AC.A_min_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_min, (AC.A_min_per_bay * AC.parallel_bays))\n    assert_close(AC.A_face_per_bundle, 19.858025)\n    assert_close(AC.A_face_per_bay, (AC.A_face_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_face, (AC.A_face_per_bay * AC.parallel_bays))\n    assert_close(AC.flow_area_contraction_ratio, 0.06877192982456128)\n    assert_close(AC.Di, 0.018639999999999997)\n    assert_close(AC.A_tube_flow, 0.00027288627771317794)\n    assert_close(AC.A_tube_flow_per_row, 0.015281631551937964)\n    assert_close(AC.A_tube_flow_per_bundle, 0.06112652620775186)\n    assert_close(AC.A_tube_flow_per_bay, 0.12225305241550372)\n    assert_close(AC.A_tube_flow_total, 0.36675915724651115)\n    assert_close(AC.tube_volume_per_tube, 0.0029943265480911587)\n    assert_close(AC.tube_volume_per_row, (AC.tube_volume_per_tube * AC.tubes_per_row))\n    assert_close(AC.tube_volume_per_bundle, (AC.tube_volume_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.tube_volume, (AC.tube_volume_per_tube * AC.tubes))\n    assert (AC.channels == 56)\n    assert (AC.pitch_str == 'triangular')\n    assert (AC.pitch_class == 'staggered')\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3, corbels=True)\n    assert_close(AC.A_face_per_bundle, 19.683831599999998)", "masked_code": "def test_AirCooledExchangerFull():\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3)\n    assert_close(AC.bare_length, 0.0022097999999999996)\n    assert (AC.tubes_per_bundle == 224)\n    assert (AC.tubes_per_bay == (224 * 2))\n    assert (AC.tubes == ((224 * 2) * 3))\n    assert_close(AC.pitch_diagonal, 0.057238126497990836)\n    assert_close(AC.A_bare_tube_per_tube, 0.875590523880476)\n    assert_close(AC.A_bare_tube_per_row, (AC.A_bare_tube_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_bare_tube_per_bundle, (AC.A_bare_tube_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_bare_tube_per_bay, (AC.A_bare_tube_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_bare_tube, (AC.A_bare_tube_per_tube * AC.tubes))\n    assert_close(AC.A_tube_showing_per_tube, 0.7617637557760141)\n    assert_close(AC.A_tube_showing_per_row, (AC.A_tube_showing_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_tube_showing_per_bundle, (AC.A_tube_showing_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_tube_showing_per_bay, (AC.A_tube_showing_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_tube_showing, (AC.A_tube_showing_per_tube * AC.tubes))\n    assert_close(AC.A_per_fin, 0.0041762830427215765)\n    assert_close(AC.A_fin_per_tube, 18.041542744557212)\n    assert_close(AC.A_fin_per_row, (AC.A_fin_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_fin_per_bundle, (AC.A_fin_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_fin_per_bay, (AC.A_fin_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_fin, (AC.A_fin_per_tube * AC.tubes))\n    assert_close(AC.A_per_tube, 18.803306500333225)\n    assert_close(AC.A_per_row, (AC.A_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_per_bundle, (AC.A_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_per_bay, (AC.A_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A, (AC.A_per_tube * AC.tubes))\n    assert_close(AC.A_increase, 21.47500000000001)\n    assert_close(AC.A_diagonal_per_bundle, 34.05507419296123)\n    assert_close(AC.A_normal_per_bundle, 1.365674687999997)\n    assert_close(AC.A_normal_per_bundle, AC.A_normal_per_bundle)\n    assert_close(AC.A_min_per_bay, (AC.A_min_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_min, (AC.A_min_per_bay * AC.parallel_bays))\n    assert_close(AC.A_face_per_bundle, 19.858025)\n    assert_close(AC.A_face_per_bay, (AC.A_face_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_face, (AC.A_face_per_bay * AC.parallel_bays))\n    assert_close(AC.flow_area_contraction_ratio, 0.06877192982456128)\n    assert_close(AC.Di, 0.018639999999999997)\n    assert_close(AC.A_tube_flow, 0.00027288627771317794)\n    assert_close(AC.A_tube_flow_per_row, 0.015281631551937964)\n    assert_close(AC.A_tube_flow_per_bundle, 0.06112652620775186)\n    assert_close(AC.A_tube_flow_per_bay, 0.12225305241550372)\n    assert_close(AC.A_tube_flow_total, 0.36675915724651115)\n    assert_close(AC.tube_volume_per_tube, 0.0029943265480911587)\n    assert_close(AC.tube_volume_per_row, (AC.tube_volume_per_tube * AC.tubes_per_row))\n    assert_close(AC.tube_volume_per_bundle, (AC.tube_volume_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.tube_volume, (AC.tube_volume_per_tube * AC.tubes))\n    assert (AC.channels == '???')\n    assert (AC.pitch_str == 'triangular')\n    assert (AC.pitch_class == 'staggered')\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3, corbels=True)\n    assert_close(AC.A_face_per_bundle, 19.683831599999998)", "ground_truth": "56", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_22", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_AirCooledExchangerFull", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_AirCooledExchangerFull():\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3)\n    assert_close(AC.bare_length, 0.0022097999999999996)\n    assert (AC.tubes_per_bundle == 224)\n    assert (AC.tubes_per_bay == (224 * 2))\n    assert (AC.tubes == ((224 * 2) * 3))\n    assert_close(AC.pitch_diagonal, 0.057238126497990836)\n    assert_close(AC.A_bare_tube_per_tube, 0.875590523880476)\n    assert_close(AC.A_bare_tube_per_row, (AC.A_bare_tube_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_bare_tube_per_bundle, (AC.A_bare_tube_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_bare_tube_per_bay, (AC.A_bare_tube_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_bare_tube, (AC.A_bare_tube_per_tube * AC.tubes))\n    assert_close(AC.A_tube_showing_per_tube, 0.7617637557760141)\n    assert_close(AC.A_tube_showing_per_row, (AC.A_tube_showing_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_tube_showing_per_bundle, (AC.A_tube_showing_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_tube_showing_per_bay, (AC.A_tube_showing_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_tube_showing, (AC.A_tube_showing_per_tube * AC.tubes))\n    assert_close(AC.A_per_fin, 0.0041762830427215765)\n    assert_close(AC.A_fin_per_tube, 18.041542744557212)\n    assert_close(AC.A_fin_per_row, (AC.A_fin_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_fin_per_bundle, (AC.A_fin_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_fin_per_bay, (AC.A_fin_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_fin, (AC.A_fin_per_tube * AC.tubes))\n    assert_close(AC.A_per_tube, 18.803306500333225)\n    assert_close(AC.A_per_row, (AC.A_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_per_bundle, (AC.A_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_per_bay, (AC.A_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A, (AC.A_per_tube * AC.tubes))\n    assert_close(AC.A_increase, 21.47500000000001)\n    assert_close(AC.A_diagonal_per_bundle, 34.05507419296123)\n    assert_close(AC.A_normal_per_bundle, 1.365674687999997)\n    assert_close(AC.A_normal_per_bundle, AC.A_normal_per_bundle)\n    assert_close(AC.A_min_per_bay, (AC.A_min_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_min, (AC.A_min_per_bay * AC.parallel_bays))\n    assert_close(AC.A_face_per_bundle, 19.858025)\n    assert_close(AC.A_face_per_bay, (AC.A_face_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_face, (AC.A_face_per_bay * AC.parallel_bays))\n    assert_close(AC.flow_area_contraction_ratio, 0.06877192982456128)\n    assert_close(AC.Di, 0.018639999999999997)\n    assert_close(AC.A_tube_flow, 0.00027288627771317794)\n    assert_close(AC.A_tube_flow_per_row, 0.015281631551937964)\n    assert_close(AC.A_tube_flow_per_bundle, 0.06112652620775186)\n    assert_close(AC.A_tube_flow_per_bay, 0.12225305241550372)\n    assert_close(AC.A_tube_flow_total, 0.36675915724651115)\n    assert_close(AC.tube_volume_per_tube, 0.0029943265480911587)\n    assert_close(AC.tube_volume_per_row, (AC.tube_volume_per_tube * AC.tubes_per_row))\n    assert_close(AC.tube_volume_per_bundle, (AC.tube_volume_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.tube_volume, (AC.tube_volume_per_tube * AC.tubes))\n    assert (AC.channels == 56)\n    assert (AC.pitch_str == 'triangular')\n    assert (AC.pitch_class == 'staggered')\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3, corbels=True)\n    assert_close(AC.A_face_per_bundle, 19.683831599999998)", "masked_code": "def test_AirCooledExchangerFull():\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3)\n    assert_close(AC.bare_length, 0.0022097999999999996)\n    assert (AC.tubes_per_bundle == 224)\n    assert (AC.tubes_per_bay == (224 * 2))\n    assert (AC.tubes == ((224 * 2) * 3))\n    assert_close(AC.pitch_diagonal, 0.057238126497990836)\n    assert_close(AC.A_bare_tube_per_tube, 0.875590523880476)\n    assert_close(AC.A_bare_tube_per_row, (AC.A_bare_tube_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_bare_tube_per_bundle, (AC.A_bare_tube_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_bare_tube_per_bay, (AC.A_bare_tube_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_bare_tube, (AC.A_bare_tube_per_tube * AC.tubes))\n    assert_close(AC.A_tube_showing_per_tube, 0.7617637557760141)\n    assert_close(AC.A_tube_showing_per_row, (AC.A_tube_showing_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_tube_showing_per_bundle, (AC.A_tube_showing_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_tube_showing_per_bay, (AC.A_tube_showing_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_tube_showing, (AC.A_tube_showing_per_tube * AC.tubes))\n    assert_close(AC.A_per_fin, 0.0041762830427215765)\n    assert_close(AC.A_fin_per_tube, 18.041542744557212)\n    assert_close(AC.A_fin_per_row, (AC.A_fin_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_fin_per_bundle, (AC.A_fin_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_fin_per_bay, (AC.A_fin_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_fin, (AC.A_fin_per_tube * AC.tubes))\n    assert_close(AC.A_per_tube, 18.803306500333225)\n    assert_close(AC.A_per_row, (AC.A_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_per_bundle, (AC.A_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_per_bay, (AC.A_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A, (AC.A_per_tube * AC.tubes))\n    assert_close(AC.A_increase, 21.47500000000001)\n    assert_close(AC.A_diagonal_per_bundle, 34.05507419296123)\n    assert_close(AC.A_normal_per_bundle, 1.365674687999997)\n    assert_close(AC.A_normal_per_bundle, AC.A_normal_per_bundle)\n    assert_close(AC.A_min_per_bay, (AC.A_min_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_min, (AC.A_min_per_bay * AC.parallel_bays))\n    assert_close(AC.A_face_per_bundle, 19.858025)\n    assert_close(AC.A_face_per_bay, (AC.A_face_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_face, (AC.A_face_per_bay * AC.parallel_bays))\n    assert_close(AC.flow_area_contraction_ratio, 0.06877192982456128)\n    assert_close(AC.Di, 0.018639999999999997)\n    assert_close(AC.A_tube_flow, 0.00027288627771317794)\n    assert_close(AC.A_tube_flow_per_row, 0.015281631551937964)\n    assert_close(AC.A_tube_flow_per_bundle, 0.06112652620775186)\n    assert_close(AC.A_tube_flow_per_bay, 0.12225305241550372)\n    assert_close(AC.A_tube_flow_total, 0.36675915724651115)\n    assert_close(AC.tube_volume_per_tube, 0.0029943265480911587)\n    assert_close(AC.tube_volume_per_row, (AC.tube_volume_per_tube * AC.tubes_per_row))\n    assert_close(AC.tube_volume_per_bundle, (AC.tube_volume_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.tube_volume, (AC.tube_volume_per_tube * AC.tubes))\n    assert (AC.channels == 56)\n    assert (AC.pitch_str == '???')\n    assert (AC.pitch_class == 'staggered')\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3, corbels=True)\n    assert_close(AC.A_face_per_bundle, 19.683831599999998)", "ground_truth": "'triangular'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_23", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_AirCooledExchangerFull", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_AirCooledExchangerFull():\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3)\n    assert_close(AC.bare_length, 0.0022097999999999996)\n    assert (AC.tubes_per_bundle == 224)\n    assert (AC.tubes_per_bay == (224 * 2))\n    assert (AC.tubes == ((224 * 2) * 3))\n    assert_close(AC.pitch_diagonal, 0.057238126497990836)\n    assert_close(AC.A_bare_tube_per_tube, 0.875590523880476)\n    assert_close(AC.A_bare_tube_per_row, (AC.A_bare_tube_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_bare_tube_per_bundle, (AC.A_bare_tube_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_bare_tube_per_bay, (AC.A_bare_tube_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_bare_tube, (AC.A_bare_tube_per_tube * AC.tubes))\n    assert_close(AC.A_tube_showing_per_tube, 0.7617637557760141)\n    assert_close(AC.A_tube_showing_per_row, (AC.A_tube_showing_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_tube_showing_per_bundle, (AC.A_tube_showing_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_tube_showing_per_bay, (AC.A_tube_showing_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_tube_showing, (AC.A_tube_showing_per_tube * AC.tubes))\n    assert_close(AC.A_per_fin, 0.0041762830427215765)\n    assert_close(AC.A_fin_per_tube, 18.041542744557212)\n    assert_close(AC.A_fin_per_row, (AC.A_fin_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_fin_per_bundle, (AC.A_fin_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_fin_per_bay, (AC.A_fin_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_fin, (AC.A_fin_per_tube * AC.tubes))\n    assert_close(AC.A_per_tube, 18.803306500333225)\n    assert_close(AC.A_per_row, (AC.A_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_per_bundle, (AC.A_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_per_bay, (AC.A_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A, (AC.A_per_tube * AC.tubes))\n    assert_close(AC.A_increase, 21.47500000000001)\n    assert_close(AC.A_diagonal_per_bundle, 34.05507419296123)\n    assert_close(AC.A_normal_per_bundle, 1.365674687999997)\n    assert_close(AC.A_normal_per_bundle, AC.A_normal_per_bundle)\n    assert_close(AC.A_min_per_bay, (AC.A_min_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_min, (AC.A_min_per_bay * AC.parallel_bays))\n    assert_close(AC.A_face_per_bundle, 19.858025)\n    assert_close(AC.A_face_per_bay, (AC.A_face_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_face, (AC.A_face_per_bay * AC.parallel_bays))\n    assert_close(AC.flow_area_contraction_ratio, 0.06877192982456128)\n    assert_close(AC.Di, 0.018639999999999997)\n    assert_close(AC.A_tube_flow, 0.00027288627771317794)\n    assert_close(AC.A_tube_flow_per_row, 0.015281631551937964)\n    assert_close(AC.A_tube_flow_per_bundle, 0.06112652620775186)\n    assert_close(AC.A_tube_flow_per_bay, 0.12225305241550372)\n    assert_close(AC.A_tube_flow_total, 0.36675915724651115)\n    assert_close(AC.tube_volume_per_tube, 0.0029943265480911587)\n    assert_close(AC.tube_volume_per_row, (AC.tube_volume_per_tube * AC.tubes_per_row))\n    assert_close(AC.tube_volume_per_bundle, (AC.tube_volume_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.tube_volume, (AC.tube_volume_per_tube * AC.tubes))\n    assert (AC.channels == 56)\n    assert (AC.pitch_str == 'triangular')\n    assert (AC.pitch_class == 'staggered')\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3, corbels=True)\n    assert_close(AC.A_face_per_bundle, 19.683831599999998)", "masked_code": "def test_AirCooledExchangerFull():\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3)\n    assert_close(AC.bare_length, 0.0022097999999999996)\n    assert (AC.tubes_per_bundle == 224)\n    assert (AC.tubes_per_bay == (224 * 2))\n    assert (AC.tubes == ((224 * 2) * 3))\n    assert_close(AC.pitch_diagonal, 0.057238126497990836)\n    assert_close(AC.A_bare_tube_per_tube, 0.875590523880476)\n    assert_close(AC.A_bare_tube_per_row, (AC.A_bare_tube_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_bare_tube_per_bundle, (AC.A_bare_tube_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_bare_tube_per_bay, (AC.A_bare_tube_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_bare_tube, (AC.A_bare_tube_per_tube * AC.tubes))\n    assert_close(AC.A_tube_showing_per_tube, 0.7617637557760141)\n    assert_close(AC.A_tube_showing_per_row, (AC.A_tube_showing_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_tube_showing_per_bundle, (AC.A_tube_showing_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_tube_showing_per_bay, (AC.A_tube_showing_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_tube_showing, (AC.A_tube_showing_per_tube * AC.tubes))\n    assert_close(AC.A_per_fin, 0.0041762830427215765)\n    assert_close(AC.A_fin_per_tube, 18.041542744557212)\n    assert_close(AC.A_fin_per_row, (AC.A_fin_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_fin_per_bundle, (AC.A_fin_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_fin_per_bay, (AC.A_fin_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A_fin, (AC.A_fin_per_tube * AC.tubes))\n    assert_close(AC.A_per_tube, 18.803306500333225)\n    assert_close(AC.A_per_row, (AC.A_per_tube * AC.tubes_per_row))\n    assert_close(AC.A_per_bundle, (AC.A_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.A_per_bay, (AC.A_per_tube * AC.tubes_per_bay))\n    assert_close(AC.A, (AC.A_per_tube * AC.tubes))\n    assert_close(AC.A_increase, 21.47500000000001)\n    assert_close(AC.A_diagonal_per_bundle, 34.05507419296123)\n    assert_close(AC.A_normal_per_bundle, 1.365674687999997)\n    assert_close(AC.A_normal_per_bundle, AC.A_normal_per_bundle)\n    assert_close(AC.A_min_per_bay, (AC.A_min_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_min, (AC.A_min_per_bay * AC.parallel_bays))\n    assert_close(AC.A_face_per_bundle, 19.858025)\n    assert_close(AC.A_face_per_bay, (AC.A_face_per_bundle * AC.bundles_per_bay))\n    assert_close(AC.A_face, (AC.A_face_per_bay * AC.parallel_bays))\n    assert_close(AC.flow_area_contraction_ratio, 0.06877192982456128)\n    assert_close(AC.Di, 0.018639999999999997)\n    assert_close(AC.A_tube_flow, 0.00027288627771317794)\n    assert_close(AC.A_tube_flow_per_row, 0.015281631551937964)\n    assert_close(AC.A_tube_flow_per_bundle, 0.06112652620775186)\n    assert_close(AC.A_tube_flow_per_bay, 0.12225305241550372)\n    assert_close(AC.A_tube_flow_total, 0.36675915724651115)\n    assert_close(AC.tube_volume_per_tube, 0.0029943265480911587)\n    assert_close(AC.tube_volume_per_row, (AC.tube_volume_per_tube * AC.tubes_per_row))\n    assert_close(AC.tube_volume_per_bundle, (AC.tube_volume_per_tube * AC.tubes_per_bundle))\n    assert_close(AC.tube_volume, (AC.tube_volume_per_tube * AC.tubes))\n    assert (AC.channels == 56)\n    assert (AC.pitch_str == 'triangular')\n    assert (AC.pitch_class == '???')\n    AC = AirCooledExchanger(tube_rows=4, tube_passes=4, tubes_per_row=56, tube_length=10.9728, tube_diameter=(1 * inch), fin_thickness=(0.013 * inch), fin_density=(10 / inch), angle=30, pitch=(2.5 * inch), fin_height=(0.625 * inch), tube_thickness=0.00338, bundles_per_bay=2, parallel_bays=3, corbels=True)\n    assert_close(AC.A_face_per_bundle, 19.683831599999998)", "ground_truth": "'staggered'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_24", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == '???')\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_25", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == '???')\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_a", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_26", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == '???')\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_f", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_27", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == '???')\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideB_k", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_28", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == '???')\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_a_ratio", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_29", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == '???')\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_30", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == '???')\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_a", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_31", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == '???')\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_f", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_32", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == '???')\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideB_k", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_33", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == '???')\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_a_ratio", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_34", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == '???')\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_35", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == '???')\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_a", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_36", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == '???')\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_f", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_37", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == '???')\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideB_k", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_38", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == '???')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_a_ratio", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_39", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == '???')\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_40", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == '???')\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_a", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_41", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == '???')\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_f", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_42", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == '???')\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideB_k", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_43", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == '???')\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_a_ratio", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_44", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == '???')\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_45", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == '???')\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_a", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_46", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == '???')\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_f", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_47", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == '???')\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideB_k", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_48", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == '???')\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "ground_truth": "T1.sideA_a_ratio", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_49", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_geometry_tank", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == 0.06)\n    assert (T1.sideB_f == 1.0)", "masked_code": "def test_geometry_tank():\n    V1 = TANK(D=1.2, L=4, horizontal=False).V_total\n    assert_close(V1, 4.523893421169302)\n    V2 = TANK(D=1.2, L=4, horizontal=False).V_from_h(0.5)\n    assert_close(V2, 0.5654866776461628)\n    V3 = TANK(D=1.2, L=4, horizontal=False).h_from_V(0.5)\n    assert_close(V3, 0.44209706414415373)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5)\n    things_calc = (T1.A, T1.A_sideA, T1.A_sideB, T1.A_lateral)\n    things = (24.94775907657148, 5.118555935958284, 5.497246519930003, 14.331956620683194)\n    assert_close1d(things_calc, things)\n    L1 = TANK(D=10.0, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=True, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=True, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=10.0, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    D1 = TANK(L=4.69953105701, horizontal=False, sideA='conical', sideB='conical', V=500).D\n    L2 = TANK(L_over_D=0.469953105701, horizontal=False, sideA='conical', sideB='conical', V=500).L\n    assert_close1d([L1, D1, L2], [4.699531057009146, 9.999999999999407, 4.69953105700979])\n    L1 = TANK(D=1.2, L_over_D=3.5, horizontal=False).L\n    D1 = TANK(L=1.2, L_over_D=3.5, horizontal=False).D\n    assert_close1d([L1, D1], [4.2, 0.342857142857])\n    V = TANK(L=1.2, L_over_D=3.5, sideA='torispherical', sideB='torispherical', sideA_f=1.0, sideA_k=0.06, sideB_f=1.0, sideB_k=0.06).V_total\n    assert_close(V, 0.117318265914)\n    assert_close(0.25, TANK(V=10, L=10, sideA='conical', sideA_a_ratio=None).sideA_a_ratio)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, D=10)\n    with pytest.raises(Exception):\n        TANK(V=10, L=10, sideA='conical', sideB_a=0.5)\n    base = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideA_a_ratio=0.25, sideB_f=1.0, sideB_k=0.06, sideA='conical', sideB='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    base = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', V=500)\n    forward = TANK(D=10.0, horizontal=True, sideB_a_ratio=0.25, sideA_f=1.0, sideA_k=0.06, sideB='conical', sideA='torispherical', L=base.L)\n    assert_close(base.V, forward.V_total, rtol=1e-11)\n    T1 = TANK(V=10, L_over_D=0.7, sideB='conical', sideB_a=0.5, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideA_f=1.0, sideA_k=0.06, sideA='torispherical', L=3, sideB='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, sideB_f=1.0, sideB_k=0.06, sideB='torispherical', L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_a == 0)\n    with pytest.raises(Exception):\n        T1 = TANK(D=10.0, horizontal=True, L=3, sideA='same', sideB='same')\n    T1 = TANK(D=10.0, horizontal=True, L=3, sideA='torispherical', sideB='torispherical')\n    assert (T1.sideB == T1.sideA)\n    assert (T1.sideB_a == T1.sideA_a)\n    assert (T1.sideB_f == T1.sideA_f)\n    assert (T1.sideB_k == T1.sideB_k)\n    assert (T1.sideB_a_ratio == T1.sideA_a_ratio)\n    assert (T1.sideB_k == '???')\n    assert (T1.sideB_f == 1.0)", "ground_truth": "0.06", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_50", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_PlateExchanger", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "masked_code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == '???')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "ground_truth": "'L3.7A0.5B45-45'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_51", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_PlateExchanger", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "masked_code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == '???')\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "ground_truth": "45", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_52", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_PlateExchanger", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "masked_code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == '???')\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "ground_truth": "(45, 45)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_53", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_PlateExchanger", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "masked_code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == '???')\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "ground_truth": "45", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_54", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_PlateExchanger", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "masked_code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == '???')\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "ground_truth": "50", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_55", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_PlateExchanger", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "masked_code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == '???')\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "ground_truth": "25", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_56", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_PlateExchanger", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "masked_code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == '???')\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "ground_truth": "45", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_57", "reponame": "fluids", "testpath": "tests/test_geometry.py", "testname": "test_geometry.py", "classname": null, "funcname": "test_PlateExchanger", "imports": ["from math import cos", "import pytest", "from fluids import TANK, A_cylinder, A_hollow_cylinder, A_multiple_hole_cylinder, A_partial_circle, AirCooledExchanger, HelicalCoil, PlateExchanger, RectangularFinExchanger, RectangularOffsetStripFinExchanger, SA_conical_head, SA_ellipsoidal_head, SA_from_h, SA_guppy_head, SA_partial_cylindrical_body, SA_partial_horiz_conical_head, SA_partial_horiz_ellipsoidal_head, SA_partial_horiz_guppy_head, SA_partial_horiz_spherical_head, SA_partial_horiz_torispherical_head, SA_partial_sphere, SA_partial_vertical_conical_head, SA_partial_vertical_ellipsoidal_head, SA_partial_vertical_spherical_head, SA_partial_vertical_torispherical_head, SA_tank, SA_torispheroidal, V_cylinder, V_from_h, V_hollow_cylinder, V_horiz_conical, V_horiz_ellipsoidal, V_horiz_guppy, V_horiz_spherical, V_horiz_torispherical, V_multiple_hole_cylinder, V_partial_sphere, V_vertical_conical, V_vertical_conical_concave, V_vertical_ellipsoidal, V_vertical_ellipsoidal_concave, V_vertical_spherical, V_vertical_spherical_concave, V_vertical_torispherical, V_vertical_torispherical_concave, a_torispherical, aspect_ratio, circle_segment_h_from_A, circularity, pitch_angle_solver, plate_enlargement_factor, sphericity", "from fluids.constants import foot, inch, pi", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (30, 60))\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "masked_code": "def test_PlateExchanger():\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51)\n    assert (ex.plate_exchanger_identifier == 'L3.7A0.5B45-45')\n    assert_close(ex.amplitude, 0.0005)\n    assert_close(ex.a, 0.0005)\n    assert_close(ex.b, 0.001)\n    assert_close(ex.wavelength, 0.0037)\n    assert_close(ex.pitch, 0.0037)\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == (45, 45))\n    assert (ex.inclination_angle == 45)\n    assert_close(ex.plate_corrugation_aspect_ratio, 0.5405405405405406)\n    assert_close(ex.gamma, 0.5405405405405406)\n    assert_close(ex.plate_enlargement_factor, 1.1611862034509677)\n    assert_close(ex.D_eq, 0.002)\n    assert_close(ex.D_hydraulic, 0.0017223766473078426)\n    assert_close(ex.length_port, 1.25)\n    assert_close(ex.A_plate_surface, 0.41802703324234836)\n    assert_close(ex.A_heat_transfer, 20.48332462887507)\n    assert_close(ex.A_channel_flow, 0.0003)\n    assert (ex.channels == 50)\n    assert (ex.channels_per_fluid == 25)\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037, length=1.2, width=0.3, d_port=0.05, plates=51, chevron_angles=(30, 60))\n    assert (ex.chevron_angle == 45)\n    assert (ex.chevron_angles == '???')\n    ex = PlateExchanger(amplitude=0.0005, wavelength=0.0037)", "ground_truth": "(30, 60)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_58", "reponame": "fluids", "testpath": "tests/test_jet_pump.py", "testname": "test_jet_pump.py", "classname": null, "funcname": "test_vacuum_air_leakage_HEI2633", "imports": ["import pytest", "from fluids import liquid_jet_pump, liquid_jet_pump_ancillary, vacuum_air_leakage_Coker_Worthington, vacuum_air_leakage_HEI2633, vacuum_air_leakage_Ryans_Croll, vacuum_air_leakage_Seider", "from fluids.constants import atm, mmHg", "from fluids.numerics import assert_close, assert_close1d, linspace"], "code": "def test_vacuum_air_leakage_HEI2633():\n    l = vacuum_air_leakage_HEI2633(10, 10000)\n    assert_close(l, 0.001186252403781038, rtol=0.0001)\n    pressures = ((atm - (700 * mmHg)), (atm - (100 * mmHg)), (atm - (50 * mmHg)), (atm - (4 * mmHg)), (atm - (2 * mmHg)), (atm - (0.5 * mmHg)))\n    for p in pressures:\n        assert (vacuum_air_leakage_HEI2633(0.1, p) == vacuum_air_leakage_HEI2633(0.2, p))\n    values = []\n    for p in pressures:\n        values.append(vacuum_air_leakage_HEI2633(6, p))\n    values_expect = [0.0008442279742808746, 0.0008442279742808746, 0.0006390170057983002, 0.00042906223685548387, 0.0002171483498876099, 0.0001093779195609018]\n    assert_close1d(values, values_expect, rtol=0.0001)", "masked_code": "def test_vacuum_air_leakage_HEI2633():\n    l = vacuum_air_leakage_HEI2633(10, 10000)\n    assert_close(l, 0.001186252403781038, rtol=0.0001)\n    pressures = ((atm - (700 * mmHg)), (atm - (100 * mmHg)), (atm - (50 * mmHg)), (atm - (4 * mmHg)), (atm - (2 * mmHg)), (atm - (0.5 * mmHg)))\n    for p in pressures:\n        assert (vacuum_air_leakage_HEI2633(0.1, p) == '???')\n    values = []\n    for p in pressures:\n        values.append(vacuum_air_leakage_HEI2633(6, p))\n    values_expect = [0.0008442279742808746, 0.0008442279742808746, 0.0006390170057983002, 0.00042906223685548387, 0.0002171483498876099, 0.0001093779195609018]\n    assert_close1d(values, values_expect, rtol=0.0001)", "ground_truth": "vacuum_air_leakage_HEI2633(0.2, p)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_59", "reponame": "fluids", "testpath": "tests/test_numba.py", "testname": "test_numba.py", "classname": null, "funcname": "test_normalize", "imports": ["import pytest", "import fluids", "import fluids.vectorized", "from fluids import ATMOSPHERE_1976, SA_ellipsoidal_head, SA_from_h, SA_partial_horiz_torispherical_head, SA_tank, friction_plate_Kumar", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "import numpy as np", "from numpy.testing import assert_allclose"], "code": "@mark_as_numba\ndef test_normalize():\n    xs = np.array([1, 2, 3, 4])\n    res = fluids.numba.normalize(xs)\n    assert (type(res) == np.ndarray)", "masked_code": "@mark_as_numba\ndef test_normalize():\n    xs = np.array([1, 2, 3, 4])\n    res = fluids.numba.normalize(xs)\n    assert (type(res) == '???')", "ground_truth": "np.ndarray", "quality_analysis": {"complexity_score": 6, "left_complexity": 4, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_60", "reponame": "fluids", "testpath": "tests/test_numba.py", "testname": "test_numba.py", "classname": null, "funcname": "test_misc_two_phase", "imports": ["import pytest", "import fluids", "import fluids.vectorized", "from fluids import ATMOSPHERE_1976, SA_ellipsoidal_head, SA_from_h, SA_partial_horiz_torispherical_head, SA_tank, friction_plate_Kumar", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "import numpy as np", "from numpy.testing import assert_allclose"], "code": "@mark_as_numba\ndef test_misc_two_phase():\n    assert_close(fluids.numba.Beggs_Brill(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, P=10000000.0, D=0.05, angle=0, roughness=0, L=1), fluids.Beggs_Brill(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, P=10000000.0, D=0.05, angle=0, roughness=0, L=1))\n    assert_close(fluids.numba.Kim_Mudawar(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1), fluids.Kim_Mudawar(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1))\n    reg_numba = fluids.numba.Mandhane_Gregory_Aziz_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.065, D=0.05)\n    reg_normal = fluids.Mandhane_Gregory_Aziz_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.065, D=0.05)\n    assert (reg_numba[0] == reg_normal[0])\n    assert_close1d(reg_numba[1:], reg_normal[1:])\n    reg_numba = fluids.numba.Taitel_Dukler_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0, angle=0)\n    reg_normal = fluids.Taitel_Dukler_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0, angle=0)\n    assert (reg_numba[0] == reg_normal[0])\n    assert_close1d(reg_numba[1:], reg_normal[1:])\n    assert_close(fluids.numba.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1), fluids.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1))\n    assert_close(fluids.numba.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, P=1000000.0), fluids.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, P=1000000.0))", "masked_code": "@mark_as_numba\ndef test_misc_two_phase():\n    assert_close(fluids.numba.Beggs_Brill(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, P=10000000.0, D=0.05, angle=0, roughness=0, L=1), fluids.Beggs_Brill(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, P=10000000.0, D=0.05, angle=0, roughness=0, L=1))\n    assert_close(fluids.numba.Kim_Mudawar(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1), fluids.Kim_Mudawar(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1))\n    reg_numba = fluids.numba.Mandhane_Gregory_Aziz_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.065, D=0.05)\n    reg_normal = fluids.Mandhane_Gregory_Aziz_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.065, D=0.05)\n    assert (reg_numba[0] == '???')\n    assert_close1d(reg_numba[1:], reg_normal[1:])\n    reg_numba = fluids.numba.Taitel_Dukler_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0, angle=0)\n    reg_normal = fluids.Taitel_Dukler_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0, angle=0)\n    assert (reg_numba[0] == reg_normal[0])\n    assert_close1d(reg_numba[1:], reg_normal[1:])\n    assert_close(fluids.numba.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1), fluids.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1))\n    assert_close(fluids.numba.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, P=1000000.0), fluids.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, P=1000000.0))", "ground_truth": "reg_normal[0]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_61", "reponame": "fluids", "testpath": "tests/test_numba.py", "testname": "test_numba.py", "classname": null, "funcname": "test_misc_two_phase", "imports": ["import pytest", "import fluids", "import fluids.vectorized", "from fluids import ATMOSPHERE_1976, SA_ellipsoidal_head, SA_from_h, SA_partial_horiz_torispherical_head, SA_tank, friction_plate_Kumar", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "import numpy as np", "from numpy.testing import assert_allclose"], "code": "@mark_as_numba\ndef test_misc_two_phase():\n    assert_close(fluids.numba.Beggs_Brill(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, P=10000000.0, D=0.05, angle=0, roughness=0, L=1), fluids.Beggs_Brill(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, P=10000000.0, D=0.05, angle=0, roughness=0, L=1))\n    assert_close(fluids.numba.Kim_Mudawar(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1), fluids.Kim_Mudawar(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1))\n    reg_numba = fluids.numba.Mandhane_Gregory_Aziz_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.065, D=0.05)\n    reg_normal = fluids.Mandhane_Gregory_Aziz_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.065, D=0.05)\n    assert (reg_numba[0] == reg_normal[0])\n    assert_close1d(reg_numba[1:], reg_normal[1:])\n    reg_numba = fluids.numba.Taitel_Dukler_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0, angle=0)\n    reg_normal = fluids.Taitel_Dukler_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0, angle=0)\n    assert (reg_numba[0] == reg_normal[0])\n    assert_close1d(reg_numba[1:], reg_normal[1:])\n    assert_close(fluids.numba.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1), fluids.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1))\n    assert_close(fluids.numba.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, P=1000000.0), fluids.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, P=1000000.0))", "masked_code": "@mark_as_numba\ndef test_misc_two_phase():\n    assert_close(fluids.numba.Beggs_Brill(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, P=10000000.0, D=0.05, angle=0, roughness=0, L=1), fluids.Beggs_Brill(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, P=10000000.0, D=0.05, angle=0, roughness=0, L=1))\n    assert_close(fluids.numba.Kim_Mudawar(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1), fluids.Kim_Mudawar(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1))\n    reg_numba = fluids.numba.Mandhane_Gregory_Aziz_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.065, D=0.05)\n    reg_normal = fluids.Mandhane_Gregory_Aziz_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.065, D=0.05)\n    assert (reg_numba[0] == reg_normal[0])\n    assert_close1d(reg_numba[1:], reg_normal[1:])\n    reg_numba = fluids.numba.Taitel_Dukler_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0, angle=0)\n    reg_normal = fluids.Taitel_Dukler_regime(m=0.6, x=0.112, rhol=915.12, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0, angle=0)\n    assert (reg_numba[0] == '???')\n    assert_close1d(reg_numba[1:], reg_normal[1:])\n    assert_close(fluids.numba.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1), fluids.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1))\n    assert_close(fluids.numba.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, P=1000000.0), fluids.two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, P=1000000.0))", "ground_truth": "reg_normal[0]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_62", "reponame": "fluids", "testpath": "tests/test_numerics.py", "testname": "test_numerics.py", "classname": null, "funcname": "test_bisect_log_exp_terminations", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics import SolverInterface, array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, best_bounding_bounds, chebder, chebint, chebval, chebval_ln_tau, chebval_ln_tau_and_der, chebval_ln_tau_and_der2, chebval_ln_tau_and_der3, cumsum, derivative, hessian, assert_close3d, exp_cheb, exp_cheb_and_der, exp_cheb_and_der2, exp_cheb_and_der3, exp_cheb_ln_tau, exp_cheb_ln_tau_and_der, exp_cheb_ln_tau_and_der2, fit_integral_linear_extrapolation, fit_integral_over_T_linear_extrapolation, full, horner, is_monotonic, is_poly_positive, isclose, jacobian, linspace, max_abs_error, max_abs_rel_error, max_squared_error, max_squared_rel_error, mean_abs_error, mean_abs_rel_error, mean_squared_error, mean_squared_rel_error, min_max_ratios, newton_system, poly_fit_integral_over_T_value, poly_fit_integral_value, polyint, polyint_over_x, polylog2, polynomial_offset_scale, secant, sincos, fixed_point, solve_2_direct, solve_3_direct, solve_4_direct, solve_tridiagonal, std, subset_matrix, translate_bound_f_jac, translate_bound_func, translate_bound_jac, tridiagonals_as_array, trunc_exp_numpy, trunc_log_numpy, zeros, is_increasing, argsort1d, fixed_point_to_residual, residual_to_fixed_point, broyden2, fixed_point_aitken, fixed_point_gdem, fixed_point_anderson, cumulative_trapezoid", "from fluids.numerics import numpy as np"], "code": "def test_bisect_log_exp_terminations():\n    from math import exp, log\n    from fluids.numerics import bisect\n\n    def to_solve(x):\n        try:\n            return exp(x)\n        except:\n            return (- 1)\n    assert (709.782712893384 == bisect(to_solve, 600, 800, xtol=1e-16))\n\n    def to_solve(x):\n        x = (10 ** x)\n        try:\n            return log(x)\n        except:\n            return 1.0\n    assert ((- 323.60724533877976) == bisect(to_solve, (- 300), (- 400), xtol=1e-16))", "masked_code": "def test_bisect_log_exp_terminations():\n    from math import exp, log\n    from fluids.numerics import bisect\n\n    def to_solve(x):\n        try:\n            return exp(x)\n        except:\n            return (- 1)\n    assert (709.782712893384 == bisect(to_solve, 600, 800, xtol=1e-16))\n\n    def to_solve(x):\n        x = (10 ** x)\n        try:\n            return log(x)\n        except:\n            return 1.0\n    assert ((- 323.60724533877976) == '???')", "ground_truth": "bisect(to_solve, (- 300), (- 400), xtol=1e-16)", "quality_analysis": {"complexity_score": 13, "left_complexity": 3, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_63", "reponame": "fluids", "testpath": "tests/test_numerics.py", "testname": "test_numerics.py", "classname": null, "funcname": "test_cumulative_trapezoid", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics import SolverInterface, array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, best_bounding_bounds, chebder, chebint, chebval, chebval_ln_tau, chebval_ln_tau_and_der, chebval_ln_tau_and_der2, chebval_ln_tau_and_der3, cumsum, derivative, hessian, assert_close3d, exp_cheb, exp_cheb_and_der, exp_cheb_and_der2, exp_cheb_and_der3, exp_cheb_ln_tau, exp_cheb_ln_tau_and_der, exp_cheb_ln_tau_and_der2, fit_integral_linear_extrapolation, fit_integral_over_T_linear_extrapolation, full, horner, is_monotonic, is_poly_positive, isclose, jacobian, linspace, max_abs_error, max_abs_rel_error, max_squared_error, max_squared_rel_error, mean_abs_error, mean_abs_rel_error, mean_squared_error, mean_squared_rel_error, min_max_ratios, newton_system, poly_fit_integral_over_T_value, poly_fit_integral_value, polyint, polyint_over_x, polylog2, polynomial_offset_scale, secant, sincos, fixed_point, solve_2_direct, solve_3_direct, solve_4_direct, solve_tridiagonal, std, subset_matrix, translate_bound_f_jac, translate_bound_func, translate_bound_jac, tridiagonals_as_array, trunc_exp_numpy, trunc_log_numpy, zeros, is_increasing, argsort1d, fixed_point_to_residual, residual_to_fixed_point, broyden2, fixed_point_aitken, fixed_point_gdem, fixed_point_anderson, cumulative_trapezoid", "from fluids.numerics import numpy as np"], "code": "def test_cumulative_trapezoid():\n    \"Test the cumulative_trapezoid implementation against scipy's version\\n    and known analytical solutions.\"\n    from scipy.integrate import cumulative_trapezoid as scipy_cumtrapz\n    x = np.linspace((- 2), 2, num=20).tolist()\n    y = x.copy()\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    y = [1, 2, 3, 4]\n    y_scipy = scipy_cumtrapz(y, dx=1).tolist()\n    y_py = cumulative_trapezoid(y, dx=1)\n    assert_allclose(y_py, y_scipy)\n    with pytest.raises(ValueError):\n        cumulative_trapezoid([1, 2, 3], [1, 2])\n    x = [0, 1, 4, 10]\n    y = [0, 1, 4, 10]\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    x = np.linspace(0, 1, 5).tolist()\n    y = ([2.0] * 5)\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    x = [(- 2), (- 1), 0, 1, 2]\n    y = [(- 4), (- 1), 0, 1, 4]\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    assert (cumulative_trapezoid([]) == [])\n    assert (cumulative_trapezoid([1]) == [])", "masked_code": "def test_cumulative_trapezoid():\n    \"Test the cumulative_trapezoid implementation against scipy's version\\n    and known analytical solutions.\"\n    from scipy.integrate import cumulative_trapezoid as scipy_cumtrapz\n    x = np.linspace((- 2), 2, num=20).tolist()\n    y = x.copy()\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    y = [1, 2, 3, 4]\n    y_scipy = scipy_cumtrapz(y, dx=1).tolist()\n    y_py = cumulative_trapezoid(y, dx=1)\n    assert_allclose(y_py, y_scipy)\n    with pytest.raises(ValueError):\n        cumulative_trapezoid([1, 2, 3], [1, 2])\n    x = [0, 1, 4, 10]\n    y = [0, 1, 4, 10]\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    x = np.linspace(0, 1, 5).tolist()\n    y = ([2.0] * 5)\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    x = [(- 2), (- 1), 0, 1, 2]\n    y = [(- 4), (- 1), 0, 1, 4]\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    assert (cumulative_trapezoid([]) == '???')\n    assert (cumulative_trapezoid([1]) == [])", "ground_truth": "[]", "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_64", "reponame": "fluids", "testpath": "tests/test_numerics.py", "testname": "test_numerics.py", "classname": null, "funcname": "test_cumulative_trapezoid", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics import SolverInterface, array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, best_bounding_bounds, chebder, chebint, chebval, chebval_ln_tau, chebval_ln_tau_and_der, chebval_ln_tau_and_der2, chebval_ln_tau_and_der3, cumsum, derivative, hessian, assert_close3d, exp_cheb, exp_cheb_and_der, exp_cheb_and_der2, exp_cheb_and_der3, exp_cheb_ln_tau, exp_cheb_ln_tau_and_der, exp_cheb_ln_tau_and_der2, fit_integral_linear_extrapolation, fit_integral_over_T_linear_extrapolation, full, horner, is_monotonic, is_poly_positive, isclose, jacobian, linspace, max_abs_error, max_abs_rel_error, max_squared_error, max_squared_rel_error, mean_abs_error, mean_abs_rel_error, mean_squared_error, mean_squared_rel_error, min_max_ratios, newton_system, poly_fit_integral_over_T_value, poly_fit_integral_value, polyint, polyint_over_x, polylog2, polynomial_offset_scale, secant, sincos, fixed_point, solve_2_direct, solve_3_direct, solve_4_direct, solve_tridiagonal, std, subset_matrix, translate_bound_f_jac, translate_bound_func, translate_bound_jac, tridiagonals_as_array, trunc_exp_numpy, trunc_log_numpy, zeros, is_increasing, argsort1d, fixed_point_to_residual, residual_to_fixed_point, broyden2, fixed_point_aitken, fixed_point_gdem, fixed_point_anderson, cumulative_trapezoid", "from fluids.numerics import numpy as np"], "code": "def test_cumulative_trapezoid():\n    \"Test the cumulative_trapezoid implementation against scipy's version\\n    and known analytical solutions.\"\n    from scipy.integrate import cumulative_trapezoid as scipy_cumtrapz\n    x = np.linspace((- 2), 2, num=20).tolist()\n    y = x.copy()\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    y = [1, 2, 3, 4]\n    y_scipy = scipy_cumtrapz(y, dx=1).tolist()\n    y_py = cumulative_trapezoid(y, dx=1)\n    assert_allclose(y_py, y_scipy)\n    with pytest.raises(ValueError):\n        cumulative_trapezoid([1, 2, 3], [1, 2])\n    x = [0, 1, 4, 10]\n    y = [0, 1, 4, 10]\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    x = np.linspace(0, 1, 5).tolist()\n    y = ([2.0] * 5)\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    x = [(- 2), (- 1), 0, 1, 2]\n    y = [(- 4), (- 1), 0, 1, 4]\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    assert (cumulative_trapezoid([]) == [])\n    assert (cumulative_trapezoid([1]) == [])", "masked_code": "def test_cumulative_trapezoid():\n    \"Test the cumulative_trapezoid implementation against scipy's version\\n    and known analytical solutions.\"\n    from scipy.integrate import cumulative_trapezoid as scipy_cumtrapz\n    x = np.linspace((- 2), 2, num=20).tolist()\n    y = x.copy()\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    y = [1, 2, 3, 4]\n    y_scipy = scipy_cumtrapz(y, dx=1).tolist()\n    y_py = cumulative_trapezoid(y, dx=1)\n    assert_allclose(y_py, y_scipy)\n    with pytest.raises(ValueError):\n        cumulative_trapezoid([1, 2, 3], [1, 2])\n    x = [0, 1, 4, 10]\n    y = [0, 1, 4, 10]\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    x = np.linspace(0, 1, 5).tolist()\n    y = ([2.0] * 5)\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    x = [(- 2), (- 1), 0, 1, 2]\n    y = [(- 4), (- 1), 0, 1, 4]\n    y_scipy = scipy_cumtrapz(y, x).tolist()\n    y_py = cumulative_trapezoid(y, x)\n    assert_allclose(y_py, y_scipy)\n    assert (cumulative_trapezoid([]) == [])\n    assert (cumulative_trapezoid([1]) == '???')", "ground_truth": "[]", "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_65", "reponame": "fluids", "testpath": "tests/test_numerics.py", "testname": "test_numerics.py", "classname": null, "funcname": "test_diff", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics import SolverInterface, array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, best_bounding_bounds, chebder, chebint, chebval, chebval_ln_tau, chebval_ln_tau_and_der, chebval_ln_tau_and_der2, chebval_ln_tau_and_der3, cumsum, derivative, hessian, assert_close3d, exp_cheb, exp_cheb_and_der, exp_cheb_and_der2, exp_cheb_and_der3, exp_cheb_ln_tau, exp_cheb_ln_tau_and_der, exp_cheb_ln_tau_and_der2, fit_integral_linear_extrapolation, fit_integral_over_T_linear_extrapolation, full, horner, is_monotonic, is_poly_positive, isclose, jacobian, linspace, max_abs_error, max_abs_rel_error, max_squared_error, max_squared_rel_error, mean_abs_error, mean_abs_rel_error, mean_squared_error, mean_squared_rel_error, min_max_ratios, newton_system, poly_fit_integral_over_T_value, poly_fit_integral_value, polyint, polyint_over_x, polylog2, polynomial_offset_scale, secant, sincos, fixed_point, solve_2_direct, solve_3_direct, solve_4_direct, solve_tridiagonal, std, subset_matrix, translate_bound_f_jac, translate_bound_func, translate_bound_jac, tridiagonals_as_array, trunc_exp_numpy, trunc_log_numpy, zeros, is_increasing, argsort1d, fixed_point_to_residual, residual_to_fixed_point, broyden2, fixed_point_aitken, fixed_point_gdem, fixed_point_anderson, cumulative_trapezoid", "from fluids.numerics import numpy as np"], "code": "def test_diff():\n    from fluids.numerics import diff\n    test_arrs = [np.ones(10), np.zeros(10), np.arange(1, 10), (np.arange(1, 10) * 25.1241251), (np.arange(1, 10) ** 1.2), (10.1 + (np.arange(1, 10) ** 20)), (10.1 + np.linspace((- 100), (- 10), 9)), (np.logspace((- 10), (- 100), 19) ** 1.241), (np.logspace(10, 100, 15) ** 1.241)]\n    for test_arr in test_arrs:\n        arr = test_arr.tolist()\n        for n in range(5):\n            diff_np = np.diff(arr, n=n)\n            diff_py = diff(arr, n=n)\n            assert_allclose(diff_np, diff_py)\n    assert (tuple(diff([1, 2, 3], n=0)) == (1, 2, 3))\n    with pytest.raises(Exception):\n        diff([1, 2, 3], n=(- 1))", "masked_code": "def test_diff():\n    from fluids.numerics import diff\n    test_arrs = [np.ones(10), np.zeros(10), np.arange(1, 10), (np.arange(1, 10) * 25.1241251), (np.arange(1, 10) ** 1.2), (10.1 + (np.arange(1, 10) ** 20)), (10.1 + np.linspace((- 100), (- 10), 9)), (np.logspace((- 10), (- 100), 19) ** 1.241), (np.logspace(10, 100, 15) ** 1.241)]\n    for test_arr in test_arrs:\n        arr = test_arr.tolist()\n        for n in range(5):\n            diff_np = np.diff(arr, n=n)\n            diff_py = diff(arr, n=n)\n            assert_allclose(diff_np, diff_py)\n    assert (tuple(diff([1, 2, 3], n=0)) == '???')\n    with pytest.raises(Exception):\n        diff([1, 2, 3], n=(- 1))", "ground_truth": "(1, 2, 3)", "quality_analysis": {"complexity_score": 16, "left_complexity": 11, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_66", "reponame": "fluids", "testpath": "tests/test_numerics.py", "testname": "test_numerics.py", "classname": null, "funcname": "test_exp_cheb_fit_ln_tau", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics import SolverInterface, array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, best_bounding_bounds, chebder, chebint, chebval, chebval_ln_tau, chebval_ln_tau_and_der, chebval_ln_tau_and_der2, chebval_ln_tau_and_der3, cumsum, derivative, hessian, assert_close3d, exp_cheb, exp_cheb_and_der, exp_cheb_and_der2, exp_cheb_and_der3, exp_cheb_ln_tau, exp_cheb_ln_tau_and_der, exp_cheb_ln_tau_and_der2, fit_integral_linear_extrapolation, fit_integral_over_T_linear_extrapolation, full, horner, is_monotonic, is_poly_positive, isclose, jacobian, linspace, max_abs_error, max_abs_rel_error, max_squared_error, max_squared_rel_error, mean_abs_error, mean_abs_rel_error, mean_squared_error, mean_squared_rel_error, min_max_ratios, newton_system, poly_fit_integral_over_T_value, poly_fit_integral_value, polyint, polyint_over_x, polylog2, polynomial_offset_scale, secant, sincos, fixed_point, solve_2_direct, solve_3_direct, solve_4_direct, solve_tridiagonal, std, subset_matrix, translate_bound_f_jac, translate_bound_func, translate_bound_jac, tridiagonals_as_array, trunc_exp_numpy, trunc_log_numpy, zeros, is_increasing, argsort1d, fixed_point_to_residual, residual_to_fixed_point, broyden2, fixed_point_aitken, fixed_point_gdem, fixed_point_anderson, cumulative_trapezoid", "from fluids.numerics import numpy as np"], "code": "def test_exp_cheb_fit_ln_tau():\n    coeffs = [(- 5.922664830406188), (- 3.6003367212635444), (- 0.0989717205896406), 0.05343895281736921, (- 0.02476759166597864), 0.010447569392539213, (- 0.004240542036664352), 0.0017273355647560718, (- 0.0007199858491173661), 0.00030714447101984343, (- 0.00013315510546685339), 5.832551964424226e-05, (- 2.5742454514671165e-05), 1.143577875153956e-05, (- 5.110008470393668e-06), 2.295229193177706e-06, (- 1.0355920205401548e-06), 4.690917226601865e-07, (- 2.1322112805921556e-07), 9.721709759435981e-08, (- 4.4448656630335925e-08), 2.0373327115630335e-08, (- 9.359475430792408e-09), 4.308620855930645e-09, (- 1.9872392620357004e-09), 9.181429297400179e-10, (- 4.2489342599871804e-10), 1.969051449668413e-10, (- 9.139573819982871e-11), 4.2452263926406886e-11, (- 1.9768853221080462e-11), 9.190537220149508e-12, (- 4.2949394041258415e-12), 1.9981863386142606e-12, (- 9.396025624219817e-13), 4.335282133283158e-13, (- 2.0410756418343112e-13), 1.0455525334407412e-13, (- 4.748978987834107e-14), 2.7630675525358583e-14]\n    (Tmin, Tmax, Tc) = (233.22, 646.15, 647.096)\n    expect = 0.031264474019763455\n    (expect_d, expect_d2) = ((- 0.00023379922039411865), (- 1.0453010755999069e-07))\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    coeffs_d = chebder(coeffs, m=1, scl=scale)\n    coeffs_d2 = chebder(coeffs_d, m=1, scl=scale)\n    coeffs_d3 = chebder(coeffs_d2, m=1, scl=scale)\n    T = 500\n    calc = exp_cheb_ln_tau(T, Tc, coeffs, offset, scale)\n    assert (0 == exp_cheb_ln_tau(700, Tc, coeffs, offset, scale))\n    assert_close(expect, calc)\n    calc2 = exp_cheb_ln_tau_and_der(T, Tc, coeffs, coeffs_d, offset, scale)\n    assert ((0, 0) == exp_cheb_ln_tau_and_der(700, Tc, coeffs, coeffs_d, offset, scale))\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = exp_cheb_ln_tau_and_der2(T, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale)\n    assert ((0, 0, 0) == exp_cheb_ln_tau_and_der2(700, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale))\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])", "masked_code": "def test_exp_cheb_fit_ln_tau():\n    coeffs = [(- 5.922664830406188), (- 3.6003367212635444), (- 0.0989717205896406), 0.05343895281736921, (- 0.02476759166597864), 0.010447569392539213, (- 0.004240542036664352), 0.0017273355647560718, (- 0.0007199858491173661), 0.00030714447101984343, (- 0.00013315510546685339), 5.832551964424226e-05, (- 2.5742454514671165e-05), 1.143577875153956e-05, (- 5.110008470393668e-06), 2.295229193177706e-06, (- 1.0355920205401548e-06), 4.690917226601865e-07, (- 2.1322112805921556e-07), 9.721709759435981e-08, (- 4.4448656630335925e-08), 2.0373327115630335e-08, (- 9.359475430792408e-09), 4.308620855930645e-09, (- 1.9872392620357004e-09), 9.181429297400179e-10, (- 4.2489342599871804e-10), 1.969051449668413e-10, (- 9.139573819982871e-11), 4.2452263926406886e-11, (- 1.9768853221080462e-11), 9.190537220149508e-12, (- 4.2949394041258415e-12), 1.9981863386142606e-12, (- 9.396025624219817e-13), 4.335282133283158e-13, (- 2.0410756418343112e-13), 1.0455525334407412e-13, (- 4.748978987834107e-14), 2.7630675525358583e-14]\n    (Tmin, Tmax, Tc) = (233.22, 646.15, 647.096)\n    expect = 0.031264474019763455\n    (expect_d, expect_d2) = ((- 0.00023379922039411865), (- 1.0453010755999069e-07))\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    coeffs_d = chebder(coeffs, m=1, scl=scale)\n    coeffs_d2 = chebder(coeffs_d, m=1, scl=scale)\n    coeffs_d3 = chebder(coeffs_d2, m=1, scl=scale)\n    T = 500\n    calc = exp_cheb_ln_tau(T, Tc, coeffs, offset, scale)\n    assert (0 == exp_cheb_ln_tau(700, Tc, coeffs, offset, scale))\n    assert_close(expect, calc)\n    calc2 = exp_cheb_ln_tau_and_der(T, Tc, coeffs, coeffs_d, offset, scale)\n    assert ((0, 0) == '???')\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = exp_cheb_ln_tau_and_der2(T, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale)\n    assert ((0, 0, 0) == exp_cheb_ln_tau_and_der2(700, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale))\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])", "ground_truth": "exp_cheb_ln_tau_and_der(700, Tc, coeffs, coeffs_d, offset, scale)", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_67", "reponame": "fluids", "testpath": "tests/test_numerics.py", "testname": "test_numerics.py", "classname": null, "funcname": "test_exp_cheb_fit_ln_tau", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics import SolverInterface, array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, best_bounding_bounds, chebder, chebint, chebval, chebval_ln_tau, chebval_ln_tau_and_der, chebval_ln_tau_and_der2, chebval_ln_tau_and_der3, cumsum, derivative, hessian, assert_close3d, exp_cheb, exp_cheb_and_der, exp_cheb_and_der2, exp_cheb_and_der3, exp_cheb_ln_tau, exp_cheb_ln_tau_and_der, exp_cheb_ln_tau_and_der2, fit_integral_linear_extrapolation, fit_integral_over_T_linear_extrapolation, full, horner, is_monotonic, is_poly_positive, isclose, jacobian, linspace, max_abs_error, max_abs_rel_error, max_squared_error, max_squared_rel_error, mean_abs_error, mean_abs_rel_error, mean_squared_error, mean_squared_rel_error, min_max_ratios, newton_system, poly_fit_integral_over_T_value, poly_fit_integral_value, polyint, polyint_over_x, polylog2, polynomial_offset_scale, secant, sincos, fixed_point, solve_2_direct, solve_3_direct, solve_4_direct, solve_tridiagonal, std, subset_matrix, translate_bound_f_jac, translate_bound_func, translate_bound_jac, tridiagonals_as_array, trunc_exp_numpy, trunc_log_numpy, zeros, is_increasing, argsort1d, fixed_point_to_residual, residual_to_fixed_point, broyden2, fixed_point_aitken, fixed_point_gdem, fixed_point_anderson, cumulative_trapezoid", "from fluids.numerics import numpy as np"], "code": "def test_exp_cheb_fit_ln_tau():\n    coeffs = [(- 5.922664830406188), (- 3.6003367212635444), (- 0.0989717205896406), 0.05343895281736921, (- 0.02476759166597864), 0.010447569392539213, (- 0.004240542036664352), 0.0017273355647560718, (- 0.0007199858491173661), 0.00030714447101984343, (- 0.00013315510546685339), 5.832551964424226e-05, (- 2.5742454514671165e-05), 1.143577875153956e-05, (- 5.110008470393668e-06), 2.295229193177706e-06, (- 1.0355920205401548e-06), 4.690917226601865e-07, (- 2.1322112805921556e-07), 9.721709759435981e-08, (- 4.4448656630335925e-08), 2.0373327115630335e-08, (- 9.359475430792408e-09), 4.308620855930645e-09, (- 1.9872392620357004e-09), 9.181429297400179e-10, (- 4.2489342599871804e-10), 1.969051449668413e-10, (- 9.139573819982871e-11), 4.2452263926406886e-11, (- 1.9768853221080462e-11), 9.190537220149508e-12, (- 4.2949394041258415e-12), 1.9981863386142606e-12, (- 9.396025624219817e-13), 4.335282133283158e-13, (- 2.0410756418343112e-13), 1.0455525334407412e-13, (- 4.748978987834107e-14), 2.7630675525358583e-14]\n    (Tmin, Tmax, Tc) = (233.22, 646.15, 647.096)\n    expect = 0.031264474019763455\n    (expect_d, expect_d2) = ((- 0.00023379922039411865), (- 1.0453010755999069e-07))\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    coeffs_d = chebder(coeffs, m=1, scl=scale)\n    coeffs_d2 = chebder(coeffs_d, m=1, scl=scale)\n    coeffs_d3 = chebder(coeffs_d2, m=1, scl=scale)\n    T = 500\n    calc = exp_cheb_ln_tau(T, Tc, coeffs, offset, scale)\n    assert (0 == exp_cheb_ln_tau(700, Tc, coeffs, offset, scale))\n    assert_close(expect, calc)\n    calc2 = exp_cheb_ln_tau_and_der(T, Tc, coeffs, coeffs_d, offset, scale)\n    assert ((0, 0) == exp_cheb_ln_tau_and_der(700, Tc, coeffs, coeffs_d, offset, scale))\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = exp_cheb_ln_tau_and_der2(T, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale)\n    assert ((0, 0, 0) == exp_cheb_ln_tau_and_der2(700, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale))\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])", "masked_code": "def test_exp_cheb_fit_ln_tau():\n    coeffs = [(- 5.922664830406188), (- 3.6003367212635444), (- 0.0989717205896406), 0.05343895281736921, (- 0.02476759166597864), 0.010447569392539213, (- 0.004240542036664352), 0.0017273355647560718, (- 0.0007199858491173661), 0.00030714447101984343, (- 0.00013315510546685339), 5.832551964424226e-05, (- 2.5742454514671165e-05), 1.143577875153956e-05, (- 5.110008470393668e-06), 2.295229193177706e-06, (- 1.0355920205401548e-06), 4.690917226601865e-07, (- 2.1322112805921556e-07), 9.721709759435981e-08, (- 4.4448656630335925e-08), 2.0373327115630335e-08, (- 9.359475430792408e-09), 4.308620855930645e-09, (- 1.9872392620357004e-09), 9.181429297400179e-10, (- 4.2489342599871804e-10), 1.969051449668413e-10, (- 9.139573819982871e-11), 4.2452263926406886e-11, (- 1.9768853221080462e-11), 9.190537220149508e-12, (- 4.2949394041258415e-12), 1.9981863386142606e-12, (- 9.396025624219817e-13), 4.335282133283158e-13, (- 2.0410756418343112e-13), 1.0455525334407412e-13, (- 4.748978987834107e-14), 2.7630675525358583e-14]\n    (Tmin, Tmax, Tc) = (233.22, 646.15, 647.096)\n    expect = 0.031264474019763455\n    (expect_d, expect_d2) = ((- 0.00023379922039411865), (- 1.0453010755999069e-07))\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    coeffs_d = chebder(coeffs, m=1, scl=scale)\n    coeffs_d2 = chebder(coeffs_d, m=1, scl=scale)\n    coeffs_d3 = chebder(coeffs_d2, m=1, scl=scale)\n    T = 500\n    calc = exp_cheb_ln_tau(T, Tc, coeffs, offset, scale)\n    assert (0 == exp_cheb_ln_tau(700, Tc, coeffs, offset, scale))\n    assert_close(expect, calc)\n    calc2 = exp_cheb_ln_tau_and_der(T, Tc, coeffs, coeffs_d, offset, scale)\n    assert ((0, 0) == exp_cheb_ln_tau_and_der(700, Tc, coeffs, coeffs_d, offset, scale))\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = exp_cheb_ln_tau_and_der2(T, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale)\n    assert ((0, 0, 0) == '???')\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])", "ground_truth": "exp_cheb_ln_tau_and_der2(700, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale)", "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_68", "reponame": "fluids", "testpath": "tests/test_numerics.py", "testname": "test_numerics.py", "classname": null, "funcname": "test_chebval_ln_tau", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics import SolverInterface, array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, best_bounding_bounds, chebder, chebint, chebval, chebval_ln_tau, chebval_ln_tau_and_der, chebval_ln_tau_and_der2, chebval_ln_tau_and_der3, cumsum, derivative, hessian, assert_close3d, exp_cheb, exp_cheb_and_der, exp_cheb_and_der2, exp_cheb_and_der3, exp_cheb_ln_tau, exp_cheb_ln_tau_and_der, exp_cheb_ln_tau_and_der2, fit_integral_linear_extrapolation, fit_integral_over_T_linear_extrapolation, full, horner, is_monotonic, is_poly_positive, isclose, jacobian, linspace, max_abs_error, max_abs_rel_error, max_squared_error, max_squared_rel_error, mean_abs_error, mean_abs_rel_error, mean_squared_error, mean_squared_rel_error, min_max_ratios, newton_system, poly_fit_integral_over_T_value, poly_fit_integral_value, polyint, polyint_over_x, polylog2, polynomial_offset_scale, secant, sincos, fixed_point, solve_2_direct, solve_3_direct, solve_4_direct, solve_tridiagonal, std, subset_matrix, translate_bound_f_jac, translate_bound_func, translate_bound_jac, tridiagonals_as_array, trunc_exp_numpy, trunc_log_numpy, zeros, is_increasing, argsort1d, fixed_point_to_residual, residual_to_fixed_point, broyden2, fixed_point_aitken, fixed_point_gdem, fixed_point_anderson, cumulative_trapezoid", "from fluids.numerics import numpy as np"], "code": "def test_chebval_ln_tau():\n    (Tmin, Tmax) = (178.18, 591.0)\n    Tc = 591.75\n    coeffs = [18231.740838720892, (- 18598.514785409734), 5237.841944302821, (- 1010.5549489362293), 147.88312821848922, (- 17.412144225239444), 1.7141064359038864, (- 0.14493639179363527), 0.01073811633477817, (- 0.0007078634084791702), 4.202655964036239e-05, (- 2.274648068123497e-06), 1.1239490049774759e-07]\n    T = 500\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    coeffs_d = chebder(coeffs, m=1, scl=scale)\n    coeffs_d2 = chebder(coeffs_d, m=1, scl=scale)\n    coeffs_d3 = chebder(coeffs_d2, m=1, scl=scale)\n    calc = chebval_ln_tau(T, Tc, coeffs, offset, scale)\n    assert (0 == chebval_ln_tau(600, Tc, coeffs, offset, scale))\n    expect = 24498.131947622023\n    (expect_d, expect_d2, expect_d3) = ((- 100.77476795241955), (- 0.6838185834436981), (- 0.012093191904152178))\n    assert_close(expect, calc)\n    calc2 = chebval_ln_tau_and_der(T, Tc, coeffs, coeffs_d, offset, scale)\n    assert ((0, 0) == chebval_ln_tau_and_der(600, Tc, coeffs, coeffs_d, offset, scale))\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = chebval_ln_tau_and_der2(T, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale)\n    assert ((0, 0, 0) == chebval_ln_tau_and_der2(600, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale))\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])\n    calc4 = chebval_ln_tau_and_der3(T, Tc, coeffs, coeffs_d, coeffs_d2, coeffs_d3, offset, scale)\n    assert ((0, 0, 0, 0) == chebval_ln_tau_and_der3(600, Tc, coeffs, coeffs_d, coeffs_d2, coeffs_d3, offset, scale))\n    assert_close(expect, calc4[0])\n    assert_close(expect_d, calc4[1])\n    assert_close(expect_d2, calc4[2])\n    assert_close(expect_d3, calc4[3])", "masked_code": "def test_chebval_ln_tau():\n    (Tmin, Tmax) = (178.18, 591.0)\n    Tc = 591.75\n    coeffs = [18231.740838720892, (- 18598.514785409734), 5237.841944302821, (- 1010.5549489362293), 147.88312821848922, (- 17.412144225239444), 1.7141064359038864, (- 0.14493639179363527), 0.01073811633477817, (- 0.0007078634084791702), 4.202655964036239e-05, (- 2.274648068123497e-06), 1.1239490049774759e-07]\n    T = 500\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    coeffs_d = chebder(coeffs, m=1, scl=scale)\n    coeffs_d2 = chebder(coeffs_d, m=1, scl=scale)\n    coeffs_d3 = chebder(coeffs_d2, m=1, scl=scale)\n    calc = chebval_ln_tau(T, Tc, coeffs, offset, scale)\n    assert (0 == chebval_ln_tau(600, Tc, coeffs, offset, scale))\n    expect = 24498.131947622023\n    (expect_d, expect_d2, expect_d3) = ((- 100.77476795241955), (- 0.6838185834436981), (- 0.012093191904152178))\n    assert_close(expect, calc)\n    calc2 = chebval_ln_tau_and_der(T, Tc, coeffs, coeffs_d, offset, scale)\n    assert ((0, 0) == '???')\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = chebval_ln_tau_and_der2(T, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale)\n    assert ((0, 0, 0) == chebval_ln_tau_and_der2(600, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale))\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])\n    calc4 = chebval_ln_tau_and_der3(T, Tc, coeffs, coeffs_d, coeffs_d2, coeffs_d3, offset, scale)\n    assert ((0, 0, 0, 0) == chebval_ln_tau_and_der3(600, Tc, coeffs, coeffs_d, coeffs_d2, coeffs_d3, offset, scale))\n    assert_close(expect, calc4[0])\n    assert_close(expect_d, calc4[1])\n    assert_close(expect_d2, calc4[2])\n    assert_close(expect_d3, calc4[3])", "ground_truth": "chebval_ln_tau_and_der(600, Tc, coeffs, coeffs_d, offset, scale)", "quality_analysis": {"complexity_score": 13, "left_complexity": 4, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_69", "reponame": "fluids", "testpath": "tests/test_numerics.py", "testname": "test_numerics.py", "classname": null, "funcname": "test_chebval_ln_tau", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics import SolverInterface, array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, best_bounding_bounds, chebder, chebint, chebval, chebval_ln_tau, chebval_ln_tau_and_der, chebval_ln_tau_and_der2, chebval_ln_tau_and_der3, cumsum, derivative, hessian, assert_close3d, exp_cheb, exp_cheb_and_der, exp_cheb_and_der2, exp_cheb_and_der3, exp_cheb_ln_tau, exp_cheb_ln_tau_and_der, exp_cheb_ln_tau_and_der2, fit_integral_linear_extrapolation, fit_integral_over_T_linear_extrapolation, full, horner, is_monotonic, is_poly_positive, isclose, jacobian, linspace, max_abs_error, max_abs_rel_error, max_squared_error, max_squared_rel_error, mean_abs_error, mean_abs_rel_error, mean_squared_error, mean_squared_rel_error, min_max_ratios, newton_system, poly_fit_integral_over_T_value, poly_fit_integral_value, polyint, polyint_over_x, polylog2, polynomial_offset_scale, secant, sincos, fixed_point, solve_2_direct, solve_3_direct, solve_4_direct, solve_tridiagonal, std, subset_matrix, translate_bound_f_jac, translate_bound_func, translate_bound_jac, tridiagonals_as_array, trunc_exp_numpy, trunc_log_numpy, zeros, is_increasing, argsort1d, fixed_point_to_residual, residual_to_fixed_point, broyden2, fixed_point_aitken, fixed_point_gdem, fixed_point_anderson, cumulative_trapezoid", "from fluids.numerics import numpy as np"], "code": "def test_chebval_ln_tau():\n    (Tmin, Tmax) = (178.18, 591.0)\n    Tc = 591.75\n    coeffs = [18231.740838720892, (- 18598.514785409734), 5237.841944302821, (- 1010.5549489362293), 147.88312821848922, (- 17.412144225239444), 1.7141064359038864, (- 0.14493639179363527), 0.01073811633477817, (- 0.0007078634084791702), 4.202655964036239e-05, (- 2.274648068123497e-06), 1.1239490049774759e-07]\n    T = 500\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    coeffs_d = chebder(coeffs, m=1, scl=scale)\n    coeffs_d2 = chebder(coeffs_d, m=1, scl=scale)\n    coeffs_d3 = chebder(coeffs_d2, m=1, scl=scale)\n    calc = chebval_ln_tau(T, Tc, coeffs, offset, scale)\n    assert (0 == chebval_ln_tau(600, Tc, coeffs, offset, scale))\n    expect = 24498.131947622023\n    (expect_d, expect_d2, expect_d3) = ((- 100.77476795241955), (- 0.6838185834436981), (- 0.012093191904152178))\n    assert_close(expect, calc)\n    calc2 = chebval_ln_tau_and_der(T, Tc, coeffs, coeffs_d, offset, scale)\n    assert ((0, 0) == chebval_ln_tau_and_der(600, Tc, coeffs, coeffs_d, offset, scale))\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = chebval_ln_tau_and_der2(T, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale)\n    assert ((0, 0, 0) == chebval_ln_tau_and_der2(600, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale))\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])\n    calc4 = chebval_ln_tau_and_der3(T, Tc, coeffs, coeffs_d, coeffs_d2, coeffs_d3, offset, scale)\n    assert ((0, 0, 0, 0) == chebval_ln_tau_and_der3(600, Tc, coeffs, coeffs_d, coeffs_d2, coeffs_d3, offset, scale))\n    assert_close(expect, calc4[0])\n    assert_close(expect_d, calc4[1])\n    assert_close(expect_d2, calc4[2])\n    assert_close(expect_d3, calc4[3])", "masked_code": "def test_chebval_ln_tau():\n    (Tmin, Tmax) = (178.18, 591.0)\n    Tc = 591.75\n    coeffs = [18231.740838720892, (- 18598.514785409734), 5237.841944302821, (- 1010.5549489362293), 147.88312821848922, (- 17.412144225239444), 1.7141064359038864, (- 0.14493639179363527), 0.01073811633477817, (- 0.0007078634084791702), 4.202655964036239e-05, (- 2.274648068123497e-06), 1.1239490049774759e-07]\n    T = 500\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    coeffs_d = chebder(coeffs, m=1, scl=scale)\n    coeffs_d2 = chebder(coeffs_d, m=1, scl=scale)\n    coeffs_d3 = chebder(coeffs_d2, m=1, scl=scale)\n    calc = chebval_ln_tau(T, Tc, coeffs, offset, scale)\n    assert (0 == chebval_ln_tau(600, Tc, coeffs, offset, scale))\n    expect = 24498.131947622023\n    (expect_d, expect_d2, expect_d3) = ((- 100.77476795241955), (- 0.6838185834436981), (- 0.012093191904152178))\n    assert_close(expect, calc)\n    calc2 = chebval_ln_tau_and_der(T, Tc, coeffs, coeffs_d, offset, scale)\n    assert ((0, 0) == chebval_ln_tau_and_der(600, Tc, coeffs, coeffs_d, offset, scale))\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = chebval_ln_tau_and_der2(T, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale)\n    assert ((0, 0, 0) == '???')\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])\n    calc4 = chebval_ln_tau_and_der3(T, Tc, coeffs, coeffs_d, coeffs_d2, coeffs_d3, offset, scale)\n    assert ((0, 0, 0, 0) == chebval_ln_tau_and_der3(600, Tc, coeffs, coeffs_d, coeffs_d2, coeffs_d3, offset, scale))\n    assert_close(expect, calc4[0])\n    assert_close(expect_d, calc4[1])\n    assert_close(expect_d2, calc4[2])\n    assert_close(expect_d3, calc4[3])", "ground_truth": "chebval_ln_tau_and_der2(600, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale)", "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_70", "reponame": "fluids", "testpath": "tests/test_numerics.py", "testname": "test_numerics.py", "classname": null, "funcname": "test_chebval_ln_tau", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics import SolverInterface, array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, best_bounding_bounds, chebder, chebint, chebval, chebval_ln_tau, chebval_ln_tau_and_der, chebval_ln_tau_and_der2, chebval_ln_tau_and_der3, cumsum, derivative, hessian, assert_close3d, exp_cheb, exp_cheb_and_der, exp_cheb_and_der2, exp_cheb_and_der3, exp_cheb_ln_tau, exp_cheb_ln_tau_and_der, exp_cheb_ln_tau_and_der2, fit_integral_linear_extrapolation, fit_integral_over_T_linear_extrapolation, full, horner, is_monotonic, is_poly_positive, isclose, jacobian, linspace, max_abs_error, max_abs_rel_error, max_squared_error, max_squared_rel_error, mean_abs_error, mean_abs_rel_error, mean_squared_error, mean_squared_rel_error, min_max_ratios, newton_system, poly_fit_integral_over_T_value, poly_fit_integral_value, polyint, polyint_over_x, polylog2, polynomial_offset_scale, secant, sincos, fixed_point, solve_2_direct, solve_3_direct, solve_4_direct, solve_tridiagonal, std, subset_matrix, translate_bound_f_jac, translate_bound_func, translate_bound_jac, tridiagonals_as_array, trunc_exp_numpy, trunc_log_numpy, zeros, is_increasing, argsort1d, fixed_point_to_residual, residual_to_fixed_point, broyden2, fixed_point_aitken, fixed_point_gdem, fixed_point_anderson, cumulative_trapezoid", "from fluids.numerics import numpy as np"], "code": "def test_chebval_ln_tau():\n    (Tmin, Tmax) = (178.18, 591.0)\n    Tc = 591.75\n    coeffs = [18231.740838720892, (- 18598.514785409734), 5237.841944302821, (- 1010.5549489362293), 147.88312821848922, (- 17.412144225239444), 1.7141064359038864, (- 0.14493639179363527), 0.01073811633477817, (- 0.0007078634084791702), 4.202655964036239e-05, (- 2.274648068123497e-06), 1.1239490049774759e-07]\n    T = 500\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    coeffs_d = chebder(coeffs, m=1, scl=scale)\n    coeffs_d2 = chebder(coeffs_d, m=1, scl=scale)\n    coeffs_d3 = chebder(coeffs_d2, m=1, scl=scale)\n    calc = chebval_ln_tau(T, Tc, coeffs, offset, scale)\n    assert (0 == chebval_ln_tau(600, Tc, coeffs, offset, scale))\n    expect = 24498.131947622023\n    (expect_d, expect_d2, expect_d3) = ((- 100.77476795241955), (- 0.6838185834436981), (- 0.012093191904152178))\n    assert_close(expect, calc)\n    calc2 = chebval_ln_tau_and_der(T, Tc, coeffs, coeffs_d, offset, scale)\n    assert ((0, 0) == chebval_ln_tau_and_der(600, Tc, coeffs, coeffs_d, offset, scale))\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = chebval_ln_tau_and_der2(T, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale)\n    assert ((0, 0, 0) == chebval_ln_tau_and_der2(600, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale))\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])\n    calc4 = chebval_ln_tau_and_der3(T, Tc, coeffs, coeffs_d, coeffs_d2, coeffs_d3, offset, scale)\n    assert ((0, 0, 0, 0) == chebval_ln_tau_and_der3(600, Tc, coeffs, coeffs_d, coeffs_d2, coeffs_d3, offset, scale))\n    assert_close(expect, calc4[0])\n    assert_close(expect_d, calc4[1])\n    assert_close(expect_d2, calc4[2])\n    assert_close(expect_d3, calc4[3])", "masked_code": "def test_chebval_ln_tau():\n    (Tmin, Tmax) = (178.18, 591.0)\n    Tc = 591.75\n    coeffs = [18231.740838720892, (- 18598.514785409734), 5237.841944302821, (- 1010.5549489362293), 147.88312821848922, (- 17.412144225239444), 1.7141064359038864, (- 0.14493639179363527), 0.01073811633477817, (- 0.0007078634084791702), 4.202655964036239e-05, (- 2.274648068123497e-06), 1.1239490049774759e-07]\n    T = 500\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    coeffs_d = chebder(coeffs, m=1, scl=scale)\n    coeffs_d2 = chebder(coeffs_d, m=1, scl=scale)\n    coeffs_d3 = chebder(coeffs_d2, m=1, scl=scale)\n    calc = chebval_ln_tau(T, Tc, coeffs, offset, scale)\n    assert (0 == chebval_ln_tau(600, Tc, coeffs, offset, scale))\n    expect = 24498.131947622023\n    (expect_d, expect_d2, expect_d3) = ((- 100.77476795241955), (- 0.6838185834436981), (- 0.012093191904152178))\n    assert_close(expect, calc)\n    calc2 = chebval_ln_tau_and_der(T, Tc, coeffs, coeffs_d, offset, scale)\n    assert ((0, 0) == chebval_ln_tau_and_der(600, Tc, coeffs, coeffs_d, offset, scale))\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = chebval_ln_tau_and_der2(T, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale)\n    assert ((0, 0, 0) == chebval_ln_tau_and_der2(600, Tc, coeffs, coeffs_d, coeffs_d2, offset, scale))\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])\n    calc4 = chebval_ln_tau_and_der3(T, Tc, coeffs, coeffs_d, coeffs_d2, coeffs_d3, offset, scale)\n    assert ((0, 0, 0, 0) == '???')\n    assert_close(expect, calc4[0])\n    assert_close(expect_d, calc4[1])\n    assert_close(expect_d2, calc4[2])\n    assert_close(expect_d3, calc4[3])", "ground_truth": "chebval_ln_tau_and_der3(600, Tc, coeffs, coeffs_d, coeffs_d2, coeffs_d3, offset, scale)", "quality_analysis": {"complexity_score": 17, "left_complexity": 6, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_71", "reponame": "fluids", "testpath": "tests/test_numerics.py", "testname": "test_numerics.py", "classname": null, "funcname": "test_newton_system_with_damping_function", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics import SolverInterface, array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, best_bounding_bounds, chebder, chebint, chebval, chebval_ln_tau, chebval_ln_tau_and_der, chebval_ln_tau_and_der2, chebval_ln_tau_and_der3, cumsum, derivative, hessian, assert_close3d, exp_cheb, exp_cheb_and_der, exp_cheb_and_der2, exp_cheb_and_der3, exp_cheb_ln_tau, exp_cheb_ln_tau_and_der, exp_cheb_ln_tau_and_der2, fit_integral_linear_extrapolation, fit_integral_over_T_linear_extrapolation, full, horner, is_monotonic, is_poly_positive, isclose, jacobian, linspace, max_abs_error, max_abs_rel_error, max_squared_error, max_squared_rel_error, mean_abs_error, mean_abs_rel_error, mean_squared_error, mean_squared_rel_error, min_max_ratios, newton_system, poly_fit_integral_over_T_value, poly_fit_integral_value, polyint, polyint_over_x, polylog2, polynomial_offset_scale, secant, sincos, fixed_point, solve_2_direct, solve_3_direct, solve_4_direct, solve_tridiagonal, std, subset_matrix, translate_bound_f_jac, translate_bound_func, translate_bound_jac, tridiagonals_as_array, trunc_exp_numpy, trunc_log_numpy, zeros, is_increasing, argsort1d, fixed_point_to_residual, residual_to_fixed_point, broyden2, fixed_point_aitken, fixed_point_gdem, fixed_point_anderson, cumulative_trapezoid", "from fluids.numerics import numpy as np"], "code": "def test_newton_system_with_damping_function():\n\n    def damping_func_max_one_second(x, step, damping, *args):\n        new_step = []\n        for v in step:\n            if (abs(v) > damping):\n                if (v < 0):\n                    new_step.append((- damping))\n                else:\n                    new_step.append(damping)\n            else:\n                new_step.append(v)\n        xnew = [(xi + s) for (xi, s) in zip(x, new_step)]\n        return xnew\n    Ts = []\n\n    def test_objf_with_damping(inputs):\n        (x, T) = inputs\n        Ts.append(T)\n        k = (0.12 * exp(((12581 * (T - 298.0)) / (298.0 * T))))\n        return [((120 * x) - ((75 * k) * (1 - x))), (((- x) * (873 - T)) - (11.0 * (T - 300)))]\n\n    def test_jac_with_damping(inputs):\n        (x, T) = inputs\n        ans = [[((9.0 * exp(((0.00335570469798658 * ((12581 * T) - 3749138.0)) / T))) + 120), ((((42.2181208053691 / T) - ((0.00335570469798658 * ((12581 * T) - 3749138.0)) / (T ** 2))) * ((9.0 * x) - 9.0)) * exp(((0.00335570469798658 * ((12581 * T) - 3749138.0)) / T)))], [(T - 873), (x - 11.0)]]\n        return ans\n    near_solution = [0.05995136780143791, 300]\n    (ans, iterations) = newton_system(test_objf_with_damping, near_solution, jac=test_jac_with_damping, line_search=True, damping=1, ytol=1e-07, xtol=None, damping_func=damping_func_max_one_second)\n    assert (Ts[0:4] == [300, 299, 298, 297])\n    Ts = []\n    (ans, iterations) = newton_system(test_objf_with_damping, near_solution, jac=test_jac_with_damping, line_search=True, damping=2, ytol=1e-07, xtol=None, damping_func=damping_func_max_one_second)\n    assert ([300, 298] == Ts[0:2])", "masked_code": "def test_newton_system_with_damping_function():\n\n    def damping_func_max_one_second(x, step, damping, *args):\n        new_step = []\n        for v in step:\n            if (abs(v) > damping):\n                if (v < 0):\n                    new_step.append((- damping))\n                else:\n                    new_step.append(damping)\n            else:\n                new_step.append(v)\n        xnew = [(xi + s) for (xi, s) in zip(x, new_step)]\n        return xnew\n    Ts = []\n\n    def test_objf_with_damping(inputs):\n        (x, T) = inputs\n        Ts.append(T)\n        k = (0.12 * exp(((12581 * (T - 298.0)) / (298.0 * T))))\n        return [((120 * x) - ((75 * k) * (1 - x))), (((- x) * (873 - T)) - (11.0 * (T - 300)))]\n\n    def test_jac_with_damping(inputs):\n        (x, T) = inputs\n        ans = [[((9.0 * exp(((0.00335570469798658 * ((12581 * T) - 3749138.0)) / T))) + 120), ((((42.2181208053691 / T) - ((0.00335570469798658 * ((12581 * T) - 3749138.0)) / (T ** 2))) * ((9.0 * x) - 9.0)) * exp(((0.00335570469798658 * ((12581 * T) - 3749138.0)) / T)))], [(T - 873), (x - 11.0)]]\n        return ans\n    near_solution = [0.05995136780143791, 300]\n    (ans, iterations) = newton_system(test_objf_with_damping, near_solution, jac=test_jac_with_damping, line_search=True, damping=1, ytol=1e-07, xtol=None, damping_func=damping_func_max_one_second)\n    assert (Ts[0:4] == '???')\n    Ts = []\n    (ans, iterations) = newton_system(test_objf_with_damping, near_solution, jac=test_jac_with_damping, line_search=True, damping=2, ytol=1e-07, xtol=None, damping_func=damping_func_max_one_second)\n    assert ([300, 298] == Ts[0:2])", "ground_truth": "[300, 299, 298, 297]", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_72", "reponame": "fluids", "testpath": "tests/test_numerics.py", "testname": "test_numerics.py", "classname": null, "funcname": "test_newton_system_with_damping_function", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics import SolverInterface, array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, best_bounding_bounds, chebder, chebint, chebval, chebval_ln_tau, chebval_ln_tau_and_der, chebval_ln_tau_and_der2, chebval_ln_tau_and_der3, cumsum, derivative, hessian, assert_close3d, exp_cheb, exp_cheb_and_der, exp_cheb_and_der2, exp_cheb_and_der3, exp_cheb_ln_tau, exp_cheb_ln_tau_and_der, exp_cheb_ln_tau_and_der2, fit_integral_linear_extrapolation, fit_integral_over_T_linear_extrapolation, full, horner, is_monotonic, is_poly_positive, isclose, jacobian, linspace, max_abs_error, max_abs_rel_error, max_squared_error, max_squared_rel_error, mean_abs_error, mean_abs_rel_error, mean_squared_error, mean_squared_rel_error, min_max_ratios, newton_system, poly_fit_integral_over_T_value, poly_fit_integral_value, polyint, polyint_over_x, polylog2, polynomial_offset_scale, secant, sincos, fixed_point, solve_2_direct, solve_3_direct, solve_4_direct, solve_tridiagonal, std, subset_matrix, translate_bound_f_jac, translate_bound_func, translate_bound_jac, tridiagonals_as_array, trunc_exp_numpy, trunc_log_numpy, zeros, is_increasing, argsort1d, fixed_point_to_residual, residual_to_fixed_point, broyden2, fixed_point_aitken, fixed_point_gdem, fixed_point_anderson, cumulative_trapezoid", "from fluids.numerics import numpy as np"], "code": "def test_newton_system_with_damping_function():\n\n    def damping_func_max_one_second(x, step, damping, *args):\n        new_step = []\n        for v in step:\n            if (abs(v) > damping):\n                if (v < 0):\n                    new_step.append((- damping))\n                else:\n                    new_step.append(damping)\n            else:\n                new_step.append(v)\n        xnew = [(xi + s) for (xi, s) in zip(x, new_step)]\n        return xnew\n    Ts = []\n\n    def test_objf_with_damping(inputs):\n        (x, T) = inputs\n        Ts.append(T)\n        k = (0.12 * exp(((12581 * (T - 298.0)) / (298.0 * T))))\n        return [((120 * x) - ((75 * k) * (1 - x))), (((- x) * (873 - T)) - (11.0 * (T - 300)))]\n\n    def test_jac_with_damping(inputs):\n        (x, T) = inputs\n        ans = [[((9.0 * exp(((0.00335570469798658 * ((12581 * T) - 3749138.0)) / T))) + 120), ((((42.2181208053691 / T) - ((0.00335570469798658 * ((12581 * T) - 3749138.0)) / (T ** 2))) * ((9.0 * x) - 9.0)) * exp(((0.00335570469798658 * ((12581 * T) - 3749138.0)) / T)))], [(T - 873), (x - 11.0)]]\n        return ans\n    near_solution = [0.05995136780143791, 300]\n    (ans, iterations) = newton_system(test_objf_with_damping, near_solution, jac=test_jac_with_damping, line_search=True, damping=1, ytol=1e-07, xtol=None, damping_func=damping_func_max_one_second)\n    assert (Ts[0:4] == [300, 299, 298, 297])\n    Ts = []\n    (ans, iterations) = newton_system(test_objf_with_damping, near_solution, jac=test_jac_with_damping, line_search=True, damping=2, ytol=1e-07, xtol=None, damping_func=damping_func_max_one_second)\n    assert ([300, 298] == Ts[0:2])", "masked_code": "def test_newton_system_with_damping_function():\n\n    def damping_func_max_one_second(x, step, damping, *args):\n        new_step = []\n        for v in step:\n            if (abs(v) > damping):\n                if (v < 0):\n                    new_step.append((- damping))\n                else:\n                    new_step.append(damping)\n            else:\n                new_step.append(v)\n        xnew = [(xi + s) for (xi, s) in zip(x, new_step)]\n        return xnew\n    Ts = []\n\n    def test_objf_with_damping(inputs):\n        (x, T) = inputs\n        Ts.append(T)\n        k = (0.12 * exp(((12581 * (T - 298.0)) / (298.0 * T))))\n        return [((120 * x) - ((75 * k) * (1 - x))), (((- x) * (873 - T)) - (11.0 * (T - 300)))]\n\n    def test_jac_with_damping(inputs):\n        (x, T) = inputs\n        ans = [[((9.0 * exp(((0.00335570469798658 * ((12581 * T) - 3749138.0)) / T))) + 120), ((((42.2181208053691 / T) - ((0.00335570469798658 * ((12581 * T) - 3749138.0)) / (T ** 2))) * ((9.0 * x) - 9.0)) * exp(((0.00335570469798658 * ((12581 * T) - 3749138.0)) / T)))], [(T - 873), (x - 11.0)]]\n        return ans\n    near_solution = [0.05995136780143791, 300]\n    (ans, iterations) = newton_system(test_objf_with_damping, near_solution, jac=test_jac_with_damping, line_search=True, damping=1, ytol=1e-07, xtol=None, damping_func=damping_func_max_one_second)\n    assert (Ts[0:4] == [300, 299, 298, 297])\n    Ts = []\n    (ans, iterations) = newton_system(test_objf_with_damping, near_solution, jac=test_jac_with_damping, line_search=True, damping=2, ytol=1e-07, xtol=None, damping_func=damping_func_max_one_second)\n    assert ([300, 298] == '???')", "ground_truth": "Ts[0:2]", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_73", "reponame": "fluids", "testpath": "tests/test_numerics.py", "testname": "test_numerics.py", "classname": null, "funcname": "test_SolverInterface_fixed_point", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics import SolverInterface, array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, best_bounding_bounds, chebder, chebint, chebval, chebval_ln_tau, chebval_ln_tau_and_der, chebval_ln_tau_and_der2, chebval_ln_tau_and_der3, cumsum, derivative, hessian, assert_close3d, exp_cheb, exp_cheb_and_der, exp_cheb_and_der2, exp_cheb_and_der3, exp_cheb_ln_tau, exp_cheb_ln_tau_and_der, exp_cheb_ln_tau_and_der2, fit_integral_linear_extrapolation, fit_integral_over_T_linear_extrapolation, full, horner, is_monotonic, is_poly_positive, isclose, jacobian, linspace, max_abs_error, max_abs_rel_error, max_squared_error, max_squared_rel_error, mean_abs_error, mean_abs_rel_error, mean_squared_error, mean_squared_rel_error, min_max_ratios, newton_system, poly_fit_integral_over_T_value, poly_fit_integral_value, polyint, polyint_over_x, polylog2, polynomial_offset_scale, secant, sincos, fixed_point, solve_2_direct, solve_3_direct, solve_4_direct, solve_tridiagonal, std, subset_matrix, translate_bound_f_jac, translate_bound_func, translate_bound_jac, tridiagonals_as_array, trunc_exp_numpy, trunc_log_numpy, zeros, is_increasing, argsort1d, fixed_point_to_residual, residual_to_fixed_point, broyden2, fixed_point_aitken, fixed_point_gdem, fixed_point_anderson, cumulative_trapezoid", "from fluids.numerics import numpy as np"], "code": "def test_SolverInterface_fixed_point():\n    solver = SolverInterface(method='fixed_point', objf=fixed_point_to_residual(fixed_point_1_func), maxiter=1000, xtol=1e-09)\n    ans = solver.solve(fixed_point_1_guess)\n    assert_close1d(ans, fixed_point_1_expect, rtol=1e-06)\n    solver = SolverInterface(method='fixed_point_aitken', objf=fixed_point_to_residual(fixed_point_1_func), maxiter=1000, xtol=1e-12)\n    ans = solver.solve(fixed_point_1_guess)\n    assert (solver.fval_iter == 79)\n    assert_close1d(ans, fixed_point_1_expect, rtol=1e-06)\n    solver = SolverInterface(method='fixed_point_gdem', objf=fixed_point_to_residual(fixed_point_1_func), maxiter=1000, xtol=1e-12)\n    ans = solver.solve(fixed_point_1_guess)\n    assert (solver.fval_iter == 37)\n    assert_close1d(ans, fixed_point_1_expect, rtol=1e-12)", "masked_code": "def test_SolverInterface_fixed_point():\n    solver = SolverInterface(method='fixed_point', objf=fixed_point_to_residual(fixed_point_1_func), maxiter=1000, xtol=1e-09)\n    ans = solver.solve(fixed_point_1_guess)\n    assert_close1d(ans, fixed_point_1_expect, rtol=1e-06)\n    solver = SolverInterface(method='fixed_point_aitken', objf=fixed_point_to_residual(fixed_point_1_func), maxiter=1000, xtol=1e-12)\n    ans = solver.solve(fixed_point_1_guess)\n    assert (solver.fval_iter == '???')\n    assert_close1d(ans, fixed_point_1_expect, rtol=1e-06)\n    solver = SolverInterface(method='fixed_point_gdem', objf=fixed_point_to_residual(fixed_point_1_func), maxiter=1000, xtol=1e-12)\n    ans = solver.solve(fixed_point_1_guess)\n    assert (solver.fval_iter == 37)\n    assert_close1d(ans, fixed_point_1_expect, rtol=1e-12)", "ground_truth": "79", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_74", "reponame": "fluids", "testpath": "tests/test_numerics.py", "testname": "test_numerics.py", "classname": null, "funcname": "test_SolverInterface_fixed_point", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics import SolverInterface, array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, best_bounding_bounds, chebder, chebint, chebval, chebval_ln_tau, chebval_ln_tau_and_der, chebval_ln_tau_and_der2, chebval_ln_tau_and_der3, cumsum, derivative, hessian, assert_close3d, exp_cheb, exp_cheb_and_der, exp_cheb_and_der2, exp_cheb_and_der3, exp_cheb_ln_tau, exp_cheb_ln_tau_and_der, exp_cheb_ln_tau_and_der2, fit_integral_linear_extrapolation, fit_integral_over_T_linear_extrapolation, full, horner, is_monotonic, is_poly_positive, isclose, jacobian, linspace, max_abs_error, max_abs_rel_error, max_squared_error, max_squared_rel_error, mean_abs_error, mean_abs_rel_error, mean_squared_error, mean_squared_rel_error, min_max_ratios, newton_system, poly_fit_integral_over_T_value, poly_fit_integral_value, polyint, polyint_over_x, polylog2, polynomial_offset_scale, secant, sincos, fixed_point, solve_2_direct, solve_3_direct, solve_4_direct, solve_tridiagonal, std, subset_matrix, translate_bound_f_jac, translate_bound_func, translate_bound_jac, tridiagonals_as_array, trunc_exp_numpy, trunc_log_numpy, zeros, is_increasing, argsort1d, fixed_point_to_residual, residual_to_fixed_point, broyden2, fixed_point_aitken, fixed_point_gdem, fixed_point_anderson, cumulative_trapezoid", "from fluids.numerics import numpy as np"], "code": "def test_SolverInterface_fixed_point():\n    solver = SolverInterface(method='fixed_point', objf=fixed_point_to_residual(fixed_point_1_func), maxiter=1000, xtol=1e-09)\n    ans = solver.solve(fixed_point_1_guess)\n    assert_close1d(ans, fixed_point_1_expect, rtol=1e-06)\n    solver = SolverInterface(method='fixed_point_aitken', objf=fixed_point_to_residual(fixed_point_1_func), maxiter=1000, xtol=1e-12)\n    ans = solver.solve(fixed_point_1_guess)\n    assert (solver.fval_iter == 79)\n    assert_close1d(ans, fixed_point_1_expect, rtol=1e-06)\n    solver = SolverInterface(method='fixed_point_gdem', objf=fixed_point_to_residual(fixed_point_1_func), maxiter=1000, xtol=1e-12)\n    ans = solver.solve(fixed_point_1_guess)\n    assert (solver.fval_iter == 37)\n    assert_close1d(ans, fixed_point_1_expect, rtol=1e-12)", "masked_code": "def test_SolverInterface_fixed_point():\n    solver = SolverInterface(method='fixed_point', objf=fixed_point_to_residual(fixed_point_1_func), maxiter=1000, xtol=1e-09)\n    ans = solver.solve(fixed_point_1_guess)\n    assert_close1d(ans, fixed_point_1_expect, rtol=1e-06)\n    solver = SolverInterface(method='fixed_point_aitken', objf=fixed_point_to_residual(fixed_point_1_func), maxiter=1000, xtol=1e-12)\n    ans = solver.solve(fixed_point_1_guess)\n    assert (solver.fval_iter == 79)\n    assert_close1d(ans, fixed_point_1_expect, rtol=1e-06)\n    solver = SolverInterface(method='fixed_point_gdem', objf=fixed_point_to_residual(fixed_point_1_func), maxiter=1000, xtol=1e-12)\n    ans = solver.solve(fixed_point_1_guess)\n    assert (solver.fval_iter == '???')\n    assert_close1d(ans, fixed_point_1_expect, rtol=1e-12)", "ground_truth": "37", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_75", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_gelsd_underdetermined", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_gelsd_underdetermined():\n    'Test underdetermined system (fewer equations than unknowns)'\n    A = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]\n    b = [7.0, 8.0]\n    (x, residuals, rank, s) = gelsd(A, b)\n    assert (len(x) == 3)\n    assert (rank == 2)\n    assert (len(s) == 2)\n    assert (residuals == 0.0)", "masked_code": "def test_gelsd_underdetermined():\n    'Test underdetermined system (fewer equations than unknowns)'\n    A = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]\n    b = [7.0, 8.0]\n    (x, residuals, rank, s) = gelsd(A, b)\n    assert (len(x) == '???')\n    assert (rank == 2)\n    assert (len(s) == 2)\n    assert (residuals == 0.0)", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_76", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_gelsd_empty_and_shapes", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "@pytest.mark.parametrize('m,n,n_rhs', [(4, 2, 1), (4, 0, 1), (4, 2, 1), (2, 4, 1)])\ndef test_gelsd_empty_and_shapes(m, n, n_rhs):\n    'Test various matrix shapes including empty matrices'\n    if ((m * n) > 0):\n        A = np.arange((m * n)).reshape(m, n).tolist()\n    else:\n        A = np.zeros((m, n)).tolist()\n    if (m > 0):\n        b = np.ones(m).tolist()\n    else:\n        b = np.ones(0).tolist()\n    (x, residuals, rank, s) = gelsd(A, b)\n    assert (len(x) == n)\n    assert (len(s) == min(m, n))\n    assert (rank == min(m, n))\n    if (m == 0):\n        assert_allclose(x, np.zeros(n))\n    if ((m > n) and (n > 0)):\n        r = (np.array(b) - np.dot(A, x))\n        expected_residuals = float(np.sum((r * r)))\n        assert_allclose(residuals, expected_residuals, atol=1e-28)", "masked_code": "@pytest.mark.parametrize('m,n,n_rhs', [(4, 2, 1), (4, 0, 1), (4, 2, 1), (2, 4, 1)])\ndef test_gelsd_empty_and_shapes(m, n, n_rhs):\n    'Test various matrix shapes including empty matrices'\n    if ((m * n) > 0):\n        A = np.arange((m * n)).reshape(m, n).tolist()\n    else:\n        A = np.zeros((m, n)).tolist()\n    if (m > 0):\n        b = np.ones(m).tolist()\n    else:\n        b = np.ones(0).tolist()\n    (x, residuals, rank, s) = gelsd(A, b)\n    assert (len(x) == '???')\n    assert (len(s) == min(m, n))\n    assert (rank == min(m, n))\n    if (m == 0):\n        assert_allclose(x, np.zeros(n))\n    if ((m > n) and (n > 0)):\n        r = (np.array(b) - np.dot(A, x))\n        expected_residuals = float(np.sum((r * r)))\n        assert_allclose(residuals, expected_residuals, atol=1e-28)", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_77", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_gelsd_empty_and_shapes", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "@pytest.mark.parametrize('m,n,n_rhs', [(4, 2, 1), (4, 0, 1), (4, 2, 1), (2, 4, 1)])\ndef test_gelsd_empty_and_shapes(m, n, n_rhs):\n    'Test various matrix shapes including empty matrices'\n    if ((m * n) > 0):\n        A = np.arange((m * n)).reshape(m, n).tolist()\n    else:\n        A = np.zeros((m, n)).tolist()\n    if (m > 0):\n        b = np.ones(m).tolist()\n    else:\n        b = np.ones(0).tolist()\n    (x, residuals, rank, s) = gelsd(A, b)\n    assert (len(x) == n)\n    assert (len(s) == min(m, n))\n    assert (rank == min(m, n))\n    if (m == 0):\n        assert_allclose(x, np.zeros(n))\n    if ((m > n) and (n > 0)):\n        r = (np.array(b) - np.dot(A, x))\n        expected_residuals = float(np.sum((r * r)))\n        assert_allclose(residuals, expected_residuals, atol=1e-28)", "masked_code": "@pytest.mark.parametrize('m,n,n_rhs', [(4, 2, 1), (4, 0, 1), (4, 2, 1), (2, 4, 1)])\ndef test_gelsd_empty_and_shapes(m, n, n_rhs):\n    'Test various matrix shapes including empty matrices'\n    if ((m * n) > 0):\n        A = np.arange((m * n)).reshape(m, n).tolist()\n    else:\n        A = np.zeros((m, n)).tolist()\n    if (m > 0):\n        b = np.ones(m).tolist()\n    else:\n        b = np.ones(0).tolist()\n    (x, residuals, rank, s) = gelsd(A, b)\n    assert (len(x) == n)\n    assert (len(s) == '???')\n    assert (rank == min(m, n))\n    if (m == 0):\n        assert_allclose(x, np.zeros(n))\n    if ((m > n) and (n > 0)):\n        r = (np.array(b) - np.dot(A, x))\n        expected_residuals = float(np.sum((r * r)))\n        assert_allclose(residuals, expected_residuals, atol=1e-28)", "ground_truth": "min(m, n)", "quality_analysis": {"complexity_score": 9, "left_complexity": 4, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_78", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_argsort1d", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_argsort1d():\n\n    def check_argsort1d(input_list, expected, error_message):\n        numpy_argsort1d = (lambda x: list(np.argsort(x)))\n        assert (argsort1d(input_list) == expected), error_message\n        assert (argsort1d(input_list) == numpy_argsort1d(input_list)), error_message\n    check_argsort1d([3, 1, 2], [1, 2, 0], 'Failed on simple test case')\n    check_argsort1d([(- 1), (- 3), (- 2)], [1, 2, 0], 'Failed with negative numbers')\n    check_argsort1d([], [], 'Failed on empty list')\n    check_argsort1d([42], [0], 'Failed with single element list')\n    check_argsort1d([99, 21, 31, 80, 70], [1, 2, 4, 3, 0], 'Mismatch with expected output')\n    check_argsort1d([2, 3, 1, 5, 4], [2, 0, 1, 4, 3], 'Mismatch with expected output')\n    check_argsort1d([3.5, 1, 2.2], [1, 2, 0], 'Failed with mixed floats and ints')\n    check_argsort1d([0.1, 0.2, 0.3], [0, 1, 2], 'Failed with floats')\n    check_argsort1d([True, False, True], [1, 0, 2], 'Failed with boolean values')\n    check_argsort1d(['apple', 'banana', 'cherry'], [0, 1, 2], 'Failed with strings')\n    check_argsort1d([2, 3, 2, 3, 3], [0, 2, 1, 3, 4], 'Failed with duplicate numbers')\n    check_argsort1d([(- 3), (- 1), 0, 1, 3], [0, 1, 2, 3, 4], 'Failed with negative and positive numbers')", "masked_code": "def test_argsort1d():\n\n    def check_argsort1d(input_list, expected, error_message):\n        numpy_argsort1d = (lambda x: list(np.argsort(x)))\n        assert (argsort1d(input_list) == '???'), error_message\n        assert (argsort1d(input_list) == numpy_argsort1d(input_list)), error_message\n    check_argsort1d([3, 1, 2], [1, 2, 0], 'Failed on simple test case')\n    check_argsort1d([(- 1), (- 3), (- 2)], [1, 2, 0], 'Failed with negative numbers')\n    check_argsort1d([], [], 'Failed on empty list')\n    check_argsort1d([42], [0], 'Failed with single element list')\n    check_argsort1d([99, 21, 31, 80, 70], [1, 2, 4, 3, 0], 'Mismatch with expected output')\n    check_argsort1d([2, 3, 1, 5, 4], [2, 0, 1, 4, 3], 'Mismatch with expected output')\n    check_argsort1d([3.5, 1, 2.2], [1, 2, 0], 'Failed with mixed floats and ints')\n    check_argsort1d([0.1, 0.2, 0.3], [0, 1, 2], 'Failed with floats')\n    check_argsort1d([True, False, True], [1, 0, 2], 'Failed with boolean values')\n    check_argsort1d(['apple', 'banana', 'cherry'], [0, 1, 2], 'Failed with strings')\n    check_argsort1d([2, 3, 2, 3, 3], [0, 2, 1, 3, 4], 'Failed with duplicate numbers')\n    check_argsort1d([(- 3), (- 1), 0, 1, 3], [0, 1, 2, 3, 4], 'Failed with negative and positive numbers')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_79", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_argsort1d", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_argsort1d():\n\n    def check_argsort1d(input_list, expected, error_message):\n        numpy_argsort1d = (lambda x: list(np.argsort(x)))\n        assert (argsort1d(input_list) == expected), error_message\n        assert (argsort1d(input_list) == numpy_argsort1d(input_list)), error_message\n    check_argsort1d([3, 1, 2], [1, 2, 0], 'Failed on simple test case')\n    check_argsort1d([(- 1), (- 3), (- 2)], [1, 2, 0], 'Failed with negative numbers')\n    check_argsort1d([], [], 'Failed on empty list')\n    check_argsort1d([42], [0], 'Failed with single element list')\n    check_argsort1d([99, 21, 31, 80, 70], [1, 2, 4, 3, 0], 'Mismatch with expected output')\n    check_argsort1d([2, 3, 1, 5, 4], [2, 0, 1, 4, 3], 'Mismatch with expected output')\n    check_argsort1d([3.5, 1, 2.2], [1, 2, 0], 'Failed with mixed floats and ints')\n    check_argsort1d([0.1, 0.2, 0.3], [0, 1, 2], 'Failed with floats')\n    check_argsort1d([True, False, True], [1, 0, 2], 'Failed with boolean values')\n    check_argsort1d(['apple', 'banana', 'cherry'], [0, 1, 2], 'Failed with strings')\n    check_argsort1d([2, 3, 2, 3, 3], [0, 2, 1, 3, 4], 'Failed with duplicate numbers')\n    check_argsort1d([(- 3), (- 1), 0, 1, 3], [0, 1, 2, 3, 4], 'Failed with negative and positive numbers')", "masked_code": "def test_argsort1d():\n\n    def check_argsort1d(input_list, expected, error_message):\n        numpy_argsort1d = (lambda x: list(np.argsort(x)))\n        assert (argsort1d(input_list) == expected), error_message\n        assert (argsort1d(input_list) == '???'), error_message\n    check_argsort1d([3, 1, 2], [1, 2, 0], 'Failed on simple test case')\n    check_argsort1d([(- 1), (- 3), (- 2)], [1, 2, 0], 'Failed with negative numbers')\n    check_argsort1d([], [], 'Failed on empty list')\n    check_argsort1d([42], [0], 'Failed with single element list')\n    check_argsort1d([99, 21, 31, 80, 70], [1, 2, 4, 3, 0], 'Mismatch with expected output')\n    check_argsort1d([2, 3, 1, 5, 4], [2, 0, 1, 4, 3], 'Mismatch with expected output')\n    check_argsort1d([3.5, 1, 2.2], [1, 2, 0], 'Failed with mixed floats and ints')\n    check_argsort1d([0.1, 0.2, 0.3], [0, 1, 2], 'Failed with floats')\n    check_argsort1d([True, False, True], [1, 0, 2], 'Failed with boolean values')\n    check_argsort1d(['apple', 'banana', 'cherry'], [0, 1, 2], 'Failed with strings')\n    check_argsort1d([2, 3, 2, 3, 3], [0, 2, 1, 3, 4], 'Failed with duplicate numbers')\n    check_argsort1d([(- 3), (- 1), 0, 1, 3], [0, 1, 2, 3, 4], 'Failed with negative and positive numbers')", "ground_truth": "numpy_argsort1d(input_list)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_80", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_eye", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_eye():\n    assert (eye(1) == [[1.0]])\n    assert (eye(2) == [[1.0, 0.0], [0.0, 1.0]])\n    assert (eye(3) == [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    assert (eye(2, dtype=int) == [[1, 0], [0, 1]])\n    assert (eye(2, dtype=float) == [[1.0, 0.0], [0.0, 1.0]])\n    with pytest.raises(ValueError):\n        eye(0)\n    with pytest.raises(ValueError):\n        eye((- 1))\n    with pytest.raises(TypeError):\n        eye(2.5)\n\n    def check_matrix_properties(matrix):\n        N = len(matrix)\n        assert all(((len(row) == N) for row in matrix)), 'Matrix rows have inconsistent lengths'\n        assert all(((matrix[i][i] == 1) for i in range(N))), 'Diagonal elements are not 1'\n        assert all(((matrix[i][j] == 0) for i in range(N) for j in range(N) if (i != j))), 'Off-diagonal elements are not 0'\n    for size in [1, 2, 3, 4, 5, 10]:\n        check_matrix_properties(eye(size))\n\n    def check_type_consistency(matrix, expected_type):\n        assert all((isinstance(x, expected_type) for row in matrix for x in row)), f'Not all elements are of type {expected_type}'\n    check_type_consistency(eye(3, dtype=float), float)\n    check_type_consistency(eye(3, dtype=int), int)", "masked_code": "def test_eye():\n    assert (eye(1) == '???')\n    assert (eye(2) == [[1.0, 0.0], [0.0, 1.0]])\n    assert (eye(3) == [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    assert (eye(2, dtype=int) == [[1, 0], [0, 1]])\n    assert (eye(2, dtype=float) == [[1.0, 0.0], [0.0, 1.0]])\n    with pytest.raises(ValueError):\n        eye(0)\n    with pytest.raises(ValueError):\n        eye((- 1))\n    with pytest.raises(TypeError):\n        eye(2.5)\n\n    def check_matrix_properties(matrix):\n        N = len(matrix)\n        assert all(((len(row) == N) for row in matrix)), 'Matrix rows have inconsistent lengths'\n        assert all(((matrix[i][i] == 1) for i in range(N))), 'Diagonal elements are not 1'\n        assert all(((matrix[i][j] == 0) for i in range(N) for j in range(N) if (i != j))), 'Off-diagonal elements are not 0'\n    for size in [1, 2, 3, 4, 5, 10]:\n        check_matrix_properties(eye(size))\n\n    def check_type_consistency(matrix, expected_type):\n        assert all((isinstance(x, expected_type) for row in matrix for x in row)), f'Not all elements are of type {expected_type}'\n    check_type_consistency(eye(3, dtype=float), float)\n    check_type_consistency(eye(3, dtype=int), int)", "ground_truth": "[[1.0]]", "quality_analysis": {"complexity_score": 9, "left_complexity": 4, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_81", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_eye", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_eye():\n    assert (eye(1) == [[1.0]])\n    assert (eye(2) == [[1.0, 0.0], [0.0, 1.0]])\n    assert (eye(3) == [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    assert (eye(2, dtype=int) == [[1, 0], [0, 1]])\n    assert (eye(2, dtype=float) == [[1.0, 0.0], [0.0, 1.0]])\n    with pytest.raises(ValueError):\n        eye(0)\n    with pytest.raises(ValueError):\n        eye((- 1))\n    with pytest.raises(TypeError):\n        eye(2.5)\n\n    def check_matrix_properties(matrix):\n        N = len(matrix)\n        assert all(((len(row) == N) for row in matrix)), 'Matrix rows have inconsistent lengths'\n        assert all(((matrix[i][i] == 1) for i in range(N))), 'Diagonal elements are not 1'\n        assert all(((matrix[i][j] == 0) for i in range(N) for j in range(N) if (i != j))), 'Off-diagonal elements are not 0'\n    for size in [1, 2, 3, 4, 5, 10]:\n        check_matrix_properties(eye(size))\n\n    def check_type_consistency(matrix, expected_type):\n        assert all((isinstance(x, expected_type) for row in matrix for x in row)), f'Not all elements are of type {expected_type}'\n    check_type_consistency(eye(3, dtype=float), float)\n    check_type_consistency(eye(3, dtype=int), int)", "masked_code": "def test_eye():\n    assert (eye(1) == [[1.0]])\n    assert (eye(2) == '???')\n    assert (eye(3) == [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    assert (eye(2, dtype=int) == [[1, 0], [0, 1]])\n    assert (eye(2, dtype=float) == [[1.0, 0.0], [0.0, 1.0]])\n    with pytest.raises(ValueError):\n        eye(0)\n    with pytest.raises(ValueError):\n        eye((- 1))\n    with pytest.raises(TypeError):\n        eye(2.5)\n\n    def check_matrix_properties(matrix):\n        N = len(matrix)\n        assert all(((len(row) == N) for row in matrix)), 'Matrix rows have inconsistent lengths'\n        assert all(((matrix[i][i] == 1) for i in range(N))), 'Diagonal elements are not 1'\n        assert all(((matrix[i][j] == 0) for i in range(N) for j in range(N) if (i != j))), 'Off-diagonal elements are not 0'\n    for size in [1, 2, 3, 4, 5, 10]:\n        check_matrix_properties(eye(size))\n\n    def check_type_consistency(matrix, expected_type):\n        assert all((isinstance(x, expected_type) for row in matrix for x in row)), f'Not all elements are of type {expected_type}'\n    check_type_consistency(eye(3, dtype=float), float)\n    check_type_consistency(eye(3, dtype=int), int)", "ground_truth": "[[1.0, 0.0], [0.0, 1.0]]", "quality_analysis": {"complexity_score": 14, "left_complexity": 4, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_82", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_eye", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_eye():\n    assert (eye(1) == [[1.0]])\n    assert (eye(2) == [[1.0, 0.0], [0.0, 1.0]])\n    assert (eye(3) == [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    assert (eye(2, dtype=int) == [[1, 0], [0, 1]])\n    assert (eye(2, dtype=float) == [[1.0, 0.0], [0.0, 1.0]])\n    with pytest.raises(ValueError):\n        eye(0)\n    with pytest.raises(ValueError):\n        eye((- 1))\n    with pytest.raises(TypeError):\n        eye(2.5)\n\n    def check_matrix_properties(matrix):\n        N = len(matrix)\n        assert all(((len(row) == N) for row in matrix)), 'Matrix rows have inconsistent lengths'\n        assert all(((matrix[i][i] == 1) for i in range(N))), 'Diagonal elements are not 1'\n        assert all(((matrix[i][j] == 0) for i in range(N) for j in range(N) if (i != j))), 'Off-diagonal elements are not 0'\n    for size in [1, 2, 3, 4, 5, 10]:\n        check_matrix_properties(eye(size))\n\n    def check_type_consistency(matrix, expected_type):\n        assert all((isinstance(x, expected_type) for row in matrix for x in row)), f'Not all elements are of type {expected_type}'\n    check_type_consistency(eye(3, dtype=float), float)\n    check_type_consistency(eye(3, dtype=int), int)", "masked_code": "def test_eye():\n    assert (eye(1) == [[1.0]])\n    assert (eye(2) == [[1.0, 0.0], [0.0, 1.0]])\n    assert (eye(3) == '???')\n    assert (eye(2, dtype=int) == [[1, 0], [0, 1]])\n    assert (eye(2, dtype=float) == [[1.0, 0.0], [0.0, 1.0]])\n    with pytest.raises(ValueError):\n        eye(0)\n    with pytest.raises(ValueError):\n        eye((- 1))\n    with pytest.raises(TypeError):\n        eye(2.5)\n\n    def check_matrix_properties(matrix):\n        N = len(matrix)\n        assert all(((len(row) == N) for row in matrix)), 'Matrix rows have inconsistent lengths'\n        assert all(((matrix[i][i] == 1) for i in range(N))), 'Diagonal elements are not 1'\n        assert all(((matrix[i][j] == 0) for i in range(N) for j in range(N) if (i != j))), 'Off-diagonal elements are not 0'\n    for size in [1, 2, 3, 4, 5, 10]:\n        check_matrix_properties(eye(size))\n\n    def check_type_consistency(matrix, expected_type):\n        assert all((isinstance(x, expected_type) for row in matrix for x in row)), f'Not all elements are of type {expected_type}'\n    check_type_consistency(eye(3, dtype=float), float)\n    check_type_consistency(eye(3, dtype=int), int)", "ground_truth": "[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]", "quality_analysis": {"complexity_score": 21, "left_complexity": 4, "right_complexity": 17, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_83", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_eye", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_eye():\n    assert (eye(1) == [[1.0]])\n    assert (eye(2) == [[1.0, 0.0], [0.0, 1.0]])\n    assert (eye(3) == [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    assert (eye(2, dtype=int) == [[1, 0], [0, 1]])\n    assert (eye(2, dtype=float) == [[1.0, 0.0], [0.0, 1.0]])\n    with pytest.raises(ValueError):\n        eye(0)\n    with pytest.raises(ValueError):\n        eye((- 1))\n    with pytest.raises(TypeError):\n        eye(2.5)\n\n    def check_matrix_properties(matrix):\n        N = len(matrix)\n        assert all(((len(row) == N) for row in matrix)), 'Matrix rows have inconsistent lengths'\n        assert all(((matrix[i][i] == 1) for i in range(N))), 'Diagonal elements are not 1'\n        assert all(((matrix[i][j] == 0) for i in range(N) for j in range(N) if (i != j))), 'Off-diagonal elements are not 0'\n    for size in [1, 2, 3, 4, 5, 10]:\n        check_matrix_properties(eye(size))\n\n    def check_type_consistency(matrix, expected_type):\n        assert all((isinstance(x, expected_type) for row in matrix for x in row)), f'Not all elements are of type {expected_type}'\n    check_type_consistency(eye(3, dtype=float), float)\n    check_type_consistency(eye(3, dtype=int), int)", "masked_code": "def test_eye():\n    assert (eye(1) == [[1.0]])\n    assert (eye(2) == [[1.0, 0.0], [0.0, 1.0]])\n    assert (eye(3) == [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    assert (eye(2, dtype=int) == '???')\n    assert (eye(2, dtype=float) == [[1.0, 0.0], [0.0, 1.0]])\n    with pytest.raises(ValueError):\n        eye(0)\n    with pytest.raises(ValueError):\n        eye((- 1))\n    with pytest.raises(TypeError):\n        eye(2.5)\n\n    def check_matrix_properties(matrix):\n        N = len(matrix)\n        assert all(((len(row) == N) for row in matrix)), 'Matrix rows have inconsistent lengths'\n        assert all(((matrix[i][i] == 1) for i in range(N))), 'Diagonal elements are not 1'\n        assert all(((matrix[i][j] == 0) for i in range(N) for j in range(N) if (i != j))), 'Off-diagonal elements are not 0'\n    for size in [1, 2, 3, 4, 5, 10]:\n        check_matrix_properties(eye(size))\n\n    def check_type_consistency(matrix, expected_type):\n        assert all((isinstance(x, expected_type) for row in matrix for x in row)), f'Not all elements are of type {expected_type}'\n    check_type_consistency(eye(3, dtype=float), float)\n    check_type_consistency(eye(3, dtype=int), int)", "ground_truth": "[[1, 0], [0, 1]]", "quality_analysis": {"complexity_score": 14, "left_complexity": 4, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_84", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_eye", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_eye():\n    assert (eye(1) == [[1.0]])\n    assert (eye(2) == [[1.0, 0.0], [0.0, 1.0]])\n    assert (eye(3) == [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    assert (eye(2, dtype=int) == [[1, 0], [0, 1]])\n    assert (eye(2, dtype=float) == [[1.0, 0.0], [0.0, 1.0]])\n    with pytest.raises(ValueError):\n        eye(0)\n    with pytest.raises(ValueError):\n        eye((- 1))\n    with pytest.raises(TypeError):\n        eye(2.5)\n\n    def check_matrix_properties(matrix):\n        N = len(matrix)\n        assert all(((len(row) == N) for row in matrix)), 'Matrix rows have inconsistent lengths'\n        assert all(((matrix[i][i] == 1) for i in range(N))), 'Diagonal elements are not 1'\n        assert all(((matrix[i][j] == 0) for i in range(N) for j in range(N) if (i != j))), 'Off-diagonal elements are not 0'\n    for size in [1, 2, 3, 4, 5, 10]:\n        check_matrix_properties(eye(size))\n\n    def check_type_consistency(matrix, expected_type):\n        assert all((isinstance(x, expected_type) for row in matrix for x in row)), f'Not all elements are of type {expected_type}'\n    check_type_consistency(eye(3, dtype=float), float)\n    check_type_consistency(eye(3, dtype=int), int)", "masked_code": "def test_eye():\n    assert (eye(1) == [[1.0]])\n    assert (eye(2) == [[1.0, 0.0], [0.0, 1.0]])\n    assert (eye(3) == [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    assert (eye(2, dtype=int) == [[1, 0], [0, 1]])\n    assert (eye(2, dtype=float) == '???')\n    with pytest.raises(ValueError):\n        eye(0)\n    with pytest.raises(ValueError):\n        eye((- 1))\n    with pytest.raises(TypeError):\n        eye(2.5)\n\n    def check_matrix_properties(matrix):\n        N = len(matrix)\n        assert all(((len(row) == N) for row in matrix)), 'Matrix rows have inconsistent lengths'\n        assert all(((matrix[i][i] == 1) for i in range(N))), 'Diagonal elements are not 1'\n        assert all(((matrix[i][j] == 0) for i in range(N) for j in range(N) if (i != j))), 'Off-diagonal elements are not 0'\n    for size in [1, 2, 3, 4, 5, 10]:\n        check_matrix_properties(eye(size))\n\n    def check_type_consistency(matrix, expected_type):\n        assert all((isinstance(x, expected_type) for row in matrix for x in row)), f'Not all elements are of type {expected_type}'\n    check_type_consistency(eye(3, dtype=float), float)\n    check_type_consistency(eye(3, dtype=int), int)", "ground_truth": "[[1.0, 0.0], [0.0, 1.0]]", "quality_analysis": {"complexity_score": 14, "left_complexity": 4, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_85", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_dot_product", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_dot_product():\n    assert (dot_product([1, 2, 3], [4, 5, 6]) == 32.0)\n    assert (dot_product([1, 0], [0, 1]) == 0.0)\n    assert (dot_product([1, 1], [1, 1]) == 2.0)\n    assert_close(dot_product([0.1, 0.2], [0.3, 0.4]), 0.11)\n    assert_close(dot_product([(- 1), (- 2)], [3, 4]), (- 11.0))\n\n    def test_commutative(a, b):\n        'Test if a·b = b·a'\n        assert_close(dot_product(a, b), dot_product(b, a), rtol=1e-14)\n\n    def test_distributive(a, b, c):\n        'Test if a·(b + c) = a·b + a·c'\n        vec_sum = [(bi + ci) for (bi, ci) in zip(b, c)]\n        left = dot_product(a, vec_sum)\n        right = (dot_product(a, b) + dot_product(a, c))\n        return assert_close(left, right, rtol=1e-14)\n    (a, b, c) = ([1, 2], [3, 4], [5, 6])\n    test_commutative(a, b)\n    test_distributive(a, b, c)\n    with pytest.raises(ValueError):\n        dot_product([1, 2], [1, 2, 3])", "masked_code": "def test_dot_product():\n    assert (dot_product([1, 2, 3], [4, 5, 6]) == '???')\n    assert (dot_product([1, 0], [0, 1]) == 0.0)\n    assert (dot_product([1, 1], [1, 1]) == 2.0)\n    assert_close(dot_product([0.1, 0.2], [0.3, 0.4]), 0.11)\n    assert_close(dot_product([(- 1), (- 2)], [3, 4]), (- 11.0))\n\n    def test_commutative(a, b):\n        'Test if a·b = b·a'\n        assert_close(dot_product(a, b), dot_product(b, a), rtol=1e-14)\n\n    def test_distributive(a, b, c):\n        'Test if a·(b + c) = a·b + a·c'\n        vec_sum = [(bi + ci) for (bi, ci) in zip(b, c)]\n        left = dot_product(a, vec_sum)\n        right = (dot_product(a, b) + dot_product(a, c))\n        return assert_close(left, right, rtol=1e-14)\n    (a, b, c) = ([1, 2], [3, 4], [5, 6])\n    test_commutative(a, b)\n    test_distributive(a, b, c)\n    with pytest.raises(ValueError):\n        dot_product([1, 2], [1, 2, 3])", "ground_truth": "32.0", "quality_analysis": {"complexity_score": 14, "left_complexity": 13, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_86", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_transpose", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "masked_code": "def test_transpose():\n    assert (transpose([]) == '???')\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "ground_truth": "[]", "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_87", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_transpose", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "masked_code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == '???')\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "ground_truth": "[]", "quality_analysis": {"complexity_score": 9, "left_complexity": 7, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_88", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_transpose", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "masked_code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == '???')\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "ground_truth": "[[1]]", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_89", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_transpose", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "masked_code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == '???')\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "ground_truth": "[[1, 3], [2, 4]]", "quality_analysis": {"complexity_score": 23, "left_complexity": 13, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_90", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_transpose", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "masked_code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == '???')\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "ground_truth": "[[1, 4, 7], [2, 5, 8], [3, 6, 9]]", "quality_analysis": {"complexity_score": 37, "left_complexity": 20, "right_complexity": 17, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_91", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_transpose", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "masked_code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == '???')\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "ground_truth": "[[1, 4], [2, 5], [3, 6]]", "quality_analysis": {"complexity_score": 29, "left_complexity": 15, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_92", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_transpose", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "masked_code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == '???')\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "ground_truth": "[[1], [2], [3]]", "quality_analysis": {"complexity_score": 21, "left_complexity": 10, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_93", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_transpose", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == [[1, 2, 3]])\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "masked_code": "def test_transpose():\n    assert (transpose([]) == [])\n    assert (transpose([[]]) == [])\n    assert (transpose([[1]]) == [[1]])\n    assert (transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]])\n    assert (transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    assert (transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]])\n    assert (transpose([[1, 2, 3]]) == [[1], [2], [3]])\n    assert (transpose([[1], [2], [3]]) == '???')\n    result = transpose([[1, 2.5], [3, 4.2]])\n    assert (result[0][0] == 1)\n    assert (abs((result[1][1] - 4.2)) < 1e-10)", "ground_truth": "[[1, 2, 3]]", "quality_analysis": {"complexity_score": 21, "left_complexity": 14, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_94", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_matrix_multiply", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_matrix_multiply():\n    A = [[1, 2], [3, 4]]\n    B = [[5, 6], [7, 8]]\n    result = matrix_multiply(A, B)\n    expect = [[19, 22], [43, 50]]\n    assert_close2d(result, expect)\n    I = [[1, 0], [0, 1]]\n    assert_close2d(matrix_multiply(A, I), A)\n    assert_close2d(matrix_multiply(I, A), A)\n    Z = [[0, 0], [0, 0]]\n    assert_close2d(matrix_multiply(A, Z), Z)\n    A = [[1, 2, 3], [4, 5, 6]]\n    B = [[7, 8], [9, 10], [11, 12]]\n    result = matrix_multiply(A, B)\n    expect = [[58, 64], [139, 154]]\n    assert_close2d(result, expect)\n    A = [[1e-15, 1e-15], [1e-15, 1e-15]]\n    result = matrix_multiply(A, A)\n    expect = [[2e-30, 2e-30], [2e-30, 2e-30]]\n    assert_close2d(result, expect)\n    A = [[1000000000000000.0, 1000000000000000.0], [1000000000000000.0, 1000000000000000.0]]\n    result = matrix_multiply(A, A)\n    expect = [[2e+30, 2e+30], [2e+30, 2e+30]]\n    assert_close2d(result, expect)\n    A = [[10000000000.0, 1e-10], [1e-10, 10000000000.0]]\n    result = matrix_multiply(A, A)\n    expect = [[(1e+20 + 1e-20), 2], [2, (1e+20 + 1e-20)]]\n    assert_close2d(result, expect)\n    A = [[2]]\n    B = [[3]]\n    C = [[6.0]]\n    assert (matrix_multiply(A, B) == C)\n    A = [[i for i in range(10)] for _ in range(10)]\n    B = [[i for i in range(10)] for _ in range(10)]\n    C = matrix_multiply(A, B)\n    assert ((len(C) == 10) and (len(C[0]) == 10))\n    with pytest.raises(ValueError):\n        matrix_multiply([], [])\n    with pytest.raises(ValueError):\n        matrix_multiply([[]], [[]])\n    with pytest.raises(ValueError):\n        matrix_multiply([], [[1]])\n    with pytest.raises(ValueError):\n        matrix_multiply([[1]], [])\n    with pytest.raises(ValueError):\n        matrix_multiply([[1, 2]], [[1], [2], [3]])\n    with pytest.raises(ValueError):\n        matrix_multiply([[1, 2], [1]], [[1, 2]])\n    with pytest.raises(ValueError):\n        matrix_multiply([[1, 2]], [[1], [1, 2]])\n    with pytest.raises(TypeError):\n        A = [[1, 2, 'a']]\n        B = [[4, 5], [6, 7], [8, 9]]\n        matrix_multiply(A, B)", "masked_code": "def test_matrix_multiply():\n    A = [[1, 2], [3, 4]]\n    B = [[5, 6], [7, 8]]\n    result = matrix_multiply(A, B)\n    expect = [[19, 22], [43, 50]]\n    assert_close2d(result, expect)\n    I = [[1, 0], [0, 1]]\n    assert_close2d(matrix_multiply(A, I), A)\n    assert_close2d(matrix_multiply(I, A), A)\n    Z = [[0, 0], [0, 0]]\n    assert_close2d(matrix_multiply(A, Z), Z)\n    A = [[1, 2, 3], [4, 5, 6]]\n    B = [[7, 8], [9, 10], [11, 12]]\n    result = matrix_multiply(A, B)\n    expect = [[58, 64], [139, 154]]\n    assert_close2d(result, expect)\n    A = [[1e-15, 1e-15], [1e-15, 1e-15]]\n    result = matrix_multiply(A, A)\n    expect = [[2e-30, 2e-30], [2e-30, 2e-30]]\n    assert_close2d(result, expect)\n    A = [[1000000000000000.0, 1000000000000000.0], [1000000000000000.0, 1000000000000000.0]]\n    result = matrix_multiply(A, A)\n    expect = [[2e+30, 2e+30], [2e+30, 2e+30]]\n    assert_close2d(result, expect)\n    A = [[10000000000.0, 1e-10], [1e-10, 10000000000.0]]\n    result = matrix_multiply(A, A)\n    expect = [[(1e+20 + 1e-20), 2], [2, (1e+20 + 1e-20)]]\n    assert_close2d(result, expect)\n    A = [[2]]\n    B = [[3]]\n    C = [[6.0]]\n    assert (matrix_multiply(A, B) == '???')\n    A = [[i for i in range(10)] for _ in range(10)]\n    B = [[i for i in range(10)] for _ in range(10)]\n    C = matrix_multiply(A, B)\n    assert ((len(C) == 10) and (len(C[0]) == 10))\n    with pytest.raises(ValueError):\n        matrix_multiply([], [])\n    with pytest.raises(ValueError):\n        matrix_multiply([[]], [[]])\n    with pytest.raises(ValueError):\n        matrix_multiply([], [[1]])\n    with pytest.raises(ValueError):\n        matrix_multiply([[1]], [])\n    with pytest.raises(ValueError):\n        matrix_multiply([[1, 2]], [[1], [2], [3]])\n    with pytest.raises(ValueError):\n        matrix_multiply([[1, 2], [1]], [[1, 2]])\n    with pytest.raises(ValueError):\n        matrix_multiply([[1, 2]], [[1], [1, 2]])\n    with pytest.raises(TypeError):\n        A = [[1, 2, 'a']]\n        B = [[4, 5], [6, 7], [8, 9]]\n        matrix_multiply(A, B)", "ground_truth": "C", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_95", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_sum_matrix_rows", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_sum_matrix_rows():\n    'Test row-wise matrix summation'\n    assert_close1d(sum_matrix_rows([[1, 2, 3], [4, 5, 6]]), [6.0, 15.0])\n    assert_close1d(sum_matrix_rows([[1], [2]]), [1.0, 2.0])\n    assert_close1d(sum_matrix_rows([[0, 0], [0, 0]]), [0.0, 0.0])\n    assert_close1d(sum_matrix_rows([[(- 1), 2], [3, (- 4)]]), [1.0, (- 1.0)])\n    assert_close1d(sum_matrix_rows([[1000000000000000.0, 1000000000000000.0], [1000000000000000.0, 1000000000000000.0]]), [2000000000000000.0, 2000000000000000.0])\n    assert_close1d(sum_matrix_rows([[1e-15, 1e-15], [1e-15, 1e-15]]), [2e-15, 2e-15])\n    assert (sum_matrix_cols([[1, 2, 3]]) == [1.0, 2.0, 3.0])\n    assert (sum_matrix_cols([[1], [2], [3]]) == [6.0])\n    with pytest.raises(ValueError):\n        sum_matrix_rows([])\n    with pytest.raises(ValueError):\n        sum_matrix_rows([[]])\n    with pytest.raises(ValueError):\n        sum_matrix_rows([[1, 2], [1]])\n    with pytest.raises(TypeError):\n        sum_matrix_cols([[1, 'a'], [2, 3]])", "masked_code": "def test_sum_matrix_rows():\n    'Test row-wise matrix summation'\n    assert_close1d(sum_matrix_rows([[1, 2, 3], [4, 5, 6]]), [6.0, 15.0])\n    assert_close1d(sum_matrix_rows([[1], [2]]), [1.0, 2.0])\n    assert_close1d(sum_matrix_rows([[0, 0], [0, 0]]), [0.0, 0.0])\n    assert_close1d(sum_matrix_rows([[(- 1), 2], [3, (- 4)]]), [1.0, (- 1.0)])\n    assert_close1d(sum_matrix_rows([[1000000000000000.0, 1000000000000000.0], [1000000000000000.0, 1000000000000000.0]]), [2000000000000000.0, 2000000000000000.0])\n    assert_close1d(sum_matrix_rows([[1e-15, 1e-15], [1e-15, 1e-15]]), [2e-15, 2e-15])\n    assert (sum_matrix_cols([[1, 2, 3]]) == '???')\n    assert (sum_matrix_cols([[1], [2], [3]]) == [6.0])\n    with pytest.raises(ValueError):\n        sum_matrix_rows([])\n    with pytest.raises(ValueError):\n        sum_matrix_rows([[]])\n    with pytest.raises(ValueError):\n        sum_matrix_rows([[1, 2], [1]])\n    with pytest.raises(TypeError):\n        sum_matrix_cols([[1, 'a'], [2, 3]])", "ground_truth": "[1.0, 2.0, 3.0]", "quality_analysis": {"complexity_score": 15, "left_complexity": 10, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_96", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_sum_matrix_rows", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_sum_matrix_rows():\n    'Test row-wise matrix summation'\n    assert_close1d(sum_matrix_rows([[1, 2, 3], [4, 5, 6]]), [6.0, 15.0])\n    assert_close1d(sum_matrix_rows([[1], [2]]), [1.0, 2.0])\n    assert_close1d(sum_matrix_rows([[0, 0], [0, 0]]), [0.0, 0.0])\n    assert_close1d(sum_matrix_rows([[(- 1), 2], [3, (- 4)]]), [1.0, (- 1.0)])\n    assert_close1d(sum_matrix_rows([[1000000000000000.0, 1000000000000000.0], [1000000000000000.0, 1000000000000000.0]]), [2000000000000000.0, 2000000000000000.0])\n    assert_close1d(sum_matrix_rows([[1e-15, 1e-15], [1e-15, 1e-15]]), [2e-15, 2e-15])\n    assert (sum_matrix_cols([[1, 2, 3]]) == [1.0, 2.0, 3.0])\n    assert (sum_matrix_cols([[1], [2], [3]]) == [6.0])\n    with pytest.raises(ValueError):\n        sum_matrix_rows([])\n    with pytest.raises(ValueError):\n        sum_matrix_rows([[]])\n    with pytest.raises(ValueError):\n        sum_matrix_rows([[1, 2], [1]])\n    with pytest.raises(TypeError):\n        sum_matrix_cols([[1, 'a'], [2, 3]])", "masked_code": "def test_sum_matrix_rows():\n    'Test row-wise matrix summation'\n    assert_close1d(sum_matrix_rows([[1, 2, 3], [4, 5, 6]]), [6.0, 15.0])\n    assert_close1d(sum_matrix_rows([[1], [2]]), [1.0, 2.0])\n    assert_close1d(sum_matrix_rows([[0, 0], [0, 0]]), [0.0, 0.0])\n    assert_close1d(sum_matrix_rows([[(- 1), 2], [3, (- 4)]]), [1.0, (- 1.0)])\n    assert_close1d(sum_matrix_rows([[1000000000000000.0, 1000000000000000.0], [1000000000000000.0, 1000000000000000.0]]), [2000000000000000.0, 2000000000000000.0])\n    assert_close1d(sum_matrix_rows([[1e-15, 1e-15], [1e-15, 1e-15]]), [2e-15, 2e-15])\n    assert (sum_matrix_cols([[1, 2, 3]]) == [1.0, 2.0, 3.0])\n    assert (sum_matrix_cols([[1], [2], [3]]) == '???')\n    with pytest.raises(ValueError):\n        sum_matrix_rows([])\n    with pytest.raises(ValueError):\n        sum_matrix_rows([[]])\n    with pytest.raises(ValueError):\n        sum_matrix_rows([[1, 2], [1]])\n    with pytest.raises(TypeError):\n        sum_matrix_cols([[1, 'a'], [2, 3]])", "ground_truth": "[6.0]", "quality_analysis": {"complexity_score": 17, "left_complexity": 14, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_97", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_sum_matrix_cols", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_sum_matrix_cols():\n    'Test column-wise matrix summation'\n    assert_close1d(sum_matrix_cols([[1, 2, 3], [4, 5, 6]]), [5.0, 7.0, 9.0])\n    assert_close1d(sum_matrix_cols([[1], [2]]), [3.0])\n    assert (sum_matrix_rows([[1, 2, 3]]) == [6.0])\n    assert (sum_matrix_rows([[1], [2], [3]]) == [1.0, 2.0, 3.0])\n    assert_close1d(sum_matrix_cols([[0, 0], [0, 0]]), [0.0, 0.0])\n    assert_close1d(sum_matrix_cols([[(- 1), 2], [3, (- 4)]]), [2.0, (- 2.0)])\n    assert_close1d(sum_matrix_cols([[1000000000000000.0, 1000000000000000.0], [1000000000000000.0, 1000000000000000.0]]), [2000000000000000.0, 2000000000000000.0])\n    assert_close1d(sum_matrix_cols([[1e-15, 1e-15], [1e-15, 1e-15]]), [2e-15, 2e-15])\n    with pytest.raises(ValueError):\n        sum_matrix_cols([])\n    with pytest.raises(ValueError):\n        sum_matrix_cols([[]])\n    with pytest.raises(ValueError):\n        sum_matrix_cols([[1, 2], [1]])\n    with pytest.raises(TypeError):\n        sum_matrix_rows([[1, 'a'], [2, 3]])", "masked_code": "def test_sum_matrix_cols():\n    'Test column-wise matrix summation'\n    assert_close1d(sum_matrix_cols([[1, 2, 3], [4, 5, 6]]), [5.0, 7.0, 9.0])\n    assert_close1d(sum_matrix_cols([[1], [2]]), [3.0])\n    assert (sum_matrix_rows([[1, 2, 3]]) == '???')\n    assert (sum_matrix_rows([[1], [2], [3]]) == [1.0, 2.0, 3.0])\n    assert_close1d(sum_matrix_cols([[0, 0], [0, 0]]), [0.0, 0.0])\n    assert_close1d(sum_matrix_cols([[(- 1), 2], [3, (- 4)]]), [2.0, (- 2.0)])\n    assert_close1d(sum_matrix_cols([[1000000000000000.0, 1000000000000000.0], [1000000000000000.0, 1000000000000000.0]]), [2000000000000000.0, 2000000000000000.0])\n    assert_close1d(sum_matrix_cols([[1e-15, 1e-15], [1e-15, 1e-15]]), [2e-15, 2e-15])\n    with pytest.raises(ValueError):\n        sum_matrix_cols([])\n    with pytest.raises(ValueError):\n        sum_matrix_cols([[]])\n    with pytest.raises(ValueError):\n        sum_matrix_cols([[1, 2], [1]])\n    with pytest.raises(TypeError):\n        sum_matrix_rows([[1, 'a'], [2, 3]])", "ground_truth": "[6.0]", "quality_analysis": {"complexity_score": 13, "left_complexity": 10, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_98", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_sum_matrix_cols", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_sum_matrix_cols():\n    'Test column-wise matrix summation'\n    assert_close1d(sum_matrix_cols([[1, 2, 3], [4, 5, 6]]), [5.0, 7.0, 9.0])\n    assert_close1d(sum_matrix_cols([[1], [2]]), [3.0])\n    assert (sum_matrix_rows([[1, 2, 3]]) == [6.0])\n    assert (sum_matrix_rows([[1], [2], [3]]) == [1.0, 2.0, 3.0])\n    assert_close1d(sum_matrix_cols([[0, 0], [0, 0]]), [0.0, 0.0])\n    assert_close1d(sum_matrix_cols([[(- 1), 2], [3, (- 4)]]), [2.0, (- 2.0)])\n    assert_close1d(sum_matrix_cols([[1000000000000000.0, 1000000000000000.0], [1000000000000000.0, 1000000000000000.0]]), [2000000000000000.0, 2000000000000000.0])\n    assert_close1d(sum_matrix_cols([[1e-15, 1e-15], [1e-15, 1e-15]]), [2e-15, 2e-15])\n    with pytest.raises(ValueError):\n        sum_matrix_cols([])\n    with pytest.raises(ValueError):\n        sum_matrix_cols([[]])\n    with pytest.raises(ValueError):\n        sum_matrix_cols([[1, 2], [1]])\n    with pytest.raises(TypeError):\n        sum_matrix_rows([[1, 'a'], [2, 3]])", "masked_code": "def test_sum_matrix_cols():\n    'Test column-wise matrix summation'\n    assert_close1d(sum_matrix_cols([[1, 2, 3], [4, 5, 6]]), [5.0, 7.0, 9.0])\n    assert_close1d(sum_matrix_cols([[1], [2]]), [3.0])\n    assert (sum_matrix_rows([[1, 2, 3]]) == [6.0])\n    assert (sum_matrix_rows([[1], [2], [3]]) == '???')\n    assert_close1d(sum_matrix_cols([[0, 0], [0, 0]]), [0.0, 0.0])\n    assert_close1d(sum_matrix_cols([[(- 1), 2], [3, (- 4)]]), [2.0, (- 2.0)])\n    assert_close1d(sum_matrix_cols([[1000000000000000.0, 1000000000000000.0], [1000000000000000.0, 1000000000000000.0]]), [2000000000000000.0, 2000000000000000.0])\n    assert_close1d(sum_matrix_cols([[1e-15, 1e-15], [1e-15, 1e-15]]), [2e-15, 2e-15])\n    with pytest.raises(ValueError):\n        sum_matrix_cols([])\n    with pytest.raises(ValueError):\n        sum_matrix_cols([[]])\n    with pytest.raises(ValueError):\n        sum_matrix_cols([[1, 2], [1]])\n    with pytest.raises(TypeError):\n        sum_matrix_rows([[1, 'a'], [2, 3]])", "ground_truth": "[1.0, 2.0, 3.0]", "quality_analysis": {"complexity_score": 19, "left_complexity": 14, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_99", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_sort_paired_lists", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_sort_paired_lists():\n    assert (sort_paired_lists([3, 1, 2], ['c', 'a', 'b']) == ([1, 2, 3], ['a', 'b', 'c']))\n    assert (sort_paired_lists([], []) == ([], []))\n    assert (sort_paired_lists([2, 2, 1], ['a', 'b', 'c']) == ([1, 2, 2], ['c', 'a', 'b']))\n    assert (sort_paired_lists([(- 3), (- 1), (- 2)], ['c', 'a', 'b']) == ([(- 3), (- 2), (- 1)], ['c', 'b', 'a']))\n    temps = [300.5, 100.1, 200.7]\n    props = ['hot', 'cold', 'warm']\n    assert (sort_paired_lists(temps, props) == ([100.1, 200.7, 300.5], ['cold', 'warm', 'hot']))\n    with pytest.raises(ValueError):\n        sort_paired_lists([1, 2], [1])", "masked_code": "def test_sort_paired_lists():\n    assert (sort_paired_lists([3, 1, 2], ['c', 'a', 'b']) == '???')\n    assert (sort_paired_lists([], []) == ([], []))\n    assert (sort_paired_lists([2, 2, 1], ['a', 'b', 'c']) == ([1, 2, 2], ['c', 'a', 'b']))\n    assert (sort_paired_lists([(- 3), (- 1), (- 2)], ['c', 'a', 'b']) == ([(- 3), (- 2), (- 1)], ['c', 'b', 'a']))\n    temps = [300.5, 100.1, 200.7]\n    props = ['hot', 'cold', 'warm']\n    assert (sort_paired_lists(temps, props) == ([100.1, 200.7, 300.5], ['cold', 'warm', 'hot']))\n    with pytest.raises(ValueError):\n        sort_paired_lists([1, 2], [1])", "ground_truth": "([1, 2, 3], ['a', 'b', 'c'])", "quality_analysis": {"complexity_score": 25, "left_complexity": 13, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_100", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_sort_paired_lists", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_sort_paired_lists():\n    assert (sort_paired_lists([3, 1, 2], ['c', 'a', 'b']) == ([1, 2, 3], ['a', 'b', 'c']))\n    assert (sort_paired_lists([], []) == ([], []))\n    assert (sort_paired_lists([2, 2, 1], ['a', 'b', 'c']) == ([1, 2, 2], ['c', 'a', 'b']))\n    assert (sort_paired_lists([(- 3), (- 1), (- 2)], ['c', 'a', 'b']) == ([(- 3), (- 2), (- 1)], ['c', 'b', 'a']))\n    temps = [300.5, 100.1, 200.7]\n    props = ['hot', 'cold', 'warm']\n    assert (sort_paired_lists(temps, props) == ([100.1, 200.7, 300.5], ['cold', 'warm', 'hot']))\n    with pytest.raises(ValueError):\n        sort_paired_lists([1, 2], [1])", "masked_code": "def test_sort_paired_lists():\n    assert (sort_paired_lists([3, 1, 2], ['c', 'a', 'b']) == ([1, 2, 3], ['a', 'b', 'c']))\n    assert (sort_paired_lists([], []) == '???')\n    assert (sort_paired_lists([2, 2, 1], ['a', 'b', 'c']) == ([1, 2, 2], ['c', 'a', 'b']))\n    assert (sort_paired_lists([(- 3), (- 1), (- 2)], ['c', 'a', 'b']) == ([(- 3), (- 2), (- 1)], ['c', 'b', 'a']))\n    temps = [300.5, 100.1, 200.7]\n    props = ['hot', 'cold', 'warm']\n    assert (sort_paired_lists(temps, props) == ([100.1, 200.7, 300.5], ['cold', 'warm', 'hot']))\n    with pytest.raises(ValueError):\n        sort_paired_lists([1, 2], [1])", "ground_truth": "([], [])", "quality_analysis": {"complexity_score": 13, "left_complexity": 7, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_101", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_sort_paired_lists", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_sort_paired_lists():\n    assert (sort_paired_lists([3, 1, 2], ['c', 'a', 'b']) == ([1, 2, 3], ['a', 'b', 'c']))\n    assert (sort_paired_lists([], []) == ([], []))\n    assert (sort_paired_lists([2, 2, 1], ['a', 'b', 'c']) == ([1, 2, 2], ['c', 'a', 'b']))\n    assert (sort_paired_lists([(- 3), (- 1), (- 2)], ['c', 'a', 'b']) == ([(- 3), (- 2), (- 1)], ['c', 'b', 'a']))\n    temps = [300.5, 100.1, 200.7]\n    props = ['hot', 'cold', 'warm']\n    assert (sort_paired_lists(temps, props) == ([100.1, 200.7, 300.5], ['cold', 'warm', 'hot']))\n    with pytest.raises(ValueError):\n        sort_paired_lists([1, 2], [1])", "masked_code": "def test_sort_paired_lists():\n    assert (sort_paired_lists([3, 1, 2], ['c', 'a', 'b']) == ([1, 2, 3], ['a', 'b', 'c']))\n    assert (sort_paired_lists([], []) == ([], []))\n    assert (sort_paired_lists([2, 2, 1], ['a', 'b', 'c']) == '???')\n    assert (sort_paired_lists([(- 3), (- 1), (- 2)], ['c', 'a', 'b']) == ([(- 3), (- 2), (- 1)], ['c', 'b', 'a']))\n    temps = [300.5, 100.1, 200.7]\n    props = ['hot', 'cold', 'warm']\n    assert (sort_paired_lists(temps, props) == ([100.1, 200.7, 300.5], ['cold', 'warm', 'hot']))\n    with pytest.raises(ValueError):\n        sort_paired_lists([1, 2], [1])", "ground_truth": "([1, 2, 2], ['c', 'a', 'b'])", "quality_analysis": {"complexity_score": 25, "left_complexity": 13, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_102", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_sort_paired_lists", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_sort_paired_lists():\n    assert (sort_paired_lists([3, 1, 2], ['c', 'a', 'b']) == ([1, 2, 3], ['a', 'b', 'c']))\n    assert (sort_paired_lists([], []) == ([], []))\n    assert (sort_paired_lists([2, 2, 1], ['a', 'b', 'c']) == ([1, 2, 2], ['c', 'a', 'b']))\n    assert (sort_paired_lists([(- 3), (- 1), (- 2)], ['c', 'a', 'b']) == ([(- 3), (- 2), (- 1)], ['c', 'b', 'a']))\n    temps = [300.5, 100.1, 200.7]\n    props = ['hot', 'cold', 'warm']\n    assert (sort_paired_lists(temps, props) == ([100.1, 200.7, 300.5], ['cold', 'warm', 'hot']))\n    with pytest.raises(ValueError):\n        sort_paired_lists([1, 2], [1])", "masked_code": "def test_sort_paired_lists():\n    assert (sort_paired_lists([3, 1, 2], ['c', 'a', 'b']) == ([1, 2, 3], ['a', 'b', 'c']))\n    assert (sort_paired_lists([], []) == ([], []))\n    assert (sort_paired_lists([2, 2, 1], ['a', 'b', 'c']) == ([1, 2, 2], ['c', 'a', 'b']))\n    assert (sort_paired_lists([(- 3), (- 1), (- 2)], ['c', 'a', 'b']) == '???')\n    temps = [300.5, 100.1, 200.7]\n    props = ['hot', 'cold', 'warm']\n    assert (sort_paired_lists(temps, props) == ([100.1, 200.7, 300.5], ['cold', 'warm', 'hot']))\n    with pytest.raises(ValueError):\n        sort_paired_lists([1, 2], [1])", "ground_truth": "([(- 3), (- 2), (- 1)], ['c', 'b', 'a'])", "quality_analysis": {"complexity_score": 37, "left_complexity": 19, "right_complexity": 18, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_103", "reponame": "fluids", "testpath": "tests/test_numerics_arrays.py", "testname": "test_numerics_arrays.py", "classname": null, "funcname": "test_sort_paired_lists", "imports": ["from math import cos, erf, exp, isnan, log, pi, sin, sqrt", "import pytest", "from fluids.numerics.arrays import inv, solve, lu, gelsd, eye, dot_product, transpose, matrix_vector_dot, matrix_multiply, sum_matrix_rows, sum_matrix_cols, scalar_divide_matrix, scalar_multiply_matrix, scalar_subtract_matrices, scalar_add_matrices, null_space", "from fluids.numerics import array_as_tridiagonals, assert_close, assert_close1d, assert_close2d, solve_tridiagonal, subset_matrix, tridiagonals_as_array, argsort1d, sort_paired_lists", "from fluids.numerics import numpy as np"], "code": "def test_sort_paired_lists():\n    assert (sort_paired_lists([3, 1, 2], ['c', 'a', 'b']) == ([1, 2, 3], ['a', 'b', 'c']))\n    assert (sort_paired_lists([], []) == ([], []))\n    assert (sort_paired_lists([2, 2, 1], ['a', 'b', 'c']) == ([1, 2, 2], ['c', 'a', 'b']))\n    assert (sort_paired_lists([(- 3), (- 1), (- 2)], ['c', 'a', 'b']) == ([(- 3), (- 2), (- 1)], ['c', 'b', 'a']))\n    temps = [300.5, 100.1, 200.7]\n    props = ['hot', 'cold', 'warm']\n    assert (sort_paired_lists(temps, props) == ([100.1, 200.7, 300.5], ['cold', 'warm', 'hot']))\n    with pytest.raises(ValueError):\n        sort_paired_lists([1, 2], [1])", "masked_code": "def test_sort_paired_lists():\n    assert (sort_paired_lists([3, 1, 2], ['c', 'a', 'b']) == ([1, 2, 3], ['a', 'b', 'c']))\n    assert (sort_paired_lists([], []) == ([], []))\n    assert (sort_paired_lists([2, 2, 1], ['a', 'b', 'c']) == ([1, 2, 2], ['c', 'a', 'b']))\n    assert (sort_paired_lists([(- 3), (- 1), (- 2)], ['c', 'a', 'b']) == ([(- 3), (- 2), (- 1)], ['c', 'b', 'a']))\n    temps = [300.5, 100.1, 200.7]\n    props = ['hot', 'cold', 'warm']\n    assert (sort_paired_lists(temps, props) == '???')\n    with pytest.raises(ValueError):\n        sort_paired_lists([1, 2], [1])", "ground_truth": "([100.1, 200.7, 300.5], ['cold', 'warm', 'hot'])", "quality_analysis": {"complexity_score": 17, "left_complexity": 5, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_104", "reponame": "fluids", "testpath": "tests/test_numerics_doubledouble.py", "testname": "test_numerics_doubledouble.py", "classname": null, "funcname": "test_pow_dd", "imports": ["import pytest", "from fluids.numerics import assert_close, assert_close1d", "from fluids.numerics.doubledouble import add_dd, add_imag_dd, cbrt_dd, cbrt_imag_dd, cube_dd, div_dd, div_imag_dd, eq_dd, exp_dd, ge_dd, gt_dd, imag_inv_dd, intpow_dd, le_dd, log_dd, lt_dd, mul_dd, mul_imag_dd, mul_imag_noerrors_dd, mul_noerrors_dd, neq_dd, pow_dd, sqrt_dd, sqrt_imag_dd, square_dd"], "code": "def test_pow_dd():\n    for n in range((- 3), 4):\n        assert (pow_dd(0.6931471805599453, 2.3190468138462996e-17, n, 0) == intpow_dd(0.6931471805599453, 2.3190468138462996e-17, n))\n    (a, b) = pow_dd(0.6931471805599453, 2.3190468138462996e-17, 0.6931471805599453, 2.3190468138462996e-17)\n    assert_close(a, 0.7756550370345752, rtol=1e-14)\n    assert_close(b, 3.1024007879879916e-17, rtol=1e-14)", "masked_code": "def test_pow_dd():\n    for n in range((- 3), 4):\n        assert (pow_dd(0.6931471805599453, 2.3190468138462996e-17, n, 0) == '???')\n    (a, b) = pow_dd(0.6931471805599453, 2.3190468138462996e-17, 0.6931471805599453, 2.3190468138462996e-17)\n    assert_close(a, 0.7756550370345752, rtol=1e-14)\n    assert_close(b, 3.1024007879879916e-17, rtol=1e-14)", "ground_truth": "intpow_dd(0.6931471805599453, 2.3190468138462996e-17, n)", "quality_analysis": {"complexity_score": 13, "left_complexity": 7, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_105", "reponame": "fluids", "testpath": "tests/test_numerics_polynomial_evaluation.py", "testname": "test_numerics_polynomial_evaluation.py", "classname": null, "funcname": "test_exp_stablepoly_fit_ln_tau", "imports": ["from math import exp, log", "from fluids.numerics import assert_close, assert_close1d, derivative", "from fluids.numerics import numpy as np", "from fluids.numerics.polynomial_evaluation import exp_horner_stable, exp_horner_stable_and_der, exp_horner_stable_and_der2, exp_horner_stable_and_der3, exp_horner_stable_ln_tau, exp_horner_stable_ln_tau_and_der, exp_horner_stable_ln_tau_and_der2, horner_domain, horner_log, horner_stable, horner_stable_and_der, horner_stable_and_der2, horner_stable_and_der3, horner_stable_and_der4, horner_stable_ln_tau, horner_stable_ln_tau_and_der, horner_stable_ln_tau_and_der2, horner_stable_ln_tau_and_der3, horner_stable_log", "from fluids.numerics.polynomial_utils import polynomial_offset_scale"], "code": "def test_exp_stablepoly_fit_ln_tau():\n    coeffs = [0.011399360373616219, (- 0.014916568994522095), (- 0.06881296308711171), 0.0900153056718409, 0.19066633691545576, (- 0.24937350547406822), (- 0.3148389292182401), 0.41171834646956995, 0.3440581845934503, (- 0.44989947455906076), (- 0.2590532901358529), 0.33869134876113094, 0.1391329435696207, (- 0.18195230788023764), (- 0.050437145563137165), 0.06583166394466389, 0.01685157036382634, (- 0.022266583863000733), 0.003539388708205138, (- 0.005171064606571463), 0.012264455189935575, (- 0.018085676249990357), 0.026950795197264732, (- 0.04077120220662778), 0.05786417011592615, (- 0.07222889554773304), 0.07433570330647113, (- 0.05829288696590232), (- 3.7182636506596722), (- 5.844828481765601)]\n    (Tmin, Tmax, Tc) = (233.22, 646.15, 647.096)\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    T = 500\n    expect = 0.03126447402046822\n    (expect_d, expect_d2) = ((- 0.0002337992205182661), (- 1.0453011134030858e-07))\n    calc = exp_horner_stable_ln_tau(T, Tc, coeffs, offset, scale)\n    assert_close(expect, calc)\n    assert (0 == exp_horner_stable_ln_tau(700, Tc, coeffs, offset, scale))\n    calc2 = exp_horner_stable_ln_tau_and_der(T, Tc, coeffs, offset, scale)\n    assert ((0, 0) == exp_horner_stable_ln_tau_and_der(700, Tc, coeffs, offset, scale))\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = exp_horner_stable_ln_tau_and_der2(T, Tc, coeffs, offset, scale)\n    assert ((0, 0, 0) == exp_horner_stable_ln_tau_and_der2(700, Tc, coeffs, offset, scale))\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])", "masked_code": "def test_exp_stablepoly_fit_ln_tau():\n    coeffs = [0.011399360373616219, (- 0.014916568994522095), (- 0.06881296308711171), 0.0900153056718409, 0.19066633691545576, (- 0.24937350547406822), (- 0.3148389292182401), 0.41171834646956995, 0.3440581845934503, (- 0.44989947455906076), (- 0.2590532901358529), 0.33869134876113094, 0.1391329435696207, (- 0.18195230788023764), (- 0.050437145563137165), 0.06583166394466389, 0.01685157036382634, (- 0.022266583863000733), 0.003539388708205138, (- 0.005171064606571463), 0.012264455189935575, (- 0.018085676249990357), 0.026950795197264732, (- 0.04077120220662778), 0.05786417011592615, (- 0.07222889554773304), 0.07433570330647113, (- 0.05829288696590232), (- 3.7182636506596722), (- 5.844828481765601)]\n    (Tmin, Tmax, Tc) = (233.22, 646.15, 647.096)\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    T = 500\n    expect = 0.03126447402046822\n    (expect_d, expect_d2) = ((- 0.0002337992205182661), (- 1.0453011134030858e-07))\n    calc = exp_horner_stable_ln_tau(T, Tc, coeffs, offset, scale)\n    assert_close(expect, calc)\n    assert (0 == exp_horner_stable_ln_tau(700, Tc, coeffs, offset, scale))\n    calc2 = exp_horner_stable_ln_tau_and_der(T, Tc, coeffs, offset, scale)\n    assert ((0, 0) == '???')\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = exp_horner_stable_ln_tau_and_der2(T, Tc, coeffs, offset, scale)\n    assert ((0, 0, 0) == exp_horner_stable_ln_tau_and_der2(700, Tc, coeffs, offset, scale))\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])", "ground_truth": "exp_horner_stable_ln_tau_and_der(700, Tc, coeffs, offset, scale)", "quality_analysis": {"complexity_score": 12, "left_complexity": 4, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_106", "reponame": "fluids", "testpath": "tests/test_numerics_polynomial_evaluation.py", "testname": "test_numerics_polynomial_evaluation.py", "classname": null, "funcname": "test_exp_stablepoly_fit_ln_tau", "imports": ["from math import exp, log", "from fluids.numerics import assert_close, assert_close1d, derivative", "from fluids.numerics import numpy as np", "from fluids.numerics.polynomial_evaluation import exp_horner_stable, exp_horner_stable_and_der, exp_horner_stable_and_der2, exp_horner_stable_and_der3, exp_horner_stable_ln_tau, exp_horner_stable_ln_tau_and_der, exp_horner_stable_ln_tau_and_der2, horner_domain, horner_log, horner_stable, horner_stable_and_der, horner_stable_and_der2, horner_stable_and_der3, horner_stable_and_der4, horner_stable_ln_tau, horner_stable_ln_tau_and_der, horner_stable_ln_tau_and_der2, horner_stable_ln_tau_and_der3, horner_stable_log", "from fluids.numerics.polynomial_utils import polynomial_offset_scale"], "code": "def test_exp_stablepoly_fit_ln_tau():\n    coeffs = [0.011399360373616219, (- 0.014916568994522095), (- 0.06881296308711171), 0.0900153056718409, 0.19066633691545576, (- 0.24937350547406822), (- 0.3148389292182401), 0.41171834646956995, 0.3440581845934503, (- 0.44989947455906076), (- 0.2590532901358529), 0.33869134876113094, 0.1391329435696207, (- 0.18195230788023764), (- 0.050437145563137165), 0.06583166394466389, 0.01685157036382634, (- 0.022266583863000733), 0.003539388708205138, (- 0.005171064606571463), 0.012264455189935575, (- 0.018085676249990357), 0.026950795197264732, (- 0.04077120220662778), 0.05786417011592615, (- 0.07222889554773304), 0.07433570330647113, (- 0.05829288696590232), (- 3.7182636506596722), (- 5.844828481765601)]\n    (Tmin, Tmax, Tc) = (233.22, 646.15, 647.096)\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    T = 500\n    expect = 0.03126447402046822\n    (expect_d, expect_d2) = ((- 0.0002337992205182661), (- 1.0453011134030858e-07))\n    calc = exp_horner_stable_ln_tau(T, Tc, coeffs, offset, scale)\n    assert_close(expect, calc)\n    assert (0 == exp_horner_stable_ln_tau(700, Tc, coeffs, offset, scale))\n    calc2 = exp_horner_stable_ln_tau_and_der(T, Tc, coeffs, offset, scale)\n    assert ((0, 0) == exp_horner_stable_ln_tau_and_der(700, Tc, coeffs, offset, scale))\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = exp_horner_stable_ln_tau_and_der2(T, Tc, coeffs, offset, scale)\n    assert ((0, 0, 0) == exp_horner_stable_ln_tau_and_der2(700, Tc, coeffs, offset, scale))\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])", "masked_code": "def test_exp_stablepoly_fit_ln_tau():\n    coeffs = [0.011399360373616219, (- 0.014916568994522095), (- 0.06881296308711171), 0.0900153056718409, 0.19066633691545576, (- 0.24937350547406822), (- 0.3148389292182401), 0.41171834646956995, 0.3440581845934503, (- 0.44989947455906076), (- 0.2590532901358529), 0.33869134876113094, 0.1391329435696207, (- 0.18195230788023764), (- 0.050437145563137165), 0.06583166394466389, 0.01685157036382634, (- 0.022266583863000733), 0.003539388708205138, (- 0.005171064606571463), 0.012264455189935575, (- 0.018085676249990357), 0.026950795197264732, (- 0.04077120220662778), 0.05786417011592615, (- 0.07222889554773304), 0.07433570330647113, (- 0.05829288696590232), (- 3.7182636506596722), (- 5.844828481765601)]\n    (Tmin, Tmax, Tc) = (233.22, 646.15, 647.096)\n    (xmin, xmax) = (log((1 - (Tmin / Tc))), log((1 - (Tmax / Tc))))\n    (offset, scale) = polynomial_offset_scale(xmin, xmax)\n    T = 500\n    expect = 0.03126447402046822\n    (expect_d, expect_d2) = ((- 0.0002337992205182661), (- 1.0453011134030858e-07))\n    calc = exp_horner_stable_ln_tau(T, Tc, coeffs, offset, scale)\n    assert_close(expect, calc)\n    assert (0 == exp_horner_stable_ln_tau(700, Tc, coeffs, offset, scale))\n    calc2 = exp_horner_stable_ln_tau_and_der(T, Tc, coeffs, offset, scale)\n    assert ((0, 0) == exp_horner_stable_ln_tau_and_der(700, Tc, coeffs, offset, scale))\n    assert_close(expect, calc2[0])\n    assert_close(expect_d, calc2[1])\n    calc3 = exp_horner_stable_ln_tau_and_der2(T, Tc, coeffs, offset, scale)\n    assert ((0, 0, 0) == '???')\n    assert_close(expect, calc3[0])\n    assert_close(expect_d, calc3[1])\n    assert_close(expect_d2, calc3[2])", "ground_truth": "exp_horner_stable_ln_tau_and_der2(700, Tc, coeffs, offset, scale)", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_107", "reponame": "fluids", "testpath": "tests/test_numerics_special.py", "testname": "test_numerics_special.py", "classname": null, "funcname": "test_py_factorial", "imports": ["from math import exp, hypot, isinf, isnan, log", "from fluids.numerics import assert_close, comb", "from fluids.numerics.special import py_cacos, py_catanh, py_hypot, trunc_exp, trunc_log"], "code": "def test_py_factorial():\n    import math\n    from fluids.numerics.special import py_factorial\n    for i in range(30):\n        assert (math.factorial(i) == py_factorial(i))", "masked_code": "def test_py_factorial():\n    import math\n    from fluids.numerics.special import py_factorial\n    for i in range(30):\n        assert (math.factorial(i) == '???')", "ground_truth": "py_factorial(i)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_108", "reponame": "fluids", "testpath": "tests/test_particle_size_distribution.py", "testname": "test_particle_size_distribution.py", "classname": null, "funcname": "test_ASTM_E11_sieves", "imports": ["from math import log10", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d, isclose, logspace", "from fluids.particle_size_distribution import ISO_3310_1_R10, ISO_3310_1_R20, ISO_3310_1_R20_3, ISO_3310_1_R40_3, ASTM_E11_sieves, ISO_3310_1_sieves, ParticleSizeDistribution, PSDCustom, PSDInterpolated, PSDLognormal, cdf_Gates_Gaudin_Schuhman, cdf_lognormal, cdf_Rosin_Rammler, pdf_Gates_Gaudin_Schuhman, pdf_Gates_Gaudin_Schuhman_basis_integral, pdf_lognormal, pdf_lognormal_basis_integral, pdf_Rosin_Rammler, pdf_Rosin_Rammler_basis_integral, psd_spacing"], "code": "def test_ASTM_E11_sieves():\n    sieves = ASTM_E11_sieves.values()\n    tot = sum([i.d_wire for i in sieves])\n    assert_close(tot, 0.105963384)\n    tot = sum([i.opening for i in sieves])\n    assert_close(tot, 0.9876439999999999)\n    assert (len(ASTM_E11_sieves) == 56)\n    tot = 0.0\n    for attr in ['Y_variation_avg', 'X_variation_max', 'max_opening', 'd_wire', 'd_wire_min', 'd_wire_max', 'opening', 'opening_inch']:\n        tot += sum((getattr(i, attr) for i in sieves))", "masked_code": "def test_ASTM_E11_sieves():\n    sieves = ASTM_E11_sieves.values()\n    tot = sum([i.d_wire for i in sieves])\n    assert_close(tot, 0.105963384)\n    tot = sum([i.opening for i in sieves])\n    assert_close(tot, 0.9876439999999999)\n    assert (len(ASTM_E11_sieves) == '???')\n    tot = 0.0\n    for attr in ['Y_variation_avg', 'X_variation_max', 'max_opening', 'd_wire', 'd_wire_min', 'd_wire_max', 'opening', 'opening_inch']:\n        tot += sum((getattr(i, attr) for i in sieves))", "ground_truth": "56", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_109", "reponame": "fluids", "testpath": "tests/test_particle_size_distribution.py", "testname": "test_particle_size_distribution.py", "classname": null, "funcname": "test_ISO_3310_2_sieves", "imports": ["from math import log10", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d, isclose, logspace", "from fluids.particle_size_distribution import ISO_3310_1_R10, ISO_3310_1_R20, ISO_3310_1_R20_3, ISO_3310_1_R40_3, ASTM_E11_sieves, ISO_3310_1_sieves, ParticleSizeDistribution, PSDCustom, PSDInterpolated, PSDLognormal, cdf_Gates_Gaudin_Schuhman, cdf_lognormal, cdf_Rosin_Rammler, pdf_Gates_Gaudin_Schuhman, pdf_Gates_Gaudin_Schuhman_basis_integral, pdf_lognormal, pdf_lognormal_basis_integral, pdf_Rosin_Rammler, pdf_Rosin_Rammler_basis_integral, psd_spacing"], "code": "def test_ISO_3310_2_sieves():\n    sieves = ISO_3310_1_sieves.values()\n    tot = sum([i.d_wire for i in sieves])\n    assert_close(tot, 0.17564599999999997)\n    tot = sum([i.opening for i in sieves])\n    assert_close(tot, 1.5205579999999994)\n    assert (len(ISO_3310_1_sieves) == 99)\n    tot = 0.0\n    for attr in ['Y_variation_avg', 'X_variation_max', 'd_wire', 'd_wire_min', 'd_wire_max', 'opening']:\n        tot += sum((getattr(i, attr) for i in sieves))\n    for l in [ISO_3310_1_R20_3, ISO_3310_1_R20, ISO_3310_1_R10, ISO_3310_1_R40_3]:\n        for i in l:\n            assert (i.designation in ISO_3310_1_sieves)", "masked_code": "def test_ISO_3310_2_sieves():\n    sieves = ISO_3310_1_sieves.values()\n    tot = sum([i.d_wire for i in sieves])\n    assert_close(tot, 0.17564599999999997)\n    tot = sum([i.opening for i in sieves])\n    assert_close(tot, 1.5205579999999994)\n    assert (len(ISO_3310_1_sieves) == '???')\n    tot = 0.0\n    for attr in ['Y_variation_avg', 'X_variation_max', 'd_wire', 'd_wire_min', 'd_wire_max', 'opening']:\n        tot += sum((getattr(i, attr) for i in sieves))\n    for l in [ISO_3310_1_R20_3, ISO_3310_1_R20, ISO_3310_1_R10, ISO_3310_1_R40_3]:\n        for i in l:\n            assert (i.designation in ISO_3310_1_sieves)", "ground_truth": "99", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_110", "reponame": "fluids", "testpath": "tests/test_particle_size_distribution.py", "testname": "test_particle_size_distribution.py", "classname": null, "funcname": "test_PSDInterpolated_pchip", "imports": ["from math import log10", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d, isclose, logspace", "from fluids.particle_size_distribution import ISO_3310_1_R10, ISO_3310_1_R20, ISO_3310_1_R20_3, ISO_3310_1_R40_3, ASTM_E11_sieves, ISO_3310_1_sieves, ParticleSizeDistribution, PSDCustom, PSDInterpolated, PSDLognormal, cdf_Gates_Gaudin_Schuhman, cdf_lognormal, cdf_Rosin_Rammler, pdf_Gates_Gaudin_Schuhman, pdf_Gates_Gaudin_Schuhman_basis_integral, pdf_lognormal, pdf_lognormal_basis_integral, pdf_Rosin_Rammler, pdf_Rosin_Rammler_basis_integral, psd_spacing"], "code": "def test_PSDInterpolated_pchip():\n    'For this test, ds is the same length as fractions, and we begin the series with the zero point.\\n\\n    Half the test is spend on the `dn` solver tests, and the other half is just\\n    that these tests are slow.\\n    '\n    import numpy as np\n    ds = [360, 450, 562.5, 703, 878, 1097, 1371, 1713, 2141, 2676, 3345, 4181, 5226, 6532]\n    ds = (np.array(ds) / 1000000.0)\n    numbers = [65, 119, 232, 410, 629, 849, 990, 981, 825, 579, 297, 111, 21, 1]\n    dist = ParticleSizeDistribution(ds=ds, fractions=numbers, order=0)\n    psd = PSDInterpolated(dist.Dis, dist.fractions)\n    assert (len(psd.fractions) == len(psd.ds))\n    assert (len(psd.fractions) == 15)\n    assert_close1d(psd.fractions_discrete(ds), dist.fractions)\n    assert_close1d(psd.cdf_discrete(ds), psd.fraction_cdf[1:])\n    cumulative_fractions = np.cumsum(dist.fractions)\n    ds_for_fractions = np.array([psd.dn(f) for f in cumulative_fractions])\n    assert_close1d(ds, ds_for_fractions)\n    test_pdf = psd._pdf(0.001)\n    assert_close(test_pdf, 106.28284463095554)\n    test_cdf = psd._cdf(0.001)\n    assert_close(test_cdf, 0.02278897476363087)\n    test_int = psd._pdf_basis_integral(0.001, 2)\n    assert_close(test_int, 1.509707233427664e-08)\n    assert_close1d(psd.ds, ([0] + ds.tolist()))\n    assert_close1d(psd.fractions, ([0] + dist.fractions))\n    test_mean = psd.mean_size(3, 2)\n    assert_close(test_mean, 0.002211577679574544)", "masked_code": "def test_PSDInterpolated_pchip():\n    'For this test, ds is the same length as fractions, and we begin the series with the zero point.\\n\\n    Half the test is spend on the `dn` solver tests, and the other half is just\\n    that these tests are slow.\\n    '\n    import numpy as np\n    ds = [360, 450, 562.5, 703, 878, 1097, 1371, 1713, 2141, 2676, 3345, 4181, 5226, 6532]\n    ds = (np.array(ds) / 1000000.0)\n    numbers = [65, 119, 232, 410, 629, 849, 990, 981, 825, 579, 297, 111, 21, 1]\n    dist = ParticleSizeDistribution(ds=ds, fractions=numbers, order=0)\n    psd = PSDInterpolated(dist.Dis, dist.fractions)\n    assert (len(psd.fractions) == '???')\n    assert (len(psd.fractions) == 15)\n    assert_close1d(psd.fractions_discrete(ds), dist.fractions)\n    assert_close1d(psd.cdf_discrete(ds), psd.fraction_cdf[1:])\n    cumulative_fractions = np.cumsum(dist.fractions)\n    ds_for_fractions = np.array([psd.dn(f) for f in cumulative_fractions])\n    assert_close1d(ds, ds_for_fractions)\n    test_pdf = psd._pdf(0.001)\n    assert_close(test_pdf, 106.28284463095554)\n    test_cdf = psd._cdf(0.001)\n    assert_close(test_cdf, 0.02278897476363087)\n    test_int = psd._pdf_basis_integral(0.001, 2)\n    assert_close(test_int, 1.509707233427664e-08)\n    assert_close1d(psd.ds, ([0] + ds.tolist()))\n    assert_close1d(psd.fractions, ([0] + dist.fractions))\n    test_mean = psd.mean_size(3, 2)\n    assert_close(test_mean, 0.002211577679574544)", "ground_truth": "len(psd.ds)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_111", "reponame": "fluids", "testpath": "tests/test_particle_size_distribution.py", "testname": "test_particle_size_distribution.py", "classname": null, "funcname": "test_PSDInterpolated_pchip", "imports": ["from math import log10", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d, isclose, logspace", "from fluids.particle_size_distribution import ISO_3310_1_R10, ISO_3310_1_R20, ISO_3310_1_R20_3, ISO_3310_1_R40_3, ASTM_E11_sieves, ISO_3310_1_sieves, ParticleSizeDistribution, PSDCustom, PSDInterpolated, PSDLognormal, cdf_Gates_Gaudin_Schuhman, cdf_lognormal, cdf_Rosin_Rammler, pdf_Gates_Gaudin_Schuhman, pdf_Gates_Gaudin_Schuhman_basis_integral, pdf_lognormal, pdf_lognormal_basis_integral, pdf_Rosin_Rammler, pdf_Rosin_Rammler_basis_integral, psd_spacing"], "code": "def test_PSDInterpolated_pchip():\n    'For this test, ds is the same length as fractions, and we begin the series with the zero point.\\n\\n    Half the test is spend on the `dn` solver tests, and the other half is just\\n    that these tests are slow.\\n    '\n    import numpy as np\n    ds = [360, 450, 562.5, 703, 878, 1097, 1371, 1713, 2141, 2676, 3345, 4181, 5226, 6532]\n    ds = (np.array(ds) / 1000000.0)\n    numbers = [65, 119, 232, 410, 629, 849, 990, 981, 825, 579, 297, 111, 21, 1]\n    dist = ParticleSizeDistribution(ds=ds, fractions=numbers, order=0)\n    psd = PSDInterpolated(dist.Dis, dist.fractions)\n    assert (len(psd.fractions) == len(psd.ds))\n    assert (len(psd.fractions) == 15)\n    assert_close1d(psd.fractions_discrete(ds), dist.fractions)\n    assert_close1d(psd.cdf_discrete(ds), psd.fraction_cdf[1:])\n    cumulative_fractions = np.cumsum(dist.fractions)\n    ds_for_fractions = np.array([psd.dn(f) for f in cumulative_fractions])\n    assert_close1d(ds, ds_for_fractions)\n    test_pdf = psd._pdf(0.001)\n    assert_close(test_pdf, 106.28284463095554)\n    test_cdf = psd._cdf(0.001)\n    assert_close(test_cdf, 0.02278897476363087)\n    test_int = psd._pdf_basis_integral(0.001, 2)\n    assert_close(test_int, 1.509707233427664e-08)\n    assert_close1d(psd.ds, ([0] + ds.tolist()))\n    assert_close1d(psd.fractions, ([0] + dist.fractions))\n    test_mean = psd.mean_size(3, 2)\n    assert_close(test_mean, 0.002211577679574544)", "masked_code": "def test_PSDInterpolated_pchip():\n    'For this test, ds is the same length as fractions, and we begin the series with the zero point.\\n\\n    Half the test is spend on the `dn` solver tests, and the other half is just\\n    that these tests are slow.\\n    '\n    import numpy as np\n    ds = [360, 450, 562.5, 703, 878, 1097, 1371, 1713, 2141, 2676, 3345, 4181, 5226, 6532]\n    ds = (np.array(ds) / 1000000.0)\n    numbers = [65, 119, 232, 410, 629, 849, 990, 981, 825, 579, 297, 111, 21, 1]\n    dist = ParticleSizeDistribution(ds=ds, fractions=numbers, order=0)\n    psd = PSDInterpolated(dist.Dis, dist.fractions)\n    assert (len(psd.fractions) == len(psd.ds))\n    assert (len(psd.fractions) == '???')\n    assert_close1d(psd.fractions_discrete(ds), dist.fractions)\n    assert_close1d(psd.cdf_discrete(ds), psd.fraction_cdf[1:])\n    cumulative_fractions = np.cumsum(dist.fractions)\n    ds_for_fractions = np.array([psd.dn(f) for f in cumulative_fractions])\n    assert_close1d(ds, ds_for_fractions)\n    test_pdf = psd._pdf(0.001)\n    assert_close(test_pdf, 106.28284463095554)\n    test_cdf = psd._cdf(0.001)\n    assert_close(test_cdf, 0.02278897476363087)\n    test_int = psd._pdf_basis_integral(0.001, 2)\n    assert_close(test_int, 1.509707233427664e-08)\n    assert_close1d(psd.ds, ([0] + ds.tolist()))\n    assert_close1d(psd.fractions, ([0] + dist.fractions))\n    test_mean = psd.mean_size(3, 2)\n    assert_close(test_mean, 0.002211577679574544)", "ground_truth": "15", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_112", "reponame": "fluids", "testpath": "tests/test_particle_size_distribution.py", "testname": "test_particle_size_distribution.py", "classname": null, "funcname": "test_psd_spacing", "imports": ["from math import log10", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d, isclose, logspace", "from fluids.particle_size_distribution import ISO_3310_1_R10, ISO_3310_1_R20, ISO_3310_1_R20_3, ISO_3310_1_R40_3, ASTM_E11_sieves, ISO_3310_1_sieves, ParticleSizeDistribution, PSDCustom, PSDInterpolated, PSDLognormal, cdf_Gates_Gaudin_Schuhman, cdf_lognormal, cdf_Rosin_Rammler, pdf_Gates_Gaudin_Schuhman, pdf_Gates_Gaudin_Schuhman_basis_integral, pdf_lognormal, pdf_lognormal_basis_integral, pdf_Rosin_Rammler, pdf_Rosin_Rammler_basis_integral, psd_spacing"], "code": "def test_psd_spacing():\n    ans_log = psd_spacing(d_min=1, d_max=10, pts=4, method='logarithmic')\n    ans_log_expect = [1.0, 2.154434690031884, 4.641588833612778, 10.0]\n    assert_close1d(ans_log, ans_log_expect)\n    ans_lin = psd_spacing(d_min=0, d_max=10, pts=4, method='linear')\n    ans_lin_expect = [0.0, 3.3333333333333335, 6.666666666666667, 10.0]\n    assert_close1d(ans_lin, ans_lin_expect)\n    with pytest.raises(Exception):\n        psd_spacing(d_min=0, d_max=10, pts=8, method='R5')\n    with pytest.raises(Exception):\n        psd_spacing(d_min=5e-05, d_max=0.0005, method='BADMETHOD')\n    ans_R5 = psd_spacing(d_max=25, pts=8, method='R5')\n    ans_R5_expect = [0.9952679263837426, 1.5773933612004825, 2.499999999999999, 3.9622329811527823, 6.279716078773949, 9.95267926383743, 15.77393361200483, 25]\n    assert_close1d(ans_R5, ans_R5_expect)\n    ans_R5_reversed = psd_spacing(d_min=0.9952679263837426, pts=8, method='R5')\n    assert_close1d(ans_R5_reversed, ans_R5_expect)\n    ans_R5_float = psd_spacing(d_max=25, pts=8, method='R5.00000001')\n    assert_close1d(ans_R5_float, ans_R5_expect)\n    ans = psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1')\n    ans_expect = [5e-05, 5.3e-05, 5.6e-05, 6.3e-05, 7.1e-05, 7.5e-05, 8e-05, 9e-05, 0.0001, 0.000106, 0.000112, 0.000125, 0.00014, 0.00015, 0.00016, 0.00018, 0.0002, 0.000212, 0.000224, 0.00025, 0.00028, 0.0003, 0.000315, 0.000355, 0.0004, 0.000425, 0.00045, 0.0005, 0.00056, 0.0006, 0.00063, 0.00071, 0.0008, 0.00085, 0.0009, 0.001]\n    assert_close1d(ans, ans_expect)\n    assert ([] == psd_spacing(d_min=0, d_max=1e-06, method='ISO 3310-1'))\n    assert ([] == psd_spacing(d_min=1, d_max=100.0, method='ISO 3310-1'))\n    assert psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1 R20')\n    assert psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1 R20/3')\n    assert psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1 R40/3')\n    assert psd_spacing(d_min=0.0, d_max=0.001, method='ISO 3310-1 R10')\n    ds = psd_spacing(d_min=1e-05, d_max=0.0001, method='ASTM E11')\n    ds_expect = [2e-05, 2.5e-05, 3.2e-05, 3.8e-05, 4.5e-05, 5.3e-05, 6.3e-05, 7.5e-05, 9e-05]\n    assert_close1d(ds, ds_expect)", "masked_code": "def test_psd_spacing():\n    ans_log = psd_spacing(d_min=1, d_max=10, pts=4, method='logarithmic')\n    ans_log_expect = [1.0, 2.154434690031884, 4.641588833612778, 10.0]\n    assert_close1d(ans_log, ans_log_expect)\n    ans_lin = psd_spacing(d_min=0, d_max=10, pts=4, method='linear')\n    ans_lin_expect = [0.0, 3.3333333333333335, 6.666666666666667, 10.0]\n    assert_close1d(ans_lin, ans_lin_expect)\n    with pytest.raises(Exception):\n        psd_spacing(d_min=0, d_max=10, pts=8, method='R5')\n    with pytest.raises(Exception):\n        psd_spacing(d_min=5e-05, d_max=0.0005, method='BADMETHOD')\n    ans_R5 = psd_spacing(d_max=25, pts=8, method='R5')\n    ans_R5_expect = [0.9952679263837426, 1.5773933612004825, 2.499999999999999, 3.9622329811527823, 6.279716078773949, 9.95267926383743, 15.77393361200483, 25]\n    assert_close1d(ans_R5, ans_R5_expect)\n    ans_R5_reversed = psd_spacing(d_min=0.9952679263837426, pts=8, method='R5')\n    assert_close1d(ans_R5_reversed, ans_R5_expect)\n    ans_R5_float = psd_spacing(d_max=25, pts=8, method='R5.00000001')\n    assert_close1d(ans_R5_float, ans_R5_expect)\n    ans = psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1')\n    ans_expect = [5e-05, 5.3e-05, 5.6e-05, 6.3e-05, 7.1e-05, 7.5e-05, 8e-05, 9e-05, 0.0001, 0.000106, 0.000112, 0.000125, 0.00014, 0.00015, 0.00016, 0.00018, 0.0002, 0.000212, 0.000224, 0.00025, 0.00028, 0.0003, 0.000315, 0.000355, 0.0004, 0.000425, 0.00045, 0.0005, 0.00056, 0.0006, 0.00063, 0.00071, 0.0008, 0.00085, 0.0009, 0.001]\n    assert_close1d(ans, ans_expect)\n    assert ([] == '???')\n    assert ([] == psd_spacing(d_min=1, d_max=100.0, method='ISO 3310-1'))\n    assert psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1 R20')\n    assert psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1 R20/3')\n    assert psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1 R40/3')\n    assert psd_spacing(d_min=0.0, d_max=0.001, method='ISO 3310-1 R10')\n    ds = psd_spacing(d_min=1e-05, d_max=0.0001, method='ASTM E11')\n    ds_expect = [2e-05, 2.5e-05, 3.2e-05, 3.8e-05, 4.5e-05, 5.3e-05, 6.3e-05, 7.5e-05, 9e-05]\n    assert_close1d(ds, ds_expect)", "ground_truth": "psd_spacing(d_min=0, d_max=1e-06, method='ISO 3310-1')", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_113", "reponame": "fluids", "testpath": "tests/test_particle_size_distribution.py", "testname": "test_particle_size_distribution.py", "classname": null, "funcname": "test_psd_spacing", "imports": ["from math import log10", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d, isclose, logspace", "from fluids.particle_size_distribution import ISO_3310_1_R10, ISO_3310_1_R20, ISO_3310_1_R20_3, ISO_3310_1_R40_3, ASTM_E11_sieves, ISO_3310_1_sieves, ParticleSizeDistribution, PSDCustom, PSDInterpolated, PSDLognormal, cdf_Gates_Gaudin_Schuhman, cdf_lognormal, cdf_Rosin_Rammler, pdf_Gates_Gaudin_Schuhman, pdf_Gates_Gaudin_Schuhman_basis_integral, pdf_lognormal, pdf_lognormal_basis_integral, pdf_Rosin_Rammler, pdf_Rosin_Rammler_basis_integral, psd_spacing"], "code": "def test_psd_spacing():\n    ans_log = psd_spacing(d_min=1, d_max=10, pts=4, method='logarithmic')\n    ans_log_expect = [1.0, 2.154434690031884, 4.641588833612778, 10.0]\n    assert_close1d(ans_log, ans_log_expect)\n    ans_lin = psd_spacing(d_min=0, d_max=10, pts=4, method='linear')\n    ans_lin_expect = [0.0, 3.3333333333333335, 6.666666666666667, 10.0]\n    assert_close1d(ans_lin, ans_lin_expect)\n    with pytest.raises(Exception):\n        psd_spacing(d_min=0, d_max=10, pts=8, method='R5')\n    with pytest.raises(Exception):\n        psd_spacing(d_min=5e-05, d_max=0.0005, method='BADMETHOD')\n    ans_R5 = psd_spacing(d_max=25, pts=8, method='R5')\n    ans_R5_expect = [0.9952679263837426, 1.5773933612004825, 2.499999999999999, 3.9622329811527823, 6.279716078773949, 9.95267926383743, 15.77393361200483, 25]\n    assert_close1d(ans_R5, ans_R5_expect)\n    ans_R5_reversed = psd_spacing(d_min=0.9952679263837426, pts=8, method='R5')\n    assert_close1d(ans_R5_reversed, ans_R5_expect)\n    ans_R5_float = psd_spacing(d_max=25, pts=8, method='R5.00000001')\n    assert_close1d(ans_R5_float, ans_R5_expect)\n    ans = psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1')\n    ans_expect = [5e-05, 5.3e-05, 5.6e-05, 6.3e-05, 7.1e-05, 7.5e-05, 8e-05, 9e-05, 0.0001, 0.000106, 0.000112, 0.000125, 0.00014, 0.00015, 0.00016, 0.00018, 0.0002, 0.000212, 0.000224, 0.00025, 0.00028, 0.0003, 0.000315, 0.000355, 0.0004, 0.000425, 0.00045, 0.0005, 0.00056, 0.0006, 0.00063, 0.00071, 0.0008, 0.00085, 0.0009, 0.001]\n    assert_close1d(ans, ans_expect)\n    assert ([] == psd_spacing(d_min=0, d_max=1e-06, method='ISO 3310-1'))\n    assert ([] == psd_spacing(d_min=1, d_max=100.0, method='ISO 3310-1'))\n    assert psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1 R20')\n    assert psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1 R20/3')\n    assert psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1 R40/3')\n    assert psd_spacing(d_min=0.0, d_max=0.001, method='ISO 3310-1 R10')\n    ds = psd_spacing(d_min=1e-05, d_max=0.0001, method='ASTM E11')\n    ds_expect = [2e-05, 2.5e-05, 3.2e-05, 3.8e-05, 4.5e-05, 5.3e-05, 6.3e-05, 7.5e-05, 9e-05]\n    assert_close1d(ds, ds_expect)", "masked_code": "def test_psd_spacing():\n    ans_log = psd_spacing(d_min=1, d_max=10, pts=4, method='logarithmic')\n    ans_log_expect = [1.0, 2.154434690031884, 4.641588833612778, 10.0]\n    assert_close1d(ans_log, ans_log_expect)\n    ans_lin = psd_spacing(d_min=0, d_max=10, pts=4, method='linear')\n    ans_lin_expect = [0.0, 3.3333333333333335, 6.666666666666667, 10.0]\n    assert_close1d(ans_lin, ans_lin_expect)\n    with pytest.raises(Exception):\n        psd_spacing(d_min=0, d_max=10, pts=8, method='R5')\n    with pytest.raises(Exception):\n        psd_spacing(d_min=5e-05, d_max=0.0005, method='BADMETHOD')\n    ans_R5 = psd_spacing(d_max=25, pts=8, method='R5')\n    ans_R5_expect = [0.9952679263837426, 1.5773933612004825, 2.499999999999999, 3.9622329811527823, 6.279716078773949, 9.95267926383743, 15.77393361200483, 25]\n    assert_close1d(ans_R5, ans_R5_expect)\n    ans_R5_reversed = psd_spacing(d_min=0.9952679263837426, pts=8, method='R5')\n    assert_close1d(ans_R5_reversed, ans_R5_expect)\n    ans_R5_float = psd_spacing(d_max=25, pts=8, method='R5.00000001')\n    assert_close1d(ans_R5_float, ans_R5_expect)\n    ans = psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1')\n    ans_expect = [5e-05, 5.3e-05, 5.6e-05, 6.3e-05, 7.1e-05, 7.5e-05, 8e-05, 9e-05, 0.0001, 0.000106, 0.000112, 0.000125, 0.00014, 0.00015, 0.00016, 0.00018, 0.0002, 0.000212, 0.000224, 0.00025, 0.00028, 0.0003, 0.000315, 0.000355, 0.0004, 0.000425, 0.00045, 0.0005, 0.00056, 0.0006, 0.00063, 0.00071, 0.0008, 0.00085, 0.0009, 0.001]\n    assert_close1d(ans, ans_expect)\n    assert ([] == psd_spacing(d_min=0, d_max=1e-06, method='ISO 3310-1'))\n    assert ([] == '???')\n    assert psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1 R20')\n    assert psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1 R20/3')\n    assert psd_spacing(d_min=5e-05, d_max=0.001, method='ISO 3310-1 R40/3')\n    assert psd_spacing(d_min=0.0, d_max=0.001, method='ISO 3310-1 R10')\n    ds = psd_spacing(d_min=1e-05, d_max=0.0001, method='ASTM E11')\n    ds_expect = [2e-05, 2.5e-05, 3.2e-05, 3.8e-05, 4.5e-05, 5.3e-05, 6.3e-05, 7.5e-05, 9e-05]\n    assert_close1d(ds, ds_expect)", "ground_truth": "psd_spacing(d_min=1, d_max=100.0, method='ISO 3310-1')", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_114", "reponame": "fluids", "testpath": "tests/test_piping.py", "testname": "test_piping.py", "classname": null, "funcname": "test_piping_schedule_basics", "imports": ["import pytest", "from fluids.numerics import assert_close, assert_close1d", "from fluids.piping import erosional_velocity, gauge_from_t, nearest_pipe, t_from_gauge"], "code": "def test_piping_schedule_basics():\n    from fluids.piping import schedule_lookup\n    for (k, (NPSs, Dis, Dos, ts)) in schedule_lookup.items():\n        assert (len(NPSs) == len(Dis))\n        assert (len(Dis) == len(Dos))\n        assert (len(Dos) == len(ts))\n        for i in range((len(NPSs) - 1)):\n            assert (NPSs[(i + 1)] >= NPSs[i])\n        for i in range((len(Dis) - 1)):\n            assert (Dis[(i + 1)] >= Dis[i])\n        for i in range((len(Dos) - 1)):\n            assert (Dos[(i + 1)] >= Dos[i])\n        for i in range((len(ts) - 1)):\n            assert (ts[(i + 1)] >= ts[i])\n        for i in range(len(NPSs)):\n            err = abs((((Dis[i] + (ts[i] * 2)) / Dos[i]) - 1))\n            assert (err < 1e-14)", "masked_code": "def test_piping_schedule_basics():\n    from fluids.piping import schedule_lookup\n    for (k, (NPSs, Dis, Dos, ts)) in schedule_lookup.items():\n        assert (len(NPSs) == '???')\n        assert (len(Dis) == len(Dos))\n        assert (len(Dos) == len(ts))\n        for i in range((len(NPSs) - 1)):\n            assert (NPSs[(i + 1)] >= NPSs[i])\n        for i in range((len(Dis) - 1)):\n            assert (Dis[(i + 1)] >= Dis[i])\n        for i in range((len(Dos) - 1)):\n            assert (Dos[(i + 1)] >= Dos[i])\n        for i in range((len(ts) - 1)):\n            assert (ts[(i + 1)] >= ts[i])\n        for i in range(len(NPSs)):\n            err = abs((((Dis[i] + (ts[i] * 2)) / Dos[i]) - 1))\n            assert (err < 1e-14)", "ground_truth": "len(Dis)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_115", "reponame": "fluids", "testpath": "tests/test_piping.py", "testname": "test_piping.py", "classname": null, "funcname": "test_piping_schedule_basics", "imports": ["import pytest", "from fluids.numerics import assert_close, assert_close1d", "from fluids.piping import erosional_velocity, gauge_from_t, nearest_pipe, t_from_gauge"], "code": "def test_piping_schedule_basics():\n    from fluids.piping import schedule_lookup\n    for (k, (NPSs, Dis, Dos, ts)) in schedule_lookup.items():\n        assert (len(NPSs) == len(Dis))\n        assert (len(Dis) == len(Dos))\n        assert (len(Dos) == len(ts))\n        for i in range((len(NPSs) - 1)):\n            assert (NPSs[(i + 1)] >= NPSs[i])\n        for i in range((len(Dis) - 1)):\n            assert (Dis[(i + 1)] >= Dis[i])\n        for i in range((len(Dos) - 1)):\n            assert (Dos[(i + 1)] >= Dos[i])\n        for i in range((len(ts) - 1)):\n            assert (ts[(i + 1)] >= ts[i])\n        for i in range(len(NPSs)):\n            err = abs((((Dis[i] + (ts[i] * 2)) / Dos[i]) - 1))\n            assert (err < 1e-14)", "masked_code": "def test_piping_schedule_basics():\n    from fluids.piping import schedule_lookup\n    for (k, (NPSs, Dis, Dos, ts)) in schedule_lookup.items():\n        assert (len(NPSs) == len(Dis))\n        assert (len(Dis) == '???')\n        assert (len(Dos) == len(ts))\n        for i in range((len(NPSs) - 1)):\n            assert (NPSs[(i + 1)] >= NPSs[i])\n        for i in range((len(Dis) - 1)):\n            assert (Dis[(i + 1)] >= Dis[i])\n        for i in range((len(Dos) - 1)):\n            assert (Dos[(i + 1)] >= Dos[i])\n        for i in range((len(ts) - 1)):\n            assert (ts[(i + 1)] >= ts[i])\n        for i in range(len(NPSs)):\n            err = abs((((Dis[i] + (ts[i] * 2)) / Dos[i]) - 1))\n            assert (err < 1e-14)", "ground_truth": "len(Dos)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_116", "reponame": "fluids", "testpath": "tests/test_piping.py", "testname": "test_piping.py", "classname": null, "funcname": "test_piping_schedule_basics", "imports": ["import pytest", "from fluids.numerics import assert_close, assert_close1d", "from fluids.piping import erosional_velocity, gauge_from_t, nearest_pipe, t_from_gauge"], "code": "def test_piping_schedule_basics():\n    from fluids.piping import schedule_lookup\n    for (k, (NPSs, Dis, Dos, ts)) in schedule_lookup.items():\n        assert (len(NPSs) == len(Dis))\n        assert (len(Dis) == len(Dos))\n        assert (len(Dos) == len(ts))\n        for i in range((len(NPSs) - 1)):\n            assert (NPSs[(i + 1)] >= NPSs[i])\n        for i in range((len(Dis) - 1)):\n            assert (Dis[(i + 1)] >= Dis[i])\n        for i in range((len(Dos) - 1)):\n            assert (Dos[(i + 1)] >= Dos[i])\n        for i in range((len(ts) - 1)):\n            assert (ts[(i + 1)] >= ts[i])\n        for i in range(len(NPSs)):\n            err = abs((((Dis[i] + (ts[i] * 2)) / Dos[i]) - 1))\n            assert (err < 1e-14)", "masked_code": "def test_piping_schedule_basics():\n    from fluids.piping import schedule_lookup\n    for (k, (NPSs, Dis, Dos, ts)) in schedule_lookup.items():\n        assert (len(NPSs) == len(Dis))\n        assert (len(Dis) == len(Dos))\n        assert (len(Dos) == '???')\n        for i in range((len(NPSs) - 1)):\n            assert (NPSs[(i + 1)] >= NPSs[i])\n        for i in range((len(Dis) - 1)):\n            assert (Dis[(i + 1)] >= Dis[i])\n        for i in range((len(Dos) - 1)):\n            assert (Dos[(i + 1)] >= Dos[i])\n        for i in range((len(ts) - 1)):\n            assert (ts[(i + 1)] >= ts[i])\n        for i in range(len(NPSs)):\n            err = abs((((Dis[i] + (ts[i] * 2)) / Dos[i]) - 1))\n            assert (err < 1e-14)", "ground_truth": "len(ts)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_117", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == '???')\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "ground_truth": "1001", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_118", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == '???')\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "ground_truth": "14", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_119", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == '???')\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "ground_truth": "1262", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_120", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == '???')\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "ground_truth": "8", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_121", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == '???')\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "ground_truth": "3800", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_122", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == '???')\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "ground_truth": "13", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_123", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == '???')\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "ground_truth": "42071", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_124", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == '???')\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "ground_truth": "10530", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_125", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == '???')\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "ground_truth": "203", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_126", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == '???')\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "ground_truth": "(120, 60, ('A', 'B'))", "quality_analysis": {"complexity_score": 16, "left_complexity": 8, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_127", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == '???')\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "ground_truth": "82144", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_128", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == '???')\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "ground_truth": "10210", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_129", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == '???')\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "ground_truth": "197", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_130", "reponame": "fluids", "testpath": "tests/test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == ((120, 208, 240, 480, 347, 600), 60))", "masked_code": "def test_power_sources():\n    assert (sum(map(ord, electrical_plug_types)) == 1001)\n    assert (len(electrical_plug_types) == 14)\n    assert (sum(voltages_1_phase_residential) == 1262)\n    assert (len(voltages_1_phase_residential) == 8)\n    assert (sum(voltages_3_phase) == 3800)\n    assert (len(voltages_3_phase) == 13)\n    assert (residential_power_frequencies == [50, 60])\n    assert (sum([i.voltage for i in residential_power.values()]) == 42071)\n    assert (sum([i.freq for i in residential_power.values()]) == 10530)\n    assert (len(residential_power) == 203)\n    ca = residential_power['ca']\n    assert ((ca.voltage, ca.freq, ca.plugs) == (120, 60, ('A', 'B')))\n    assert (sum([sum(i.voltage) for i in industrial_power.values()]) == 82144)\n    assert (sum([i.freq for i in industrial_power.values()]) == 10210)\n    assert (len(industrial_power) == 197)\n    ca = industrial_power['ca']\n    assert ((ca.voltage, ca.freq) == '???')", "ground_truth": "((120, 208, 240, 480, 347, 600), 60)", "quality_analysis": {"complexity_score": 17, "left_complexity": 6, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_131", "reponame": "fluids", "testpath": "tests/test_two_phase.py", "testname": "test_two_phase.py", "classname": null, "funcname": "test_two_phase_dP", "imports": ["from math import log10", "import pytest", "from fluids.numerics import assert_close, assert_close1d", "from fluids.two_phase import Bankoff, Baroczy_Chisholm, Beggs_Brill, Chen_Friedel, Chisholm, Friedel, Gronnerud, Hwang_Kim, Jung_Radermacher, Kim_Mudawar, Lockhart_Martinelli, Lombardi_Pedrocchi, Mishima_Hibiki, Muller_Steinhagen_Heck, Theissing, Tran, Wang_Chiang_Lu, Xu_Fang, Yu_France, Zhang_Hibiki_Mishima, Zhang_Webb, two_phase_dP, two_phase_dP_acceleration, two_phase_dP_dz_acceleration, two_phase_dP_dz_gravitational, two_phase_dP_gravitational, two_phase_dP_methods", "from fluids.two_phase_voidage import homogeneous"], "code": "def test_two_phase_dP():\n    assert (['Lombardi_Pedrocchi'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, sigma=0.02))\n    assert (['Zhang_Webb'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, mul=0.001, P=100000.0, Pc=1000000.0))\n    expect = ['Jung_Radermacher', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Yu_France', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Gronnerud', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06)))\n    expect = ['Zhang_Hibiki_Mishima adiabatic gas', 'Kim_Mudawar', 'Friedel', 'Jung_Radermacher', 'Hwang_Kim', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Tran', 'Yu_France', 'Zhang_Hibiki_Mishima flow boiling', 'Xu_Fang', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Mishima_Hibiki', 'Gronnerud', 'Chen_Friedel', 'Lombardi_Pedrocchi', 'Zhang_Hibiki_Mishima', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06, sigma=0.014)))\n    assert (24 == len(two_phase_dP_methods(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)))\n    kwargs = dict(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)\n    for m in two_phase_dP_methods(**kwargs):\n        two_phase_dP(Method=m, **kwargs)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1.0)\n    assert_close(dP, 1567.328374498781)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, mul=0.00018, P=200000.0, Pc=4055000, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 712.0999804205619)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 1084.1489922923736)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1.0)\n    assert_close(dP, 840.4137796786074)\n    dP = two_phase_dP(Method='Friedel', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 738.6500525002243)\n    dP = two_phase_dP(Method='Lockhart_Martinelli', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, L=1.0)\n    assert_close(dP, 716.4695654888484)\n    dP = two_phase_dP(Method='Chisholm rough', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0001, L=1.0)\n    assert_close(dP, 846.6778299960783)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima adiabatic gas', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 1109.1976111277042)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima flow boiling', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 770.0975665928916)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, D=0.05, L=1.0)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1, Method='BADMETHOD')", "masked_code": "def test_two_phase_dP():\n    assert (['Lombardi_Pedrocchi'] == '???')\n    assert (['Zhang_Webb'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, mul=0.001, P=100000.0, Pc=1000000.0))\n    expect = ['Jung_Radermacher', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Yu_France', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Gronnerud', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06)))\n    expect = ['Zhang_Hibiki_Mishima adiabatic gas', 'Kim_Mudawar', 'Friedel', 'Jung_Radermacher', 'Hwang_Kim', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Tran', 'Yu_France', 'Zhang_Hibiki_Mishima flow boiling', 'Xu_Fang', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Mishima_Hibiki', 'Gronnerud', 'Chen_Friedel', 'Lombardi_Pedrocchi', 'Zhang_Hibiki_Mishima', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06, sigma=0.014)))\n    assert (24 == len(two_phase_dP_methods(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)))\n    kwargs = dict(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)\n    for m in two_phase_dP_methods(**kwargs):\n        two_phase_dP(Method=m, **kwargs)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1.0)\n    assert_close(dP, 1567.328374498781)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, mul=0.00018, P=200000.0, Pc=4055000, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 712.0999804205619)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 1084.1489922923736)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1.0)\n    assert_close(dP, 840.4137796786074)\n    dP = two_phase_dP(Method='Friedel', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 738.6500525002243)\n    dP = two_phase_dP(Method='Lockhart_Martinelli', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, L=1.0)\n    assert_close(dP, 716.4695654888484)\n    dP = two_phase_dP(Method='Chisholm rough', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0001, L=1.0)\n    assert_close(dP, 846.6778299960783)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima adiabatic gas', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 1109.1976111277042)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima flow boiling', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 770.0975665928916)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, D=0.05, L=1.0)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1, Method='BADMETHOD')", "ground_truth": "two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, sigma=0.02)", "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_132", "reponame": "fluids", "testpath": "tests/test_two_phase.py", "testname": "test_two_phase.py", "classname": null, "funcname": "test_two_phase_dP", "imports": ["from math import log10", "import pytest", "from fluids.numerics import assert_close, assert_close1d", "from fluids.two_phase import Bankoff, Baroczy_Chisholm, Beggs_Brill, Chen_Friedel, Chisholm, Friedel, Gronnerud, Hwang_Kim, Jung_Radermacher, Kim_Mudawar, Lockhart_Martinelli, Lombardi_Pedrocchi, Mishima_Hibiki, Muller_Steinhagen_Heck, Theissing, Tran, Wang_Chiang_Lu, Xu_Fang, Yu_France, Zhang_Hibiki_Mishima, Zhang_Webb, two_phase_dP, two_phase_dP_acceleration, two_phase_dP_dz_acceleration, two_phase_dP_dz_gravitational, two_phase_dP_gravitational, two_phase_dP_methods", "from fluids.two_phase_voidage import homogeneous"], "code": "def test_two_phase_dP():\n    assert (['Lombardi_Pedrocchi'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, sigma=0.02))\n    assert (['Zhang_Webb'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, mul=0.001, P=100000.0, Pc=1000000.0))\n    expect = ['Jung_Radermacher', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Yu_France', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Gronnerud', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06)))\n    expect = ['Zhang_Hibiki_Mishima adiabatic gas', 'Kim_Mudawar', 'Friedel', 'Jung_Radermacher', 'Hwang_Kim', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Tran', 'Yu_France', 'Zhang_Hibiki_Mishima flow boiling', 'Xu_Fang', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Mishima_Hibiki', 'Gronnerud', 'Chen_Friedel', 'Lombardi_Pedrocchi', 'Zhang_Hibiki_Mishima', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06, sigma=0.014)))\n    assert (24 == len(two_phase_dP_methods(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)))\n    kwargs = dict(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)\n    for m in two_phase_dP_methods(**kwargs):\n        two_phase_dP(Method=m, **kwargs)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1.0)\n    assert_close(dP, 1567.328374498781)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, mul=0.00018, P=200000.0, Pc=4055000, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 712.0999804205619)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 1084.1489922923736)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1.0)\n    assert_close(dP, 840.4137796786074)\n    dP = two_phase_dP(Method='Friedel', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 738.6500525002243)\n    dP = two_phase_dP(Method='Lockhart_Martinelli', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, L=1.0)\n    assert_close(dP, 716.4695654888484)\n    dP = two_phase_dP(Method='Chisholm rough', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0001, L=1.0)\n    assert_close(dP, 846.6778299960783)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima adiabatic gas', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 1109.1976111277042)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima flow boiling', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 770.0975665928916)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, D=0.05, L=1.0)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1, Method='BADMETHOD')", "masked_code": "def test_two_phase_dP():\n    assert (['Lombardi_Pedrocchi'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, sigma=0.02))\n    assert (['Zhang_Webb'] == '???')\n    expect = ['Jung_Radermacher', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Yu_France', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Gronnerud', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06)))\n    expect = ['Zhang_Hibiki_Mishima adiabatic gas', 'Kim_Mudawar', 'Friedel', 'Jung_Radermacher', 'Hwang_Kim', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Tran', 'Yu_France', 'Zhang_Hibiki_Mishima flow boiling', 'Xu_Fang', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Mishima_Hibiki', 'Gronnerud', 'Chen_Friedel', 'Lombardi_Pedrocchi', 'Zhang_Hibiki_Mishima', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06, sigma=0.014)))\n    assert (24 == len(two_phase_dP_methods(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)))\n    kwargs = dict(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)\n    for m in two_phase_dP_methods(**kwargs):\n        two_phase_dP(Method=m, **kwargs)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1.0)\n    assert_close(dP, 1567.328374498781)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, mul=0.00018, P=200000.0, Pc=4055000, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 712.0999804205619)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 1084.1489922923736)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1.0)\n    assert_close(dP, 840.4137796786074)\n    dP = two_phase_dP(Method='Friedel', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 738.6500525002243)\n    dP = two_phase_dP(Method='Lockhart_Martinelli', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, L=1.0)\n    assert_close(dP, 716.4695654888484)\n    dP = two_phase_dP(Method='Chisholm rough', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0001, L=1.0)\n    assert_close(dP, 846.6778299960783)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima adiabatic gas', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 1109.1976111277042)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima flow boiling', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 770.0975665928916)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, D=0.05, L=1.0)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1, Method='BADMETHOD')", "ground_truth": "two_phase_dP_methods(10, 0.7, 1000, 0.1, mul=0.001, P=100000.0, Pc=1000000.0)", "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_133", "reponame": "fluids", "testpath": "tests/test_two_phase.py", "testname": "test_two_phase.py", "classname": null, "funcname": "test_two_phase_dP", "imports": ["from math import log10", "import pytest", "from fluids.numerics import assert_close, assert_close1d", "from fluids.two_phase import Bankoff, Baroczy_Chisholm, Beggs_Brill, Chen_Friedel, Chisholm, Friedel, Gronnerud, Hwang_Kim, Jung_Radermacher, Kim_Mudawar, Lockhart_Martinelli, Lombardi_Pedrocchi, Mishima_Hibiki, Muller_Steinhagen_Heck, Theissing, Tran, Wang_Chiang_Lu, Xu_Fang, Yu_France, Zhang_Hibiki_Mishima, Zhang_Webb, two_phase_dP, two_phase_dP_acceleration, two_phase_dP_dz_acceleration, two_phase_dP_dz_gravitational, two_phase_dP_gravitational, two_phase_dP_methods", "from fluids.two_phase_voidage import homogeneous"], "code": "def test_two_phase_dP():\n    assert (['Lombardi_Pedrocchi'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, sigma=0.02))\n    assert (['Zhang_Webb'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, mul=0.001, P=100000.0, Pc=1000000.0))\n    expect = ['Jung_Radermacher', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Yu_France', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Gronnerud', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06)))\n    expect = ['Zhang_Hibiki_Mishima adiabatic gas', 'Kim_Mudawar', 'Friedel', 'Jung_Radermacher', 'Hwang_Kim', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Tran', 'Yu_France', 'Zhang_Hibiki_Mishima flow boiling', 'Xu_Fang', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Mishima_Hibiki', 'Gronnerud', 'Chen_Friedel', 'Lombardi_Pedrocchi', 'Zhang_Hibiki_Mishima', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06, sigma=0.014)))\n    assert (24 == len(two_phase_dP_methods(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)))\n    kwargs = dict(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)\n    for m in two_phase_dP_methods(**kwargs):\n        two_phase_dP(Method=m, **kwargs)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1.0)\n    assert_close(dP, 1567.328374498781)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, mul=0.00018, P=200000.0, Pc=4055000, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 712.0999804205619)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 1084.1489922923736)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1.0)\n    assert_close(dP, 840.4137796786074)\n    dP = two_phase_dP(Method='Friedel', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 738.6500525002243)\n    dP = two_phase_dP(Method='Lockhart_Martinelli', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, L=1.0)\n    assert_close(dP, 716.4695654888484)\n    dP = two_phase_dP(Method='Chisholm rough', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0001, L=1.0)\n    assert_close(dP, 846.6778299960783)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima adiabatic gas', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 1109.1976111277042)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima flow boiling', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 770.0975665928916)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, D=0.05, L=1.0)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1, Method='BADMETHOD')", "masked_code": "def test_two_phase_dP():\n    assert (['Lombardi_Pedrocchi'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, sigma=0.02))\n    assert (['Zhang_Webb'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, mul=0.001, P=100000.0, Pc=1000000.0))\n    expect = ['Jung_Radermacher', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Yu_France', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Gronnerud', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == '???')\n    expect = ['Zhang_Hibiki_Mishima adiabatic gas', 'Kim_Mudawar', 'Friedel', 'Jung_Radermacher', 'Hwang_Kim', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Tran', 'Yu_France', 'Zhang_Hibiki_Mishima flow boiling', 'Xu_Fang', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Mishima_Hibiki', 'Gronnerud', 'Chen_Friedel', 'Lombardi_Pedrocchi', 'Zhang_Hibiki_Mishima', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06, sigma=0.014)))\n    assert (24 == len(two_phase_dP_methods(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)))\n    kwargs = dict(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)\n    for m in two_phase_dP_methods(**kwargs):\n        two_phase_dP(Method=m, **kwargs)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1.0)\n    assert_close(dP, 1567.328374498781)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, mul=0.00018, P=200000.0, Pc=4055000, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 712.0999804205619)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 1084.1489922923736)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1.0)\n    assert_close(dP, 840.4137796786074)\n    dP = two_phase_dP(Method='Friedel', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 738.6500525002243)\n    dP = two_phase_dP(Method='Lockhart_Martinelli', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, L=1.0)\n    assert_close(dP, 716.4695654888484)\n    dP = two_phase_dP(Method='Chisholm rough', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0001, L=1.0)\n    assert_close(dP, 846.6778299960783)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima adiabatic gas', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 1109.1976111277042)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima flow boiling', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 770.0975665928916)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, D=0.05, L=1.0)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1, Method='BADMETHOD')", "ground_truth": "sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06))", "quality_analysis": {"complexity_score": 14, "left_complexity": 4, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_134", "reponame": "fluids", "testpath": "tests/test_two_phase.py", "testname": "test_two_phase.py", "classname": null, "funcname": "test_two_phase_dP", "imports": ["from math import log10", "import pytest", "from fluids.numerics import assert_close, assert_close1d", "from fluids.two_phase import Bankoff, Baroczy_Chisholm, Beggs_Brill, Chen_Friedel, Chisholm, Friedel, Gronnerud, Hwang_Kim, Jung_Radermacher, Kim_Mudawar, Lockhart_Martinelli, Lombardi_Pedrocchi, Mishima_Hibiki, Muller_Steinhagen_Heck, Theissing, Tran, Wang_Chiang_Lu, Xu_Fang, Yu_France, Zhang_Hibiki_Mishima, Zhang_Webb, two_phase_dP, two_phase_dP_acceleration, two_phase_dP_dz_acceleration, two_phase_dP_dz_gravitational, two_phase_dP_gravitational, two_phase_dP_methods", "from fluids.two_phase_voidage import homogeneous"], "code": "def test_two_phase_dP():\n    assert (['Lombardi_Pedrocchi'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, sigma=0.02))\n    assert (['Zhang_Webb'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, mul=0.001, P=100000.0, Pc=1000000.0))\n    expect = ['Jung_Radermacher', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Yu_France', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Gronnerud', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06)))\n    expect = ['Zhang_Hibiki_Mishima adiabatic gas', 'Kim_Mudawar', 'Friedel', 'Jung_Radermacher', 'Hwang_Kim', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Tran', 'Yu_France', 'Zhang_Hibiki_Mishima flow boiling', 'Xu_Fang', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Mishima_Hibiki', 'Gronnerud', 'Chen_Friedel', 'Lombardi_Pedrocchi', 'Zhang_Hibiki_Mishima', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06, sigma=0.014)))\n    assert (24 == len(two_phase_dP_methods(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)))\n    kwargs = dict(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)\n    for m in two_phase_dP_methods(**kwargs):\n        two_phase_dP(Method=m, **kwargs)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1.0)\n    assert_close(dP, 1567.328374498781)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, mul=0.00018, P=200000.0, Pc=4055000, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 712.0999804205619)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 1084.1489922923736)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1.0)\n    assert_close(dP, 840.4137796786074)\n    dP = two_phase_dP(Method='Friedel', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 738.6500525002243)\n    dP = two_phase_dP(Method='Lockhart_Martinelli', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, L=1.0)\n    assert_close(dP, 716.4695654888484)\n    dP = two_phase_dP(Method='Chisholm rough', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0001, L=1.0)\n    assert_close(dP, 846.6778299960783)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima adiabatic gas', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 1109.1976111277042)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima flow boiling', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 770.0975665928916)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, D=0.05, L=1.0)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1, Method='BADMETHOD')", "masked_code": "def test_two_phase_dP():\n    assert (['Lombardi_Pedrocchi'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, sigma=0.02))\n    assert (['Zhang_Webb'] == two_phase_dP_methods(10, 0.7, 1000, 0.1, mul=0.001, P=100000.0, Pc=1000000.0))\n    expect = ['Jung_Radermacher', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Yu_France', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Gronnerud', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06)))\n    expect = ['Zhang_Hibiki_Mishima adiabatic gas', 'Kim_Mudawar', 'Friedel', 'Jung_Radermacher', 'Hwang_Kim', 'Muller_Steinhagen_Heck', 'Baroczy_Chisholm', 'Tran', 'Yu_France', 'Zhang_Hibiki_Mishima flow boiling', 'Xu_Fang', 'Wang_Chiang_Lu', 'Theissing', 'Chisholm rough', 'Chisholm', 'Mishima_Hibiki', 'Gronnerud', 'Chen_Friedel', 'Lombardi_Pedrocchi', 'Zhang_Hibiki_Mishima', 'Lockhart_Martinelli', 'Bankoff']\n    assert (sorted(expect) == '???')\n    assert (24 == len(two_phase_dP_methods(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)))\n    kwargs = dict(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1, angle=30.0, roughness=0.0001, P=100000.0, Pc=1000000.0)\n    for m in two_phase_dP_methods(**kwargs):\n        two_phase_dP(Method=m, **kwargs)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1.0)\n    assert_close(dP, 1567.328374498781)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, mul=0.00018, P=200000.0, Pc=4055000, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 712.0999804205619)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 1084.1489922923736)\n    dP = two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, L=1.0)\n    assert_close(dP, 840.4137796786074)\n    dP = two_phase_dP(Method='Friedel', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, roughness=0.0, L=1.0)\n    assert_close(dP, 738.6500525002243)\n    dP = two_phase_dP(Method='Lockhart_Martinelli', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, L=1.0)\n    assert_close(dP, 716.4695654888484)\n    dP = two_phase_dP(Method='Chisholm rough', m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, D=0.05, roughness=0.0001, L=1.0)\n    assert_close(dP, 846.6778299960783)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima adiabatic gas', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 1109.1976111277042)\n    dP = two_phase_dP(Method='Zhang_Hibiki_Mishima flow boiling', m=0.0005, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.003, roughness=0.0, L=1.0)\n    assert_close(dP, 770.0975665928916)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, D=0.05, L=1.0)\n    with pytest.raises(Exception):\n        two_phase_dP(m=0.6, x=0.1, rhol=915.0, rhog=2.67, sigma=0.045, D=0.05, L=1, Method='BADMETHOD')", "ground_truth": "sorted(two_phase_dP_methods(10, 0.7, 1000, 0.1, rhog=1.2, mul=0.001, mug=1e-06, sigma=0.014))", "quality_analysis": {"complexity_score": 14, "left_complexity": 4, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_135", "reponame": "fluids", "testpath": "tests/test_two_phase_voidage.py", "testname": "test_two_phase_voidage.py", "classname": null, "funcname": "test_liquid_gas_voidage", "imports": ["import pytest", "from fluids.numerics import assert_close, assert_close1d, linspace", "from fluids.two_phase_voidage import Armand, Baroczy, Beattie_Whalley, Chisholm_Armand, Chisholm_voidage, Cicchitti, Dix, Domanski_Didion, Duckler, Fauske, Fourar_Bories, Graham, Gregory_Scott, Guzhov, Harms, Huq_Loth, Kawahara, Kopte_Newell_Chato, Lin_Kwok, Lockhart_Martinelli_Xtt, McAdams, Nicklin_Wilkes_Davidson, Nishino_Yamazaki, Rouhani_1, Rouhani_2, Smith, Steiner, Sun_Duffey_Peng, Tandon_Varma_Gupta, Thom, Turner_Wallis, Woldesemayat_Ghajar, Xu_Fang_voidage, Yashar, Zivi, density_two_phase, gas_liquid_viscosity, gas_liquid_viscosity_methods, homogeneous, liquid_gas_voidage, liquid_gas_voidage_methods, two_phase_voidage_experimental"], "code": "def test_liquid_gas_voidage():\n    voidage = liquid_gas_voidage(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05)\n    assert_close(voidage, 0.9744097632663492)\n    kwargs = dict(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, P=100000.0, Pc=10000000.0)\n    for m in liquid_gas_voidage_methods(**kwargs):\n        liquid_gas_voidage(Method=m, **kwargs)\n    with pytest.raises(Exception):\n        liquid_gas_voidage(Method='BADMETHOD', **kwargs)\n    assert (len(liquid_gas_voidage_methods(**kwargs)) == 29)", "masked_code": "def test_liquid_gas_voidage():\n    voidage = liquid_gas_voidage(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05)\n    assert_close(voidage, 0.9744097632663492)\n    kwargs = dict(m=0.6, x=0.1, rhol=915.0, rhog=2.67, mul=0.00018, mug=1.4e-05, sigma=0.0487, D=0.05, P=100000.0, Pc=10000000.0)\n    for m in liquid_gas_voidage_methods(**kwargs):\n        liquid_gas_voidage(Method=m, **kwargs)\n    with pytest.raises(Exception):\n        liquid_gas_voidage(Method='BADMETHOD', **kwargs)\n    assert (len(liquid_gas_voidage_methods(**kwargs)) == '???')", "ground_truth": "29", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_136", "reponame": "fluids", "testpath": "tests/test_two_phase_voidage.py", "testname": "test_two_phase_voidage.py", "classname": null, "funcname": "test_gas_liquid_viscosity", "imports": ["import pytest", "from fluids.numerics import assert_close, assert_close1d, linspace", "from fluids.two_phase_voidage import Armand, Baroczy, Beattie_Whalley, Chisholm_Armand, Chisholm_voidage, Cicchitti, Dix, Domanski_Didion, Duckler, Fauske, Fourar_Bories, Graham, Gregory_Scott, Guzhov, Harms, Huq_Loth, Kawahara, Kopte_Newell_Chato, Lin_Kwok, Lockhart_Martinelli_Xtt, McAdams, Nicklin_Wilkes_Davidson, Nishino_Yamazaki, Rouhani_1, Rouhani_2, Smith, Steiner, Sun_Duffey_Peng, Tandon_Varma_Gupta, Thom, Turner_Wallis, Woldesemayat_Ghajar, Xu_Fang_voidage, Yashar, Zivi, density_two_phase, gas_liquid_viscosity, gas_liquid_viscosity_methods, homogeneous, liquid_gas_voidage, liquid_gas_voidage_methods, two_phase_voidage_experimental"], "code": "def test_gas_liquid_viscosity():\n    mu = gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05)\n    assert_close(2.4630541871921184e-05, mu)\n    mu = gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05, rhol=850.0, rhog=1.2, Method='Duckler')\n    assert_close(mu, 1.2092040385066917e-05)\n    simple_methods = gas_liquid_viscosity_methods()\n    assert (list(sorted(simple_methods)) == list(sorted(['McAdams', 'Cicchitti', 'Lin Kwok'])))\n    all_methods = gas_liquid_viscosity_methods(rhol=1000.0, rhog=2.0)\n    all_methods_expect = ['Beattie Whalley', 'Fourar Bories', 'Duckler', 'McAdams', 'Cicchitti', 'Lin Kwok']\n    assert (list(sorted(all_methods)) == list(sorted(all_methods_expect)))\n    for m in all_methods_expect:\n        gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05, rhol=850.0, rhog=1.2, Method=m)\n    with pytest.raises(Exception):\n        gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05, Method='NOTAMETHOD')", "masked_code": "def test_gas_liquid_viscosity():\n    mu = gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05)\n    assert_close(2.4630541871921184e-05, mu)\n    mu = gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05, rhol=850.0, rhog=1.2, Method='Duckler')\n    assert_close(mu, 1.2092040385066917e-05)\n    simple_methods = gas_liquid_viscosity_methods()\n    assert (list(sorted(simple_methods)) == '???')\n    all_methods = gas_liquid_viscosity_methods(rhol=1000.0, rhog=2.0)\n    all_methods_expect = ['Beattie Whalley', 'Fourar Bories', 'Duckler', 'McAdams', 'Cicchitti', 'Lin Kwok']\n    assert (list(sorted(all_methods)) == list(sorted(all_methods_expect)))\n    for m in all_methods_expect:\n        gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05, rhol=850.0, rhog=1.2, Method=m)\n    with pytest.raises(Exception):\n        gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05, Method='NOTAMETHOD')", "ground_truth": "list(sorted(['McAdams', 'Cicchitti', 'Lin Kwok']))", "quality_analysis": {"complexity_score": 18, "left_complexity": 7, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_137", "reponame": "fluids", "testpath": "tests/test_two_phase_voidage.py", "testname": "test_two_phase_voidage.py", "classname": null, "funcname": "test_gas_liquid_viscosity", "imports": ["import pytest", "from fluids.numerics import assert_close, assert_close1d, linspace", "from fluids.two_phase_voidage import Armand, Baroczy, Beattie_Whalley, Chisholm_Armand, Chisholm_voidage, Cicchitti, Dix, Domanski_Didion, Duckler, Fauske, Fourar_Bories, Graham, Gregory_Scott, Guzhov, Harms, Huq_Loth, Kawahara, Kopte_Newell_Chato, Lin_Kwok, Lockhart_Martinelli_Xtt, McAdams, Nicklin_Wilkes_Davidson, Nishino_Yamazaki, Rouhani_1, Rouhani_2, Smith, Steiner, Sun_Duffey_Peng, Tandon_Varma_Gupta, Thom, Turner_Wallis, Woldesemayat_Ghajar, Xu_Fang_voidage, Yashar, Zivi, density_two_phase, gas_liquid_viscosity, gas_liquid_viscosity_methods, homogeneous, liquid_gas_voidage, liquid_gas_voidage_methods, two_phase_voidage_experimental"], "code": "def test_gas_liquid_viscosity():\n    mu = gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05)\n    assert_close(2.4630541871921184e-05, mu)\n    mu = gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05, rhol=850.0, rhog=1.2, Method='Duckler')\n    assert_close(mu, 1.2092040385066917e-05)\n    simple_methods = gas_liquid_viscosity_methods()\n    assert (list(sorted(simple_methods)) == list(sorted(['McAdams', 'Cicchitti', 'Lin Kwok'])))\n    all_methods = gas_liquid_viscosity_methods(rhol=1000.0, rhog=2.0)\n    all_methods_expect = ['Beattie Whalley', 'Fourar Bories', 'Duckler', 'McAdams', 'Cicchitti', 'Lin Kwok']\n    assert (list(sorted(all_methods)) == list(sorted(all_methods_expect)))\n    for m in all_methods_expect:\n        gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05, rhol=850.0, rhog=1.2, Method=m)\n    with pytest.raises(Exception):\n        gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05, Method='NOTAMETHOD')", "masked_code": "def test_gas_liquid_viscosity():\n    mu = gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05)\n    assert_close(2.4630541871921184e-05, mu)\n    mu = gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05, rhol=850.0, rhog=1.2, Method='Duckler')\n    assert_close(mu, 1.2092040385066917e-05)\n    simple_methods = gas_liquid_viscosity_methods()\n    assert (list(sorted(simple_methods)) == list(sorted(['McAdams', 'Cicchitti', 'Lin Kwok'])))\n    all_methods = gas_liquid_viscosity_methods(rhol=1000.0, rhog=2.0)\n    all_methods_expect = ['Beattie Whalley', 'Fourar Bories', 'Duckler', 'McAdams', 'Cicchitti', 'Lin Kwok']\n    assert (list(sorted(all_methods)) == '???')\n    for m in all_methods_expect:\n        gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05, rhol=850.0, rhog=1.2, Method=m)\n    with pytest.raises(Exception):\n        gas_liquid_viscosity(x=0.4, mul=0.001, mug=1e-05, Method='NOTAMETHOD')", "ground_truth": "list(sorted(all_methods_expect))", "quality_analysis": {"complexity_score": 14, "left_complexity": 7, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_138", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_kwargs_to_args", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_kwargs_to_args():\n    sig = ['rho', 'mu', 'nu']\n    args = (1,)\n    kwargs = {'mu': 2.2}\n    assert ([1, 2.2, None] == kwargs_to_args(args, kwargs, sig))\n    kwargs = {'nu': 2.2}\n    assert ([1, None, 2.2] == kwargs_to_args(args, kwargs, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args(tuple(), {'mu': 2.2, 'nu': 5.5, 'rho': 12.2}, sig))\n    assert ([None, None, None] == kwargs_to_args(tuple(), {}, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args((12.2, 2.2, 5.5), {}, sig))", "masked_code": "def test_kwargs_to_args():\n    sig = ['rho', 'mu', 'nu']\n    args = (1,)\n    kwargs = {'mu': 2.2}\n    assert ([1, 2.2, None] == '???')\n    kwargs = {'nu': 2.2}\n    assert ([1, None, 2.2] == kwargs_to_args(args, kwargs, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args(tuple(), {'mu': 2.2, 'nu': 5.5, 'rho': 12.2}, sig))\n    assert ([None, None, None] == kwargs_to_args(tuple(), {}, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args((12.2, 2.2, 5.5), {}, sig))", "ground_truth": "kwargs_to_args(args, kwargs, sig)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_139", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_kwargs_to_args", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_kwargs_to_args():\n    sig = ['rho', 'mu', 'nu']\n    args = (1,)\n    kwargs = {'mu': 2.2}\n    assert ([1, 2.2, None] == kwargs_to_args(args, kwargs, sig))\n    kwargs = {'nu': 2.2}\n    assert ([1, None, 2.2] == kwargs_to_args(args, kwargs, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args(tuple(), {'mu': 2.2, 'nu': 5.5, 'rho': 12.2}, sig))\n    assert ([None, None, None] == kwargs_to_args(tuple(), {}, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args((12.2, 2.2, 5.5), {}, sig))", "masked_code": "def test_kwargs_to_args():\n    sig = ['rho', 'mu', 'nu']\n    args = (1,)\n    kwargs = {'mu': 2.2}\n    assert ([1, 2.2, None] == kwargs_to_args(args, kwargs, sig))\n    kwargs = {'nu': 2.2}\n    assert ([1, None, 2.2] == '???')\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args(tuple(), {'mu': 2.2, 'nu': 5.5, 'rho': 12.2}, sig))\n    assert ([None, None, None] == kwargs_to_args(tuple(), {}, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args((12.2, 2.2, 5.5), {}, sig))", "ground_truth": "kwargs_to_args(args, kwargs, sig)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_140", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_kwargs_to_args", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_kwargs_to_args():\n    sig = ['rho', 'mu', 'nu']\n    args = (1,)\n    kwargs = {'mu': 2.2}\n    assert ([1, 2.2, None] == kwargs_to_args(args, kwargs, sig))\n    kwargs = {'nu': 2.2}\n    assert ([1, None, 2.2] == kwargs_to_args(args, kwargs, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args(tuple(), {'mu': 2.2, 'nu': 5.5, 'rho': 12.2}, sig))\n    assert ([None, None, None] == kwargs_to_args(tuple(), {}, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args((12.2, 2.2, 5.5), {}, sig))", "masked_code": "def test_kwargs_to_args():\n    sig = ['rho', 'mu', 'nu']\n    args = (1,)\n    kwargs = {'mu': 2.2}\n    assert ([1, 2.2, None] == kwargs_to_args(args, kwargs, sig))\n    kwargs = {'nu': 2.2}\n    assert ([1, None, 2.2] == kwargs_to_args(args, kwargs, sig))\n    assert ([12.2, 2.2, 5.5] == '???')\n    assert ([None, None, None] == kwargs_to_args(tuple(), {}, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args((12.2, 2.2, 5.5), {}, sig))", "ground_truth": "kwargs_to_args(tuple(), {'mu': 2.2, 'nu': 5.5, 'rho': 12.2}, sig)", "quality_analysis": {"complexity_score": 21, "left_complexity": 5, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_141", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_kwargs_to_args", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_kwargs_to_args():\n    sig = ['rho', 'mu', 'nu']\n    args = (1,)\n    kwargs = {'mu': 2.2}\n    assert ([1, 2.2, None] == kwargs_to_args(args, kwargs, sig))\n    kwargs = {'nu': 2.2}\n    assert ([1, None, 2.2] == kwargs_to_args(args, kwargs, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args(tuple(), {'mu': 2.2, 'nu': 5.5, 'rho': 12.2}, sig))\n    assert ([None, None, None] == kwargs_to_args(tuple(), {}, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args((12.2, 2.2, 5.5), {}, sig))", "masked_code": "def test_kwargs_to_args():\n    sig = ['rho', 'mu', 'nu']\n    args = (1,)\n    kwargs = {'mu': 2.2}\n    assert ([1, 2.2, None] == kwargs_to_args(args, kwargs, sig))\n    kwargs = {'nu': 2.2}\n    assert ([1, None, 2.2] == kwargs_to_args(args, kwargs, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args(tuple(), {'mu': 2.2, 'nu': 5.5, 'rho': 12.2}, sig))\n    assert ([None, None, None] == '???')\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args((12.2, 2.2, 5.5), {}, sig))", "ground_truth": "kwargs_to_args(tuple(), {}, sig)", "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_142", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_kwargs_to_args", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_kwargs_to_args():\n    sig = ['rho', 'mu', 'nu']\n    args = (1,)\n    kwargs = {'mu': 2.2}\n    assert ([1, 2.2, None] == kwargs_to_args(args, kwargs, sig))\n    kwargs = {'nu': 2.2}\n    assert ([1, None, 2.2] == kwargs_to_args(args, kwargs, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args(tuple(), {'mu': 2.2, 'nu': 5.5, 'rho': 12.2}, sig))\n    assert ([None, None, None] == kwargs_to_args(tuple(), {}, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args((12.2, 2.2, 5.5), {}, sig))", "masked_code": "def test_kwargs_to_args():\n    sig = ['rho', 'mu', 'nu']\n    args = (1,)\n    kwargs = {'mu': 2.2}\n    assert ([1, 2.2, None] == kwargs_to_args(args, kwargs, sig))\n    kwargs = {'nu': 2.2}\n    assert ([1, None, 2.2] == kwargs_to_args(args, kwargs, sig))\n    assert ([12.2, 2.2, 5.5] == kwargs_to_args(tuple(), {'mu': 2.2, 'nu': 5.5, 'rho': 12.2}, sig))\n    assert ([None, None, None] == kwargs_to_args(tuple(), {}, sig))\n    assert ([12.2, 2.2, 5.5] == '???')", "ground_truth": "kwargs_to_args((12.2, 2.2, 5.5), {}, sig)", "quality_analysis": {"complexity_score": 17, "left_complexity": 5, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_143", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_in_right_units", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_in_right_units():\n    assert (u.default_system == 'mks')", "masked_code": "def test_in_right_units():\n    assert (u.default_system == '???')", "ground_truth": "'mks'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_144", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_convert_output", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_convert_output():\n    assert (convert_output(None, ['Pa'], ['Pt'], u) is None)\n    assert (convert_output(True, ['Pa'], ['Pt'], u) is True)\n    assert (convert_output('hi', ['Pa'], ['Pt'], u) == 'hi')\n    val = convert_output(5.5, ['Pa'], ['Pt'], u)\n    assert_close(val.to_base_units().magnitude, 5.5)\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output(np.array([[1, 2, 6], [3, 4, 9.5]]), ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output([[1, 2, 6], [3, 4, 9.5]], ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})", "masked_code": "def test_convert_output():\n    assert (convert_output(None, ['Pa'], ['Pt'], u) is None)\n    assert (convert_output(True, ['Pa'], ['Pt'], u) is True)\n    assert (convert_output('hi', ['Pa'], ['Pt'], u) == '???')\n    val = convert_output(5.5, ['Pa'], ['Pt'], u)\n    assert_close(val.to_base_units().magnitude, 5.5)\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output(np.array([[1, 2, 6], [3, 4, 9.5]]), ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output([[1, 2, 6], [3, 4, 9.5]], ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})", "ground_truth": "'hi'", "quality_analysis": {"complexity_score": 12, "left_complexity": 11, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_145", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_convert_output", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_convert_output():\n    assert (convert_output(None, ['Pa'], ['Pt'], u) is None)\n    assert (convert_output(True, ['Pa'], ['Pt'], u) is True)\n    assert (convert_output('hi', ['Pa'], ['Pt'], u) == 'hi')\n    val = convert_output(5.5, ['Pa'], ['Pt'], u)\n    assert_close(val.to_base_units().magnitude, 5.5)\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output(np.array([[1, 2, 6], [3, 4, 9.5]]), ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output([[1, 2, 6], [3, 4, 9.5]], ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})", "masked_code": "def test_convert_output():\n    assert (convert_output(None, ['Pa'], ['Pt'], u) is None)\n    assert (convert_output(True, ['Pa'], ['Pt'], u) is True)\n    assert (convert_output('hi', ['Pa'], ['Pt'], u) == 'hi')\n    val = convert_output(5.5, ['Pa'], ['Pt'], u)\n    assert_close(val.to_base_units().magnitude, 5.5)\n    assert (dict(val.dimensionality) == '???')\n    mat = convert_output(np.array([[1, 2, 6], [3, 4, 9.5]]), ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output([[1, 2, 6], [3, 4, 9.5]], ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})", "ground_truth": "{'[length]': (- 1), '[mass]': 1, '[time]': (- 2)}", "quality_analysis": {"complexity_score": 18, "left_complexity": 5, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_146", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_convert_output", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_convert_output():\n    assert (convert_output(None, ['Pa'], ['Pt'], u) is None)\n    assert (convert_output(True, ['Pa'], ['Pt'], u) is True)\n    assert (convert_output('hi', ['Pa'], ['Pt'], u) == 'hi')\n    val = convert_output(5.5, ['Pa'], ['Pt'], u)\n    assert_close(val.to_base_units().magnitude, 5.5)\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output(np.array([[1, 2, 6], [3, 4, 9.5]]), ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output([[1, 2, 6], [3, 4, 9.5]], ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})", "masked_code": "def test_convert_output():\n    assert (convert_output(None, ['Pa'], ['Pt'], u) is None)\n    assert (convert_output(True, ['Pa'], ['Pt'], u) is True)\n    assert (convert_output('hi', ['Pa'], ['Pt'], u) == 'hi')\n    val = convert_output(5.5, ['Pa'], ['Pt'], u)\n    assert_close(val.to_base_units().magnitude, 5.5)\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output(np.array([[1, 2, 6], [3, 4, 9.5]]), ['Pa'], ['Pt'], u)\n    assert (mat.shape == '???')\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output([[1, 2, 6], [3, 4, 9.5]], ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})", "ground_truth": "(2, 3)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_147", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_convert_output", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_convert_output():\n    assert (convert_output(None, ['Pa'], ['Pt'], u) is None)\n    assert (convert_output(True, ['Pa'], ['Pt'], u) is True)\n    assert (convert_output('hi', ['Pa'], ['Pt'], u) == 'hi')\n    val = convert_output(5.5, ['Pa'], ['Pt'], u)\n    assert_close(val.to_base_units().magnitude, 5.5)\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output(np.array([[1, 2, 6], [3, 4, 9.5]]), ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output([[1, 2, 6], [3, 4, 9.5]], ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})", "masked_code": "def test_convert_output():\n    assert (convert_output(None, ['Pa'], ['Pt'], u) is None)\n    assert (convert_output(True, ['Pa'], ['Pt'], u) is True)\n    assert (convert_output('hi', ['Pa'], ['Pt'], u) == 'hi')\n    val = convert_output(5.5, ['Pa'], ['Pt'], u)\n    assert_close(val.to_base_units().magnitude, 5.5)\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output(np.array([[1, 2, 6], [3, 4, 9.5]]), ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == '???')\n    mat = convert_output([[1, 2, 6], [3, 4, 9.5]], ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})", "ground_truth": "{'[length]': (- 1), '[mass]': 1, '[time]': (- 2)}", "quality_analysis": {"complexity_score": 18, "left_complexity": 5, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_148", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_convert_output", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_convert_output():\n    assert (convert_output(None, ['Pa'], ['Pt'], u) is None)\n    assert (convert_output(True, ['Pa'], ['Pt'], u) is True)\n    assert (convert_output('hi', ['Pa'], ['Pt'], u) == 'hi')\n    val = convert_output(5.5, ['Pa'], ['Pt'], u)\n    assert_close(val.to_base_units().magnitude, 5.5)\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output(np.array([[1, 2, 6], [3, 4, 9.5]]), ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output([[1, 2, 6], [3, 4, 9.5]], ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})", "masked_code": "def test_convert_output():\n    assert (convert_output(None, ['Pa'], ['Pt'], u) is None)\n    assert (convert_output(True, ['Pa'], ['Pt'], u) is True)\n    assert (convert_output('hi', ['Pa'], ['Pt'], u) == 'hi')\n    val = convert_output(5.5, ['Pa'], ['Pt'], u)\n    assert_close(val.to_base_units().magnitude, 5.5)\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output(np.array([[1, 2, 6], [3, 4, 9.5]]), ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output([[1, 2, 6], [3, 4, 9.5]], ['Pa'], ['Pt'], u)\n    assert (mat.shape == '???')\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})", "ground_truth": "(2, 3)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_149", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_convert_output", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_convert_output():\n    assert (convert_output(None, ['Pa'], ['Pt'], u) is None)\n    assert (convert_output(True, ['Pa'], ['Pt'], u) is True)\n    assert (convert_output('hi', ['Pa'], ['Pt'], u) == 'hi')\n    val = convert_output(5.5, ['Pa'], ['Pt'], u)\n    assert_close(val.to_base_units().magnitude, 5.5)\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output(np.array([[1, 2, 6], [3, 4, 9.5]]), ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output([[1, 2, 6], [3, 4, 9.5]], ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})", "masked_code": "def test_convert_output():\n    assert (convert_output(None, ['Pa'], ['Pt'], u) is None)\n    assert (convert_output(True, ['Pa'], ['Pt'], u) is True)\n    assert (convert_output('hi', ['Pa'], ['Pt'], u) == 'hi')\n    val = convert_output(5.5, ['Pa'], ['Pt'], u)\n    assert_close(val.to_base_units().magnitude, 5.5)\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output(np.array([[1, 2, 6], [3, 4, 9.5]]), ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == {'[length]': (- 1), '[mass]': 1, '[time]': (- 2)})\n    mat = convert_output([[1, 2, 6], [3, 4, 9.5]], ['Pa'], ['Pt'], u)\n    assert (mat.shape == (2, 3))\n    assert (dict(val.dimensionality) == '???')", "ground_truth": "{'[length]': (- 1), '[mass]': 1, '[time]': (- 2)}", "quality_analysis": {"complexity_score": 18, "left_complexity": 5, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_150", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == '???')\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{}", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_151", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == '???')\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': 2.0}", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_152", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == '???')\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[temperature]': 1.0}", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_153", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == '???')\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': 3.0, '[time]': (- 1.0)}", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_154", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == '???')\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': 2.0}", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_155", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == '???')\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': 0.75, '[time]': (- 1.5)}", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_156", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == '???')\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': 1.0, '[time]': (- 1.0)}", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_157", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == '???')\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[time]': (- 1.0)}", "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_158", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == '???')\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': 1.0}", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_159", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == '???')\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)}", "quality_analysis": {"complexity_score": 18, "left_complexity": 5, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_160", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == '???')\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)}", "quality_analysis": {"complexity_score": 18, "left_complexity": 5, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_161", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == '???')\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)}", "quality_analysis": {"complexity_score": 18, "left_complexity": 5, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_162", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == '???')\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': (- 0.3333333333333333), '[time]': 1.0}", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_163", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == '???')\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': 3.0, '[time]': (- 1.0)}", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_164", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == '???')\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[time]': 1.0}", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_165", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == '???')\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': 1.0, '[time]': (- 1.0)}", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_166", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == '???')\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[current]': 1.0}", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_167", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == '???')\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{}", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_168", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == '???')\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{}", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_169", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == '???')\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': 3.0, '[time]': (- 1.0)}", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_170", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == '???')\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{}", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_171", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == '???')\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': 1.0, '[time]': (- 1.0)}", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_172", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == '???')\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': 1.0}", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_173", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == '???')\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{}", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_174", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == '???')\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "ground_truth": "{'[length]': 1.0}", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_175", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_sample_cases", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == {'[length]': 1.0})", "masked_code": "def test_sample_cases():\n    Re = Reynolds(V=((3.5 * u.m) / u.s), D=(2 * u.m), rho=((997.1 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(Re.to_base_units().magnitude, 6979700.0)\n    assert (dict(Re.dimensionality) == {})\n    A = API520_A_g(m=((24270 * u.kg) / u.hour), T=(348.0 * u.K), Z=0.9, MW=((51.0 * u.g) / u.mol), k=1.11, P1=(670 * u.kPa), Kb=1, Kc=1)\n    assert_close(A.to_base_units().magnitude, 0.00369904606468)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    T = T_critical_flow((473 * u.K), 1.289)\n    assert_close(T.to_base_units().magnitude, 413.280908694)\n    assert (dict(T.dimensionality) == {'[temperature]': 1.0})\n    T2 = T_critical_flow((473 * u.K), (1.289 * u.dimensionless))\n    assert (T == T2)\n    with pytest.raises(Exception):\n        T_critical_flow(473, 1.289)\n    with pytest.raises(Exception):\n        T_critical_flow((473 * u.m), 1.289)\n    P1 = ((8 * u.bar) + (1 * u.atm))\n    P2 = (1 * u.atm)\n    assert (True is is_critical_flow(P1, P2, k=(1.4 * u.dimensionless)))\n    A = size_control_valve_g(T=(433.0 * u.K), MW=((44.01 * u.g) / u.mol), mu=((0.00014665 * u.Pa) * u.s), gamma=1.3, Z=0.988, P1=(680 * u.kPa), P2=(310 * u.kPa), Q=(((38 / 36.0) * (u.m ** 3)) / u.s), D1=(0.08 * u.m), D2=(0.1 * u.m), d=(0.05 * u.m), FL=0.85, Fd=0.42, xT=0.6)\n    assert_close(A.to_base_units().magnitude, 0.0201629570705307)\n    assert (dict(A.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    A = API520_round_size(A=(0.0001 * (u.m ** 2)))\n    assert_close(A.to_base_units().magnitude, 0.00012645136)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    SS = specific_speed(((0.0402 * (u.m ** 3)) / u.s), (100 * u.m), (3550 * u.rpm))\n    assert_close(SS.to_base_units().magnitude, 2.3570565251512066)\n    assert (dict(SS.dimensionality) == {'[length]': 0.75, '[time]': (- 1.5)})\n    v = Geldart_Ling(((1.0 * u.kg) / u.s), ((1.2 * u.kg) / (u.m ** 3)), (0.1 * u.m), ((2e-05 * u.Pa) * u.s))\n    assert_close(v.to_base_units().magnitude, 7.467495862402707)\n    assert (dict(v.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    s = speed_synchronous((50 * u.Hz), poles=12)\n    assert_close(s.to_base_units().magnitude, (157.07963267948966 / 3))\n    assert (dict(s.dimensionality) == {'[time]': (- 1.0)})\n    t = t_from_gauge(0.2, False, 'AWG')\n    assert_close(t.to_base_units().magnitude, 0.5165)\n    assert (dict(t.dimensionality) == {'[length]': 1.0})\n    dP = Robbins(G=(((2.03 * u.kg) / (u.m ** 2)) / u.s), rhol=((1000 * u.kg) / (u.m ** 3)), Fpd=(24 / u.ft), L=(((12.2 * u.kg) / (u.m ** 2)) / u.s), rhog=((1.1853 * u.kg) / (u.m ** 3)), mul=((0.001 * u.Pa) * u.s), H=(2 * u.m))\n    assert_close(dP.to_base_units().magnitude, 619.662459344)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=0.4, vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s))\n    assert_close(dP.to_base_units().magnitude, 1438.28269588)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    dP = dP_packed_bed(dp=(0.0008 * u.m), voidage=(0.4 * u.dimensionless), vs=((0.001 * u.m) / u.s), rho=((1000.0 * u.kg) / (u.m ** 3)), mu=((0.001 * u.Pa) * u.s), Dt=(0.01 * u.m))\n    assert_close(dP.to_base_units().magnitude, 1255.16256625)\n    assert (dict(dP.dimensionality) == {'[length]': (- 1.0), '[mass]': 1.0, '[time]': (- 2.0)})\n    n = C_Chezy_to_n_Manning(((26.15 * (u.m ** 0.5)) / u.s), Rh=(5 * u.m))\n    assert_close(n.to_base_units().magnitude, 0.05000613713238358)\n    assert (dict(n.dimensionality) == {'[length]': (- 0.3333333333333333), '[time]': 1.0})\n    Q = Q_weir_rectangular_SIA((0.2 * u.m), (0.5 * u.m), (1 * u.m), (2 * u.m))\n    assert_close(Q.to_base_units().magnitude, 1.0408858453811165)\n    assert (dict(Q.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    t = agitator_time_homogeneous(D=((36 * 0.0254) * u.m), N=(((56 / 60.0) * u.revolutions) / u.second), P=(957.0 * u.W), T=(1.83 * u.m), H=(1.83 * u.m), mu=((0.018 * u.Pa) * u.s), rho=((1020 * u.kg) / (u.m ** 3)), homogeneity=0.995)\n    assert_close(t.to_base_units().magnitude, 15.143198226374668)\n    assert (dict(t.dimensionality) == {'[time]': 1.0})\n    K = K_separator_Watkins((0.88 * u.dimensionless), ((985.4 * u.kg) / (u.m ** 3)), ((1.3 * u.kg) / (u.m ** 3)), horizontal=True)\n    assert_close(K.to_base_units().magnitude, 0.07951613600476297, rtol=0.01)\n    assert (dict(K.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    A = current_ideal(V=(120 * u.V), P=(10000.0 * u.W), PF=1, phase=1)\n    assert_close(A.to_base_units().magnitude, 83.33333333333333)\n    assert (dict(A.dimensionality) == {'[current]': 1.0})\n    fd = friction_factor(Re=100000.0, eD=0.0001)\n    assert_close(fd.to_base_units().magnitude, 0.01851386607747165)\n    assert (dict(fd.dimensionality) == {})\n    K = Cv_to_K(((2.712 * u.gallon) / u.minute), (0.015 * u.m))\n    assert_close(K.to_base_units().magnitude, 14.719595348352552)\n    assert (dict(K.dimensionality) == {})\n    Cv = K_to_Cv(16, (0.015 * u.m))\n    assert_close(Cv.to_base_units().magnitude, 0.0001641116865931214)\n    assert (dict(Cv.dimensionality) == {'[length]': 3.0, '[time]': (- 1.0)})\n    Cd = drag_sphere(200)\n    assert_close(Cd.to_base_units().magnitude, 0.7682237950389874)\n    assert (dict(Cd.dimensionality) == {})\n    (V, D) = integrate_drag_sphere(D=(0.001 * u.m), rhop=((2200.0 * u.kg) / (u.m ** 3)), rho=((1.2 * u.kg) / (u.m ** 3)), mu=((1.78e-05 * u.Pa) * u.s), t=(0.5 * u.s), V=((30 * u.m) / u.s), distance=True)\n    assert_close(V.to_base_units().magnitude, 9.686465044063436)\n    assert (dict(V.dimensionality) == {'[length]': 1.0, '[time]': (- 1.0)})\n    assert_close(D.to_base_units().magnitude, 7.829454643649386)\n    assert (dict(D.dimensionality) == {'[length]': 1.0})\n    Bo = Bond(((1000 * u.kg) / (u.m ** 3)), ((1.2 * u.kg) / (u.m ** 3)), ((0.0589 * u.N) / u.m), (2 * u.m))\n    assert_close(Bo.to_base_units().magnitude, 665187.2339558573)\n    assert (dict(Bo.dimensionality) == {})\n    head = head_from_P(P=(98066.5 * u.Pa), rho=((1000 * u.kg) / (u.m ** 3)))\n    assert_close(head.to_base_units().magnitude, 10.000000000000002)\n    assert (dict(head.dimensionality) == {'[length]': 1.0})\n    roughness = roughness_Farshad('Cr13, bare', (0.05 * u.m))\n    assert_close(roughness.to_base_units().magnitude, 5.3141677781137006e-05)\n    assert (dict(roughness.dimensionality) == '???')", "ground_truth": "{'[length]': 1.0}", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_176", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_custom_wraps", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_custom_wraps():\n    A = A_multiple_hole_cylinder((0.01 * u.m), (0.1 * u.m), [((0.005 * u.m), 1)])\n    assert_close(A.to_base_units().magnitude, 0.004830198704894308)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    V = V_multiple_hole_cylinder((0.01 * u.m), (0.1 * u.m), [((0.005 * u.m), 1)])\n    assert_close(V.to_base_units().magnitude, 5.890486225480862e-06)\n    assert (dict(V.dimensionality) == {'[length]': 3.0})\n    functions = [Panhandle_A, Panhandle_B, Weymouth, Spitzglass_high, Oliphant, Fritzsche]\n    values = [42.56082051195928, 42.35366178004172, 32.07729055913029, 29.42670246281681, 28.851535408143057, 39.421535157535565]\n    for (f, v) in zip(functions, values):\n        ans = f(D=(0.34 * u.m), P1=(9000000.0 * u.Pa), P2=(2000000.0 * u.Pa), L=(160000.0 * u.m), SG=0.693, Tavg=(277.15 * u.K))\n        assert_pint_allclose(ans, v, {'[length]': 3.0, '[time]': (- 1.0)})\n    ans = IGT(D=(0.34 * u.m), P1=(9000000.0 * u.Pa), P2=(2000000.0 * u.Pa), L=(160000.0 * u.m), SG=0.693, mu=((1e-05 * u.Pa) * u.s), Tavg=(277.15 * u.K))\n    assert_pint_allclose(ans, 48.92351786788815, {'[length]': 3.0, '[time]': (- 1.0)})\n    ans = Muller(D=(0.34 * u.m), P1=(9000000.0 * u.Pa), P2=(2000000.0 * u.Pa), L=(160000.0 * u.m), SG=0.693, mu=((1e-05 * u.Pa) * u.s), Tavg=(277.15 * u.K))\n    assert_pint_allclose(ans, 60.45796698148659, {'[length]': 3.0, '[time]': (- 1.0)})\n    nu = nu_mu_converter(rho=((1000 * u.kg) / (u.m ** 3)), mu=((0.0001 * u.Pa) * u.s))\n    assert_pint_allclose(nu, 1e-07, {'[length]': 2.0, '[time]': (- 1.0)})\n    mu = nu_mu_converter(rho=((1000 * u.kg) / (u.m ** 3)), nu=((1e-07 * (u.m ** 2)) / u.s))\n    assert_pint_allclose(mu, 0.0001, {'[time]': (- 1.0), '[length]': (- 1.0), '[mass]': 1.0})\n    SA = SA_tank(D=(1.0 * u.m), L=(0 * u.m), sideA='ellipsoidal', sideA_a=(2 * u.m), sideB='ellipsoidal', sideB_a=(2 * u.m))[0]\n    assert_pint_allclose(SA, 10.124375616183064, {'[length]': 2.0})\n    (SA, sideA_SA, sideB_SA, lateral_SA) = SA_tank(D=(1.0 * u.m), L=(0 * u.m), sideA='ellipsoidal', sideA_a=(2 * u.m), sideB='ellipsoidal', sideB_a=(2 * u.m))\n    expect = [10.124375616183064, 5.062187808091532, 5.062187808091532, 0]\n    for (value, expected) in zip([SA, sideA_SA, sideB_SA, lateral_SA], expect):\n        assert_pint_allclose(value, expected, {'[length]': 2.0})\n    m = isothermal_gas(rho=((11.3 * u.kg) / (u.m ** 3)), fd=(0.00185 * u.dimensionless), P1=(1000000.0 * u.Pa), P2=(900000.0 * u.Pa), L=(1000 * u.m), D=(0.5 * u.m))\n    assert_pint_allclose(m, 145.484757, {'[mass]': 1.0, '[time]': (- 1.0)})", "masked_code": "def test_custom_wraps():\n    A = A_multiple_hole_cylinder((0.01 * u.m), (0.1 * u.m), [((0.005 * u.m), 1)])\n    assert_close(A.to_base_units().magnitude, 0.004830198704894308)\n    assert (dict(A.dimensionality) == '???')\n    V = V_multiple_hole_cylinder((0.01 * u.m), (0.1 * u.m), [((0.005 * u.m), 1)])\n    assert_close(V.to_base_units().magnitude, 5.890486225480862e-06)\n    assert (dict(V.dimensionality) == {'[length]': 3.0})\n    functions = [Panhandle_A, Panhandle_B, Weymouth, Spitzglass_high, Oliphant, Fritzsche]\n    values = [42.56082051195928, 42.35366178004172, 32.07729055913029, 29.42670246281681, 28.851535408143057, 39.421535157535565]\n    for (f, v) in zip(functions, values):\n        ans = f(D=(0.34 * u.m), P1=(9000000.0 * u.Pa), P2=(2000000.0 * u.Pa), L=(160000.0 * u.m), SG=0.693, Tavg=(277.15 * u.K))\n        assert_pint_allclose(ans, v, {'[length]': 3.0, '[time]': (- 1.0)})\n    ans = IGT(D=(0.34 * u.m), P1=(9000000.0 * u.Pa), P2=(2000000.0 * u.Pa), L=(160000.0 * u.m), SG=0.693, mu=((1e-05 * u.Pa) * u.s), Tavg=(277.15 * u.K))\n    assert_pint_allclose(ans, 48.92351786788815, {'[length]': 3.0, '[time]': (- 1.0)})\n    ans = Muller(D=(0.34 * u.m), P1=(9000000.0 * u.Pa), P2=(2000000.0 * u.Pa), L=(160000.0 * u.m), SG=0.693, mu=((1e-05 * u.Pa) * u.s), Tavg=(277.15 * u.K))\n    assert_pint_allclose(ans, 60.45796698148659, {'[length]': 3.0, '[time]': (- 1.0)})\n    nu = nu_mu_converter(rho=((1000 * u.kg) / (u.m ** 3)), mu=((0.0001 * u.Pa) * u.s))\n    assert_pint_allclose(nu, 1e-07, {'[length]': 2.0, '[time]': (- 1.0)})\n    mu = nu_mu_converter(rho=((1000 * u.kg) / (u.m ** 3)), nu=((1e-07 * (u.m ** 2)) / u.s))\n    assert_pint_allclose(mu, 0.0001, {'[time]': (- 1.0), '[length]': (- 1.0), '[mass]': 1.0})\n    SA = SA_tank(D=(1.0 * u.m), L=(0 * u.m), sideA='ellipsoidal', sideA_a=(2 * u.m), sideB='ellipsoidal', sideB_a=(2 * u.m))[0]\n    assert_pint_allclose(SA, 10.124375616183064, {'[length]': 2.0})\n    (SA, sideA_SA, sideB_SA, lateral_SA) = SA_tank(D=(1.0 * u.m), L=(0 * u.m), sideA='ellipsoidal', sideA_a=(2 * u.m), sideB='ellipsoidal', sideB_a=(2 * u.m))\n    expect = [10.124375616183064, 5.062187808091532, 5.062187808091532, 0]\n    for (value, expected) in zip([SA, sideA_SA, sideB_SA, lateral_SA], expect):\n        assert_pint_allclose(value, expected, {'[length]': 2.0})\n    m = isothermal_gas(rho=((11.3 * u.kg) / (u.m ** 3)), fd=(0.00185 * u.dimensionless), P1=(1000000.0 * u.Pa), P2=(900000.0 * u.Pa), L=(1000 * u.m), D=(0.5 * u.m))\n    assert_pint_allclose(m, 145.484757, {'[mass]': 1.0, '[time]': (- 1.0)})", "ground_truth": "{'[length]': 2.0}", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_177", "reponame": "fluids", "testpath": "tests/test_units.py", "testname": "test_units.py", "classname": null, "funcname": "test_custom_wraps", "imports": ["import types", "import numpy as np", "import pytest", "import fluids", "from fluids.numerics import assert_close, assert_close1d, assert_close2d", "from fluids.units import check_module_docstring_parameters", "from fluids.units import ATMOSPHERE_1976, ATMOSPHERE_NRLMSISE00, IGT, TANK, A_multiple_hole_cylinder, API520_A_g, API520_round_size, Bond, C_Chezy_to_n_Manning, Cv_to_K, Fritzsche, Geldart_Ling, HelicalCoil, K_separator_Watkins, K_to_Cv, Muller, Oliphant, Panhandle_A, Panhandle_B, Q_weir_rectangular_SIA, Reynolds, Robbins, SA_tank, Spitzglass_high, T_critical_flow, V_multiple_hole_cylinder, Weymouth, agitator_time_homogeneous, control_valve_noise_g_2011, convert_output, current_ideal, differential_pressure_meter_solver, dP_packed_bed, drag_sphere, friction_factor, head_from_P, integrate_drag_sphere, is_critical_flow, isothermal_gas, kwargs_to_args, nu_mu_converter, roughness_Farshad, size_control_valve_g, specific_speed, speed_synchronous, t_from_gauge, u"], "code": "def test_custom_wraps():\n    A = A_multiple_hole_cylinder((0.01 * u.m), (0.1 * u.m), [((0.005 * u.m), 1)])\n    assert_close(A.to_base_units().magnitude, 0.004830198704894308)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    V = V_multiple_hole_cylinder((0.01 * u.m), (0.1 * u.m), [((0.005 * u.m), 1)])\n    assert_close(V.to_base_units().magnitude, 5.890486225480862e-06)\n    assert (dict(V.dimensionality) == {'[length]': 3.0})\n    functions = [Panhandle_A, Panhandle_B, Weymouth, Spitzglass_high, Oliphant, Fritzsche]\n    values = [42.56082051195928, 42.35366178004172, 32.07729055913029, 29.42670246281681, 28.851535408143057, 39.421535157535565]\n    for (f, v) in zip(functions, values):\n        ans = f(D=(0.34 * u.m), P1=(9000000.0 * u.Pa), P2=(2000000.0 * u.Pa), L=(160000.0 * u.m), SG=0.693, Tavg=(277.15 * u.K))\n        assert_pint_allclose(ans, v, {'[length]': 3.0, '[time]': (- 1.0)})\n    ans = IGT(D=(0.34 * u.m), P1=(9000000.0 * u.Pa), P2=(2000000.0 * u.Pa), L=(160000.0 * u.m), SG=0.693, mu=((1e-05 * u.Pa) * u.s), Tavg=(277.15 * u.K))\n    assert_pint_allclose(ans, 48.92351786788815, {'[length]': 3.0, '[time]': (- 1.0)})\n    ans = Muller(D=(0.34 * u.m), P1=(9000000.0 * u.Pa), P2=(2000000.0 * u.Pa), L=(160000.0 * u.m), SG=0.693, mu=((1e-05 * u.Pa) * u.s), Tavg=(277.15 * u.K))\n    assert_pint_allclose(ans, 60.45796698148659, {'[length]': 3.0, '[time]': (- 1.0)})\n    nu = nu_mu_converter(rho=((1000 * u.kg) / (u.m ** 3)), mu=((0.0001 * u.Pa) * u.s))\n    assert_pint_allclose(nu, 1e-07, {'[length]': 2.0, '[time]': (- 1.0)})\n    mu = nu_mu_converter(rho=((1000 * u.kg) / (u.m ** 3)), nu=((1e-07 * (u.m ** 2)) / u.s))\n    assert_pint_allclose(mu, 0.0001, {'[time]': (- 1.0), '[length]': (- 1.0), '[mass]': 1.0})\n    SA = SA_tank(D=(1.0 * u.m), L=(0 * u.m), sideA='ellipsoidal', sideA_a=(2 * u.m), sideB='ellipsoidal', sideB_a=(2 * u.m))[0]\n    assert_pint_allclose(SA, 10.124375616183064, {'[length]': 2.0})\n    (SA, sideA_SA, sideB_SA, lateral_SA) = SA_tank(D=(1.0 * u.m), L=(0 * u.m), sideA='ellipsoidal', sideA_a=(2 * u.m), sideB='ellipsoidal', sideB_a=(2 * u.m))\n    expect = [10.124375616183064, 5.062187808091532, 5.062187808091532, 0]\n    for (value, expected) in zip([SA, sideA_SA, sideB_SA, lateral_SA], expect):\n        assert_pint_allclose(value, expected, {'[length]': 2.0})\n    m = isothermal_gas(rho=((11.3 * u.kg) / (u.m ** 3)), fd=(0.00185 * u.dimensionless), P1=(1000000.0 * u.Pa), P2=(900000.0 * u.Pa), L=(1000 * u.m), D=(0.5 * u.m))\n    assert_pint_allclose(m, 145.484757, {'[mass]': 1.0, '[time]': (- 1.0)})", "masked_code": "def test_custom_wraps():\n    A = A_multiple_hole_cylinder((0.01 * u.m), (0.1 * u.m), [((0.005 * u.m), 1)])\n    assert_close(A.to_base_units().magnitude, 0.004830198704894308)\n    assert (dict(A.dimensionality) == {'[length]': 2.0})\n    V = V_multiple_hole_cylinder((0.01 * u.m), (0.1 * u.m), [((0.005 * u.m), 1)])\n    assert_close(V.to_base_units().magnitude, 5.890486225480862e-06)\n    assert (dict(V.dimensionality) == '???')\n    functions = [Panhandle_A, Panhandle_B, Weymouth, Spitzglass_high, Oliphant, Fritzsche]\n    values = [42.56082051195928, 42.35366178004172, 32.07729055913029, 29.42670246281681, 28.851535408143057, 39.421535157535565]\n    for (f, v) in zip(functions, values):\n        ans = f(D=(0.34 * u.m), P1=(9000000.0 * u.Pa), P2=(2000000.0 * u.Pa), L=(160000.0 * u.m), SG=0.693, Tavg=(277.15 * u.K))\n        assert_pint_allclose(ans, v, {'[length]': 3.0, '[time]': (- 1.0)})\n    ans = IGT(D=(0.34 * u.m), P1=(9000000.0 * u.Pa), P2=(2000000.0 * u.Pa), L=(160000.0 * u.m), SG=0.693, mu=((1e-05 * u.Pa) * u.s), Tavg=(277.15 * u.K))\n    assert_pint_allclose(ans, 48.92351786788815, {'[length]': 3.0, '[time]': (- 1.0)})\n    ans = Muller(D=(0.34 * u.m), P1=(9000000.0 * u.Pa), P2=(2000000.0 * u.Pa), L=(160000.0 * u.m), SG=0.693, mu=((1e-05 * u.Pa) * u.s), Tavg=(277.15 * u.K))\n    assert_pint_allclose(ans, 60.45796698148659, {'[length]': 3.0, '[time]': (- 1.0)})\n    nu = nu_mu_converter(rho=((1000 * u.kg) / (u.m ** 3)), mu=((0.0001 * u.Pa) * u.s))\n    assert_pint_allclose(nu, 1e-07, {'[length]': 2.0, '[time]': (- 1.0)})\n    mu = nu_mu_converter(rho=((1000 * u.kg) / (u.m ** 3)), nu=((1e-07 * (u.m ** 2)) / u.s))\n    assert_pint_allclose(mu, 0.0001, {'[time]': (- 1.0), '[length]': (- 1.0), '[mass]': 1.0})\n    SA = SA_tank(D=(1.0 * u.m), L=(0 * u.m), sideA='ellipsoidal', sideA_a=(2 * u.m), sideB='ellipsoidal', sideB_a=(2 * u.m))[0]\n    assert_pint_allclose(SA, 10.124375616183064, {'[length]': 2.0})\n    (SA, sideA_SA, sideB_SA, lateral_SA) = SA_tank(D=(1.0 * u.m), L=(0 * u.m), sideA='ellipsoidal', sideA_a=(2 * u.m), sideB='ellipsoidal', sideB_a=(2 * u.m))\n    expect = [10.124375616183064, 5.062187808091532, 5.062187808091532, 0]\n    for (value, expected) in zip([SA, sideA_SA, sideB_SA, lateral_SA], expect):\n        assert_pint_allclose(value, expected, {'[length]': 2.0})\n    m = isothermal_gas(rho=((11.3 * u.kg) / (u.m ** 3)), fd=(0.00185 * u.dimensionless), P1=(1000000.0 * u.Pa), P2=(900000.0 * u.Pa), L=(1000 * u.m), D=(0.5 * u.m))\n    assert_pint_allclose(m, 145.484757, {'[mass]': 1.0, '[time]': (- 1.0)})", "ground_truth": "{'[length]': 3.0}", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
